{"id": "cloudnetpy.cloudnetpy.categorize.atmos_utils.calc_vapor_pressure", "project": "cloudnetpy", "func": "calc_vapor_pressure", "origin_file": "cloudnetpy/categorize/atmos_utils.py", "test_list": ["tests/unit/test_atmos_utils.py"], "prob_info": {"func_start_lineno": 65, "func_end_lineno": 86, "key_block_start_lineno": 82, "key_block_end_lineno": 86, "new_func_code": "def calc_vapor_pressure(\n    pressure: npt.NDArray, specific_humidity: npt.NDArray\n) -> npt.NDArray:\n    \"\"\"Calculate vapor pressure of water based on pressure and specific\n    humidity.\n\n    Args:\n        pressure: Pressure (Pa)\n        specific_humidity: Specific humidity (1)\n\n    Returns:\n        Vapor pressure (Pa)\n\n    References:\n        Cai, J. (2019). Humidity Measures.\n        https://cran.r-project.org/web/packages/humidity/vignettes/humidity-measures.html\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.atmos_utils.calc_mixing_ratio", "project": "cloudnetpy", "func": "calc_mixing_ratio", "origin_file": "cloudnetpy/categorize/atmos_utils.py", "test_list": ["tests/unit/test_atmos_utils.py"], "prob_info": {"func_start_lineno": 269, "func_end_lineno": 280, "key_block_start_lineno": 280, "key_block_end_lineno": 280, "new_func_code": "def calc_mixing_ratio(vapor_pressure: np.ndarray, pressure: np.ndarray) -> np.ndarray:\n    \"\"\"Calculates mixing ratio from partial vapor pressure and pressure.\n\n    Args:\n        vapor_pressure: Partial pressure of water vapor (Pa).\n        pressure: Atmospheric pressure (Pa).\n\n    Returns:\n        Mixing ratio (kg kg-1).\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.atmos_utils.calc_adiabatic_lwc", "project": "cloudnetpy", "func": "calc_adiabatic_lwc", "origin_file": "cloudnetpy/categorize/atmos_utils.py", "test_list": ["tests/unit/test_atmos_utils.py"], "prob_info": {"func_start_lineno": 302, "func_end_lineno": 318, "key_block_start_lineno": 314, "key_block_end_lineno": 318, "new_func_code": "def calc_adiabatic_lwc(lwc_dz: np.ndarray, height: np.ndarray) -> np.ndarray:\n    \"\"\"Calculates adiabatic liquid water content (kg m-3).\n\n    Args:\n        lwc_dz: Liquid water content change rate (kg m-3 m-1) calculated at the\n            base of each cloud and filled to that cloud.\n        height: Height vector (m).\n\n    Returns:\n        Liquid water content (kg m-3).\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.cumsumr", "project": "cloudnetpy", "func": "cumsumr", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_atmos_utils.py"], "prob_info": {"func_start_lineno": 532, "func_end_lineno": 549, "key_block_start_lineno": 548, "key_block_end_lineno": 549, "new_func_code": "def cumsumr(array: np.ndarray, axis: int = 0) -> np.ndarray:\n    \"\"\"Finds cumulative sum that resets on 0.\n\n    Args:\n        array: Input array.\n        axis: Axis where the sum is calculated. Default is 0.\n\n    Returns:\n        Cumulative sum, restarted at 0.\n\n    Examples:\n        >>> x = np.array([0, 0, 1, 1, 0, 0, 0, 1, 1, 1])\n        >>> cumsumr(x)\n            [0, 0, 1, 2, 0, 0, 0, 1, 2, 3]\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.basta.basta2nc", "project": "cloudnetpy", "func": "basta2nc", "origin_file": "cloudnetpy/instruments/basta.py", "test_list": ["tests/unit/test_basta.py"], "prob_info": {"func_start_lineno": 12, "func_end_lineno": 68, "key_block_start_lineno": 45, "key_block_end_lineno": 68, "new_func_code": "def basta2nc(\n    basta_file: str,\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | None = None,\n) -> str:\n    \"\"\"Converts BASTA cloud radar data into Cloudnet Level 1b netCDF file.\n\n    This function converts daily BASTA file into a much smaller file that\n    contains only the relevant data and can be used in further processing\n    steps.\n\n    Args:\n        basta_file: Filename of a daily BASTA .nc file.\n        output_file: Output filename.\n        site_meta: Dictionary containing information about the site. Required key\n            is `name`.\n        uuid: Set specific UUID for the file.\n        date: Expected date of the measurements as YYYY-MM-DD.\n\n    Returns:\n        UUID of the generated file.\n\n    Raises:\n        ValueError: Timestamps do not match the expected date.\n\n    Examples:\n          >>> from cloudnetpy.instruments import basta2nc\n          >>> site_meta = {'name': 'Palaiseau', 'latitude': 48.718, 'longitude': 2.207}\n          >>> basta2nc('basta_file.nc', 'radar.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.seconds2hours", "project": "cloudnetpy", "func": "seconds2hours", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_basta.py"], "prob_info": {"func_start_lineno": 31, "func_end_lineno": 48, "key_block_start_lineno": 44, "key_block_end_lineno": 48, "new_func_code": "def seconds2hours(time_in_seconds: np.ndarray) -> np.ndarray:\n    \"\"\"Converts seconds since some epoch to fraction hour.\n\n    Args:\n        time_in_seconds: 1-D array of seconds since some epoch that starts on midnight.\n\n    Returns:\n        Time as fraction hour.\n\n    Notes:\n        Excludes leap seconds.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.range_to_height", "project": "cloudnetpy", "func": "range_to_height", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_basta.py"], "prob_info": {"func_start_lineno": 774, "func_end_lineno": 788, "key_block_start_lineno": 788, "key_block_end_lineno": 788, "new_func_code": "def range_to_height(range_los: np.ndarray, tilt_angle: float) -> np.ndarray:\n    \"\"\"Converts distances from a tilted instrument to height above the ground.\n\n    Args:\n        range_los: Distances towards the line of sign from the instrument.\n        tilt_angle: Angle in degrees from the zenith (0 = zenith).\n\n    Returns:\n        Altitudes of the LOS points.\n\n    Notes:\n        Uses plane parallel Earth approximation.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.isscalar", "project": "cloudnetpy", "func": "isscalar", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_basta.py"], "prob_info": {"func_start_lineno": 655, "func_end_lineno": 672, "key_block_start_lineno": 671, "key_block_end_lineno": 672, "new_func_code": "def isscalar(array: np.ndarray | float | list | netCDF4.Variable) -> bool:\n    \"\"\"Tests if input is scalar.\n\n    By \"scalar\" we mean that array has a single value.\n\n    Examples:\n        >>> isscalar(1)\n            True\n        >>> isscalar([1])\n            True\n        >>> isscalar(np.array(1))\n            True\n        >>> isscalar(np.array([1]))\n            True\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.output.update_attributes", "project": "cloudnetpy", "func": "update_attributes", "origin_file": "cloudnetpy/output.py", "test_list": ["tests/unit/test_basta.py"], "prob_info": {"func_start_lineno": 377, "func_end_lineno": 392, "key_block_start_lineno": 388, "key_block_end_lineno": 392, "new_func_code": "def update_attributes(cloudnet_variables: dict, attributes: dict) -> None:\n    \"\"\"Overrides existing CloudnetArray-attributes.\n\n    Overrides existing attributes using hard-coded values.\n    New attributes are added.\n\n    Args:\n        cloudnet_variables: CloudnetArray instances.\n        attributes: Product-specific attributes.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.output.init_file", "project": "cloudnetpy", "func": "init_file", "origin_file": "cloudnetpy/output.py", "test_list": ["tests/unit/test_basta.py"], "prob_info": {"func_start_lineno": 250, "func_end_lineno": 270, "key_block_start_lineno": 265, "key_block_end_lineno": 270, "new_func_code": "def init_file(\n    file_name: PathLike | str,\n    dimensions: dict,\n    cloudnet_arrays: dict,\n    uuid: UUID | str | None = None,\n) -> netCDF4.Dataset:\n    \"\"\"Initializes a Cloudnet file for writing.\n\n    Args:\n        file_name: File name to be generated.\n        dimensions: Dictionary containing dimension for this file.\n        cloudnet_arrays: Dictionary containing :class:`CloudnetArray` instances.\n        uuid: Set specific UUID for the file.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.output.get_references", "project": "cloudnetpy", "func": "get_references", "origin_file": "cloudnetpy/output.py", "test_list": ["tests/unit/test_basta.py"], "prob_info": {"func_start_lineno": 150, "func_end_lineno": 179, "key_block_start_lineno": 158, "key_block_end_lineno": 179, "new_func_code": "def get_references(identifier: str | None = None, extra: list | None = None) -> str:\n    \"\"\"Returns references.\n\n    Args:\n        identifier: Cloudnet file type, e.g., 'iwc'.\n        extra: List of additional references to include\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.bowtie.bowtie2nc", "project": "cloudnetpy", "func": "bowtie2nc", "origin_file": "cloudnetpy/instruments/bowtie.py", "test_list": ["tests/unit/test_bowtie.py"], "prob_info": {"func_start_lineno": 11, "func_end_lineno": 65, "key_block_start_lineno": 36, "key_block_end_lineno": 65, "new_func_code": "def bowtie2nc(\n    bowtie_file: str | PathLike,\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | None = None,\n) -> str:\n    \"\"\"Converts data from 'BOW-TIE' campaign cloud radar on RV-Meteor into\n       Cloudnet Level 1b netCDF file.\n\n    Args:\n        bowtie_file: Input filename.\n        output_file: Output filename.\n        site_meta: Dictionary containing information about the site. Required key\n            value pair is `name`. Optional are `latitude`, `longitude`, `altitude`.\n        uuid: Set specific UUID for the file.\n        date: Expected date as YYYY-MM-DD of all profiles in the file.\n\n    Returns:\n        UUID of the generated file.\n\n    Raises:\n        ValidTimeStampError: No valid timestamps found.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.seconds2date", "project": "cloudnetpy", "func": "seconds2date", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 69, "func_end_lineno": 88, "key_block_start_lineno": 80, "key_block_end_lineno": 88, "new_func_code": "def seconds2date(time_in_seconds: float, epoch: Epoch = (2001, 1, 1)) -> list:\n    \"\"\"Converts seconds since some epoch to datetime (UTC).\n\n    Args:\n        time_in_seconds: Seconds since some epoch.\n        epoch: Epoch, default is (2001, 1, 1) (UTC).\n\n    Returns:\n        [year, month, day, hours, minutes, seconds] formatted as '05' etc (UTC).\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.n_elements", "project": "cloudnetpy", "func": "n_elements", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 616, "func_end_lineno": 652, "key_block_start_lineno": 649, "key_block_end_lineno": 652, "new_func_code": "def n_elements(array: np.ndarray, dist: float, var: str | None = None) -> int:\n    \"\"\"Returns the number of elements that cover certain distance.\n\n    Args:\n        array: Input array with arbitrary units or time in fraction hour. *x* should\n            be evenly spaced or at least close to.\n        dist: Distance to be covered. If x is fraction time, *dist* is in minutes.\n            Otherwise, *x* and *dist* should have the same units.\n        var: If 'time', input is fraction hour and distance in minutes, else inputs\n            have the same units. Default is None (same units).\n\n    Returns:\n        Number of elements in the input array that cover *dist*.\n\n    Examples:\n        >>> x = np.array([2, 4, 6, 8, 10])\n        >>> n_elements(x, 6)\n            3\n\n        The result is rounded to the closest integer, so:\n\n        >>> n_elements(x, 6.9)\n            3\n        >>> n_elements(x, 7)\n            4\n\n        With fraction hour time vector:\n\n        >>> x = np.linspace(0, 1, 61)\n        >>> n_elements(x, 10, 'time')\n            10\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.ceilo.ceilo2nc", "project": "cloudnetpy", "func": "ceilo2nc", "origin_file": "cloudnetpy/instruments/ceilo.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 15, "func_end_lineno": 113, "key_block_start_lineno": 70, "key_block_end_lineno": 113, "new_func_code": "def ceilo2nc(\n    full_path: str,\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | None = None,\n) -> str:\n    \"\"\"Converts Vaisala, Lufft and Campbell Scientific ceilometer data into\n    Cloudnet Level 1b netCDF file.\n\n    This function reads raw Vaisala (CT25k, CL31, CL51, CL61), Lufft\n    (CHM 15k, CHM 15k-x) and Campbell Scientific (CS135) ceilometer files and writes\n    the data into netCDF file. Three variants of the backscatter are saved:\n\n        1. Raw backscatter, `beta_raw`\n        2. Signal-to-noise screened backscatter, `beta`\n        3. SNR-screened backscatter with smoothed weak background, `beta_smooth`\n\n    With CL61 two additional depolarisation parameters are saved:\n\n        1. Signal-to-noise screened depolarisation, `depolarisation`\n        2. SNR-screened depolarisation with smoothed weak background,\n           `depolarisation_smooth`\n\n    CL61 screened backscatter is screened using beta_smooth mask to improve detection\n    of weak aerosol layers and supercooled liquid clouds.\n\n    Args:\n        full_path: Ceilometer file name.\n        output_file: Output file name, e.g. 'ceilo.nc'.\n        site_meta: Dictionary containing information about the site and instrument.\n            Required key value pairs are `name` and `altitude` (metres above mean\n            sea level). Also, 'calibration_factor' is recommended because the default\n            value is probably incorrect. If the background noise is *not*\n            range-corrected, you must define: {'range_corrected': False}.\n            You can also explicitly set the instrument model with\n            e.g. {'model': 'cl61d'}.\n        uuid: Set specific UUID for the file.\n        date: Expected date as YYYY-MM-DD of all profiles in the file.\n\n    Returns:\n        UUID of the generated file.\n\n    Raises:\n        RuntimeError: Failed to read or process raw ceilometer data.\n\n    Examples:\n        >>> from cloudnetpy.instruments import ceilo2nc\n        >>> site_meta = {'name': 'Mace-Head', 'altitude': 5}\n        >>> ceilo2nc('vaisala_raw.txt', 'vaisala.nc', site_meta)\n        >>> site_meta = {'name': 'Juelich', 'altitude': 108,\n        'calibration_factor': 2.3e-12}\n        >>> ceilo2nc('chm15k_raw.nc', 'chm15k.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.edges2mid", "project": "cloudnetpy", "func": "edges2mid", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 928, "func_end_lineno": 944, "key_block_start_lineno": 939, "key_block_end_lineno": 944, "new_func_code": "def edges2mid(data: np.ndarray, reference: Literal[\"upper\", \"lower\"]) -> np.ndarray:\n    \"\"\"Shifts values half bin towards up or down.\n\n    Args:\n        data: 1D numpy array (e.g. range)\n        reference: If 'lower', increase values by half bin. If 'upper', decrease values.\n\n    Returns:\n        Shifted values.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.ceilometer.calc_sigma_units", "project": "cloudnetpy", "func": "calc_sigma_units", "origin_file": "cloudnetpy/instruments/ceilometer.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 340, "key_block_start_lineno": 332, "key_block_end_lineno": 340, "new_func_code": "def calc_sigma_units(\n    time_vector: np.ndarray,\n    range_los: np.ndarray,\n    sigma_minutes: float = 1,\n    sigma_metres: float = 10,\n) -> tuple[float, float]:\n    \"\"\"Calculates Gaussian peak std parameters.\n\n    The amount of smoothing is hard coded. This function calculates\n    how many steps in time and height corresponds to this smoothing.\n\n    Args:\n        time_vector: 1D vector (fraction hour).\n        range_los: 1D vector (m).\n        sigma_minutes: Smoothing in minutes.\n        sigma_metres: Smoothing in metres.\n\n    Returns:\n        tuple: Two element tuple containing number of steps in time and height to\n            achieve wanted smoothing.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.categorize.generate_categorize", "project": "cloudnetpy", "func": "generate_categorize", "origin_file": "cloudnetpy/categorize/categorize.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 24, "func_end_lineno": 202, "key_block_start_lineno": 75, "key_block_end_lineno": 202, "new_func_code": "def generate_categorize(\n    input_files: dict,\n    output_file: str,\n    uuid: str | None = None,\n    options: dict | None = None,\n) -> str:\n    \"\"\"Generates a Cloudnet Level 1c categorize file.\n\n    This function rebins measurements into a common height/time grid\n    and classifies them into different scatterer types, such as ice,\n    liquid, insects, etc. The radar signal is corrected for atmospheric\n    attenuation, and error estimates are computed. The results are saved in\n    *output_file*, a compressed netCDF4 file.\n\n    Args:\n        input_files (dict): Contains filenames for calibrated `radar`, `lidar`,\n            and `model` files. Optionally, it can also include `disdrometer`,\n            `mwr` (containing the LWP variable), and `lv0_files` (a list of RPG\n            Level 0 files).\n        output_file (str): The full path of the output file.\n        uuid (str): Specific UUID to assign to the generated file.\n        options (dict): Dictionary containing optional parameters.\n\n    Returns:\n        str: UUID of the generated file.\n\n    Raises:\n        RuntimeError: Raised if the categorize file creation fails.\n\n    Notes:\n        A separate MWR file is not required when using an RPG cloud radar that\n        measures liquid water path (LWP). In this case, the radar file can also\n        serve as the MWR file (e.g., {'mwr': 'radar.nc'}). If no MWR file\n        is provided, liquid attenuation correction cannot be performed.\n\n        If RPG L0 files are included as additional input, the Voodoo method\n        is used to detect liquid droplets.\n\n    Examples:\n        >>> from cloudnetpy.categorize import generate_categorize\n        >>> input_files = {\n        ...     'radar': 'radar.nc',\n        ...     'lidar': 'lidar.nc',\n        ...     'model': 'model.nc',\n        ...     'mwr': 'mwr.nc'\n        ... }\n        >>> generate_categorize(input_files, 'output.nc')\n\n        >>> input_files['lv0_files'] = ['file1.LV0', 'file2.LV0']  # Add RPG LV0 files\n        >>> generate_categorize(input_files, 'output.nc')  # Use the Voodoo method\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.l2norm", "project": "cloudnetpy", "func": "l2norm", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 482, "func_end_lineno": 501, "key_block_start_lineno": 492, "key_block_end_lineno": 501, "new_func_code": "def l2norm(*args) -> ma.MaskedArray:\n    \"\"\"Returns l2 norm.\n\n    Args:\n       *args: Variable number of data (*array_like*) with the same shape.\n\n    Returns:\n        The l2 norm.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.cloudnetarray.CloudnetArray::rebin_data", "project": "cloudnetpy", "func": "CloudnetArray::rebin_data", "origin_file": "cloudnetpy/cloudnetarray.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 61, "func_end_lineno": 84, "key_block_start_lineno": 75, "key_block_end_lineno": 84, "new_func_code": "def rebin_data(\n        self, time: np.ndarray, time_new: np.ndarray, *, mask_zeros: bool = True\n    ) -> list:\n        \"\"\"Rebins `data` in time.\n\n        Args:\n            time: 1D time array.\n            time_new: 1D new time array.\n            mask_zeros: Whether to mask 0 values in the returned array. Default is True.\n\n        Returns:\n            Time indices without data.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.rebin_1d", "project": "cloudnetpy", "func": "rebin_1d", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 195, "func_end_lineno": 231, "key_block_start_lineno": 217, "key_block_end_lineno": 231, "new_func_code": "def rebin_1d(\n    x_in: np.ndarray,\n    array: np.ndarray | ma.MaskedArray,\n    x_new: np.ndarray,\n    statistic: str = \"mean\",\n    *,\n    mask_zeros: bool = True,\n) -> ma.MaskedArray:\n    \"\"\"Rebins 1D array.\n\n    Args:\n        x_in: 1-D array with shape (n,).\n        array: 1-D input data with shape (m,).\n        x_new: 1-D target vector (center points) with shape (N,).\n        statistic: Statistic to be calculated. Possible statistics are 'mean', 'std'.\n            Default is 'mean'.\n        mask_zeros: Whether to mask 0 values in the returned array. Default is True.\n\n    Returns:\n        Re-binned data with shape (N,).\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.binvec", "project": "cloudnetpy", "func": "binvec", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 124, "func_end_lineno": 140, "key_block_start_lineno": 138, "key_block_end_lineno": 140, "new_func_code": "def binvec(x: np.ndarray | list) -> np.ndarray:\n    \"\"\"Converts 1-D center points to bins with even spacing.\n\n    Args:\n        x: 1-D array of N real values.\n\n    Returns:\n        ndarray: N + 1 edge values.\n\n    Examples:\n        >>> binvec([1, 2, 3])\n            [0.5, 1.5, 2.5, 3.5]\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.rebin_2d", "project": "cloudnetpy", "func": "rebin_2d", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 143, "func_end_lineno": 192, "key_block_start_lineno": 166, "key_block_end_lineno": 192, "new_func_code": "def rebin_2d(\n    x_in: np.ndarray,\n    array: ma.MaskedArray,\n    x_new: np.ndarray,\n    statistic: Literal[\"mean\", \"std\"] = \"mean\",\n    n_min: int = 1,\n    *,\n    mask_zeros: bool = True,\n) -> tuple[ma.MaskedArray, list]:\n    \"\"\"Rebins 2-D data in one dimension.\n\n    Args:\n        x_in: 1-D array with shape (n,).\n        array: 2-D input data with shape (n, m).\n        x_new: 1-D target vector (center points) with shape (N,).\n        statistic: Statistic to be calculated. Possible statistics are 'mean', 'std'.\n            Default is 'mean'.\n        n_min: Minimum number of points to have good statistics in a bin. Default is 1.\n        mask_zeros: Whether to mask 0 values in the returned array. Default is True.\n\n    Returns:\n        tuple: Rebinned data with shape (N, m) and indices of bins without enough data.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.concat_lib.concatenate_files", "project": "cloudnetpy", "func": "concatenate_files", "origin_file": "cloudnetpy/concat_lib.py", "test_list": ["tests/unit/test_cl61d.py"], "prob_info": {"func_start_lineno": 85, "func_end_lineno": 119, "key_block_start_lineno": 116, "key_block_end_lineno": 119, "new_func_code": "def concatenate_files(\n    filenames: Iterable[PathLike | str],\n    output_file: str,\n    concat_dimension: str = \"time\",\n    variables: list | None = None,\n    new_attributes: dict | None = None,\n    ignore: list | None = None,\n    allow_difference: list | None = None,\n) -> list:\n    \"\"\"Concatenate netCDF files in one dimension.\n\n    Args:\n        filenames: List of files to be concatenated.\n        output_file: Output file name.\n        concat_dimension: Dimension name for concatenation. Default is 'time'.\n        variables: List of variables with the 'concat_dimension' to be concatenated.\n            Default is None when all variables with 'concat_dimension' will be saved.\n        new_attributes: Optional new global attributes as {'attribute_name': value}.\n        ignore: List of variables to be ignored.\n        allow_difference: Names of scalar variables that can differ from one file to\n            another (value from the first file is saved).\n\n    Returns:\n        List of filenames that were successfully concatenated.\n\n    Notes:\n        Arrays without 'concat_dimension', scalars, and global attributes will be taken\n        from the first file. Groups, possibly present in a NETCDF4 formatted file,\n        are ignored.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.screen_by_time", "project": "cloudnetpy", "func": "screen_by_time", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_cl61d.py"], "prob_info": {"func_start_lineno": 843, "func_end_lineno": 877, "key_block_start_lineno": 860, "key_block_end_lineno": 877, "new_func_code": "def screen_by_time(data_in: dict, epoch: Epoch, expected_date: str) -> dict:\n    \"\"\"Screen data by time.\n\n    Args:\n        data_in: Dictionary containing at least 'time' key and other numpy arrays.\n        epoch: Epoch of the time array, e.g., (1970, 1, 1)\n        expected_date: Expected date in yyyy-mm-dd\n\n    Returns:\n        data: Screened and sorted by the time vector.\n\n    Notes:\n        - Requires 'time' key\n        - Works for dimensions 1, 2, 3 (time has to be at 0-axis)\n        - Does nothing for scalars\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.find_valid_time_indices", "project": "cloudnetpy", "func": "find_valid_time_indices", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_cl61d.py"], "prob_info": {"func_start_lineno": 880, "func_end_lineno": 908, "key_block_start_lineno": 900, "key_block_end_lineno": 908, "new_func_code": "def find_valid_time_indices(time: np.ndarray, epoch: Epoch, expected_date: str) -> list:\n    \"\"\"Finds valid time array indices for the given date.\n\n    Args:\n        time: Time in seconds from some epoch.\n        epoch: Epoch of the time array, e.g., (1970, 1, 1)\n        expected_date: Expected date in yyyy-mm-dd\n\n    Returns:\n        list: Valid indices for the given date in sorted order.\n\n    Raises:\n        RuntimeError: No valid timestamps.\n\n    Examples:\n        >>> time = [1, 5, 1e6, 3]\n        >>> find_valid_time_indices(time, (1970, 1, 1) '1970-01-01')\n            [0, 3, 2]\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.classify._find_aerosols", "project": "cloudnetpy", "func": "_find_aerosols", "origin_file": "cloudnetpy/categorize/classify.py", "test_list": ["tests/unit/test_classify.py"], "prob_info": {"func_start_lineno": 145, "func_end_lineno": 162, "key_block_start_lineno": 161, "key_block_end_lineno": 162, "new_func_code": "def _find_aerosols(\n    obs: ClassData,\n    bits: CategoryBits,\n) -> NDArray[np.bool_]:\n    \"\"\"Estimates aerosols from lidar backscattering.\n\n    Aerosols are lidar signals that are: a) not falling, b) not liquid droplets.\n\n    Args:\n        obs: A :class:`ClassData` instance.\n        bits: A :class:`CategoryBits instance.\n\n    Returns:\n        2-D boolean array containing aerosols.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.containers._find_clutter", "project": "cloudnetpy", "func": "_find_clutter", "origin_file": "cloudnetpy/categorize/containers.py", "test_list": ["tests/unit/test_classify.py"], "prob_info": {"func_start_lineno": 131, "func_end_lineno": 155, "key_block_start_lineno": 151, "key_block_end_lineno": 155, "new_func_code": "def _find_clutter(\n    v: np.ma.MaskedArray,\n    is_rain: np.ndarray,\n    n_gates: int = 10,\n    v_lim: float = 0.05,\n) -> np.ndarray:\n    \"\"\"Estimates clutter from doppler velocity.\n\n    Args:\n        v: 2D radar velocity.\n        is_rain: 2D boolean array denoting rain.\n        n_gates: Number of range gates from the ground where clutter is expected\n            to be found. Default is 10.\n        v_lim: Velocity threshold. Smaller values are classified as clutter.\n            Default is 0.05 (m/s).\n\n    Returns:\n        2-D boolean array denoting pixels contaminated by clutter.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.concat_lib.update_nc", "project": "cloudnetpy", "func": "update_nc", "origin_file": "cloudnetpy/concat_lib.py", "test_list": ["tests/unit/test_concat_lib.py"], "prob_info": {"func_start_lineno": 57, "func_end_lineno": 82, "key_block_start_lineno": 71, "key_block_end_lineno": 82, "new_func_code": "def update_nc(old_file: str, new_file: str) -> int:\n    \"\"\"Appends data to existing netCDF file.\n\n    Args:\n        old_file: Filename of an existing netCDF file.\n        new_file: Filename of a new file whose data will be appended to the end.\n\n    Returns:\n        1 = success, 0 = failed to add new data.\n\n    Notes:\n        Requires 'time' variable with unlimited dimension.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.output.save_level1b", "project": "cloudnetpy", "func": "save_level1b", "origin_file": "cloudnetpy/output.py", "test_list": ["tests/unit/test_copernicus.py"], "prob_info": {"func_start_lineno": 21, "func_end_lineno": 51, "key_block_start_lineno": 27, "key_block_end_lineno": 51, "new_func_code": "def save_level1b(\n    obj,\n    output_file: PathLike | str,\n    uuid: UUID | str | None = None,\n) -> str:\n    \"\"\"Saves Cloudnet Level 1b file.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.datasource.DataSource::getvar", "project": "cloudnetpy", "func": "DataSource::getvar", "origin_file": "cloudnetpy/datasource.py", "test_list": ["tests/unit/test_datasource.py"], "prob_info": {"func_start_lineno": 60, "func_end_lineno": 80, "key_block_start_lineno": 76, "key_block_end_lineno": 80, "new_func_code": "def getvar(self, *args) -> np.ndarray:\n        \"\"\"Returns data array from the source file variables.\n\n        Returns just the data (and no attributes) from the original\n            variables dictionary, fetched from the input netCDF file.\n\n        Args:\n            *args: possible names of the variable. The first match is returned.\n\n        Returns:\n            ndarray: The actual data.\n\n        Raises:\n             RuntimeError: The variable is not found.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.datasource.DataSource::get_date", "project": "cloudnetpy", "func": "DataSource::get_date", "origin_file": "cloudnetpy/datasource.py", "test_list": ["tests/unit/test_datasource.py"], "prob_info": {"func_start_lineno": 103, "func_end_lineno": 124, "key_block_start_lineno": 113, "key_block_end_lineno": 124, "new_func_code": "def get_date(self) -> list:\n        \"\"\"Returns date components.\n\n        Returns:\n            list: Date components [YYYY, MM, DD].\n\n        Raises:\n             RuntimeError: Not found or invalid date.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.isbit", "project": "cloudnetpy", "func": "isbit", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_der.py"], "prob_info": {"func_start_lineno": 286, "func_end_lineno": 313, "key_block_start_lineno": 309, "key_block_end_lineno": 313, "new_func_code": "def isbit(array: np.ndarray, nth_bit: int) -> np.ndarray:\n    \"\"\"Tests if nth bit (0,1,2,...) is set.\n\n    Args:\n        array: Integer array.\n        nth_bit: Investigated bit.\n\n    Returns:\n        Boolean array denoting values where nth_bit is set.\n\n    Raises:\n        ValueError: negative bit as input.\n\n    Examples:\n        >>> isbit(4, 1)\n            False\n        >>> isbit(4, 2)\n            True\n\n    See Also:\n        utils.setbit()\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.atmos_utils.find_cloud_bases", "project": "cloudnetpy", "func": "find_cloud_bases", "origin_file": "cloudnetpy/categorize/atmos_utils.py", "test_list": ["tests/unit/test_der.py"], "prob_info": {"func_start_lineno": 99, "func_end_lineno": 111, "key_block_start_lineno": 109, "key_block_end_lineno": 111, "new_func_code": "def find_cloud_bases(array: np.ndarray) -> np.ndarray:\n    \"\"\"Finds bases of clouds.\n\n    Args:\n        array: 2D boolean array denoting clouds or some other similar field.\n\n    Returns:\n        Boolean array indicating bases of the individual clouds.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.atmos_utils.find_cloud_tops", "project": "cloudnetpy", "func": "find_cloud_tops", "origin_file": "cloudnetpy/categorize/atmos_utils.py", "test_list": ["tests/unit/test_der.py"], "prob_info": {"func_start_lineno": 114, "func_end_lineno": 126, "key_block_start_lineno": 124, "key_block_end_lineno": 126, "new_func_code": "def find_cloud_tops(array: np.ndarray) -> np.ndarray:\n    \"\"\"Finds tops of clouds.\n\n    Args:\n        array: 2D boolean array denoting clouds or some other similar field.\n\n    Returns:\n        Boolean array indicating tops of the individual clouds.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.disdrometer.parsivel.parsivel2nc", "project": "cloudnetpy", "func": "parsivel2nc", "origin_file": "cloudnetpy/instruments/disdrometer/parsivel.py", "test_list": ["tests/unit/test_disdrometer.py"], "prob_info": {"func_start_lineno": 23, "func_end_lineno": 77, "key_block_start_lineno": 62, "key_block_end_lineno": 77, "new_func_code": "def parsivel2nc(\n    disdrometer_file: str | PathLike | Iterable[str | PathLike],\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | datetime.date | None = None,\n    telegram: Sequence[int | None] | None = None,\n    timestamps: Sequence[datetime.datetime] | None = None,\n) -> str:\n    \"\"\"Converts OTT Parsivel-2 disdrometer data into Cloudnet Level 1b netCDF\n    file.\n\n    Args:\n        disdrometer_file: Filename of disdrometer file or list of filenames.\n        output_file: Output filename.\n        site_meta: Dictionary containing information about the site. Required key\n            is `name`.\n        uuid: Set specific UUID for the file.\n        date: Expected date of the measurements as YYYY-MM-DD.\n        telegram: List of measured value numbers as specified in section 11.2 of\n            the instrument's operating instructions. Unknown values are indicated\n            with None. Telegram is required if the input file doesn't contain a\n            header.\n        timestamps: Specify list of timestamps if they are missing in the input file.\n\n    Returns:\n        UUID of the generated file.\n\n    Raises:\n        DisdrometerDataError: Timestamps do not match the expected date, or unable\n            to read the disdrometer file.\n\n    Examples:\n        >>> from cloudnetpy.instruments import parsivel2nc\n        >>> site_meta = {'name': 'Lindenberg', 'altitude': 104, 'latitude': 52.2,\n        'longitude': 14.1}\n        >>> uuid = parsivel2nc('parsivel.log', 'parsivel.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.disdrometer.parsivel._read_fmi", "project": "cloudnetpy", "func": "_read_fmi", "origin_file": "cloudnetpy/instruments/disdrometer/parsivel.py", "test_list": ["tests/unit/test_disdrometer.py"], "prob_info": {"func_start_lineno": 618, "func_end_lineno": 657, "key_block_start_lineno": 627, "key_block_end_lineno": 657, "new_func_code": "def _read_fmi(content: str):\n    r\"\"\"Read format used by Finnish Meteorological Institute and University of\n    Helsinki.\n\n    Format consists of sequence of the following:\n    - \"[YYYY-MM-DD HH:MM:SS\\n\"\n    - output of \"CS/PA\" command without non-printable characters at the end\n    - \"]\\n\"\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.disdrometer.thies.thies2nc", "project": "cloudnetpy", "func": "thies2nc", "origin_file": "cloudnetpy/instruments/disdrometer/thies.py", "test_list": ["tests/unit/test_disdrometer.py"], "prob_info": {"func_start_lineno": 71, "func_end_lineno": 116, "key_block_start_lineno": 102, "key_block_end_lineno": 116, "new_func_code": "def thies2nc(\n    disdrometer_file: str,\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | datetime.date | None = None,\n) -> str:\n    \"\"\"Converts Thies-LNM disdrometer data into Cloudnet Level 1b netCDF file.\n\n    Args:\n        disdrometer_file: Filename of disdrometer .log file.\n        output_file: Output filename.\n        site_meta: Dictionary containing information about the site. Required key\n            is `name`.\n        uuid: Set specific UUID for the file.\n        date: Expected date of the measurements as YYYY-MM-DD.\n\n    Returns:\n        UUID of the generated file.\n\n    Raises:\n        DisdrometerDataError: Timestamps do not match the expected date, or unable\n            to read the disdrometer file.\n\n    Examples:\n        >>> from cloudnetpy.instruments import thies2nc\n        >>> site_meta = {'name': 'Lindenberg', 'altitude': 104, 'latitude': 52.2,\n        'longitude': 14.1}\n        >>> uuid = thies2nc('thies-lnm.log', 'thies-lnm.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.get_wl_band", "project": "cloudnetpy", "func": "get_wl_band", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_drizzle.py"], "prob_info": {"func_start_lineno": 696, "func_end_lineno": 713, "key_block_start_lineno": 706, "key_block_end_lineno": 713, "new_func_code": "def get_wl_band(radar_frequency: float) -> Literal[\"X\", \"Ka\", \"W\"]:\n    \"\"\"Returns IEEE radar band corresponding to radar frequency.\n\n    Args:\n        radar_frequency: Radar frequency (GHz).\n\n    Returns:\n        IEEE radar band as string.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.products.product_tools.interpolate_model", "project": "cloudnetpy", "func": "interpolate_model", "origin_file": "cloudnetpy/products/product_tools.py", "test_list": ["tests/unit/test_drizzle.py"], "prob_info": {"func_start_lineno": 285, "func_end_lineno": 306, "key_block_start_lineno": 297, "key_block_end_lineno": 306, "new_func_code": "def interpolate_model(cat_file: str, names: str | list) -> dict[str, np.ndarray]:\n    \"\"\"Interpolates 2D model field into dense Cloudnet grid.\n\n    Args:\n        cat_file: Categorize file name.\n        names: Model variable to be interpolated, e.g. 'temperature' or ['temperature',\n            'pressure'].\n\n    Returns:\n        dict: Interpolated variables.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.interpolate_2d", "project": "cloudnetpy", "func": "interpolate_2d", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_drizzle.py"], "prob_info": {"func_start_lineno": 347, "func_end_lineno": 371, "key_block_start_lineno": 370, "key_block_end_lineno": 371, "new_func_code": "def interpolate_2d(\n    x: np.ndarray,\n    y: np.ndarray,\n    z: np.ndarray,\n    x_new: np.ndarray,\n    y_new: np.ndarray,\n) -> np.ndarray:\n    \"\"\"Linear interpolation of gridded 2d data.\n\n    Args:\n        x: 1-D array.\n        y: 1-D array.\n        z: 2-D array at points (x, y).\n        x_new: 1-D array.\n        y_new: 1-D array.\n\n    Returns:\n        Interpolated data.\n\n    Notes:\n        Does not work with nans. Ignores mask of masked data. Does not extrapolate.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.products.drizzle_error.get_drizzle_error", "project": "cloudnetpy", "func": "get_drizzle_error", "origin_file": "cloudnetpy/products/drizzle_error.py", "test_list": ["tests/unit/test_drizzle.py"], "prob_info": {"func_start_lineno": 11, "func_end_lineno": 33, "key_block_start_lineno": 25, "key_block_end_lineno": 33, "new_func_code": "def get_drizzle_error(\n    categorize: DrizzleSource,\n    drizzle_parameters: DrizzleSolver,\n) -> dict:\n    \"\"\"Estimates error and bias for drizzle classification.\n\n    Args:\n        categorize: The :class:`DrizzleSource` instance.\n        drizzle_parameters: The :class:`DrizzleSolver` instance.\n\n    Returns:\n        dict: Dictionary containing information of estimated error and bias for drizzle\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.l2norm_weighted", "project": "cloudnetpy", "func": "l2norm_weighted", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_drizzle.py"], "prob_info": {"func_start_lineno": 504, "func_end_lineno": 529, "key_block_start_lineno": 527, "key_block_end_lineno": 529, "new_func_code": "def l2norm_weighted(\n    values: tuple,\n    overall_scale: float,\n    term_weights: tuple,\n) -> ma.MaskedArray:\n    \"\"\"Calculates scaled and weighted Euclidean distance.\n\n    Calculated distance is of form: scale * sqrt((a1*a)**2 + (b1*b)**2 + ...)\n    where a, b, ... are terms to be summed and a1, a2, ... are optional weights\n    for the terms.\n\n    Args:\n        values: Tuple containing the values.\n        overall_scale: Scale factor for the calculated Euclidean distance.\n        term_weights: Weights for the terms. Must be single float or a list of numbers\n            (one per term).\n\n    Returns:\n        Scaled and weighted Euclidean distance.\n\n    TODO: Use masked arrays instead of tuples.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.droplet.ind_base", "project": "cloudnetpy", "func": "ind_base", "origin_file": "cloudnetpy/categorize/droplet.py", "test_list": ["tests/unit/test_droplet.py"], "prob_info": {"func_start_lineno": 124, "func_end_lineno": 186, "key_block_start_lineno": 183, "key_block_end_lineno": 186, "new_func_code": "def ind_base(dprof: np.ndarray, ind_peak: int, dist: int, lim: float) -> int:\n    \"\"\"Finds base index of a peak in profile.\n\n    Return the lowermost index of profile where 1st order differences\n    below the peak exceed a threshold value.\n\n    Args:\n        dprof: 1-D array of 1st discrete difference. Masked values should\n            be 0, e.g. dprof = np.diff(masked_prof).filled(0)\n        ind_peak: Index of (possibly local) peak in the original profile.\n            Note that the peak must be found with some other method before\n            calling this function.\n        dist: Number of elements investigated below *p*. If ( *p* - *dist*)<0,\n            search starts from index 0.\n        lim: Parameter for base index. Values greater than 1.0 are valid.\n            Values close to 1 most likely return the point right below the\n            maximum 1st order difference (within *dist* points below *p*).\n            Values larger than 1 more likely accept some other point, lower\n            in the profile.\n\n    Returns:\n        Base index of the peak.\n\n    Raises:\n        IndexError: Can't find proper base index (probably too many masked\n            values in the profile).\n\n    Examples:\n        Consider a profile\n\n        >>> x = np.array([0, 0.5, 1, -99, 4, 8, 5])\n\n        that contains one bad, masked value\n\n        >>> mx = ma.masked_array(x, mask=[0, 0, 0, 1, 0, 0, 0])\n            [0, 0.5, 1.0, --, 4.0, 8.0, 5.0]\n\n        The 1st order difference is now\n\n        >>> dx = np.diff(mx).filled(0)\n            [0.5, 0.5, 0, 0, 4, -3]\n\n        From the original profile we see that the peak index is 5.\n        Let's assume our base can't be more than 4 elements below\n        peak and the threshold value is 2. Thus we call\n\n        >>> ind_base(dx, 5, 4, 2)\n            4\n\n        When x[4] is the lowermost point that satisfies the condition.\n        Changing the threshold value would alter the result\n\n        >>> ind_base(dx, 5, 4, 10)\n            1\n\n    See Also:\n        droplet.ind_top()\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.droplet.ind_top", "project": "cloudnetpy", "func": "ind_top", "origin_file": "cloudnetpy/categorize/droplet.py", "test_list": ["tests/unit/test_droplet.py"], "prob_info": {"func_start_lineno": 189, "func_end_lineno": 222, "key_block_start_lineno": 219, "key_block_end_lineno": 222, "new_func_code": "def ind_top(dprof: np.ndarray, ind_peak: int, nprof: int, dist: int, lim: float) -> int:\n    \"\"\"Finds top index of a peak in profile.\n\n    Return the uppermost index of profile where 1st order differences\n    above the peak exceed a threshold value.\n\n    Args:\n        dprof: 1-D array of 1st discrete difference. Masked values should be 0, e.g.\n            dprof = np.diff(masked_prof).filled(0)\n        nprof: Length of the profile. Top index can't be higher than this.\n        ind_peak: Index of (possibly local) peak in the profile. Note that the peak\n            must be found with some other method before calling this function.\n        dist: Number of elements investigated above *p*. If (*p* + *dist*) > *nprof*,\n            search ends to *nprof*.\n        lim: Parameter for top index. Values greater than 1.0 are valid. Values close\n            to 1 most likely return the point right above the maximum 1st order\n            difference (within *dist* points above *p*). Values larger than 1 more\n            likely accept some other point, higher in the profile.\n\n    Returns:\n        Top index of the peak.\n\n    Raises:\n        IndexError: Can not find proper top index (probably too many masked\n            values in the profile).\n\n    See Also:\n        droplet.ind_base()\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.droplet.interpolate_lwp", "project": "cloudnetpy", "func": "interpolate_lwp", "origin_file": "cloudnetpy/categorize/droplet.py", "test_list": ["tests/unit/test_droplet.py"], "prob_info": {"func_start_lineno": 225, "func_end_lineno": 238, "key_block_start_lineno": 235, "key_block_end_lineno": 238, "new_func_code": "def interpolate_lwp(obs: ClassData) -> np.ndarray:\n    \"\"\"Linear interpolation of liquid water path to fill masked values.\n\n    Args:\n        obs: The :class:`ClassData` instance.\n\n    Returns:\n        Liquid water path where the masked values are filled by interpolation.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.output.copy_variables", "project": "cloudnetpy", "func": "copy_variables", "origin_file": "cloudnetpy/output.py", "test_list": ["tests/unit/test_epsilon.py"], "prob_info": {"func_start_lineno": 273, "func_end_lineno": 303, "key_block_start_lineno": 286, "key_block_end_lineno": 303, "new_func_code": "def copy_variables(\n    source: netCDF4.Dataset,\n    target: netCDF4.Dataset,\n    keys: tuple,\n) -> None:\n    \"\"\"Copies variables (and their attributes) from one file to another.\n\n    Args:\n        source: Source object.\n        target: Target object.\n        keys: Variable names to be copied.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.freezing.find_t0_alt", "project": "cloudnetpy", "func": "find_t0_alt", "origin_file": "cloudnetpy/categorize/freezing.py", "test_list": ["tests/unit/test_freezing.py"], "prob_info": {"func_start_lineno": 81, "func_end_lineno": 107, "key_block_start_lineno": 92, "key_block_end_lineno": 107, "new_func_code": "def find_t0_alt(temperature: np.ndarray, height: np.ndarray) -> np.ndarray:\n    \"\"\"Interpolates altitudes where temperature goes below freezing.\n\n    Args:\n        temperature: 2-D temperature (K).\n        height: 1-D altitude grid (m).\n\n    Returns:\n        1-D array denoting altitudes where the temperature drops below 0 deg C.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.output._write_vars2nc", "project": "cloudnetpy", "func": "_write_vars2nc", "origin_file": "cloudnetpy/output.py", "test_list": ["tests/unit/test_galileo.py"], "prob_info": {"func_start_lineno": 395, "func_end_lineno": 414, "key_block_start_lineno": 397, "key_block_end_lineno": 414, "new_func_code": "def _write_vars2nc(nc: netCDF4.Dataset, cloudnet_variables: dict) -> None:\n    \"\"\"Iterates over Cloudnet instances and write to netCDF file.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.hatpro.hatpro2nc", "project": "cloudnetpy", "func": "hatpro2nc", "origin_file": "cloudnetpy/instruments/hatpro.py", "test_list": ["tests/unit/test_hatpro.py"], "prob_info": {"func_start_lineno": 134, "func_end_lineno": 194, "key_block_start_lineno": 178, "key_block_end_lineno": 194, "new_func_code": "def hatpro2nc(\n    path_to_files: str,\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | None = None,\n) -> tuple[str, list]:\n    \"\"\"Converts RPG HATPRO microwave radiometer data into Cloudnet Level 1b\n    netCDF file.\n\n    This function reads one day of RPG HATPRO .LWP and .IWV binary files,\n    concatenates the data and writes it into netCDF file.\n\n    Args:\n        path_to_files: Folder containing one day of RPG HATPRO files.\n        output_file: Output file name.\n        site_meta: Dictionary containing information about the site with keys:\n\n            - `name`: Name of the site (required)\n            - `altitude`: Site altitude in [m] (optional).\n            - `latitude` (optional).\n            - `longitude` (optional).\n\n        uuid: Set specific UUID for the file.\n        date: Expected date in the input files. If not set,\n            all files will be used. This might cause unexpected behavior if\n            there are files from several days. If date is set as 'YYYY-MM-DD',\n            only files that match the date will be used.\n\n    Returns:\n        2-element tuple containing\n\n        - UUID of the generated file.\n        - Files used in the processing.\n\n    Raises:\n        ValidTimeStampError: No valid timestamps found.\n\n    Examples:\n        >>> from cloudnetpy.instruments import hatpro2nc\n        >>> site_meta = {'name': 'Hyytiala', 'altitude': 174}\n        >>> hatpro2nc('/path/to/files/', 'hatpro.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.itu.calc_liquid_specific_attenuation", "project": "cloudnetpy", "func": "calc_liquid_specific_attenuation", "origin_file": "cloudnetpy/categorize/itu.py", "test_list": ["tests/unit/test_itu.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 39, "key_block_start_lineno": 24, "key_block_end_lineno": 39, "new_func_code": "def calc_liquid_specific_attenuation(\n    temperature: npt.NDArray, frequency: float | np.floating\n) -> npt.NDArray:\n    \"\"\"Calculate cloud liquid water specific attenuation coefficient for\n    frequency up to 200 GHz.\n\n    Args:\n        temperature: Temperature (K)\n        frequency: Frequency (GHz)\n\n    Returns:\n        Cloud liquid water specific attenuation coefficient ((dB km-1)/(g m-3))\n\n    References:\n        ITU-R P.840-9: Attenuation due to clouds and fog.\n        https://www.itu.int/dms_pubrec/itu-r/rec/p/R-REC-P.840-9-202308-I!!PDF-E.pdf\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.atmos_utils.fill_clouds_with_lwc_dz", "project": "cloudnetpy", "func": "fill_clouds_with_lwc_dz", "origin_file": "cloudnetpy/categorize/atmos_utils.py", "test_list": ["tests/unit/test_lwc.py"], "prob_info": {"func_start_lineno": 154, "func_end_lineno": 172, "key_block_start_lineno": 169, "key_block_end_lineno": 172, "new_func_code": "def fill_clouds_with_lwc_dz(\n    temperature: np.ndarray, pressure: np.ndarray, is_liquid: np.ndarray\n) -> np.ndarray:\n    \"\"\"Fills liquid clouds with lwc change rate at the cloud bases.\n\n    Args:\n        temperature: 2D temperature array (K).\n        pressure: 2D pressure array (Pa).\n        is_liquid: Boolean array indicating presence of liquid clouds.\n\n    Returns:\n        Liquid water content change rate (kg m-3 m-1), so that for each cloud the base\n        value is filled for the whole cloud.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.atmos_utils.calc_lwc_change_rate", "project": "cloudnetpy", "func": "calc_lwc_change_rate", "origin_file": "cloudnetpy/categorize/atmos_utils.py", "test_list": ["tests/unit/test_lwc.py"], "prob_info": {"func_start_lineno": 201, "func_end_lineno": 242, "key_block_start_lineno": 218, "key_block_end_lineno": 242, "new_func_code": "def calc_lwc_change_rate(temperature: np.ndarray, pressure: np.ndarray) -> np.ndarray:\n    \"\"\"Returns rate of change of condensable water (LWC).\n\n    Calculates the theoretical adiabatic rate of increase of LWC\n    with height, given the cloud base temperature and pressure.\n\n    Args:\n        temperature: Temperature of cloud base (K).\n        pressure: Pressure of cloud base (Pa).\n\n    Returns:\n        dlwc/dz (kg m-3 m-1)\n\n    References:\n        Brenguier, 1991, https://doi.org/10.1175/1520-0469(1991)048<0264:POTCPA>2.0.CO;2\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.itu.calc_saturation_vapor_pressure", "project": "cloudnetpy", "func": "calc_saturation_vapor_pressure", "origin_file": "cloudnetpy/categorize/itu.py", "test_list": ["tests/unit/test_model.py"], "prob_info": {"func_start_lineno": 134, "func_end_lineno": 153, "key_block_start_lineno": 149, "key_block_end_lineno": 153, "new_func_code": "def calc_saturation_vapor_pressure(temperature: npt.NDArray) -> npt.NDArray:\n    \"\"\"Calculate saturation vapor pressure using Tetens equation with respect to\n    water or ice depending on whether the temperature is above freezing or not.\n\n    Args:\n        temperature: Temperature (K)\n\n    Returns:\n        Saturation vapor pressure (Pa)\n\n    References:\n        Murray, F. W. (1967). On the Computation of Saturation Vapor Pressure.\n        Journal of Applied Meteorology and Climatology, 6(1), 203-204.\n        https://doi.org/10.1175/1520-0450(1967)006<0203:OTCOSV>2.0.CO;2\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.output.copy_global", "project": "cloudnetpy", "func": "copy_global", "origin_file": "cloudnetpy/output.py", "test_list": ["tests/unit/test_output.py"], "prob_info": {"func_start_lineno": 306, "func_end_lineno": 322, "key_block_start_lineno": 319, "key_block_end_lineno": 322, "new_func_code": "def copy_global(\n    source: netCDF4.Dataset,\n    target: netCDF4.Dataset,\n    attributes: tuple,\n) -> None:\n    \"\"\"Copies global attributes from one file to another.\n\n    Args:\n        source: Source object.\n        target: Target object.\n        attributes: List of attributes to be copied.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.output.get_source_uuids", "project": "cloudnetpy", "func": "get_source_uuids", "origin_file": "cloudnetpy/output.py", "test_list": ["tests/unit/test_output.py"], "prob_info": {"func_start_lineno": 182, "func_end_lineno": 202, "key_block_start_lineno": 192, "key_block_end_lineno": 202, "new_func_code": "def get_source_uuids(data: Observations | list[netCDF4.Dataset | DataSource]) -> str:\n    \"\"\"Returns file_uuid attributes of objects.\n\n    Args:\n        data: Observations instance.\n\n    Returns:\n        str: UUIDs separated by comma.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.plotting.plotting.generate_figure", "project": "cloudnetpy", "func": "generate_figure", "origin_file": "cloudnetpy/plotting/plotting.py", "test_list": ["tests/unit/test_plotting.py"], "prob_info": {"func_start_lineno": 880, "func_end_lineno": 956, "key_block_start_lineno": 901, "key_block_end_lineno": 956, "new_func_code": "def generate_figure(\n    filename: os.PathLike | str,\n    variables: list[str],\n    *,\n    show: bool = True,\n    output_filename: os.PathLike | str | None = None,\n    options: PlotParameters | None = None,\n) -> Dimensions:\n    \"\"\"Generate a figure based on the given filename and variables.\n\n    Args:\n        filename: The path to the input file.\n        variables: A list of variable names to plot.\n        show: Whether to display the figure. Defaults to True.\n        output_filename: The path to save the figure. Defaults to None.\n        options: Additional plot parameters. Defaults to None.\n\n    Returns:\n        Dimensions: Dimensions of a generated figure in pixels.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.pollyxt.pollyxt2nc", "project": "cloudnetpy", "func": "pollyxt2nc", "origin_file": "cloudnetpy/instruments/pollyxt.py", "test_list": ["tests/unit/test_pollyxt.py"], "prob_info": {"func_start_lineno": 20, "func_end_lineno": 67, "key_block_start_lineno": 53, "key_block_end_lineno": 67, "new_func_code": "def pollyxt2nc(\n    input_folder: str,\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | None = None,\n) -> str:\n    \"\"\"Converts PollyXT Raman lidar data into Cloudnet Level 1b netCDF file.\n\n    Args:\n        input_folder: Path to pollyxt netCDF files.\n        output_file: Output filename.\n        site_meta: Dictionary containing information about the site with keys:\n\n            - `name`: Name of the site (mandatory)\n            - `altitude`: Site altitude in [m] (mandatory).\n            - `latitude` (optional).\n            - `longitude` (optional).\n            - `zenith_angle`: If not the default 5 degrees (optional).\n            - `snr_limit`: If not the default 2 (optional).\n        uuid: Set specific UUID for the file.\n        date: Expected date of the measurements as YYYY-MM-DD.\n\n    Returns:\n        UUID of the generated file.\n\n    Examples:\n        >>> from cloudnetpy.instruments import pollyxt2nc\n        >>> site_meta = {'name': 'Mindelo', 'altitude': 13, 'zenith_angle': 6,\n        'snr_limit': 3}\n        >>> pollyxt2nc('/path/to/files/', 'pollyxt.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.append_data", "project": "cloudnetpy", "func": "append_data", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_pollyxt.py"], "prob_info": {"func_start_lineno": 911, "func_end_lineno": 925, "key_block_start_lineno": 920, "key_block_end_lineno": 925, "new_func_code": "def append_data(data_in: dict, key: str, array: np.ndarray) -> dict:\n    \"\"\"Appends data to a dictionary field (creates the field if not yet present).\n\n    Args:\n        data_in: Dictionary where data will be appended.\n        key: Key of the field.\n        array: Numpy array to be appended to data_in[key].\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.radiometrics.radiometrics2nc", "project": "cloudnetpy", "func": "radiometrics2nc", "origin_file": "cloudnetpy/instruments/radiometrics.py", "test_list": ["tests/unit/test_radiometrics.py"], "prob_info": {"func_start_lineno": 20, "func_end_lineno": 73, "key_block_start_lineno": 47, "key_block_end_lineno": 73, "new_func_code": "def radiometrics2nc(\n    full_path: str,\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | datetime.date | None = None,\n) -> str:\n    \"\"\"Converts Radiometrics .csv file into Cloudnet Level 1b netCDF file.\n\n    Args:\n        full_path: Input file name or folder containing multiple input files.\n        output_file: Output file name, e.g. 'radiometrics.nc'.\n        site_meta: Dictionary containing information about the site and instrument.\n            Required key value pairs are `name` and `altitude` (metres above mean\n            sea level).\n        uuid: Set specific UUID for the file.\n        date: Expected date as YYYY-MM-DD of all profiles in the file.\n\n    Returns:\n        UUID of the generated file.\n\n    Examples:\n        >>> from cloudnetpy.instruments import radiometrics2nc\n        >>> site_meta = {'name': 'Soverato', 'altitude': 21}\n        >>> radiometrics2nc('radiometrics.csv', 'radiometrics.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.rpg.rpg2nc", "project": "cloudnetpy", "func": "rpg2nc", "origin_file": "cloudnetpy/instruments/rpg.py", "test_list": ["tests/unit/test_rpg.py"], "prob_info": {"func_start_lineno": 25, "func_end_lineno": 85, "key_block_start_lineno": 64, "key_block_end_lineno": 85, "new_func_code": "def rpg2nc(\n    path_to_l1_files: str,\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | None = None,\n) -> tuple[str, list]:\n    \"\"\"Converts RPG-FMCW-94 cloud radar data into Cloudnet Level 1b netCDF file.\n\n    This function reads one day of RPG Level 1 cloud radar binary files,\n    concatenates the data and writes a netCDF file.\n\n    Args:\n        path_to_l1_files: Folder containing one day of RPG LV1 files.\n        output_file: Output file name.\n        site_meta: Dictionary containing information about the\n            site. Required key value pairs are `altitude` (metres above mean\n            sea level) and `name`.\n        uuid: Set specific UUID for the file.\n        date: Expected date in the input files. If not set,\n            all files will be used. This might cause unexpected behavior if\n            there are files from several days. If date is set as 'YYYY-MM-DD',\n            only files that match the date will be used.\n\n    Returns:\n        2-element tuple containing\n\n        - UUID of the generated file.\n        - Files used in the processing.\n\n    Raises:\n        ValidTimeStampError: No valid timestamps found.\n\n    Examples:\n        >>> from cloudnetpy.instruments import rpg2nc\n        >>> site_meta = {'name': 'Hyytiala', 'altitude': 174}\n        >>> rpg2nc('/path/to/files/', 'test.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.array_to_probability", "project": "cloudnetpy", "func": "array_to_probability", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_utils.py"], "prob_info": {"func_start_lineno": 742, "func_end_lineno": 771, "key_block_start_lineno": 764, "key_block_end_lineno": 771, "new_func_code": "def array_to_probability(\n    array: np.ndarray,\n    loc: float,\n    scale: float,\n    *,\n    invert: bool = False,\n) -> np.ndarray:\n    \"\"\"Converts continuous variable into 0-1 probability.\n\n    Args:\n        array: Numpy array.\n        loc: Center of the distribution. Values smaller than this will have small\n            probability. Values greater than this will have large probability.\n        scale: Width of the distribution, i.e., how fast the probability drops or\n            increases from the peak.\n        invert: If True, large values have small probability and vice versa.\n            Default is False.\n\n    Returns:\n        Probability with the same shape as the input data.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.del_dict_keys", "project": "cloudnetpy", "func": "del_dict_keys", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_utils.py"], "prob_info": {"func_start_lineno": 724, "func_end_lineno": 739, "key_block_start_lineno": 735, "key_block_end_lineno": 739, "new_func_code": "def del_dict_keys(data: dict, keys: tuple | list) -> dict:\n    \"\"\"Deletes multiple keys from dictionary.\n\n    Args:\n        data: A dictionary.\n        keys: Keys to be deleted.\n\n    Returns:\n        Dictionary without the deleted keys.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.setbit", "project": "cloudnetpy", "func": "setbit", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_utils.py"], "prob_info": {"func_start_lineno": 316, "func_end_lineno": 344, "key_block_start_lineno": 339, "key_block_end_lineno": 344, "new_func_code": "def setbit(array: np.ndarray, nth_bit: int) -> np.ndarray:\n    \"\"\"Sets nth bit (0, 1, 2, ...) on number.\n\n    Args:\n        array: Integer array.\n        nth_bit: Bit to be set.\n\n    Returns:\n        Integer where nth bit is set.\n\n    Raises:\n        ValueError: negative bit as input.\n\n    Examples:\n        >>> setbit(1, 1)\n            3\n        >>> setbit(0, 2)\n            4\n\n    See Also:\n        utils.isbit()\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.filter_isolated_pixels", "project": "cloudnetpy", "func": "filter_isolated_pixels", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_utils.py"], "prob_info": {"func_start_lineno": 234, "func_end_lineno": 251, "key_block_start_lineno": 250, "key_block_end_lineno": 251, "new_func_code": "def filter_isolated_pixels(array: np.ndarray) -> np.ndarray:\n    \"\"\"From a 2D boolean array, remove completely isolated single cells.\n\n    Args:\n        array: 2-D boolean array containing isolated values.\n\n    Returns:\n        Cleaned array.\n\n    Examples:\n        >>> filter_isolated_pixels([[0, 0, 0], [0, 1, 0], [0, 0, 0]])\n            array([[0, 0, 0],\n                   [0, 0, 0],\n                   [0, 0, 0]])\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.filter_x_pixels", "project": "cloudnetpy", "func": "filter_x_pixels", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_utils.py"], "prob_info": {"func_start_lineno": 254, "func_end_lineno": 274, "key_block_start_lineno": 273, "key_block_end_lineno": 274, "new_func_code": "def filter_x_pixels(array: np.ndarray) -> np.ndarray:\n    \"\"\"From a 2D boolean array, remove cells isolated in x-direction.\n\n    Args:\n        array: 2-D boolean array containing isolated pixels in x-direction.\n\n    Returns:\n        Cleaned array.\n\n    Notes:\n        Stronger cleaning than `filter_isolated_pixels()`\n\n    Examples:\n        >>> filter_x_pixels([[1, 0, 0], [0, 1, 0], [0, 1, 1]])\n            array([[0, 0, 0],\n                   [0, 1, 0],\n                   [0, 1, 0]])\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.ffill", "project": "cloudnetpy", "func": "ffill", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_utils.py"], "prob_info": {"func_start_lineno": 552, "func_end_lineno": 577, "key_block_start_lineno": 571, "key_block_end_lineno": 577, "new_func_code": "def ffill(array: np.ndarray, value: int = 0) -> np.ndarray:\n    \"\"\"Forward fills an array.\n\n    Args:\n        array: 1-D or 2-D array.\n        value: Value to be filled. Default is 0.\n\n    Returns:\n        ndarray: Forward-filled array.\n\n    Examples:\n        >>> x = np.array([0, 5, 0, 0, 2, 0])\n        >>> ffill(x)\n            [0, 5, 5, 5, 2, 2]\n\n    Notes:\n        Works only in axis=1 direction.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.time_grid", "project": "cloudnetpy", "func": "time_grid", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_utils.py"], "prob_info": {"func_start_lineno": 101, "func_end_lineno": 121, "key_block_start_lineno": 117, "key_block_end_lineno": 121, "new_func_code": "def time_grid(time_step: int = 30) -> np.ndarray:\n    \"\"\"Returns decimal hour array between 0 and 24.\n\n    Computes fraction hour time vector 0-24 with user-given\n    resolution (in seconds).\n\n    Args:\n        time_step: Time resolution in seconds, greater than 1. Default is 30.\n\n    Returns:\n        Time vector between 0 and 24.\n\n    Raises:\n        ValueError: Bad resolution as input.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.mira.Mira::screen_invalid_ldr", "project": "cloudnetpy", "func": "Mira::screen_invalid_ldr", "origin_file": "cloudnetpy/instruments/mira.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 145, "func_end_lineno": 157, "key_block_start_lineno": 149, "key_block_end_lineno": 157, "new_func_code": "def screen_invalid_ldr(self) -> None:\n        \"\"\"Masks LDR in MIRA STSR mode data.\n        Is there a better way to identify this mode?\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.radar.Radar::rebin_to_grid", "project": "cloudnetpy", "func": "Radar::rebin_to_grid", "origin_file": "cloudnetpy/categorize/radar.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 52, "func_end_lineno": 81, "key_block_start_lineno": 59, "key_block_end_lineno": 81, "new_func_code": "def rebin_to_grid(self, time_new: np.ndarray) -> list:\n        \"\"\"Rebins radar data in time using mean.\n\n        Args:\n            time_new: Target time array as fraction hour. Updates *time* attribute.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.cloudnetarray.CloudnetArray::calc_linear_std", "project": "cloudnetpy", "func": "CloudnetArray::calc_linear_std", "origin_file": "cloudnetpy/cloudnetarray.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 158, "func_end_lineno": 170, "key_block_start_lineno": 168, "key_block_end_lineno": 170, "new_func_code": "def calc_linear_std(self, time: np.ndarray, time_new: np.ndarray) -> None:\n        \"\"\"Calculates std of radar velocity.\n\n        Args:\n            time: 1D time array.\n            time_new: 1D new time array.\n\n        Notes:\n            The result is masked if the bin contains masked values.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.classify.classify_measurements", "project": "cloudnetpy", "func": "classify_measurements", "origin_file": "cloudnetpy/categorize/classify.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 25, "func_end_lineno": 102, "key_block_start_lineno": 49, "key_block_end_lineno": 102, "new_func_code": "def classify_measurements(data: Observations) -> ClassificationResult:\n    \"\"\"Classifies radar/lidar observations.\n\n    This function classifies atmospheric scatterers from the input data.\n    The input data needs to be averaged or interpolated to the common\n    time / height grid before calling this function.\n\n    Args:\n        data: A :class:`Observations` instance.\n\n    Returns:\n        A :class:`ClassificationResult` instance.\n\n    References:\n        The Cloudnet classification scheme is based on methodology proposed by\n        Hogan R. and O'Connor E., 2004, https://bit.ly/2Yjz9DZ and its\n        proprietary Matlab implementation.\n\n    Notes:\n        Some individual classification methods are changed in this Python\n        implementation compared to the original Cloudnet methodology.\n        Especially methods classifying insects, melting layer and liquid droplets.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.insects.find_insects", "project": "cloudnetpy", "func": "find_insects", "origin_file": "cloudnetpy/categorize/insects.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 12, "func_end_lineno": 52, "key_block_start_lineno": 49, "key_block_end_lineno": 52, "new_func_code": "def find_insects(\n    obs: ClassData,\n    melting_layer: np.ndarray,\n    liquid_layers: np.ndarray,\n    prob_lim: float = 0.8,\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"Returns insect probability and boolean array of insect presence.\n\n    Insects are classified by estimating heuristic probability\n    of insects from various individual radar parameters and combining\n    these probabilities. Insects typically yield small echo and spectral width\n    but high linear depolarization ratio (ldr), and they are present in warm\n    temperatures.\n\n    The combination of echo, ldr and temperature is generally the best proxy\n    for insects. If ldr is not available, we use other radar parameters.\n\n    Insects are finally screened from liquid layers and melting layer - and\n    above melting layer.\n\n    Args:\n        obs: The :class:`ClassData` instance.\n        melting_layer: 2D array denoting melting layer.\n        liquid_layers: 2D array denoting liquid layers.\n        prob_lim: Probability higher than this will lead to positive detection.\n            Default is 0.8.\n\n    Returns:\n        tuple: 2-element tuple containing\n\n        - 2-D boolean flag of insects presence.\n        - 2-D probability of pixel containing insects.\n\n    Notes:\n        This insect detection method is novel and needs to be validated.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.falling.find_falling_hydrometeors", "project": "cloudnetpy", "func": "find_falling_hydrometeors", "origin_file": "cloudnetpy/categorize/falling.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 11, "func_end_lineno": 43, "key_block_start_lineno": 36, "key_block_end_lineno": 43, "new_func_code": "def find_falling_hydrometeors(\n    obs: ClassData,\n    is_liquid: np.ndarray,\n    is_insects: np.ndarray,\n) -> np.ndarray:\n    \"\"\"Finds falling hydrometeors.\n\n    Falling hydrometeors are radar signals that are\n    a) not insects b) not clutter. Furthermore, falling hydrometeors\n    are strong lidar pixels excluding liquid layers (thus these pixels\n    are ice or rain). They are also weak radar signals in very cold\n    temperatures.\n\n    Args:\n        obs: The :class:`ClassData` instance.\n        is_liquid: 2-D boolean array of liquid droplets.\n        is_insects: 2-D boolean array of insects.\n\n    Returns:\n        2-D boolean array containing falling hydrometeors.\n\n    References:\n        Hogan R. and O'Connor E., 2004, https://bit.ly/2Yjz9DZ.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.classify._find_drizzle_and_falling", "project": "cloudnetpy", "func": "_find_drizzle_and_falling", "origin_file": "cloudnetpy/categorize/classify.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 171, "func_end_lineno": 189, "key_block_start_lineno": 182, "key_block_end_lineno": 189, "new_func_code": "def _find_drizzle_and_falling(bits: CategoryBits) -> np.ndarray:\n    \"\"\"Classifies pixels as falling, drizzle and others.\n\n    Args:\n        bits: A :class:`CategoryBits instance.\n\n    Returns:\n        2D array where values are 1 (falling, drizzle, supercooled liquids),\n        2 (drizzle), and masked (all others).\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.atmos_utils.get_lwc_change_rate_at_bases", "project": "cloudnetpy", "func": "get_lwc_change_rate_at_bases", "origin_file": "cloudnetpy/categorize/atmos_utils.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 175, "func_end_lineno": 198, "key_block_start_lineno": 191, "key_block_end_lineno": 198, "new_func_code": "def get_lwc_change_rate_at_bases(\n    temperature: np.ndarray,\n    pressure: np.ndarray,\n    is_liquid: np.ndarray,\n) -> np.ndarray:\n    \"\"\"Finds LWC change rate in liquid cloud bases.\n\n    Args:\n        temperature: 2D temperature array (K).\n        pressure: 2D pressure array (Pa).\n        is_liquid: Boolean array indicating presence of liquid clouds.\n\n    Returns:\n        Liquid water content change rate at cloud bases (kg m-3 m-1).\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.atmos_utils.calc_air_density", "project": "cloudnetpy", "func": "calc_air_density", "origin_file": "cloudnetpy/categorize/atmos_utils.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 283, "func_end_lineno": 299, "key_block_start_lineno": 299, "key_block_end_lineno": 299, "new_func_code": "def calc_air_density(\n    pressure: np.ndarray,\n    temperature: np.ndarray,\n    svp_mixing_ratio: np.ndarray,\n) -> np.ndarray:\n    \"\"\"Calculates air density (kg m-3).\n\n    Args:\n        pressure: Pressure (Pa).\n        temperature: Temperature (K).\n        svp_mixing_ratio: Saturation vapor pressure mixing ratio (kg kg-1).\n\n    Returns:\n        Air density (kg m-3).\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.atmos_utils.normalize_lwc_by_lwp", "project": "cloudnetpy", "func": "normalize_lwc_by_lwp", "origin_file": "cloudnetpy/categorize/atmos_utils.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 321, "func_end_lineno": 342, "key_block_start_lineno": 339, "key_block_end_lineno": 342, "new_func_code": "def normalize_lwc_by_lwp(\n    lwc_adiabatic: np.ndarray, lwp: np.ndarray, height: np.ndarray\n) -> np.ndarray:\n    \"\"\"Finds LWC that would produce measured LWP.\n\n    Calculates LWP-weighted, normalized LWC. This is the measured\n    LWP distributed to liquid cloud pixels according to their\n    theoretical proportion.\n\n    Args:\n        lwc_adiabatic: Theoretical 2D liquid water content (kg m-3).\n        lwp: 1D liquid water path (kg m-2).\n        height: Height vector (m).\n\n    Returns:\n        2D LWP-weighted, scaled LWC (kg m-3) that would produce the observed LWP.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.radar.Radar::correct_atten", "project": "cloudnetpy", "func": "Radar::correct_atten", "origin_file": "cloudnetpy/categorize/radar.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 206, "func_end_lineno": 224, "key_block_start_lineno": 217, "key_block_end_lineno": 224, "new_func_code": "def correct_atten(self, attenuations: RadarAttenuation) -> None:\n        \"\"\"Corrects radar echo for liquid and gas attenuation.\n\n        Args:\n            attenuations: Radar attenuation object.\n\n        References:\n            The method is based on Hogan R. and O'Connor E., 2004,\n            https://bit.ly/2Yjz9DZ and the original Cloudnet Matlab implementation.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.radar.Radar::calc_errors", "project": "cloudnetpy", "func": "Radar::calc_errors", "origin_file": "cloudnetpy/categorize/radar.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 226, "func_end_lineno": 315, "key_block_start_lineno": 245, "key_block_end_lineno": 315, "new_func_code": "def calc_errors(\n        self,\n        attenuations: RadarAttenuation,\n        is_clutter: np.ndarray,\n    ) -> None:\n        \"\"\"Calculates uncertainties of radar echo.\n\n        Calculates and adds `Z_error`, `Z_sensitivity` and `Z_bias`\n        :class:`CloudnetArray` instances to `data` attribute.\n\n        Args:\n            attenuations: 2-D attenuations due to atmospheric gases.\n            is_clutter: 2-D boolean array denoting pixels contaminated by clutter.\n\n        References:\n            The method is based on Hogan R. and O'Connor E., 2004,\n            https://bit.ly/2Yjz9DZ and the original Cloudnet Matlab implementation.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.output.merge_history", "project": "cloudnetpy", "func": "merge_history", "origin_file": "cloudnetpy/output.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 205, "func_end_lineno": 235, "key_block_start_lineno": 216, "key_block_end_lineno": 235, "new_func_code": "def merge_history(\n    nc: netCDF4.Dataset, file_type: str, data: Observations | DataSource\n) -> None:\n    \"\"\"Merges history fields from one or several files and creates a new record.\n\n    Args:\n        nc: The netCDF Dataset instance.\n        file_type: Long description of the file.\n        data: Dictionary of objects with history attribute.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.ceilometer.NoisyData::_find_fog_profiles", "project": "cloudnetpy", "func": "NoisyData::_find_fog_profiles", "origin_file": "cloudnetpy/instruments/ceilometer.py", "test_list": ["tests/unit/test_cl61d.py"], "prob_info": {"func_start_lineno": 225, "func_end_lineno": 239, "key_block_start_lineno": 232, "key_block_end_lineno": 239, "new_func_code": "def _find_fog_profiles(\n        self,\n        n_gates_for_signal_sum: int = 20,\n        signal_sum_threshold: float = 1e-3,\n        variance_threshold: float = 1e-15,\n    ) -> np.ndarray:\n        \"\"\"Finds saturated (usually fog) profiles from beta_raw.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.datasource.DataSource::_init_altitude", "project": "cloudnetpy", "func": "DataSource::_init_altitude", "origin_file": "cloudnetpy/datasource.py", "test_list": ["tests/unit/test_datasource.py"], "prob_info": {"func_start_lineno": 162, "func_end_lineno": 174, "key_block_start_lineno": 164, "key_block_end_lineno": 174, "new_func_code": "def _init_altitude(self) -> float | None:\n        \"\"\"Returns altitude of the instrument (m).\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.falling._find_cold_aerosols", "project": "cloudnetpy", "func": "_find_cold_aerosols", "origin_file": "cloudnetpy/categorize/falling.py", "test_list": ["tests/unit/test_falling.py"], "prob_info": {"func_start_lineno": 53, "func_end_lineno": 88, "key_block_start_lineno": 61, "key_block_end_lineno": 88, "new_func_code": "def _find_cold_aerosols(obs: ClassData, is_liquid: np.ndarray) -> np.ndarray:\n    \"\"\"Lidar signals which are in colder than the threshold temperature\n    and threshold altitude from the ground are assumed ice.\n\n    These pixels are easily mixed with aerosols at lower altitudes,\n    and at higher altitudes they could be supercooled liquid, actually.\n    This should be investigated and fixed in the future.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.init", "project": "cloudnetpy", "func": "init", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_utils.py"], "prob_info": {"func_start_lineno": 580, "func_end_lineno": 613, "key_block_start_lineno": 609, "key_block_end_lineno": 613, "new_func_code": "def init(\n    n_vars: int,\n    shape: tuple,\n    dtype: type = float,\n    *,\n    masked: bool = True,\n) -> Iterator[np.ndarray | ma.MaskedArray]:\n    \"\"\"Initializes several numpy arrays.\n\n    Args:\n        n_vars: Number of arrays to be generated.\n        shape: Shape of the arrays, e.g. (2, 3).\n        dtype: The desired data-type for the arrays, e.g., int. Default is float.\n        masked: If True, generated arrays are masked arrays, else ordinary numpy arrays.\n            Default is True.\n\n    Yields:\n        Iterator containing the empty arrays.\n\n    Examples:\n        >>> a, b = init(2, (2, 3))\n        >>> a\n            masked_array(\n              data=[[0., 0., 0.],\n                    [0., 0., 0.]],\n              mask=False,\n              fill_value=1e+20)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.seconds2time", "project": "cloudnetpy", "func": "seconds2time", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_utils.py"], "prob_info": {"func_start_lineno": 51, "func_end_lineno": 66, "key_block_start_lineno": 61, "key_block_end_lineno": 66, "new_func_code": "def seconds2time(time_in_seconds: float) -> list:\n    \"\"\"Converts seconds since some epoch to time of day.\n\n    Args:\n        time_in_seconds: seconds since some epoch.\n\n    Returns:\n        list: [hours, minutes, seconds] formatted as '05' etc.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.mira._get_keymap", "project": "cloudnetpy", "func": "_get_keymap", "origin_file": "cloudnetpy/instruments/mira.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 240, "func_end_lineno": 284, "key_block_start_lineno": 244, "key_block_end_lineno": 284, "new_func_code": "def _get_keymap(filetype: str) -> dict:\n    \"\"\"Returns a dictionary mapping the variables in the raw data to the processed\n    Cloudnet file.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.cloudnetarray.CloudnetArray::rebin_velocity", "project": "cloudnetpy", "func": "CloudnetArray::rebin_velocity", "origin_file": "cloudnetpy/cloudnetarray.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 172, "func_end_lineno": 211, "key_block_start_lineno": 191, "key_block_end_lineno": 211, "new_func_code": "def rebin_velocity(\n        self,\n        time: np.ndarray,\n        time_new: np.ndarray,\n        folding_velocity: float | np.ndarray,\n        sequence_indices: list,\n    ) -> None:\n        \"\"\"Rebins Doppler velocity in polar coordinates.\n\n        Args:\n            time: 1D time array.\n            time_new: 1D new time array.\n            folding_velocity: Folding velocity (m/s). Can be a float when\n                it's the same for all altitudes, or np.ndarray when it\n                matches difference altitude regions (defined in `sequence_indices`).\n            sequence_indices: List containing indices of different folding regions,\n                e.g. [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10]].\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.get_files_with_common_range", "project": "cloudnetpy", "func": "get_files_with_common_range", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_copernicus.py"], "prob_info": {"func_start_lineno": 961, "func_end_lineno": 972, "key_block_start_lineno": 963, "key_block_end_lineno": 972, "new_func_code": "def get_files_with_common_range(filenames: list) -> list:\n    \"\"\"Returns files with the same (most common) number of range gates.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.disdrometer.parsivel._read_toa5", "project": "cloudnetpy", "func": "_read_toa5", "origin_file": "cloudnetpy/instruments/disdrometer/parsivel.py", "test_list": ["tests/unit/test_disdrometer.py"], "prob_info": {"func_start_lineno": 450, "func_end_lineno": 519, "key_block_start_lineno": 457, "key_block_end_lineno": 519, "new_func_code": "def _read_toa5(filename: str | PathLike) -> dict[str, list]:\n    \"\"\"Read ASCII data from Campbell Scientific datalogger such as CR1000.\n\n    References:\n        CR1000 Measurement and Control System.\n        https://s.campbellsci.com/documents/us/manuals/cr1000.pdf\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.rpg_reader._decode_angles", "project": "cloudnetpy", "func": "_decode_angles", "origin_file": "cloudnetpy/instruments/rpg_reader.py", "test_list": ["tests/unit/test_hatpro.py"], "prob_info": {"func_start_lineno": 123, "func_end_lineno": 161, "key_block_start_lineno": 137, "key_block_end_lineno": 161, "new_func_code": "def _decode_angles(\n    x: np.ndarray,\n    version: Literal[1, 2],\n) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"Decode elevation and azimuth angles.\n\n    >>> _decode_angles(np.array([1267438.5]), version=1)\n    (array([138.5]), array([267.4]))\n    >>> _decode_angles(np.array([1453031045, -900001232]), version=2)\n    (array([145.3, -90. ]), array([310.45,  12.32]))\n\n    Based on `interpret_angle` from mwr_raw2l1 licensed under BSD 3-Clause:\n    https://github.com/MeteoSwiss/mwr_raw2l1/blob/0738490d22f77138cdf9329bf102f319c78be584/mwr_raw2l1/readers/reader_rpg_helpers.py#L30\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.cloudnetarray.CloudnetArray::fetch_attributes", "project": "cloudnetpy", "func": "CloudnetArray::fetch_attributes", "origin_file": "cloudnetpy/cloudnetarray.py", "test_list": ["tests/unit/test_mrr.py"], "prob_info": {"func_start_lineno": 86, "func_end_lineno": 102, "key_block_start_lineno": 88, "key_block_end_lineno": 102, "new_func_code": "def fetch_attributes(self) -> list:\n        \"\"\"Returns list of user-defined attributes.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.mira.mira2nc", "project": "cloudnetpy", "func": "mira2nc", "origin_file": "cloudnetpy/instruments/mira.py", "test_list": ["tests/unit/test_categorize.py"], "prob_info": {"func_start_lineno": 16, "func_end_lineno": 104, "key_block_start_lineno": 58, "key_block_end_lineno": 104, "new_func_code": "def mira2nc(\n    raw_mira: str | list[str],\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | None = None,\n) -> str:\n    \"\"\"Converts METEK MIRA-35 cloud radar data into Cloudnet Level 1b netCDF file.\n\n    This function converts raw MIRA file(s) into a much smaller file that\n    contains only the relevant data and can be used in further processing\n    steps.\n\n    Args:\n        raw_mira: Filename of a daily MIRA .mmclx or .zncfile. Can be also a folder\n            containing several non-concatenated .mmclx or .znc files from one day\n            or list of files. znc files take precedence because they are the newer\n            filetype\n        output_file: Output filename.\n        site_meta: Dictionary containing information about the site. Required key\n            value pair is `name`.\n        uuid: Set specific UUID for the file.\n        date: Expected date as YYYY-MM-DD of all profiles in the file.\n\n    Returns:\n        UUID of the generated file.\n\n    Raises:\n        ValidTimeStampError: No valid timestamps found.\n        FileNotFoundError: No suitable input files found.\n        ValueError: Wrong suffix in input file(s).\n        TypeError: Mixed mmclx and znc files.\n\n    Examples:\n          >>> from cloudnetpy.instruments import mira2nc\n          >>> site_meta = {'name': 'Vehmasmaki'}\n          >>> mira2nc('raw_radar.mmclx', 'radar.nc', site_meta)\n          >>> mira2nc('raw_radar.znc', 'radar.nc', site_meta)\n          >>> mira2nc('/one/day/of/mira/mmclx/files/', 'radar.nc', site_meta)\n          >>> mira2nc('/one/day/of/mira/znc/files/', 'radar.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.concat_lib._Concat::concat_data", "project": "cloudnetpy", "func": "_Concat::concat_data", "origin_file": "cloudnetpy/concat_lib.py", "test_list": ["tests/unit/test_cl61d.py"], "prob_info": {"func_start_lineno": 151, "func_end_lineno": 171, "key_block_start_lineno": 158, "key_block_end_lineno": 171, "new_func_code": "def concat_data(\n        self,\n        variables: list | None,\n        ignore: list | None,\n        allow_vary: list | None,\n    ) -> list:\n        \"\"\"Concatenates data arrays.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.copernicus.copernicus2nc", "project": "cloudnetpy", "func": "copernicus2nc", "origin_file": "cloudnetpy/instruments/copernicus.py", "test_list": ["tests/unit/test_copernicus.py"], "prob_info": {"func_start_lineno": 15, "func_end_lineno": 109, "key_block_start_lineno": 46, "key_block_end_lineno": 109, "new_func_code": "def copernicus2nc(\n    raw_files: str,\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | None = None,\n) -> str:\n    \"\"\"Converts 'Copernicus' cloud radar data into Cloudnet Level 1b netCDF file.\n\n    Args:\n        raw_files: Input file name or folder containing multiple input files.\n        output_file: Output filename.\n        site_meta: Dictionary containing information about the site. Required key\n            value pair is `name`. Optional are `latitude`, `longitude`, `altitude` and\n            'calibration_offset' (default = -146.8).\n        uuid: Set specific UUID for the file.\n        date: Expected date as YYYY-MM-DD of all profiles in the file.\n\n    Returns:\n        UUID of the generated file.\n\n    Raises:\n        ValidTimeStampError: No valid timestamps found.\n\n    Examples:\n          >>> from cloudnetpy.instruments import copernicus2nc\n          >>> site_meta = {'name': 'Chilbolton'}\n          >>> copernicus2nc('raw_radar.nc', 'radar.nc', site_meta)\n          >>> copernicus2nc('/one/day/of/copernicus/files/', 'radar.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.droplet.correct_liquid_top", "project": "cloudnetpy", "func": "correct_liquid_top", "origin_file": "cloudnetpy/categorize/droplet.py", "test_list": ["tests/unit/test_droplet.py"], "prob_info": {"func_start_lineno": 12, "func_end_lineno": 43, "key_block_start_lineno": 34, "key_block_end_lineno": 43, "new_func_code": "def correct_liquid_top(\n    obs: ClassData,\n    is_liquid: np.ndarray,\n    is_freezing: np.ndarray,\n    limit: float = 200,\n) -> np.ndarray:\n    \"\"\"Corrects lidar detected liquid cloud top using radar data.\n\n    Args:\n        obs: The :class:`ClassData` instance.\n        is_liquid: 2-D boolean array denoting liquid clouds from lidar data.\n        is_freezing: 2-D boolean array of sub-zero temperature, derived from the model\n            temperature and melting layer based on radar data.\n        limit: The maximum correction distance (m) above liquid cloud top.\n\n    Returns:\n        Corrected liquid cloud array.\n\n    References:\n        Hogan R. and O'Connor E., 2004, https://bit.ly/2Yjz9DZ.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.droplet.find_liquid", "project": "cloudnetpy", "func": "find_liquid", "origin_file": "cloudnetpy/categorize/droplet.py", "test_list": ["tests/unit/test_droplet.py"], "prob_info": {"func_start_lineno": 52, "func_end_lineno": 121, "key_block_start_lineno": 82, "key_block_end_lineno": 121, "new_func_code": "def find_liquid(\n    obs: ClassData,\n    peak_amp: float = 1e-6,\n    max_width: float = 300,\n    min_points: int = 3,\n    min_top_der: float = 1e-7,\n    min_lwp: float = 0,\n    min_alt: float = 100,\n) -> np.ndarray:\n    \"\"\"Estimate liquid layers from SNR-screened attenuated backscatter.\n\n    Args:\n        obs: The :class:`ClassData` instance.\n        peak_amp: Minimum value of peak. Default is 1e-6.\n        max_width: Maximum width of peak. Default is 300 (m).\n        min_points: Minimum number of valid points in peak. Default is 3.\n        min_top_der: Minimum derivative above peak, defined as\n            (beta_peak-beta_top) / (alt_top-alt_peak). Default is 1e-7.\n        min_lwp: Minimum value from linearly interpolated lwp (kg m-2)\n            measured by the mwr. Default is 0.\n        min_alt: Minimum altitude of the peak from the ground. Default is 100 (m).\n\n    Returns:\n        2-D boolean array denoting liquid layers.\n\n    References:\n        The method is based on Tuononen, M. et.al, 2019,\n        https://acp.copernicus.org/articles/19/1985/2019/.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.freezing.find_freezing_region", "project": "cloudnetpy", "func": "find_freezing_region", "origin_file": "cloudnetpy/categorize/freezing.py", "test_list": ["tests/unit/test_freezing.py"], "prob_info": {"func_start_lineno": 14, "func_end_lineno": 59, "key_block_start_lineno": 37, "key_block_end_lineno": 59, "new_func_code": "def find_freezing_region(obs: ClassData, melting_layer: np.ndarray) -> np.ndarray:\n    \"\"\"Finds freezing region using the model temperature and melting layer.\n\n    Every profile that contains melting layer, subzero region starts from\n    the mean melting layer height. If there are (long) time windows where\n    no melting layer is present, model temperature is used in the\n    middle of the time window. Finally, the subzero altitudes are linearly\n    interpolated for all profiles.\n\n    Args:\n        obs: The :class:`ClassData` instance.\n        melting_layer: 2-D boolean array denoting melting layer.\n\n    Returns:\n        2-D boolean array denoting the sub-zero region.\n\n    Notes:\n        It is not clear how model temperature and melting layer should be\n        ideally combined to determine the sub-zero region. This current\n        method differs slightly from the original Matlab code and should\n        be validated more carefully later.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.galileo.galileo2nc", "project": "cloudnetpy", "func": "galileo2nc", "origin_file": "cloudnetpy/instruments/galileo.py", "test_list": ["tests/unit/test_galileo.py"], "prob_info": {"func_start_lineno": 14, "func_end_lineno": 105, "key_block_start_lineno": 45, "key_block_end_lineno": 105, "new_func_code": "def galileo2nc(\n    raw_files: str,\n    output_file: str,\n    site_meta: dict,\n    uuid: str | None = None,\n    date: str | None = None,\n) -> str:\n    \"\"\"Converts 'Galileo' cloud radar data into Cloudnet Level 1b netCDF file.\n\n    Args:\n        raw_files: Input file name or folder containing multiple input files.\n        output_file: Output filename.\n        site_meta: Dictionary containing information about the site. Required key\n            value pair is `name`. Optional are `latitude`, `longitude`, `altitude` and\n            `snr_limit` (default = 3).\n        uuid: Set specific UUID for the file.\n        date: Expected date as YYYY-MM-DD of all profiles in the file.\n\n    Returns:\n        UUID of the generated file.\n\n    Raises:\n        ValidTimeStampError: No valid timestamps found.\n\n    Examples:\n          >>> from cloudnetpy.instruments import galileo2nc\n          >>> site_meta = {'name': 'Chilbolton'}\n          >>> galileo2nc('raw_radar.nc', 'radar.nc', site_meta)\n          >>> galileo2nc('/one/day/of/galileo/files/', 'radar.nc', site_meta)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.itu.calc_gas_specific_attenuation", "project": "cloudnetpy", "func": "calc_gas_specific_attenuation", "origin_file": "cloudnetpy/categorize/itu.py", "test_list": ["tests/unit/test_itu.py"], "prob_info": {"func_start_lineno": 42, "func_end_lineno": 71, "key_block_start_lineno": 61, "key_block_end_lineno": 71, "new_func_code": "def calc_gas_specific_attenuation(\n    pressure: npt.NDArray,\n    vapor_pressure: npt.NDArray,\n    temperature: npt.NDArray,\n    frequency: float | np.floating,\n) -> npt.NDArray:\n    \"\"\"Calculate specific attenuation due to dry air and water vapor for\n    frequency up to 1000 GHz.\n\n    Args:\n        pressure: Pressure (Pa)\n        vapor_pressure: Water vapor partial pressure (Pa)\n        temperature: Temperature (K)\n        frequency: Frequency (GHz)\n\n    References:\n        ITU-R P.676-13: Attenuation by atmospheric gases and related effects.\n        https://www.itu.int/dms_pubrec/itu-r/rec/p/R-REC-P.676-13-202208-I!!PDF-E.pdf\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.interpolate_2d_nearest", "project": "cloudnetpy", "func": "interpolate_2d_nearest", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_lidar.py"], "prob_info": {"func_start_lineno": 420, "func_end_lineno": 452, "key_block_start_lineno": 443, "key_block_end_lineno": 452, "new_func_code": "def interpolate_2d_nearest(\n    x: np.ndarray,\n    y: np.ndarray,\n    z: np.ndarray,\n    x_new: np.ndarray,\n    y_new: np.ndarray,\n) -> ma.MaskedArray:\n    \"\"\"2D nearest neighbor interpolation preserving mask.\n\n    Args:\n        x: 1D array, x-coordinates.\n        y: 1D array, y-coordinates.\n        z: 2D masked array, data values.\n        x_new: 1D array, new x-coordinates.\n        y_new: 1D array, new y-coordinates.\n\n    Returns:\n        Interpolated 2D masked array.\n\n    Notes:\n        Points outside the original range will be interpolated but masked.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.melting.find_melting_layer", "project": "cloudnetpy", "func": "find_melting_layer", "origin_file": "cloudnetpy/categorize/melting.py", "test_list": ["tests/unit/test_melting.py"], "prob_info": {"func_start_lineno": 13, "func_end_lineno": 101, "key_block_start_lineno": 50, "key_block_end_lineno": 101, "new_func_code": "def find_melting_layer(obs: ClassData, *, smooth: bool = True) -> np.ndarray:\n    \"\"\"Finds melting layer from model temperature, ldr, and velocity.\n\n    Melting layer is detected using linear depolarization ratio, *ldr*,\n    Doppler velocity, *v*, and wet-bulb temperature, *Tw*.\n\n    The algorithm is based on *ldr* having a clear Gaussian peak around\n    the melting layer. This signature is caused by the growth of ice\n    crystals into snowflakes that are much larger. In addition, when snow and\n    ice melt, emerging heavy water droplets start to drop rapidly towards\n    ground. Thus, there is also a similar positive peak in the\n    first difference of *v*.\n\n    The peak in *ldr* is the primary parameter we analyze. If\n    *ldr* has a proper peak, and *v* < -1 m/s in the base, melting layer\n    has been found. If *ldr* is missing we only analyze the behaviour\n    of *v*, which is always present, to detect the melting layer.\n\n    Model temperature is used to limit the melting layer search to a certain\n    temperature range around 0 C. For ECMWF the range is -4..+3, and for\n    the rest -8..+6.\n\n    Notes:\n        This melting layer detection method is novel and needs to be validated.\n        Also note that there might be some detection problems with strong\n        updrafts of air. In these cases the absolute values for speed do not\n        make sense (rain drops can even move upwards instead of down).\n\n    Args:\n        obs: The :class:`ClassData` instance.\n        smooth: If True, apply a small Gaussian smoother to the\n            melting layer. Default is True.\n\n    Returns:\n        2-D boolean array denoting the melting layer.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.model.Model::interpolate_to_common_height", "project": "cloudnetpy", "func": "Model::interpolate_to_common_height", "origin_file": "cloudnetpy/categorize/model.py", "test_list": ["tests/unit/test_model.py"], "prob_info": {"func_start_lineno": 63, "func_end_lineno": 82, "key_block_start_lineno": 65, "key_block_end_lineno": 82, "new_func_code": "def interpolate_to_common_height(self) -> None:\n        \"\"\"Interpolates model variables to common height grid.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.model.Model::interpolate_to_grid", "project": "cloudnetpy", "func": "Model::interpolate_to_grid", "origin_file": "cloudnetpy/categorize/model.py", "test_list": ["tests/unit/test_model.py"], "prob_info": {"func_start_lineno": 84, "func_end_lineno": 113, "key_block_start_lineno": 99, "key_block_end_lineno": 113, "new_func_code": "def interpolate_to_grid(\n        self,\n        time_grid: np.ndarray,\n        height_grid: np.ndarray,\n    ) -> list:\n        \"\"\"Interpolates model variables to Cloudnet's dense time / height grid.\n\n        Args:\n            time_grid: The target time array (fraction hour).\n            height_grid: The target height array (m).\n\n        Returns:\n            Indices fully masked profiles.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.utils.interpolate_2d_mask", "project": "cloudnetpy", "func": "interpolate_2d_mask", "origin_file": "cloudnetpy/utils.py", "test_list": ["tests/unit/test_model.py"], "prob_info": {"func_start_lineno": 374, "func_end_lineno": 417, "key_block_start_lineno": 398, "key_block_end_lineno": 417, "new_func_code": "def interpolate_2d_mask(\n    x: np.ndarray,\n    y: np.ndarray,\n    z: ma.MaskedArray,\n    x_new: np.ndarray,\n    y_new: np.ndarray,\n) -> ma.MaskedArray:\n    \"\"\"2D linear interpolation preserving the mask.\n\n    Args:\n        x: 1D array, x-coordinates.\n        y: 1D array, y-coordinates.\n        z: 2D masked array, data values.\n        x_new: 1D array, new x-coordinates.\n        y_new: 1D array, new y-coordinates.\n\n    Returns:\n        Interpolated 2D masked array.\n\n    Notes:\n        Points outside the original range will be nans (and masked). Uses linear\n        interpolation. Input data may contain nan-values.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.instruments.mrr.mrr2nc", "project": "cloudnetpy", "func": "mrr2nc", "origin_file": "cloudnetpy/instruments/mrr.py", "test_list": ["tests/unit/test_mrr.py"], "prob_info": {"func_start_lineno": 18, "func_end_lineno": 115, "key_block_start_lineno": 51, "key_block_end_lineno": 115, "new_func_code": "def mrr2nc(\n    input_file: PathLike | str | Iterable[PathLike | str],\n    output_file: PathLike | str,\n    site_meta: dict,\n    uuid: UUID | str | None = None,\n    date: datetime.date | str | None = None,\n) -> str:\n    \"\"\"Converts METEK MRR-PRO data into Cloudnet Level 1b netCDF file.\n\n    This function converts raw MRR file(s) into a much smaller file that\n    contains only the relevant data.\n\n    Args:\n        input_file: Filename of a daily MMR-PRO .nc file, path to directory\n            containing several non-concatenated .nc files from one day, or list\n            of filenames.\n        output_file: Output filename.\n        site_meta: Dictionary containing information about the site. Required key\n            value pairs are `name`, `latitude`, `longitude` and `altitude`.\n        uuid: Set specific UUID for the file.\n        date: Expected date as YYYY-MM-DD of all profiles in the file.\n\n    Returns:\n        UUID of the generated file.\n\n    Raises:\n        ValidTimeStampError: No valid timestamps found.\n\n    Examples:\n          >>> from cloudnetpy.instruments import mira2nc\n          >>> site_meta = {'name': 'LIM', 'latitude': 51.333, 'longitude': 12.389}\n          >>> mrr2nc('input.nc', 'output.nc', site_meta)\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "cloudnetpy.cloudnetpy.categorize.radar.Radar::remove_incomplete_pixels", "project": "cloudnetpy", "func": "Radar::remove_incomplete_pixels", "origin_file": "cloudnetpy/categorize/radar.py", "test_list": ["tests/unit/test_radar.py"], "prob_info": {"func_start_lineno": 83, "func_end_lineno": 100, "key_block_start_lineno": 91, "key_block_end_lineno": 100, "new_func_code": "def remove_incomplete_pixels(self) -> None:\n        \"\"\"Mask radar pixels where one or more required quantities are missing.\n\n        All valid radar pixels **must** contain proper values for `Z`, and `v` and\n        also for `width` if exists. Otherwise there is some kind of problem with the\n        data and the pixel should not be used in any further analysis.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "d3rlpy.d3rlpy.optimizers.optimizers.OptimizerWrapper::step", "project": "d3rlpy", "func": "OptimizerWrapper::step", "origin_file": "./Source_Copy/d3rlpy/d3rlpy/optimizers/optimizers.py", "test_list": ["tests_copy/test_torch_utility.py"], "prob_info": {"func_start_lineno": 73, "func_end_lineno": 91, "key_block_start_lineno": 80, "key_block_end_lineno": 91, "new_func_code": "def step(self) -> None:\n        \"\"\"Updates parameters.\n\n        Args:\n            grad_step: Total gradient step. This can be used for learning rate\n                schedulers.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "d3rlpy.d3rlpy.dataset.components.Transition::observation_signature", "project": "d3rlpy", "func": "Transition::observation_signature", "origin_file": "./Source_Copy/d3rlpy/d3rlpy/dataset/components.py", "test_list": ["tests_copy/dataset/test_components.py"], "prob_info": {"func_start_lineno": 84, "func_end_lineno": 95, "key_block_start_lineno": 90, "key_block_end_lineno": 95, "new_func_code": "def observation_signature(self) -> Signature:\n        r\"\"\"Returns observation sigunature.\n\n        Returns:\n            Observation signature.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "d3rlpy.d3rlpy.dataset.components.PartialTrajectory::observation_signature", "project": "d3rlpy", "func": "PartialTrajectory::observation_signature", "origin_file": "./Source_Copy/d3rlpy/d3rlpy/dataset/components.py", "test_list": ["tests_copy/dataset/test_components.py"], "prob_info": {"func_start_lineno": 147, "func_end_lineno": 158, "key_block_start_lineno": 153, "key_block_end_lineno": 158, "new_func_code": "def observation_signature(self) -> Signature:\n        r\"\"\"Returns observation sigunature.\n\n        Returns:\n            Observation signature.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "d3rlpy.d3rlpy.dataset.writers.ExperienceWriter::write", "project": "d3rlpy", "func": "ExperienceWriter::write", "origin_file": "./Source_Copy/d3rlpy/d3rlpy/dataset/writers.py", "test_list": ["tests_copy/dataset/test_writers.py"], "prob_info": {"func_start_lineno": 351, "func_end_lineno": 372, "key_block_start_lineno": 364, "key_block_end_lineno": 372, "new_func_code": "def write(\n        self,\n        observation: Observation,\n        action: Union[int, NDArray],\n        reward: Union[float, NDArray],\n    ) -> None:\n        r\"\"\"Writes state tuple to buffer.\n\n        Args:\n            observation: Observation.\n            action: Action.\n            reward: Reward.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "d3rlpy.d3rlpy.base._process_device", "project": "d3rlpy", "func": "_process_device", "origin_file": "./Source_Copy/d3rlpy/d3rlpy/base.py", "test_list": ["tests_copy/envs/test_wrappers.py"], "prob_info": {"func_start_lineno": 151, "func_end_lineno": 166, "key_block_start_lineno": 157, "key_block_end_lineno": 166, "new_func_code": "def _process_device(value: DeviceArg) -> str:\n    \"\"\"Checks value and returns PyTorch target device.\n\n    Returns:\n        str: target device.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.random.rand", "project": "datachain", "func": "rand", "origin_file": "datachain/func/random.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 6, "func_end_lineno": 23, "key_block_start_lineno": 23, "key_block_end_lineno": 23, "new_func_code": "def rand() -> Func:\n    \"\"\"\n    Returns the random integer value.\n\n    Returns:\n        Func: A Func object that represents the rand function.\n\n    Example:\n        ```py\n        dc.mutate(\n            rnd=func.random.rand(),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type integer.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.catalog.catalog.Catalog::create_new_dataset_version", "project": "datachain", "func": "Catalog::create_new_dataset_version", "origin_file": "datachain/catalog/catalog.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 828, "func_end_lineno": 874, "key_block_start_lineno": 848, "key_block_end_lineno": 874, "new_func_code": "def create_new_dataset_version(\n        self,\n        dataset: DatasetRecord,\n        version: int,\n        *,\n        columns: Sequence[Column],\n        sources=\"\",\n        feature_schema=None,\n        query_script=\"\",\n        error_message=\"\",\n        error_stack=\"\",\n        script_output=\"\",\n        create_rows_table=True,\n        job_id: Optional[str] = None,\n        uuid: Optional[str] = None,\n    ) -> DatasetRecord:\n        \"\"\"\n        Creates dataset version if it doesn't exist.\n        If create_rows is False, dataset rows table will not be created\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.query.dataset.DatasetQuery::select", "project": "datachain", "func": "DatasetQuery::select", "origin_file": "datachain/query/dataset.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 1339, "func_end_lineno": 1357, "key_block_start_lineno": 1354, "key_block_end_lineno": 1357, "new_func_code": "def select(self, *args, **kwargs) -> \"Self\":\n        \"\"\"\n        Select the given columns or expressions using a subquery.\n\n        If used with no arguments, this simply creates a subquery and\n        select all columns from it.\n\n        Note that the `save` function expects default dataset columns to\n        be present. This function is meant to be followed by a call to\n        `results` if used to exclude any default columns.\n\n        Example:\n            >>> ds.select(C.name, C.size * 10).results()\n            >>> ds.select(C.name, size10x=C.size * 10).order_by(C.size10x).results()\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.query.dataset.DatasetQuery::apply_steps", "project": "datachain", "func": "DatasetQuery::apply_steps", "origin_file": "datachain/query/dataset.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 1181, "func_end_lineno": 1213, "key_block_start_lineno": 1186, "key_block_end_lineno": 1213, "new_func_code": "def apply_steps(self) -> QueryGenerator:\n        \"\"\"\n        Apply the steps in the query and return the resulting\n        sqlalchemy.SelectBase.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.dc.DataChain::gen", "project": "datachain", "func": "DataChain::gen", "origin_file": "datachain/lib/dc.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 846, "func_end_lineno": 882, "key_block_start_lineno": 873, "key_block_end_lineno": 882, "new_func_code": "def gen(\n        self,\n        func: Optional[Union[Callable, Generator]] = None,\n        params: Union[None, str, Sequence[str]] = None,\n        output: OutputType = None,\n        **signal_map,\n    ) -> \"Self\":\n        r\"\"\"Apply a function to each row to create new rows (with potentially new\n        signals). The function needs to return a new objects for each of the new rows.\n        It returns a chain itself with new signals.\n\n        Input-output relationship: 1:N\n\n        This method is similar to `map()`, uses the same list of parameters, but with\n        one key differences: It produces a sequence of rows for each input row (like\n        extracting multiple file records from a single tar file or bounding boxes from a\n        single image file).\n\n        Example:\n            ```py\n            chain = chain.gen(\n                line=lambda file: [l for l in file.read().split(\"\\n\")],\n                output=str,\n            )\n            chain.save(\"new_dataset\")\n            ```\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.string.length", "project": "datachain", "func": "length", "origin_file": "datachain/func/string.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 10, "func_end_lineno": 34, "key_block_start_lineno": 34, "key_block_end_lineno": 34, "new_func_code": "def length(col: Union[str, Func]) -> Func:\n    \"\"\"\n    Returns the length of the string.\n\n    Args:\n        col (str | literal | Func): String to compute the length of.\n            If a string is provided, it is assumed to be the name of the column.\n            If a literal is provided, it is assumed to be a string literal.\n            If a Func is provided, it is assumed to be a function returning a string.\n\n    Returns:\n        Func: A Func object that represents the string length function.\n\n    Example:\n        ```py\n        dc.mutate(\n            len1=func.string.length(\"file.path\"),\n            len2=func.string.length(\"Random string\"),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type int.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.dc.DataChain::mutate", "project": "datachain", "func": "DataChain::mutate", "origin_file": "datachain/lib/dc.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 1136, "func_end_lineno": 1215, "key_block_start_lineno": 1184, "key_block_end_lineno": 1215, "new_func_code": "def mutate(self, **kwargs) -> \"Self\":\n        \"\"\"Create new signals based on existing signals.\n\n        This method cannot modify existing columns. If you need to modify an\n        existing column, use a different name for the new column and then use\n        `select()` to choose which columns to keep.\n\n        This method is vectorized and more efficient compared to map(), and it does not\n        extract or download any data from the internal database. However, it can only\n        utilize predefined built-in functions and their combinations.\n\n        The supported functions:\n           Numerical:   +, -, *, /, rand(), avg(), count(), func(),\n                        greatest(), least(), max(), min(), sum()\n           String:      length(), split(), replace(), regexp_replace()\n           Filename:    name(), parent(), file_stem(), file_ext()\n           Array:       length(), sip_hash_64(), euclidean_distance(),\n                        cosine_distance()\n           Window:      row_number(), rank(), dense_rank(), first()\n\n        Example:\n        ```py\n         dc.mutate(\n            area=Column(\"image.height\") * Column(\"image.width\"),\n            extension=file_ext(Column(\"file.name\")),\n            dist=cosine_distance(embedding_text, embedding_image)\n        )\n        ```\n\n        Window function example:\n        ```py\n        window = func.window(partition_by=\"file.parent\", order_by=\"file.size\")\n        dc.mutate(\n            row_number=func.row_number().over(window),\n        )\n        ```\n\n        This method can be also used to rename signals. If the Column(\"name\") provided\n        as value for the new signal - the old column will be dropped. Otherwise a new\n        column is created.\n\n        Example:\n        ```py\n         dc.mutate(\n            newkey=Column(\"oldkey\")\n        )\n        ```\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.listing.get_listing", "project": "datachain", "func": "get_listing", "origin_file": "datachain/lib/listing.py", "test_list": ["../tests/unit/test_listing.py"], "prob_info": {"func_start_lineno": 159, "func_end_lineno": 205, "key_block_start_lineno": 169, "key_block_end_lineno": 205, "new_func_code": "def get_listing(\n    uri: str, session: \"Session\", update: bool = False\n) -> tuple[Optional[str], str, str, bool]:\n    \"\"\"Returns correct listing dataset name that must be used for saving listing\n    operation. It takes into account existing listings and reusability of those.\n    It also returns boolean saying if returned dataset name is reused / already\n    exists or not (on update it always returns False - just because there was no\n    reason to complicate it so far). And it returns correct listing path that should\n    be used to find rows based on uri.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.data_storage.schema.convert_rows_custom_column_types", "project": "datachain", "func": "convert_rows_custom_column_types", "origin_file": "datachain/data_storage/schema.py", "test_list": ["../tests/unit/test_listing.py"], "prob_info": {"func_start_lineno": 56, "func_end_lineno": 83, "key_block_start_lineno": 66, "key_block_end_lineno": 83, "new_func_code": "def convert_rows_custom_column_types(\n    columns: \"ColumnCollection[str, ColumnElement[Any]]\",\n    rows: Iterator[tuple[Any, ...]],\n    dialect: \"Dialect\",\n) -> Iterator[tuple[Any, ...]]:\n    \"\"\"\n    This function converts values of rows columns based on their types which are\n    defined in columns. We are only converting column values for which types are\n    subclasses of our SQLType, as only for those we have converters registered.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.asyn.AsyncMapper::shutdown_producer", "project": "datachain", "func": "AsyncMapper::shutdown_producer", "origin_file": "datachain/asyn.py", "test_list": ["../tests/unit/test_pytorch.py"], "prob_info": {"func_start_lineno": 84, "func_end_lineno": 98, "key_block_start_lineno": 94, "key_block_end_lineno": 98, "new_func_code": "def shutdown_producer(self) -> None:\n        \"\"\"\n        Signal the producer to stop and drain any remaining items from the work_queue.\n\n        This method sets an internal event, `_shutdown_producer`, which tells the\n        producer that it should stop adding items to the queue. To ensure that the\n        producer notices this signal promptly, we also attempt to drain any items\n        currently in the queue, clearing it so that the event can be checked without\n        delay.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.catalog.catalog.Catalog::create_dataset", "project": "datachain", "func": "Catalog::create_dataset", "origin_file": "datachain/catalog/catalog.py", "test_list": ["../tests/unit/test_session.py"], "prob_info": {"func_start_lineno": 766, "func_end_lineno": 826, "key_block_start_lineno": 785, "key_block_end_lineno": 826, "new_func_code": "def create_dataset(\n        self,\n        name: str,\n        version: Optional[int] = None,\n        *,\n        columns: Sequence[Column],\n        feature_schema: Optional[dict] = None,\n        query_script: str = \"\",\n        create_rows: Optional[bool] = True,\n        validate_version: Optional[bool] = True,\n        listing: Optional[bool] = False,\n        uuid: Optional[str] = None,\n    ) -> \"DatasetRecord\":\n        \"\"\"\n        Creates new dataset of a specific version.\n        If dataset is not yet created, it will create it with version 1\n        If version is None, then next unused version is created.\n        If version is given, then it must be an unused version number.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.data_storage.sqlite.SQLiteDatabaseEngine::has_table", "project": "datachain", "func": "SQLiteDatabaseEngine::has_table", "origin_file": "datachain/data_storage/sqlite.py", "test_list": ["../tests/unit/lib/test_arrow.py"], "prob_info": {"func_start_lineno": 258, "func_end_lineno": 277, "key_block_start_lineno": 267, "key_block_end_lineno": 277, "new_func_code": "def has_table(self, name: str) -> bool:\n        \"\"\"\n        Return True if a table exists with the given name\n\n        We cannot simply use `inspect(engine).has_table(name)` like the\n        parent class does because that will return False for a table\n        created during a pending transaction. Instead, we check the\n        sqlite_master table.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.image.convert_images", "project": "datachain", "func": "convert_images", "origin_file": "datachain/lib/image.py", "test_list": ["../tests/unit/lib/test_clip.py"], "prob_info": {"func_start_lineno": 49, "func_end_lineno": 81, "key_block_start_lineno": 68, "key_block_end_lineno": 81, "new_func_code": "def convert_images(\n    images: Union[Image.Image, list[Image.Image]],\n    mode: str = \"RGB\",\n    size: Optional[tuple[int, int]] = None,\n    transform: Optional[Callable] = None,\n    encoder: Optional[Callable] = None,\n    device: Optional[Union[str, torch.device]] = None,\n) -> Union[list[Image.Image], torch.Tensor]:\n    \"\"\"\n    Resize, transform, and otherwise convert one or more images.\n\n    Args:\n        images (Image, list[Image]): PIL.Image object or list of objects.\n        mode (str): PIL.Image mode.\n        size (tuple[int, int]): Size in (width, height) pixels for resizing.\n        transform (Callable): Torchvision transform or huggingface processor to apply.\n        encoder (Callable): Encode image using model.\n        device (str or torch.device): Device to use.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.image.convert_image", "project": "datachain", "func": "convert_image", "origin_file": "datachain/lib/image.py", "test_list": ["../tests/unit/lib/test_clip.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 46, "key_block_start_lineno": 26, "key_block_end_lineno": 46, "new_func_code": "def convert_image(\n    img: Image.Image,\n    mode: str = \"RGB\",\n    size: Optional[tuple[int, int]] = None,\n    transform: Optional[Callable] = None,\n    encoder: Optional[Callable] = None,\n    device: Optional[Union[str, torch.device]] = None,\n) -> Union[Image.Image, torch.Tensor]:\n    \"\"\"\n    Resize, transform, and otherwise convert an image.\n\n    Args:\n        img (Image): PIL.Image object.\n        mode (str): PIL.Image mode.\n        size (tuple[int, int]): Size in (width, height) pixels for resizing.\n        transform (Callable): Torchvision transform or huggingface processor to apply.\n        encoder (Callable): Encode image using model.\n        device (str or torch.device): Device to use.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.query.dataset.DatasetQuery::ordered_select", "project": "datachain", "func": "DatasetQuery::ordered_select", "origin_file": "datachain/query/dataset.py", "test_list": ["../tests/unit/lib/test_feature_utils.py"], "prob_info": {"func_start_lineno": 1360, "func_end_lineno": 1378, "key_block_start_lineno": 1372, "key_block_end_lineno": 1378, "new_func_code": "def ordered_select(self, *args, **kwargs) -> \"Self\":\n        \"\"\"\n        Select the given columns or expressions using a subquery whilst\n        maintaining query ordering (only applicable if last step was order_by).\n\n        If used with no arguments, this simply creates a subquery and\n        select all columns from it.\n\n        Example:\n            >>> ds.ordered_select(C.name, C.size * 10)\n            >>> ds.ordered_select(C.name, size10x=C.size * 10)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.signal_schema.SignalSchema::db_signals", "project": "datachain", "func": "SignalSchema::db_signals", "origin_file": "datachain/lib/signal_schema.py", "test_list": ["../tests/unit/lib/test_feature_utils.py"], "prob_info": {"func_start_lineno": 481, "func_end_lineno": 503, "key_block_start_lineno": 488, "key_block_end_lineno": 503, "new_func_code": "def db_signals(\n        self, name: Optional[str] = None, as_columns=False\n    ) -> Union[list[str], list[Column]]:\n        \"\"\"\n        Returns DB columns as strings or Column objects with proper types\n        Optionally, it can filter results by specific object, returning only his signals\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.dc.DataChain::order_by", "project": "datachain", "func": "DataChain::order_by", "origin_file": "datachain/lib/dc.py", "test_list": ["../tests/unit/lib/test_feature_utils.py"], "prob_info": {"func_start_lineno": 1010, "func_end_lineno": 1032, "key_block_start_lineno": 1029, "key_block_end_lineno": 1032, "new_func_code": "def order_by(self, *args, descending: bool = False) -> \"Self\":\n        \"\"\"Orders by specified set of columns.\n\n        Parameters:\n            descending (bool): Whether to sort in descending order or not.\n\n        Example:\n            ```py\n            dc.order_by(\"similarity_score\", descending=True).limit(10)\n            ```\n\n        Note:\n            Order is not guaranteed when steps are added after an `order_by` statement.\n            I.e. when using `from_dataset` an `order_by` statement should be used if\n            the order of the records in the chain is important.\n            Using `order_by` directly before `limit`, `collect` and `collect_flatten`\n            will give expected results.\n            See https://github.com/iterative/datachain/issues/477 for further details.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.file.File::resolve", "project": "datachain", "func": "File::resolve", "origin_file": "datachain/lib/file.py", "test_list": ["../tests/unit/lib/test_file.py"], "prob_info": {"func_start_lineno": 426, "func_end_lineno": 468, "key_block_start_lineno": 433, "key_block_end_lineno": 468, "new_func_code": "def resolve(self) -> \"Self\":\n        \"\"\"\n        Resolve a File object by checking its existence and updating its metadata.\n\n        Returns:\n            File: The resolved File object with updated metadata.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.file.resolve", "project": "datachain", "func": "resolve", "origin_file": "datachain/lib/file.py", "test_list": ["../tests/unit/lib/test_file.py"], "prob_info": {"func_start_lineno": 471, "func_end_lineno": 488, "key_block_start_lineno": 488, "key_block_end_lineno": 488, "new_func_code": "def resolve(file: File) -> File:\n    \"\"\"\n    Resolve a File object by checking its existence and updating its metadata.\n\n    This function is a wrapper around the File.resolve() method, designed to be\n    used as a mapper in DataChain operations.\n\n    Args:\n        file (File): The File object to resolve.\n\n    Returns:\n        File: The resolved File object with updated metadata.\n\n    Raises:\n        RuntimeError: If the file's catalog is not set or if\n        the file source protocol is unsupported.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.dc.DataChain::filter", "project": "datachain", "func": "DataChain::filter", "origin_file": "datachain/lib/dc.py", "test_list": ["../tests/unit/lib/test_schema.py"], "prob_info": {"func_start_lineno": 2546, "func_end_lineno": 2579, "key_block_start_lineno": 2579, "key_block_end_lineno": 2579, "new_func_code": "def filter(self, *args: Any) -> \"Self\":\n        \"\"\"Filter the chain according to conditions.\n\n        Example:\n            Basic usage with built-in operators\n            ```py\n            dc.filter(C(\"width\") < 200)\n            ```\n\n            Using glob to match patterns\n            ```py\n            dc.filter(C(\"file.name\").glob(\"*.jpg\"))\n            ```\n\n            Using `datachain.func`\n            ```py\n            from datachain.func import string\n            dc.filter(string.length(C(\"file.name\")) > 5)\n            ```\n\n            Combining filters with \"or\"\n            ```py\n            dc.filter(C(\"file.name\").glob(\"cat*\") | C(\"file.name\").glob(\"dog*))\n            ```\n\n            Combining filters with \"and\"\n            ```py\n            dc.filter(\n                C(\"file.name\").glob(\"*.jpg) &\n                (string.length(C(\"file.name\")) > 5)\n            )\n            ```\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.utils.normalize_col_names", "project": "datachain", "func": "normalize_col_names", "origin_file": "datachain/lib/utils.py", "test_list": ["../tests/unit/lib/test_utils.py"], "prob_info": {"func_start_lineno": 35, "func_end_lineno": 61, "key_block_start_lineno": 37, "key_block_end_lineno": 61, "new_func_code": "def normalize_col_names(col_names: Sequence[str]) -> dict[str, str]:\n    \"\"\"Returns normalized_name -> original_name dict.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.array.cosine_distance", "project": "datachain", "func": "cosine_distance", "origin_file": "datachain/func/array.py", "test_list": ["../tests/unit/sql/test_array.py"], "prob_info": {"func_start_lineno": 9, "func_end_lineno": 57, "key_block_start_lineno": 39, "key_block_end_lineno": 57, "new_func_code": "def cosine_distance(*args: Union[str, Sequence]) -> Func:\n    \"\"\"\n    Computes the cosine distance between two vectors.\n\n    The cosine distance is derived from the cosine similarity, which measures the angle\n    between two vectors. This function returns the dissimilarity between the vectors,\n    where 0 indicates identical vectors and values closer to 1\n    indicate higher dissimilarity.\n\n    Args:\n        args (str | Sequence): Two vectors to compute the cosine distance between.\n            If a string is provided, it is assumed to be the name of the column vector.\n            If a sequence is provided, it is assumed to be a vector of values.\n\n    Returns:\n        Func: A Func object that represents the cosine_distance function.\n\n    Example:\n        ```py\n        target_embedding = [0.1, 0.2, 0.3]\n        dc.mutate(\n            cos_dist1=func.cosine_distance(\"embedding\", target_embedding),\n            cos_dist2=func.cosine_distance(target_embedding, [0.4, 0.5, 0.6]),\n        )\n        ```\n\n    Notes:\n        - Ensure both vectors have the same number of elements.\n        - Result column will always be of type float.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.array.euclidean_distance", "project": "datachain", "func": "euclidean_distance", "origin_file": "datachain/func/array.py", "test_list": ["../tests/unit/sql/test_array.py"], "prob_info": {"func_start_lineno": 60, "func_end_lineno": 106, "key_block_start_lineno": 88, "key_block_end_lineno": 106, "new_func_code": "def euclidean_distance(*args: Union[str, Sequence]) -> Func:\n    \"\"\"\n    Computes the Euclidean distance between two vectors.\n\n    The Euclidean distance is the straight-line distance between two points\n    in Euclidean space. This function returns the distance between the two vectors.\n\n    Args:\n        args (str | Sequence): Two vectors to compute the Euclidean distance between.\n            If a string is provided, it is assumed to be the name of the column vector.\n            If a sequence is provided, it is assumed to be a vector of values.\n\n    Returns:\n        Func: A Func object that represents the euclidean_distance function.\n\n    Example:\n        ```py\n        target_embedding = [0.1, 0.2, 0.3]\n        dc.mutate(\n            eu_dist1=func.euclidean_distance(\"embedding\", target_embedding),\n            eu_dist2=func.euclidean_distance(target_embedding, [0.4, 0.5, 0.6]),\n        )\n        ```\n\n    Notes:\n        - Ensure both vectors have the same number of elements.\n        - Result column will always be of type float.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.array.length", "project": "datachain", "func": "length", "origin_file": "datachain/func/array.py", "test_list": ["../tests/unit/sql/test_array.py"], "prob_info": {"func_start_lineno": 109, "func_end_lineno": 140, "key_block_start_lineno": 133, "key_block_end_lineno": 140, "new_func_code": "def length(arg: Union[str, Sequence, Func]) -> Func:\n    \"\"\"\n    Returns the length of the array.\n\n    Args:\n        arg (str | Sequence | Func): Array to compute the length of.\n            If a string is provided, it is assumed to be the name of the array column.\n            If a sequence is provided, it is assumed to be an array of values.\n            If a Func is provided, it is assumed to be a function returning an array.\n\n    Returns:\n        Func: A Func object that represents the array length function.\n\n    Example:\n        ```py\n        dc.mutate(\n            len1=func.array.length(\"signal.values\"),\n            len2=func.array.length([1, 2, 3, 4, 5]),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type int.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.array.contains", "project": "datachain", "func": "contains", "origin_file": "datachain/func/array.py", "test_list": ["../tests/unit/sql/test_array.py"], "prob_info": {"func_start_lineno": 143, "func_end_lineno": 178, "key_block_start_lineno": 166, "key_block_end_lineno": 178, "new_func_code": "def contains(arr: Union[str, Sequence, Func], elem: Any) -> Func:\n    \"\"\"\n    Checks whether the `arr` array has the `elem` element.\n\n    Args:\n        arr (str | Sequence | Func): Array to check for the element.\n            If a string is provided, it is assumed to be the name of the array column.\n            If a sequence is provided, it is assumed to be an array of values.\n            If a Func is provided, it is assumed to be a function returning an array.\n        elem (Any): Element to check for in the array.\n\n    Returns:\n        Func: A Func object that represents the contains function. Result of the\n            function will be 1 if the element is present in the array, and 0 otherwise.\n\n    Example:\n        ```py\n        dc.mutate(\n            contains1=func.array.contains(\"signal.values\", 3),\n            contains2=func.array.contains([1, 2, 3, 4, 5], 7),\n        )\n        ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.string.split", "project": "datachain", "func": "split", "origin_file": "datachain/func/string.py", "test_list": ["../tests/unit/sql/test_array.py"], "prob_info": {"func_start_lineno": 37, "func_end_lineno": 76, "key_block_start_lineno": 63, "key_block_end_lineno": 76, "new_func_code": "def split(col: Union[str, Func], sep: str, limit: Optional[int] = None) -> Func:\n    \"\"\"\n    Takes a column and split character and returns an array of the parts.\n\n    Args:\n        col (str | literal): Column to split.\n            If a string is provided, it is assumed to be the name of the column.\n            If a literal is provided, it is assumed to be a string literal.\n            If a Func is provided, it is assumed to be a function returning a string.\n        sep (str): Separator to split the string.\n        limit (int, optional): Maximum number of splits to perform.\n\n    Returns:\n        Func: A Func object that represents the split function.\n\n    Example:\n        ```py\n        dc.mutate(\n            path_parts=func.string.split(\"file.path\", \"/\"),\n            str_words=func.string.length(\"Random string\", \" \"),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type array of strings.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.conditional.greatest", "project": "datachain", "func": "greatest", "origin_file": "datachain/func/conditional.py", "test_list": ["../tests/unit/sql/test_conditional.py"], "prob_info": {"func_start_lineno": 17, "func_end_lineno": 54, "key_block_start_lineno": 40, "key_block_end_lineno": 54, "new_func_code": "def greatest(*args: Union[ColT, float]) -> Func:\n    \"\"\"\n    Returns the greatest (largest) value from the given input values.\n\n    Args:\n        args (ColT | str | int | float | Sequence): The values to compare.\n            If a string is provided, it is assumed to be the name of the column.\n            If a Func is provided, it is assumed to be a function returning a value.\n            If an int, float, or Sequence is provided, it is assumed to be a literal.\n\n    Returns:\n        Func: A Func object that represents the greatest function.\n\n    Example:\n        ```py\n        dc.mutate(\n            greatest=func.greatest(\"signal.value\", 0),\n        )\n        ```\n\n    Note:\n        - Result column will always be of the same type as the input columns.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.conditional.least", "project": "datachain", "func": "least", "origin_file": "datachain/func/conditional.py", "test_list": ["../tests/unit/sql/test_conditional.py"], "prob_info": {"func_start_lineno": 57, "func_end_lineno": 90, "key_block_start_lineno": 80, "key_block_end_lineno": 90, "new_func_code": "def least(*args: Union[ColT, float]) -> Func:\n    \"\"\"\n    Returns the least (smallest) value from the given input values.\n\n    Args:\n        args (ColT | str | int | float | Sequence): The values to compare.\n            If a string is provided, it is assumed to be the name of the column.\n            If a Func is provided, it is assumed to be a function returning a value.\n            If an int, float, or Sequence is provided, it is assumed to be a literal.\n\n    Returns:\n        Func: A Func object that represents the least function.\n\n    Example:\n        ```py\n        dc.mutate(\n            least=func.least(\"signal.value\", 0),\n        )\n        ```\n\n    Note:\n        - Result column will always be of the same type as the input columns.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.conditional.ifelse", "project": "datachain", "func": "ifelse", "origin_file": "datachain/func/conditional.py", "test_list": ["../tests/unit/sql/test_conditional.py"], "prob_info": {"func_start_lineno": 161, "func_end_lineno": 187, "key_block_start_lineno": 187, "key_block_end_lineno": 187, "new_func_code": "def ifelse(\n    condition: Union[ColumnElement, Func], if_val: CaseT, else_val: CaseT\n) -> Func:\n    \"\"\"\n    Returns the ifelse function that produces if expression which has a condition\n    and values for true and false outcome. Results can be one of python primitives\n    like string, numbers or booleans, but can also be nested functions or columns.\n    Result type is inferred from the values.\n\n    Args:\n        condition (ColumnElement, Func):  Condition which is evaluated.\n        if_val (str | int | float | complex | bool, Func, ColumnElement): Value for true\n            condition outcome.\n        else_val (str | int | float | complex | bool, Func, ColumnElement): Value for\n            false condition outcome.\n\n    Returns:\n        Func: A Func object that represents the ifelse function.\n\n    Example:\n        ```py\n        dc.mutate(\n            res=func.ifelse(isnone(\"col\"), \"EMPTY\", \"NOT_EMPTY\")\n        )\n        ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.conditional.isnone", "project": "datachain", "func": "isnone", "origin_file": "datachain/func/conditional.py", "test_list": ["../tests/unit/sql/test_conditional.py"], "prob_info": {"func_start_lineno": 190, "func_end_lineno": 212, "key_block_start_lineno": 206, "key_block_end_lineno": 212, "new_func_code": "def isnone(col: Union[str, Column]) -> Func:\n    \"\"\"\n    Returns True if column value is None, otherwise False.\n\n    Args:\n        col (str | Column): Column to check if it's None or not.\n            If a string is provided, it is assumed to be the name of the column.\n\n    Returns:\n        Func: A Func object that represents the conditional to check if column is None.\n\n    Example:\n        ```py\n        dc.mutate(test=ifelse(isnone(\"col\"), \"EMPTY\", \"NOT_EMPTY\"))\n        ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.conditional.or_", "project": "datachain", "func": "or_", "origin_file": "datachain/func/conditional.py", "test_list": ["../tests/unit/sql/test_conditional.py"], "prob_info": {"func_start_lineno": 215, "func_end_lineno": 241, "key_block_start_lineno": 233, "key_block_end_lineno": 241, "new_func_code": "def or_(*args: Union[ColumnElement, Func]) -> Func:\n    \"\"\"\n    Returns the function that produces conjunction of expressions joined by OR\n    logical operator.\n\n    Args:\n        args (ColumnElement | Func): The expressions for OR statement.\n\n    Returns:\n        Func: A Func object that represents the or function.\n\n    Example:\n        ```py\n        dc.mutate(\n            test=ifelse(or_(isnone(\"name\"), C(\"name\") == ''), \"Empty\", \"Not Empty\")\n        )\n        ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.conditional.and_", "project": "datachain", "func": "and_", "origin_file": "datachain/func/conditional.py", "test_list": ["../tests/unit/sql/test_conditional.py"], "prob_info": {"func_start_lineno": 244, "func_end_lineno": 270, "key_block_start_lineno": 262, "key_block_end_lineno": 270, "new_func_code": "def and_(*args: Union[ColumnElement, Func]) -> Func:\n    \"\"\"\n    Returns the function that produces conjunction of expressions joined by AND\n    logical operator.\n\n    Args:\n        args (ColumnElement | Func): The expressions for AND statement.\n\n    Returns:\n        Func: A Func object that represents the and function.\n\n    Example:\n        ```py\n        dc.mutate(\n            test=ifelse(and_(isnone(\"name\"), isnone(\"surname\")), \"Empty\", \"Not Empty\")\n        )\n        ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.path.parent", "project": "datachain", "func": "parent", "origin_file": "datachain/func/path.py", "test_list": ["../tests/unit/sql/test_path.py"], "prob_info": {"func_start_lineno": 6, "func_end_lineno": 29, "key_block_start_lineno": 29, "key_block_end_lineno": 29, "new_func_code": "def parent(col: ColT) -> Func:\n    \"\"\"\n    Returns the directory component of a posix-style path.\n\n    Args:\n        col (str | literal | Func): String to compute the path parent of.\n            If a string is provided, it is assumed to be the name of the column.\n            If a literal is provided, it is assumed to be a string literal.\n            If a Func is provided, it is assumed to be a function returning a string.\n\n    Returns:\n        Func: A Func object that represents the path parent function.\n\n    Example:\n        ```py\n        dc.mutate(\n            parent=func.path.parent(\"file.path\"),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.path.name", "project": "datachain", "func": "name", "origin_file": "datachain/func/path.py", "test_list": ["../tests/unit/sql/test_path.py"], "prob_info": {"func_start_lineno": 32, "func_end_lineno": 56, "key_block_start_lineno": 55, "key_block_end_lineno": 56, "new_func_code": "def name(col: ColT) -> Func:\n    \"\"\"\n    Returns the final component of a posix-style path.\n\n    Args:\n        col (str | literal): String to compute the path name of.\n            If a string is provided, it is assumed to be the name of the column.\n            If a literal is provided, it is assumed to be a string literal.\n            If a Func is provided, it is assumed to be a function returning a string.\n\n    Returns:\n        Func: A Func object that represents the path name function.\n\n    Example:\n        ```py\n        dc.mutate(\n            file_name=func.path.name(\"file.path\"),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.path.file_stem", "project": "datachain", "func": "file_stem", "origin_file": "datachain/func/path.py", "test_list": ["../tests/unit/sql/test_path.py"], "prob_info": {"func_start_lineno": 59, "func_end_lineno": 83, "key_block_start_lineno": 82, "key_block_end_lineno": 83, "new_func_code": "def file_stem(col: ColT) -> Func:\n    \"\"\"\n    Returns the path without the extension.\n\n    Args:\n        col (str | literal): String to compute the file stem of.\n            If a string is provided, it is assumed to be the name of the column.\n            If a literal is provided, it is assumed to be a string literal.\n            If a Func is provided, it is assumed to be a function returning a string.\n\n    Returns:\n        Func: A Func object that represents the file stem function.\n\n    Example:\n        ```py\n        dc.mutate(\n            file_stem=func.path.file_stem(\"file.path\"),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.path.file_ext", "project": "datachain", "func": "file_ext", "origin_file": "datachain/func/path.py", "test_list": ["../tests/unit/sql/test_path.py"], "prob_info": {"func_start_lineno": 86, "func_end_lineno": 110, "key_block_start_lineno": 109, "key_block_end_lineno": 110, "new_func_code": "def file_ext(col: ColT) -> Func:\n    \"\"\"\n    Returns the extension of the given path.\n\n    Args:\n        col (str | literal): String to compute the file extension of.\n            If a string is provided, it is assumed to be the name of the column.\n            If a literal is provided, it is assumed to be a string literal.\n            If a Func is provided, it is assumed to be a function returning a string.\n\n    Returns:\n        Func: A Func object that represents the file extension function.\n\n    Example:\n        ```py\n        dc.mutate(\n            file_stem=func.path.file_ext(\"file.path\"),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.string.regexp_replace", "project": "datachain", "func": "regexp_replace", "origin_file": "datachain/func/string.py", "test_list": ["../tests/unit/sql/test_string.py"], "prob_info": {"func_start_lineno": 118, "func_end_lineno": 154, "key_block_start_lineno": 143, "key_block_end_lineno": 154, "new_func_code": "def regexp_replace(col: Union[str, Func], regex: str, replacement: str) -> Func:\n    r\"\"\"\n    Replaces substring that match a regular expression.\n\n    Args:\n        col (str | literal): Column to split.\n            If a string is provided, it is assumed to be the name of the column.\n            If a literal is provided, it is assumed to be a string literal.\n            If a Func is provided, it is assumed to be a function returning a string.\n        regex (str): Regular expression pattern to replace.\n        replacement (str): Replacement string.\n\n    Returns:\n        Func: A Func object that represents the regexp_replace function.\n\n    Example:\n        ```py\n        dc.mutate(\n            signal=func.string.regexp_replace(\"signal.name\", r\"\\d+\", \"X\"),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.string.replace", "project": "datachain", "func": "replace", "origin_file": "datachain/func/string.py", "test_list": ["../tests/unit/sql/test_string.py"], "prob_info": {"func_start_lineno": 79, "func_end_lineno": 115, "key_block_start_lineno": 104, "key_block_end_lineno": 115, "new_func_code": "def replace(col: Union[str, Func], pattern: str, replacement: str) -> Func:\n    \"\"\"\n    Replaces substring with another string.\n\n    Args:\n        col (str | literal): Column to split.\n            If a string is provided, it is assumed to be the name of the column.\n            If a literal is provided, it is assumed to be a string literal.\n            If a Func is provided, it is assumed to be a function returning a string.\n        pattern (str): Pattern to replace.\n        replacement (str): Replacement string.\n\n    Returns:\n        Func: A Func object that represents the replace function.\n\n    Example:\n        ```py\n        dc.mutate(\n            signal=func.string.replace(\"signal.name\", \"pattern\", \"replacement),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.catalog.loader.get_catalog", "project": "datachain", "func": "get_catalog", "origin_file": "datachain/catalog/loader.py", "test_list": ["../tests/unit/test_catalog_loader.py"], "prob_info": {"func_start_lineno": 122, "func_end_lineno": 141, "key_block_start_lineno": 136, "key_block_end_lineno": 141, "new_func_code": "def get_catalog(\n    client_config: Optional[dict[str, Any]] = None, in_memory: bool = False\n) -> Catalog:\n    \"\"\"\n    Function that creates Catalog instance with appropriate metastore\n    and warehouse classes. Metastore class can be provided with env variable\n    DATACHAIN_METASTORE and if not provided, default one is used. Warehouse class\n    can be provided with env variable DATACHAIN_WAREHOUSE and if not provided,\n\n    If classes expects some kwargs, they can be provided via env variables\n    by adding them with prefix (DATACHAIN_METASTORE_ARG_ and DATACHAIN_WAREHOUSE_ARG_)\n    and name of variable after, e.g. if it accepts team_id as kwargs\n    we can provide DATACHAIN_METASTORE_ARG_TEAM_ID=12345 env variable.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.client.gcs.GCSClient::url", "project": "datachain", "func": "GCSClient::url", "origin_file": "datachain/client/gcs.py", "test_list": ["../tests/unit/test_client_gcs.py"], "prob_info": {"func_start_lineno": 35, "func_end_lineno": 51, "key_block_start_lineno": 41, "key_block_end_lineno": 51, "new_func_code": "def url(self, path: str, expires: int = 3600, **kwargs) -> str:\n        \"\"\"\n        Generate a signed URL for the given path.\n        If the client is anonymous, a public URL is returned instead\n        (see https://cloud.google.com/storage/docs/access-public-data#api-link).\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.data_storage.schema.dedup_columns", "project": "datachain", "func": "dedup_columns", "origin_file": "datachain/data_storage/schema.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 37, "func_end_lineno": 53, "key_block_start_lineno": 43, "key_block_end_lineno": 53, "new_func_code": "def dedup_columns(columns: Iterable[sa.Column]) -> list[sa.Column]:\n    \"\"\"\n    Removes duplicate columns from a list of columns.\n    If column with the same name and different type is found, exception is\n    raised\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.numeric.int_hash_64", "project": "datachain", "func": "int_hash_64", "origin_file": "datachain/func/numeric.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 131, "func_end_lineno": 162, "key_block_start_lineno": 154, "key_block_end_lineno": 162, "new_func_code": "def int_hash_64(col: Union[ColT, int]) -> Func:\n    \"\"\"\n    Returns the 64-bit hash of an integer.\n\n    Args:\n        col (str | int): String to compute the hash of.\n            If a string is provided, it is assumed to be the name of the column.\n            If a int is provided, it is assumed to be an int literal.\n            If a Func is provided, it is assumed to be a function returning an int.\n\n    Returns:\n        Func: A Func object that represents the 64-bit hash function.\n\n    Example:\n        ```py\n        dc.mutate(\n            val_hash=func.int_hash_64(\"val\"),\n        )\n        ```\n\n    Note:\n        - Result column will always be of type int.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.numeric.bit_hamming_distance", "project": "datachain", "func": "bit_hamming_distance", "origin_file": "datachain/func/numeric.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 165, "func_end_lineno": 208, "key_block_start_lineno": 192, "key_block_end_lineno": 208, "new_func_code": "def bit_hamming_distance(*args: Union[ColT, int]) -> Func:\n    \"\"\"\n    Computes the Hamming distance between the bit representations of two integer values.\n\n    The Hamming distance is the number of positions at which the corresponding bits\n    are different. This function returns the dissimilarity between the integers,\n    where 0 indicates identical integers and values closer to the number of bits\n    in the integer indicate higher dissimilarity.\n\n    Args:\n        args (str | int): Two integers to compute the Hamming distance between.\n            If a str is provided, it is assumed to be the name of the column.\n            If an int is provided, it is assumed to be an integer literal.\n\n    Returns:\n        Func: A Func object that represents the Hamming distance function.\n\n    Example:\n        ```py\n        dc.mutate(\n            ham_dist=func.bit_hamming_distance(\"embed1\", 123456),\n        )\n        ```\n\n    Notes:\n        - Result column will always be of type int.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.func.string.byte_hamming_distance", "project": "datachain", "func": "byte_hamming_distance", "origin_file": "datachain/func/string.py", "test_list": ["../tests/unit/test_func.py"], "prob_info": {"func_start_lineno": 157, "func_end_lineno": 200, "key_block_start_lineno": 184, "key_block_end_lineno": 200, "new_func_code": "def byte_hamming_distance(*args: Union[str, Func]) -> Func:\n    \"\"\"\n    Computes the Hamming distance between two strings.\n\n    The Hamming distance is the number of positions at which the corresponding\n    characters are different. This function returns the dissimilarity between\n    the strings, where 0 indicates identical strings and values closer to the length\n    of the strings indicate higher dissimilarity.\n\n    Args:\n        args (str | literal): Two strings to compute the Hamming distance between.\n            If a str is provided, it is assumed to be the name of the column.\n            If a Literal is provided, it is assumed to be a string literal.\n\n    Returns:\n        Func: A Func object that represents the Hamming distance function.\n\n    Example:\n        ```py\n        dc.mutate(\n            ham_dist=func.byte_hamming_distance(\"file.phash\", literal(\"hello\")),\n        )\n        ```\n\n    Notes:\n        - Result column will always be of type int.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.catalog.catalog.Catalog::list_datasets_versions", "project": "datachain", "func": "Catalog::list_datasets_versions", "origin_file": "datachain/catalog/catalog.py", "test_list": ["../tests/unit/test_listing.py"], "prob_info": {"func_start_lineno": 1173, "func_end_lineno": 1192, "key_block_start_lineno": 1178, "key_block_end_lineno": 1192, "new_func_code": "def list_datasets_versions(\n        self,\n        include_listing: bool = False,\n    ) -> Iterator[tuple[DatasetListRecord, \"DatasetListVersion\", Optional[\"Job\"]]]:\n        \"\"\"Iterate over all dataset versions with related jobs.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.dc.DataChain::save", "project": "datachain", "func": "DataChain::save", "origin_file": "datachain/lib/dc.py", "test_list": ["../tests/unit/test_listing.py"], "prob_info": {"func_start_lineno": 755, "func_end_lineno": 770, "key_block_start_lineno": 765, "key_block_end_lineno": 770, "new_func_code": "def save(  # type: ignore[override]\n        self, name: Optional[str] = None, version: Optional[int] = None, **kwargs\n    ) -> \"Self\":\n        \"\"\"Save to a Dataset. It returns the chain itself.\n\n        Parameters:\n            name : dataset name. Empty name saves to a temporary dataset that will be\n                removed after process ends. Temp dataset are useful for optimization.\n            version : version of a dataset. Default - the last version that exist.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.query.dataset.DatasetQuery::save", "project": "datachain", "func": "DatasetQuery::save", "origin_file": "datachain/query/dataset.py", "test_list": ["../tests/unit/test_listing.py"], "prob_info": {"func_start_lineno": 1642, "func_end_lineno": 1699, "key_block_start_lineno": 1650, "key_block_end_lineno": 1699, "new_func_code": "def save(\n        self,\n        name: Optional[str] = None,\n        version: Optional[int] = None,\n        feature_schema: Optional[dict] = None,\n        **kwargs,\n    ) -> \"Self\":\n        \"\"\"Save the query as a dataset.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.catalog.catalog.Catalog::remove_dataset_version", "project": "datachain", "func": "Catalog::remove_dataset_version", "origin_file": "datachain/catalog/catalog.py", "test_list": ["../tests/unit/test_session.py"], "prob_info": {"func_start_lineno": 943, "func_end_lineno": 954, "key_block_start_lineno": 950, "key_block_end_lineno": 954, "new_func_code": "def remove_dataset_version(\n        self, dataset: DatasetRecord, version: int, drop_rows: Optional[bool] = True\n    ) -> None:\n        \"\"\"\n        Deletes one single dataset version.\n        If it was last version, it removes dataset completely\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.query.dataset.DatasetQuery::cleanup", "project": "datachain", "func": "DatasetQuery::cleanup", "origin_file": "datachain/query/dataset.py", "test_list": ["../tests/unit/lib/test_schema.py"], "prob_info": {"func_start_lineno": 1235, "func_end_lineno": 1247, "key_block_start_lineno": 1237, "key_block_end_lineno": 1247, "new_func_code": "def cleanup(self) -> None:\n        \"\"\"Cleanup any temporary tables.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.sql.sqlite.base.compile_least", "project": "datachain", "func": "compile_least", "origin_file": "datachain/sql/sqlite/base.py", "test_list": ["../tests/unit/sql/test_conditional.py"], "prob_info": {"func_start_lineno": 493, "func_end_lineno": 516, "key_block_start_lineno": 506, "key_block_end_lineno": 516, "new_func_code": "def compile_least(element, compiler, **kwargs):\n    \"\"\"\n    Compiles a sql function for `least(*args)` taking 1 or more args\n\n    Compiles to:\n      - `min(arg1, arg2...)` for 2 or more args\n      - `arg1` for 1 arg\n\n    sqlite's min() is a simple function when it has 2 or more\n    arguments but operates as an aggregate function if given only a\n    single argument\n    See https://www.sqlite.org/lang_corefunc.html#min_scalar\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.clip.clip_similarity_scores", "project": "datachain", "func": "clip_similarity_scores", "origin_file": "datachain/lib/clip.py", "test_list": ["../tests/unit/lib/test_clip.py"], "prob_info": {"func_start_lineno": 34, "func_end_lineno": 177, "key_block_start_lineno": 134, "key_block_end_lineno": 177, "new_func_code": "def clip_similarity_scores(\n    images: Union[None, \"Image.Image\", list[\"Image.Image\"]],\n    text: Union[None, str, list[str]],\n    model: Any,\n    preprocess: Callable,\n    tokenizer: Callable,\n    prob: bool = False,\n    image_to_text: bool = True,\n    device: Optional[Union[str, torch.device]] = None,\n) -> list[list[float]]:\n    \"\"\"\n    Calculate CLIP similarity scores between one or more images and/or text.\n\n    Parameters:\n        images : Images to use as inputs.\n        text : Text to use as inputs.\n        model : Model from clip or open_clip packages.\n        preprocess : Image preprocessor to apply.\n        tokenizer : Text tokenizer.\n        prob : Compute softmax probabilities.\n        image_to_text : Whether to compute for image-to-text or text-to-image. Ignored\n            if only one of images or text provided.\n        device : Device to use. Defaults is None - use model's device.\n\n\n    Example:\n        Using https://github.com/openai/CLIP\n        ```py\n        >>> import clip\n        >>> model, preprocess = clip.load(\"ViT-B/32\")\n        >>> similarity_scores(img, \"cat\", model, preprocess, clip.tokenize)\n        [[21.813]]\n        ```\n\n        Using https://github.com/mlfoundations/open_clip\n        ```py\n        >>> import open_clip\n        >>> model, _, preprocess = open_clip.create_model_and_transforms(\n        ...     \"ViT-B-32\", pretrained=\"laion2b_s34b_b79k\"\n        ... )\n        >>> tokenizer = open_clip.get_tokenizer(\"ViT-B-32\")\n        >>> similarity_scores(img, \"cat\", model, preprocess, tokenizer)\n        [[21.813]]\n        ```\n\n        Using https://huggingface.co/docs/transformers/en/model_doc/clip\n        ```py\n        >>> from transformers import CLIPProcessor, CLIPModel\n        >>> model = CLIPModel.from_pretrained(\"openai/clip-vit-base-patch32\")\n        >>> processor = CLIPProcessor.from_pretrained(\"openai/clip-vit-base-patch32\")\n        >>> scores = similarity_scores(\n        ...     img, \"cat\", model, processor.image_processor, processor.tokenizer\n        ... )\n        [[21.813]]\n        ```\n\n        Image -> list of text\n        ```py\n        >>> similarity_scores(img, [\"cat\", \"dog\"], model, preprocess, tokenizer)\n        [[21.813, 35.313]]\n        ```\n\n        List of images -> text\n        ```py\n        >>> similarity_scores([img1, img2], \"cat\", model, preprocess, tokenizer)\n        [[21.813], [83.123]]\n        ```\n\n        List of images -> list of text\n        ```py\n        >>> similarity_scores(\n        ...     [img1, img2], [\"cat\", \"dog\"], model, preprocess, tokenizer)\n        ... )\n        [[21.813, 35.313], [83.123, 34.843]]\n        ```\n\n        List of images -> list of images\n        ```py\n        >>> similarity_scores([img1, img2], None, model, preprocess, tokenizer)\n        [[94.189, 37.092]]\n        ```\n\n        List of text -> list of text\n        ```py\n        >>> similarity_scores(None, [\"cat\", \"dog\"], model, preprocess, tokenizer)\n        [[67.334, 23.588]]\n        ```\n\n        Text -> list of images\n        ```py\n        >>> similarity_scores([img1, img2], \"cat\", ..., image_to_text=False)\n        [[19.708, 19.842]]\n        ```\n\n        Show scores as softmax probabilities\n        ```py\n        >>> similarity_scores(img, [\"cat\", \"dog\"], ..., prob=True)\n        [[0.423, 0.577]]\n        ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.text.convert_text", "project": "datachain", "func": "convert_text", "origin_file": "datachain/lib/text.py", "test_list": ["../tests/unit/lib/test_clip.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 43, "key_block_start_lineno": 24, "key_block_end_lineno": 43, "new_func_code": "def convert_text(\n    text: Union[str, list[str]],\n    tokenizer: Optional[Callable] = None,\n    tokenizer_kwargs: Optional[dict[str, Any]] = None,\n    encoder: Optional[Callable] = None,\n    device: Optional[Union[str, torch.device]] = None,\n) -> Union[str, list[str], torch.Tensor]:\n    \"\"\"\n    Tokenize and otherwise transform text.\n\n    Args:\n        text (str): Text to convert.\n        tokenizer (Callable): Tokenizer to use to tokenize objects.\n        tokenizer_kwargs (dict): Additional kwargs to pass when calling tokenizer.\n        encoder (Callable): Encode text using model.\n        device (str or torch.device): Device to use.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.file.File::get_destination_path", "project": "datachain", "func": "File::get_destination_path", "origin_file": "datachain/lib/file.py", "test_list": ["../tests/unit/lib/test_file.py"], "prob_info": {"func_start_lineno": 396, "func_end_lineno": 414, "key_block_start_lineno": 401, "key_block_end_lineno": 414, "new_func_code": "def get_destination_path(self, output: str, placement: ExportPlacement) -> str:\n        \"\"\"\n        Returns full destination path of a file for exporting to some output\n        based on export placement\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.lib.file.File::export", "project": "datachain", "func": "File::export", "origin_file": "datachain/lib/file.py", "test_list": ["../tests/unit/lib/test_file.py"], "prob_info": {"func_start_lineno": 297, "func_end_lineno": 319, "key_block_start_lineno": 305, "key_block_end_lineno": 319, "new_func_code": "def export(\n        self,\n        output: str,\n        placement: ExportPlacement = \"fullpath\",\n        use_cache: bool = True,\n        link_type: Literal[\"copy\", \"symlink\"] = \"copy\",\n    ) -> None:\n        \"\"\"Export file to new location.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "datachain.src.datachain.sql.sqlite.base.functions_exist", "project": "datachain", "func": "functions_exist", "origin_file": "datachain/sql/sqlite/base.py", "test_list": ["../tests/unit/sql/sqlite/test_utils.py"], "prob_info": {"func_start_lineno": 131, "func_end_lineno": 162, "key_block_start_lineno": 137, "key_block_end_lineno": 162, "new_func_code": "def functions_exist(\n    names: Iterable[str], connection: Optional[sqlite3.Connection] = None\n) -> bool:\n    \"\"\"\n    Returns True if all function names are defined for the given connection.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.component.sockets.Sockets::get", "project": "haystack", "func": "Sockets::get", "origin_file": "./Source_Copy/haystack/haystack/core/component/sockets.py", "test_list": ["test/components/audio/test_whisper_remote.py"], "prob_info": {"func_start_lineno": 106, "func_end_lineno": 119, "key_block_start_lineno": 119, "key_block_end_lineno": 119, "new_func_code": "def get(\n        self, key: str, default: Optional[Union[InputSocket, OutputSocket]] = None\n    ) -> Optional[Union[InputSocket, OutputSocket]]:\n        \"\"\"\n        Get a socket from the Sockets object.\n\n        :param key:\n            The name of the socket to get.\n        :param default:\n            The value to return if the key is not found.\n        :returns:\n            The socket with the given key or `default` if the key is not found.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.serialization.default_to_dict", "project": "haystack", "func": "default_to_dict", "origin_file": "./Source_Copy/haystack/haystack/core/serialization.py", "test_list": ["test/components/audio/test_whisper_remote.py"], "prob_info": {"func_start_lineno": 172, "func_end_lineno": 210, "key_block_start_lineno": 210, "key_block_end_lineno": 210, "new_func_code": "def default_to_dict(obj: Any, **init_parameters) -> Dict[str, Any]:\n    \"\"\"\n    Utility function to serialize an object to a dictionary.\n\n    This is mostly necessary for components but can be used by any object.\n    `init_parameters` are parameters passed to the object class `__init__`.\n    They must be defined explicitly as they'll be used when creating a new\n    instance of `obj` with `from_dict`. Omitting them might cause deserialisation\n    errors or unexpected behaviours later, when calling `from_dict`.\n\n    An example usage:\n\n    ```python\n    class MyClass:\n        def __init__(self, my_param: int = 10):\n            self.my_param = my_param\n\n        def to_dict(self):\n            return default_to_dict(self, my_param=self.my_param)\n\n\n    obj = MyClass(my_param=1000)\n    data = obj.to_dict()\n    assert data == {\n        \"type\": \"MyClass\",\n        \"init_parameters\": {\n            \"my_param\": 1000,\n        },\n    }\n    ```\n\n    :param obj:\n        The object to be serialized.\n    :param init_parameters:\n        The parameters used to create a new instance of the class.\n    :returns:\n        A dictionary representation of the instance.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.serialization.default_from_dict", "project": "haystack", "func": "default_from_dict", "origin_file": "./Source_Copy/haystack/haystack/core/serialization.py", "test_list": ["test/components/audio/test_whisper_remote.py"], "prob_info": {"func_start_lineno": 213, "func_end_lineno": 240, "key_block_start_lineno": 235, "key_block_end_lineno": 240, "new_func_code": "def default_from_dict(cls: Type[object], data: Dict[str, Any]) -> Any:\n    \"\"\"\n    Utility function to deserialize a dictionary to an object.\n\n    This is mostly necessary for components but can be used by any object.\n\n    The function will raise a `DeserializationError` if the `type` field in `data` is\n    missing or it doesn't match the type of `cls`.\n\n    If `data` contains an `init_parameters` field it will be used as parameters to create\n    a new instance of `cls`.\n\n    :param cls:\n        The class to be used for deserialization.\n    :param data:\n        The serialized data.\n    :returns:\n        The deserialized object.\n\n    :raises DeserializationError:\n        If the `type` field in `data` is missing or it doesn't match the type of `cls`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.component.component._Component::set_input_type", "project": "haystack", "func": "_Component::set_input_type", "origin_file": "./Source_Copy/haystack/haystack/core/component/component.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 339, "func_end_lineno": 363, "key_block_start_lineno": 356, "key_block_end_lineno": 363, "new_func_code": "def set_input_type(\n        self,\n        instance,\n        name: str,\n        type: Any,  # noqa: A002\n        default: Any = _empty,\n    ):\n        \"\"\"\n        Add a single input socket to the component instance.\n\n        Replaces any existing input socket with the same name.\n\n        :param instance: Component instance where the input type will be added.\n        :param name: name of the input socket.\n        :param type: type of the input socket.\n        :param default: default value of the input socket, defaults to _empty\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.builders.chat_prompt_builder.ChatPromptBuilder::_validate_variables", "project": "haystack", "func": "ChatPromptBuilder::_validate_variables", "origin_file": "./Source_Copy/haystack/haystack/components/builders/chat_prompt_builder.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 219, "func_end_lineno": 238, "key_block_start_lineno": 228, "key_block_end_lineno": 238, "new_func_code": "def _validate_variables(self, provided_variables: Set[str]):\n        \"\"\"\n        Checks if all the required template variables are provided.\n\n        :param provided_variables:\n            A set of provided template variables.\n        :raises ValueError:\n            If no template is provided or if all the required template variables are not provided.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.component.component._Component::output_types", "project": "haystack", "func": "_Component::output_types", "origin_file": "./Source_Copy/haystack/haystack/core/component/component.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 445, "func_end_lineno": 480, "key_block_start_lineno": 459, "key_block_end_lineno": 480, "new_func_code": "def output_types(self, **types):\n        \"\"\"\n        Decorator factory that specifies the output types of a component.\n\n        Use as:\n\n        ```python\n        @component\n        class MyComponent:\n            @component.output_types(output_1=int, output_2=str)\n            def run(self, value: int):\n                return {\"output_1\": 1, \"output_2\": \"2\"}\n        ```\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.component.component._Component::_component", "project": "haystack", "func": "_Component::_component", "origin_file": "./Source_Copy/haystack/haystack/core/component/component.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 482, "func_end_lineno": 529, "key_block_start_lineno": 486, "key_block_end_lineno": 529, "new_func_code": "def _component(self, cls: Any):\n        \"\"\"\n        Decorator validating the structure of the component and registering it in the components registry.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.type_utils._types_are_compatible", "project": "haystack", "func": "_types_are_compatible", "origin_file": "./Source_Copy/haystack/haystack/core/type_utils.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 14, "func_end_lineno": 26, "key_block_start_lineno": 23, "key_block_end_lineno": 26, "new_func_code": "def _types_are_compatible(sender, receiver, type_validation: bool = True) -> bool:\n    \"\"\"\n    Determines if two types are compatible based on the specified validation mode.\n\n    :param sender: The sender type.\n    :param receiver: The receiver type.\n    :param type_validation: Whether to perform strict type validation.\n    :return: True if the types are compatible, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.pipeline.Pipeline::run", "project": "haystack", "func": "Pipeline::run", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/pipeline.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 93, "func_end_lineno": 265, "key_block_start_lineno": 185, "key_block_end_lineno": 265, "new_func_code": "def run(  # noqa: PLR0915, PLR0912\n        self, data: Dict[str, Any], include_outputs_from: Optional[Set[str]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Runs the Pipeline with given input data.\n\n        Usage:\n        ```python\n        from haystack import Pipeline, Document\n        from haystack.utils import Secret\n        from haystack.document_stores.in_memory import InMemoryDocumentStore\n        from haystack.components.retrievers.in_memory import InMemoryBM25Retriever\n        from haystack.components.generators import OpenAIGenerator\n        from haystack.components.builders.answer_builder import AnswerBuilder\n        from haystack.components.builders.prompt_builder import PromptBuilder\n\n        # Write documents to InMemoryDocumentStore\n        document_store = InMemoryDocumentStore()\n        document_store.write_documents([\n            Document(content=\"My name is Jean and I live in Paris.\"),\n            Document(content=\"My name is Mark and I live in Berlin.\"),\n            Document(content=\"My name is Giorgio and I live in Rome.\")\n        ])\n\n        prompt_template = \\\"\\\"\\\"\n        Given these documents, answer the question.\n        Documents:\n        {% for doc in documents %}\n            {{ doc.content }}\n        {% endfor %}\n        Question: {{question}}\n        Answer:\n        \\\"\\\"\\\"\n\n        retriever = InMemoryBM25Retriever(document_store=document_store)\n        prompt_builder = PromptBuilder(template=prompt_template)\n        llm = OpenAIGenerator(api_key=Secret.from_token(api_key))\n\n        rag_pipeline = Pipeline()\n        rag_pipeline.add_component(\"retriever\", retriever)\n        rag_pipeline.add_component(\"prompt_builder\", prompt_builder)\n        rag_pipeline.add_component(\"llm\", llm)\n        rag_pipeline.connect(\"retriever\", \"prompt_builder.documents\")\n        rag_pipeline.connect(\"prompt_builder\", \"llm\")\n\n        # Ask a question\n        question = \"Who lives in Paris?\"\n        results = rag_pipeline.run(\n            {\n                \"retriever\": {\"query\": question},\n                \"prompt_builder\": {\"question\": question},\n            }\n        )\n\n        print(results[\"llm\"][\"replies\"])\n        # Jean lives in Paris\n        ```\n\n        :param data:\n            A dictionary of inputs for the pipeline's components. Each key is a component name\n            and its value is a dictionary of that component's input parameters:\n            ```\n            data = {\n                \"comp1\": {\"input1\": 1, \"input2\": 2},\n            }\n            ```\n            For convenience, this format is also supported when input names are unique:\n            ```\n            data = {\n                \"input1\": 1, \"input2\": 2,\n            }\n            ```\n        :param include_outputs_from:\n            Set of component names whose individual outputs are to be\n            included in the pipeline's output. For components that are\n            invoked multiple times (in a loop), only the last-produced\n            output is included.\n        :returns:\n            A dictionary where each entry corresponds to a component name\n            and its output. If `include_outputs_from` is `None`, this dictionary\n            will only contain the outputs of leaf components, i.e., components\n            without outgoing connections.\n\n        :raises ValueError:\n            If invalid inputs are provided to the pipeline.\n        :raises PipelineRuntimeError:\n            If the Pipeline contains cycles with unsupported connections that would cause\n            it to get stuck and fail running.\n            Or if a Component fails or returns output in an unsupported type.\n        :raises PipelineMaxComponentRuns:\n            If a Component reaches the maximum number of times it can be run in this Pipeline.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.telemetry._telemetry.Telemetry::send_event", "project": "haystack", "func": "Telemetry::send_event", "origin_file": "./Source_Copy/haystack/haystack/telemetry/_telemetry.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 99, "func_end_lineno": 113, "key_block_start_lineno": 107, "key_block_end_lineno": 113, "new_func_code": "def send_event(self, event_name: str, event_properties: Optional[Dict[str, Any]] = None):\n        \"\"\"\n        Sends a telemetry event.\n\n        :param event_name: The name of the event to show in PostHog.\n        :param event_properties: Additional event metadata. These are merged with the\n            system metadata collected in __init__, so take care not to overwrite them.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.utils.FIFOPriorityQueue::push", "project": "haystack", "func": "FIFOPriorityQueue::push", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/utils.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 43, "func_end_lineno": 57, "key_block_start_lineno": 55, "key_block_end_lineno": 57, "new_func_code": "def push(self, item: Any, priority: int) -> None:\n        \"\"\"\n        Push an item into the queue with a given priority.\n\n        Items with equal priority maintain FIFO ordering based on insertion time.\n        Lower priority numbers are dequeued first.\n\n        :param item:\n            The item to insert into the queue.\n        :param priority:\n            Priority level for the item. Lower numbers indicate higher priority.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.utils.FIFOPriorityQueue::get", "project": "haystack", "func": "FIFOPriorityQueue::get", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/utils.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 91, "func_end_lineno": 104, "key_block_start_lineno": 101, "key_block_end_lineno": 104, "new_func_code": "def get(self) -> Optional[Tuple[int, Any]]:\n        \"\"\"\n        Remove and return the highest priority item from the queue.\n\n        For items with equal priority, returns the one that was inserted first.\n        Unlike pop(), returns None if the queue is empty instead of raising an exception.\n\n        :returns:\n            A tuple containing (priority, item), or None if the queue is empty.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.type_utils._strict_types_are_compatible", "project": "haystack", "func": "_strict_types_are_compatible", "origin_file": "./Source_Copy/haystack/haystack/core/type_utils.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 29, "func_end_lineno": 76, "key_block_start_lineno": 42, "key_block_end_lineno": 76, "new_func_code": "def _strict_types_are_compatible(sender, receiver):  # pylint: disable=too-many-return-statements\n    \"\"\"\n    Checks whether the sender type is equal to or a subtype of the receiver type under strict validation.\n\n    Note: this method has no pretense to perform proper type matching. It especially does not deal with aliasing of\n    typing classes such as `List` or `Dict` to their runtime counterparts `list` and `dict`. It also does not deal well\n    with \"bare\" types, so `List` is treated differently from `List[Any]`, even though they should be the same.\n    Consider simplifying the typing of your components if you observe unexpected errors during component connection.\n\n    :param sender: The sender type.\n    :param receiver: The receiver type.\n    :return: True if the sender type is strictly compatible with the receiver type, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.dataclasses.chat_message.ChatMessage::to_dict", "project": "haystack", "func": "ChatMessage::to_dict", "origin_file": "./Source_Copy/haystack/haystack/dataclasses/chat_message.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 293, "func_end_lineno": 316, "key_block_start_lineno": 300, "key_block_end_lineno": 316, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Converts ChatMessage into a dictionary.\n\n        :returns:\n            Serialized version of the object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.logging.getLogger", "project": "haystack", "func": "getLogger", "origin_file": "./Source_Copy/haystack/haystack/logging.py", "test_list": ["test/components/builders/test_prompt_builder.py"], "prob_info": {"func_start_lineno": 230, "func_end_lineno": 255, "key_block_start_lineno": 239, "key_block_end_lineno": 255, "new_func_code": "def getLogger(name: str) -> PatchedLogger:\n    \"\"\"\n    Get the Haystack logger, a patched version of the one from the standard library.\n\n    We patch the default logger methods to make sure that they are only called with keyword arguments.\n    We enforce keyword-arguments because\n        - it brings in consistency\n        - it makes structure logging effective, not just an available feature\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.builders.prompt_builder.PromptBuilder::run", "project": "haystack", "func": "PromptBuilder::run", "origin_file": "./Source_Copy/haystack/haystack/components/builders/prompt_builder.py", "test_list": ["test/components/builders/test_prompt_builder.py"], "prob_info": {"func_start_lineno": 213, "func_end_lineno": 245, "key_block_start_lineno": 235, "key_block_end_lineno": 245, "new_func_code": "def run(self, template: Optional[str] = None, template_variables: Optional[Dict[str, Any]] = None, **kwargs):\n        \"\"\"\n        Renders the prompt template with the provided variables.\n\n        It applies the template variables to render the final prompt. You can provide variables via pipeline kwargs.\n        In order to overwrite the default template, you can set the `template` parameter.\n        In order to overwrite pipeline kwargs, you can set the `template_variables` parameter.\n\n        :param template:\n            An optional string template to overwrite PromptBuilder's default template. If None, the default template\n            provided at initialization is used.\n        :param template_variables:\n            An optional dictionary of template variables to overwrite the pipeline variables.\n        :param kwargs:\n            Pipeline variables used for rendering the prompt.\n\n        :returns: A dictionary with the following keys:\n            - `prompt`: The updated prompt text after rendering the prompt template.\n\n        :raises ValueError:\n            If any of the required template variables is not provided.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.builders.prompt_builder.PromptBuilder::_validate_variables", "project": "haystack", "func": "PromptBuilder::_validate_variables", "origin_file": "./Source_Copy/haystack/haystack/components/builders/prompt_builder.py", "test_list": ["test/components/builders/test_prompt_builder.py"], "prob_info": {"func_start_lineno": 247, "func_end_lineno": 266, "key_block_start_lineno": 256, "key_block_end_lineno": 266, "new_func_code": "def _validate_variables(self, provided_variables: Set[str]):\n        \"\"\"\n        Checks if all the required template variables are provided.\n\n        :param provided_variables:\n            A set of provided template variables.\n        :raises ValueError:\n            If any of the required template variables is not provided.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.classifiers.document_language_classifier.DocumentLanguageClassifier::run", "project": "haystack", "func": "DocumentLanguageClassifier::run", "origin_file": "./Source_Copy/haystack/haystack/components/classifiers/document_language_classifier.py", "test_list": ["test/components/classifiers/test_document_language_classifier.py"], "prob_info": {"func_start_lineno": 69, "func_end_lineno": 99, "key_block_start_lineno": 83, "key_block_end_lineno": 99, "new_func_code": "def run(self, documents: List[Document]):\n        \"\"\"\n        Classifies the language of each document and adds it to its metadata.\n\n        If the document's text doesn't match any of the languages specified at initialization,\n        sets the metadata value to \"unmatched\".\n\n        :param documents: A list of documents for language classification.\n\n        :returns: A dictionary with the following key:\n            - `documents`: A list of documents with an added `language` metadata field.\n\n        :raises TypeError: if the input is not a list of Documents.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.device.ComponentDevice::update_hf_kwargs", "project": "haystack", "func": "ComponentDevice::update_hf_kwargs", "origin_file": "./Source_Copy/haystack/haystack/utils/device.py", "test_list": ["test/components/classifiers/test_zero_shot_document_classifier.py"], "prob_info": {"func_start_lineno": 381, "func_end_lineno": 402, "key_block_start_lineno": 394, "key_block_end_lineno": 402, "new_func_code": "def update_hf_kwargs(self, hf_kwargs: Dict[str, Any], *, overwrite: bool) -> Dict[str, Any]:\n        \"\"\"\n        Convert the component device representation to HuggingFace format.\n\n        Add them as canonical keyword arguments to the keyword arguments dictionary.\n\n        :param hf_kwargs:\n            The HuggingFace keyword arguments dictionary.\n        :param overwrite:\n            Whether to overwrite existing device arguments.\n        :returns:\n            The HuggingFace keyword arguments dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.device.ComponentDevice::to_hf", "project": "haystack", "func": "ComponentDevice::to_hf", "origin_file": "./Source_Copy/haystack/haystack/utils/device.py", "test_list": ["test/components/classifiers/test_zero_shot_document_classifier.py"], "prob_info": {"func_start_lineno": 359, "func_end_lineno": 379, "key_block_start_lineno": 366, "key_block_end_lineno": 379, "new_func_code": "def to_hf(self) -> Union[Union[int, str], Dict[str, Union[int, str]]]:\n        \"\"\"\n        Convert the component device representation to HuggingFace format.\n\n        :returns:\n            The HuggingFace device representation.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.classifiers.zero_shot_document_classifier.TransformersZeroShotDocumentClassifier::to_dict", "project": "haystack", "func": "TransformersZeroShotDocumentClassifier::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/classifiers/zero_shot_document_classifier.py", "test_list": ["test/components/classifiers/test_zero_shot_document_classifier.py"], "prob_info": {"func_start_lineno": 152, "func_end_lineno": 171, "key_block_start_lineno": 159, "key_block_end_lineno": 171, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.hf.deserialize_hf_model_kwargs", "project": "haystack", "func": "deserialize_hf_model_kwargs", "origin_file": "./Source_Copy/haystack/haystack/utils/hf.py", "test_list": ["test/components/classifiers/test_zero_shot_document_classifier.py"], "prob_info": {"func_start_lineno": 115, "func_end_lineno": 132, "key_block_start_lineno": 121, "key_block_end_lineno": 132, "new_func_code": "def deserialize_hf_model_kwargs(kwargs: Dict[str, Any]):\n    \"\"\"\n    Recursively deserialize HuggingFace specific model keyword arguments in-place to make them JSON serializable.\n\n    :param kwargs: The keyword arguments to deserialize\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.classifiers.zero_shot_document_classifier.TransformersZeroShotDocumentClassifier::run", "project": "haystack", "func": "TransformersZeroShotDocumentClassifier::run", "origin_file": "./Source_Copy/haystack/haystack/components/classifiers/zero_shot_document_classifier.py", "test_list": ["test/components/classifiers/test_zero_shot_document_classifier.py"], "prob_info": {"func_start_lineno": 189, "func_end_lineno": 245, "key_block_start_lineno": 205, "key_block_end_lineno": 245, "new_func_code": "def run(self, documents: List[Document], batch_size: int = 1):\n        \"\"\"\n        Classifies the documents based on the provided labels and adds them to their metadata.\n\n        The classification results are stored in the `classification` dict within\n        each document's metadata. If `multi_label` is set to `True`, the scores for each label are available under\n        the `details` key within the `classification` dictionary.\n\n        :param documents:\n            Documents to process.\n        :param batch_size:\n            Batch size used for processing the content in each document.\n        :returns:\n            A dictionary with the following key:\n            - `documents`: A list of documents with an added metadata field called `classification`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.dataclasses.document.Document::to_dict", "project": "haystack", "func": "Document::to_dict", "origin_file": "./Source_Copy/haystack/haystack/dataclasses/document.py", "test_list": ["test/components/classifiers/test_zero_shot_document_classifier.py"], "prob_info": {"func_start_lineno": 123, "func_end_lineno": 140, "key_block_start_lineno": 132, "key_block_end_lineno": 140, "new_func_code": "def to_dict(self, flatten=True) -> Dict[str, Any]:\n        \"\"\"\n        Converts Document into a dictionary.\n\n        `blob` field is converted to a JSON-serializable type.\n\n        :param flatten:\n            Whether to flatten `meta` field or not. Defaults to `True` to be backward-compatible with Haystack 1.x.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.document_stores.in_memory.document_store.InMemoryDocumentStore::_dispatch_bm25", "project": "haystack", "func": "InMemoryDocumentStore::_dispatch_bm25", "origin_file": "./Source_Copy/haystack/haystack/document_stores/in_memory/document_store.py", "test_list": ["test/components/classifiers/test_zero_shot_document_classifier.py"], "prob_info": {"func_start_lineno": 159, "func_end_lineno": 170, "key_block_start_lineno": 166, "key_block_end_lineno": 170, "new_func_code": "def _dispatch_bm25(self):\n        \"\"\"\n        Select the correct BM25 algorithm based on user specification.\n\n        :returns:\n            The BM25 algorithm method.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.utils.parse_connect_string", "project": "haystack", "func": "parse_connect_string", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/utils.py", "test_list": ["test/components/classifiers/test_zero_shot_document_classifier.py"], "prob_info": {"func_start_lineno": 10, "func_end_lineno": 22, "key_block_start_lineno": 19, "key_block_end_lineno": 22, "new_func_code": "def parse_connect_string(connection: str) -> Tuple[str, Optional[str]]:\n    \"\"\"\n    Returns component-connection pairs from a connect_to/from string.\n\n    :param connection:\n        The connection string.\n    :returns:\n        A tuple containing the component name and the connection name.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.retrievers.in_memory.bm25_retriever.InMemoryBM25Retriever::to_dict", "project": "haystack", "func": "InMemoryBM25Retriever::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/retrievers/in_memory/bm25_retriever.py", "test_list": ["test/components/classifiers/test_zero_shot_document_classifier.py"], "prob_info": {"func_start_lineno": 88, "func_end_lineno": 103, "key_block_start_lineno": 95, "key_block_end_lineno": 103, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.document_stores.in_memory.document_store.InMemoryDocumentStore::to_dict", "project": "haystack", "func": "InMemoryDocumentStore::to_dict", "origin_file": "./Source_Copy/haystack/haystack/document_stores/in_memory/document_store.py", "test_list": ["test/components/classifiers/test_zero_shot_document_classifier.py"], "prob_info": {"func_start_lineno": 344, "func_end_lineno": 358, "key_block_start_lineno": 351, "key_block_end_lineno": 358, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.connectors.openapi_service.OpenAPIServiceConnector::_authenticate_service", "project": "haystack", "func": "OpenAPIServiceConnector::_authenticate_service", "origin_file": "./Source_Copy/haystack/haystack/components/connectors/openapi_service.py", "test_list": ["test/components/connectors/test_openapi_service.py"], "prob_info": {"func_start_lineno": 286, "func_end_lineno": 339, "key_block_start_lineno": 308, "key_block_end_lineno": 339, "new_func_code": "def _authenticate_service(self, openapi_service: \"OpenAPI\", credentials: Optional[Union[dict, str]] = None):\n        \"\"\"\n        Authentication with an OpenAPI service.\n\n        Authenticates with the OpenAPI service if required, supporting both single (str) and multiple\n        authentication methods (dict).\n\n        OpenAPI spec v3 supports the following security schemes:\n        http  for Basic, Bearer and other HTTP authentications schemes\n        apiKey  for API keys and cookie authentication\n        oauth2  for OAuth 2\n        openIdConnect  for OpenID Connect Discovery\n\n        Currently, only the http and apiKey schemes are supported. Multiple security schemes can be defined in the\n        OpenAPI spec, and the credentials should be provided as a dictionary with keys matching the security scheme\n        names. If only one security scheme is defined, the credentials can be provided as a simple string.\n\n        :param openapi_service: The OpenAPI service instance.\n        :param credentials: Credentials for authentication, which can be either a string (e.g. token) or a dictionary\n        with keys matching the authentication method names.\n        :raises ValueError: If authentication fails, is not found, or if appropriate credentials are missing.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.serialization.component_from_dict", "project": "haystack", "func": "component_from_dict", "origin_file": "./Source_Copy/haystack/haystack/core/serialization.py", "test_list": ["test/components/connectors/test_openapi_service.py"], "prob_info": {"func_start_lineno": 134, "func_end_lineno": 169, "key_block_start_lineno": 153, "key_block_end_lineno": 169, "new_func_code": "def component_from_dict(\n    cls: Type[object], data: Dict[str, Any], name: str, callbacks: Optional[DeserializationCallbacks] = None\n) -> Any:\n    \"\"\"\n    Creates a component instance from a dictionary.\n\n    If a `from_dict` method is present in the component class, that will be used instead of the default method.\n\n    :param cls:\n        The class to be used for deserialization.\n    :param data:\n        The serialized data.\n    :param name:\n        The name of the component.\n    :param callbacks:\n        Callbacks to invoke during deserialization.\n    :returns:\n        The deserialized component.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.logging.patch_log_method_to_kwargs_only", "project": "haystack", "func": "patch_log_method_to_kwargs_only", "origin_file": "./Source_Copy/haystack/haystack/logging.py", "test_list": ["test/components/converters/test_json.py"], "prob_info": {"func_start_lineno": 136, "func_end_lineno": 154, "key_block_start_lineno": 138, "key_block_end_lineno": 154, "new_func_code": "def patch_log_method_to_kwargs_only(func: typing.Callable) -> typing.Callable:\n    \"\"\"A decorator to make sure that a function is only called with keyword arguments.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.converters.json.JSONConverter::to_dict", "project": "haystack", "func": "JSONConverter::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/converters/json.py", "test_list": ["test/components/converters/test_json.py"], "prob_info": {"func_start_lineno": 152, "func_end_lineno": 165, "key_block_start_lineno": 159, "key_block_end_lineno": 165, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.converters.utils.normalize_metadata", "project": "haystack", "func": "normalize_metadata", "origin_file": "./Source_Copy/haystack/haystack/components/converters/utils.py", "test_list": ["test/components/converters/test_json.py"], "prob_info": {"func_start_lineno": 30, "func_end_lineno": 51, "key_block_start_lineno": 43, "key_block_end_lineno": 51, "new_func_code": "def normalize_metadata(\n    meta: Optional[Union[Dict[str, Any], List[Dict[str, Any]]]], sources_count: int\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Normalize the metadata input for a converter.\n\n    Given all the possible value of the meta input for a converter (None, dictionary or list of dicts),\n    makes sure to return a list of dictionaries of the correct length for the converter to use.\n\n    :param meta: the meta input of the converter, as-is\n    :param sources_count: the number of sources the converter received\n    :returns: a list of dictionaries of the make length as the sources list\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.converters.openapi_functions.OpenAPIServiceToFunctions::_parse_openapi_spec", "project": "haystack", "func": "OpenAPIServiceToFunctions::_parse_openapi_spec", "origin_file": "./Source_Copy/haystack/haystack/components/converters/openapi_functions.py", "test_list": ["test/components/converters/test_openapi_functions.py"], "prob_info": {"func_start_lineno": 232, "func_end_lineno": 257, "key_block_start_lineno": 239, "key_block_end_lineno": 257, "new_func_code": "def _parse_openapi_spec(self, content: str) -> Dict[str, Any]:\n        \"\"\"\n        Parses OpenAPI specification content, supporting both JSON and YAML formats.\n\n        :param content: The content of the OpenAPI specification.\n        :return: The parsed OpenAPI specification.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.converters.openapi_functions.OpenAPIServiceToFunctions::_openapi_to_functions", "project": "haystack", "func": "OpenAPIServiceToFunctions::_openapi_to_functions", "origin_file": "./Source_Copy/haystack/haystack/components/converters/openapi_functions.py", "test_list": ["test/components/converters/test_openapi_functions.py"], "prob_info": {"func_start_lineno": 117, "func_end_lineno": 151, "key_block_start_lineno": 130, "key_block_end_lineno": 151, "new_func_code": "def _openapi_to_functions(self, service_openapi_spec: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"\n        OpenAPI to OpenAI function conversion.\n\n        Extracts functions from the OpenAPI specification of the service and converts them into a format\n        suitable for OpenAI function calling.\n\n        :param service_openapi_spec: The OpenAPI specification from which functions are to be extracted.\n        :type service_openapi_spec: Dict[str, Any]\n        :return: A list of dictionaries, each representing a function. Each dictionary includes the function's\n                 name, description, and a schema of its parameters.\n        :rtype: List[Dict[str, Any]]\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.converters.openapi_functions.OpenAPIServiceToFunctions::_parse_property_attributes", "project": "haystack", "func": "OpenAPIServiceToFunctions::_parse_property_attributes", "origin_file": "./Source_Copy/haystack/haystack/components/converters/openapi_functions.py", "test_list": ["test/components/converters/test_openapi_functions.py"], "prob_info": {"func_start_lineno": 193, "func_end_lineno": 230, "key_block_start_lineno": 206, "key_block_end_lineno": 230, "new_func_code": "def _parse_property_attributes(\n        self, property_schema: Dict[str, Any], include_attributes: Optional[List[str]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Parses the attributes of a property schema.\n\n        Recursively parses the attributes of a property schema, including nested objects and arrays,\n        and includes specified attributes like description, pattern, etc.\n\n        :param property_schema: The schema of the property to parse.\n        :param include_attributes: The list of attributes to include in the parsed schema.\n        :return: The parsed schema of the property including the specified attributes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.logging.patch_log_with_level_method_to_kwargs_only", "project": "haystack", "func": "patch_log_with_level_method_to_kwargs_only", "origin_file": "./Source_Copy/haystack/haystack/logging.py", "test_list": ["test/components/converters/test_output_adapter.py"], "prob_info": {"func_start_lineno": 157, "func_end_lineno": 184, "key_block_start_lineno": 159, "key_block_end_lineno": 184, "new_func_code": "def patch_log_with_level_method_to_kwargs_only(func: typing.Callable) -> typing.Callable:\n    \"\"\"A decorator to make sure that a function is only called with keyword arguments.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.component.component._Component::set_input_types", "project": "haystack", "func": "_Component::set_input_types", "origin_file": "./Source_Copy/haystack/haystack/core/component/component.py", "test_list": ["test/components/converters/test_output_adapter.py"], "prob_info": {"func_start_lineno": 365, "func_end_lineno": 413, "key_block_start_lineno": 406, "key_block_end_lineno": 413, "new_func_code": "def set_input_types(self, instance, **types):\n        \"\"\"\n        Method that specifies the input types when 'kwargs' is passed to the run method.\n\n        Use as:\n\n        ```python\n        @component\n        class MyComponent:\n\n            def __init__(self, value: int):\n                component.set_input_types(self, value_1=str, value_2=str)\n                ...\n\n            @component.output_types(output_1=int, output_2=str)\n            def run(self, **kwargs):\n                return {\"output_1\": kwargs[\"value_1\"], \"output_2\": \"\"}\n        ```\n\n        Note that if the `run()` method also specifies some parameters, those will take precedence.\n\n        For example:\n\n        ```python\n        @component\n        class MyComponent:\n\n            def __init__(self, value: int):\n                component.set_input_types(self, value_1=str, value_2=str)\n                ...\n\n            @component.output_types(output_1=int, output_2=str)\n            def run(self, value_0: str, value_1: Optional[str] = None, **kwargs):\n                return {\"output_1\": kwargs[\"value_1\"], \"output_2\": \"\"}\n        ```\n\n        would add a mandatory `value_0` parameters, make the `value_1`\n        parameter optional with a default None, and keep the `value_2`\n        parameter mandatory as specified in `set_input_types`.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.component.component._Component::set_output_types", "project": "haystack", "func": "_Component::set_output_types", "origin_file": "./Source_Copy/haystack/haystack/core/component/component.py", "test_list": ["test/components/converters/test_output_adapter.py"], "prob_info": {"func_start_lineno": 415, "func_end_lineno": 443, "key_block_start_lineno": 434, "key_block_end_lineno": 443, "new_func_code": "def set_output_types(self, instance, **types):\n        \"\"\"\n        Method that specifies the output types when the 'run' method is not decorated with 'component.output_types'.\n\n        Use as:\n\n        ```python\n        @component\n        class MyComponent:\n\n            def __init__(self, value: int):\n                component.set_output_types(self, output_1=int, output_2=str)\n                ...\n\n            # no decorators here\n            def run(self, value: int):\n                return {\"output_1\": 1, \"output_2\": \"2\"}\n        ```\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.converters.output_adapter.OutputAdapter::run", "project": "haystack", "func": "OutputAdapter::run", "origin_file": "./Source_Copy/haystack/haystack/components/converters/output_adapter.py", "test_list": ["test/components/converters/test_output_adapter.py"], "prob_info": {"func_start_lineno": 102, "func_end_lineno": 137, "key_block_start_lineno": 114, "key_block_end_lineno": 137, "new_func_code": "def run(self, **kwargs):\n        \"\"\"\n        Renders the Jinja template with the provided inputs.\n\n        :param kwargs:\n            Must contain all variables used in the `template` string.\n        :returns:\n            A dictionary with the following keys:\n            - `output`: Rendered Jinja template.\n\n        :raises OutputAdaptationException: If template rendering fails.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.converters.output_adapter.OutputAdapter::to_dict", "project": "haystack", "func": "OutputAdapter::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/converters/output_adapter.py", "test_list": ["test/components/converters/test_output_adapter.py"], "prob_info": {"func_start_lineno": 139, "func_end_lineno": 153, "key_block_start_lineno": 146, "key_block_end_lineno": 153, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.callable_serialization.serialize_callable", "project": "haystack", "func": "serialize_callable", "origin_file": "./Source_Copy/haystack/haystack/utils/callable_serialization.py", "test_list": ["test/components/converters/test_output_adapter.py"], "prob_info": {"func_start_lineno": 12, "func_end_lineno": 42, "key_block_start_lineno": 19, "key_block_end_lineno": 42, "new_func_code": "def serialize_callable(callable_handle: Callable) -> str:\n    \"\"\"\n    Serializes a callable to its full path.\n\n    :param callable_handle: The callable to serialize\n    :return: The full path of the callable\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.type_serialization.thread_safe_import", "project": "haystack", "func": "thread_safe_import", "origin_file": "./Source_Copy/haystack/haystack/utils/type_serialization.py", "test_list": ["test/components/converters/test_output_adapter.py"], "prob_info": {"func_start_lineno": 159, "func_end_lineno": 170, "key_block_start_lineno": 169, "key_block_end_lineno": 170, "new_func_code": "def thread_safe_import(module_name: str) -> ModuleType:\n    \"\"\"\n    Import a module in a thread-safe manner.\n\n    Importing modules in a multi-threaded environment can lead to race conditions.\n    This function ensures that the module is imported in a thread-safe manner without having impact\n    on the performance of the import for single-threaded environments.\n\n    :param module_name: the module to import\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.azure_document_embedder.AzureOpenAIDocumentEmbedder::to_dict", "project": "haystack", "func": "AzureOpenAIDocumentEmbedder::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/azure_document_embedder.py", "test_list": ["test/components/embedders/test_azure_document_embedder.py"], "prob_info": {"func_start_lineno": 154, "func_end_lineno": 183, "key_block_start_lineno": 161, "key_block_end_lineno": 183, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.azure_text_embedder.AzureOpenAITextEmbedder::to_dict", "project": "haystack", "func": "AzureOpenAITextEmbedder::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/azure_text_embedder.py", "test_list": ["test/components/embedders/test_azure_text_embedder.py"], "prob_info": {"func_start_lineno": 136, "func_end_lineno": 161, "key_block_start_lineno": 143, "key_block_end_lineno": 161, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.hugging_face_api_document_embedder.HuggingFaceAPIDocumentEmbedder::to_dict", "project": "haystack", "func": "HuggingFaceAPIDocumentEmbedder::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/hugging_face_api_document_embedder.py", "test_list": ["test/components/embedders/test_hugging_face_api_document_embedder.py"], "prob_info": {"func_start_lineno": 184, "func_end_lineno": 204, "key_block_start_lineno": 191, "key_block_end_lineno": 204, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.hugging_face_api_document_embedder.HuggingFaceAPIDocumentEmbedder::run", "project": "haystack", "func": "HuggingFaceAPIDocumentEmbedder::run", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/hugging_face_api_document_embedder.py", "test_list": ["test/components/embedders/test_hugging_face_api_document_embedder.py"], "prob_info": {"func_start_lineno": 274, "func_end_lineno": 298, "key_block_start_lineno": 285, "key_block_end_lineno": 298, "new_func_code": "def run(self, documents: List[Document]):\n        \"\"\"\n        Embeds a list of documents.\n\n        :param documents:\n            Documents to embed.\n\n        :returns:\n            A dictionary with the following keys:\n            - `documents`: A list of documents with embeddings.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.hugging_face_api_text_embedder.HuggingFaceAPITextEmbedder::to_dict", "project": "haystack", "func": "HuggingFaceAPITextEmbedder::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/hugging_face_api_text_embedder.py", "test_list": ["test/components/embedders/test_hugging_face_api_text_embedder.py"], "prob_info": {"func_start_lineno": 150, "func_end_lineno": 166, "key_block_start_lineno": 157, "key_block_end_lineno": 166, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.openai_document_embedder.OpenAIDocumentEmbedder::to_dict", "project": "haystack", "func": "OpenAIDocumentEmbedder::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/openai_document_embedder.py", "test_list": ["test/components/embedders/test_openai_document_embedder.py"], "prob_info": {"func_start_lineno": 129, "func_end_lineno": 149, "key_block_start_lineno": 136, "key_block_end_lineno": 149, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.openai_document_embedder.OpenAIDocumentEmbedder::_prepare_texts_to_embed", "project": "haystack", "func": "OpenAIDocumentEmbedder::_prepare_texts_to_embed", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/openai_document_embedder.py", "test_list": ["test/components/embedders/test_openai_document_embedder.py"], "prob_info": {"func_start_lineno": 164, "func_end_lineno": 181, "key_block_start_lineno": 168, "key_block_end_lineno": 181, "new_func_code": "def _prepare_texts_to_embed(self, documents: List[Document]) -> Dict[str, str]:\n        \"\"\"\n        Prepare the texts to embed by concatenating the Document text with the metadata fields to embed.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.openai_document_embedder.OpenAIDocumentEmbedder::run", "project": "haystack", "func": "OpenAIDocumentEmbedder::run", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/openai_document_embedder.py", "test_list": ["test/components/embedders/test_openai_document_embedder.py"], "prob_info": {"func_start_lineno": 220, "func_end_lineno": 245, "key_block_start_lineno": 232, "key_block_end_lineno": 245, "new_func_code": "def run(self, documents: List[Document]):\n        \"\"\"\n        Embeds a list of documents.\n\n        :param documents:\n            A list of documents to embed.\n\n        :returns:\n            A dictionary with the following keys:\n            - `documents`: A list of documents with embeddings.\n            - `meta`: Information about the usage of the model.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.openai_text_embedder.OpenAITextEmbedder::to_dict", "project": "haystack", "func": "OpenAITextEmbedder::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/openai_text_embedder.py", "test_list": ["test/components/embedders/test_openai_text_embedder.py"], "prob_info": {"func_start_lineno": 111, "func_end_lineno": 127, "key_block_start_lineno": 118, "key_block_end_lineno": 127, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.openai_text_embedder.OpenAITextEmbedder::run", "project": "haystack", "func": "OpenAITextEmbedder::run", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/openai_text_embedder.py", "test_list": ["test/components/embedders/test_openai_text_embedder.py"], "prob_info": {"func_start_lineno": 143, "func_end_lineno": 174, "key_block_start_lineno": 155, "key_block_end_lineno": 174, "new_func_code": "def run(self, text: str):\n        \"\"\"\n        Embeds a single string.\n\n        :param text:\n            Text to embed.\n\n        :returns:\n            A dictionary with the following keys:\n            - `embedding`: The embedding of the input text.\n            - `meta`: Information about the usage of the model.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.sentence_transformers_document_embedder.SentenceTransformersDocumentEmbedder::to_dict", "project": "haystack", "func": "SentenceTransformersDocumentEmbedder::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/sentence_transformers_document_embedder.py", "test_list": ["test/components/embedders/test_sentence_transformers_document_embedder.py"], "prob_info": {"func_start_lineno": 145, "func_end_lineno": 175, "key_block_start_lineno": 152, "key_block_end_lineno": 175, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.device.ComponentDevice::to_dict", "project": "haystack", "func": "ComponentDevice::to_dict", "origin_file": "./Source_Copy/haystack/haystack/utils/device.py", "test_list": ["test/components/embedders/test_sentence_transformers_document_embedder.py"], "prob_info": {"func_start_lineno": 450, "func_end_lineno": 463, "key_block_start_lineno": 457, "key_block_end_lineno": 463, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert the component device representation to a JSON-serializable dictionary.\n\n        :returns:\n            The dictionary representation.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.hf.serialize_hf_model_kwargs", "project": "haystack", "func": "serialize_hf_model_kwargs", "origin_file": "./Source_Copy/haystack/haystack/utils/hf.py", "test_list": ["test/components/embedders/test_sentence_transformers_document_embedder.py"], "prob_info": {"func_start_lineno": 98, "func_end_lineno": 112, "key_block_start_lineno": 104, "key_block_end_lineno": 112, "new_func_code": "def serialize_hf_model_kwargs(kwargs: Dict[str, Any]):\n    \"\"\"\n    Recursively serialize HuggingFace specific model keyword arguments in-place to make them JSON serializable.\n\n    :param kwargs: The keyword arguments to serialize\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.auth.deserialize_secrets_inplace", "project": "haystack", "func": "deserialize_secrets_inplace", "origin_file": "./Source_Copy/haystack/haystack/utils/auth.py", "test_list": ["test/components/embedders/test_sentence_transformers_document_embedder.py"], "prob_info": {"func_start_lineno": 214, "func_end_lineno": 229, "key_block_start_lineno": 225, "key_block_end_lineno": 229, "new_func_code": "def deserialize_secrets_inplace(data: Dict[str, Any], keys: Iterable[str], *, recursive: bool = False):\n    \"\"\"\n    Deserialize secrets in a dictionary inplace.\n\n    :param data:\n        The dictionary with the serialized data.\n    :param keys:\n        The keys of the secrets to deserialize.\n    :param recursive:\n        Whether to recursively deserialize nested dictionaries.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.device.ComponentDevice::to_torch_str", "project": "haystack", "func": "ComponentDevice::to_torch_str", "origin_file": "./Source_Copy/haystack/haystack/utils/device.py", "test_list": ["test/components/embedders/test_sentence_transformers_document_embedder.py"], "prob_info": {"func_start_lineno": 321, "func_end_lineno": 336, "key_block_start_lineno": 330, "key_block_end_lineno": 336, "new_func_code": "def to_torch_str(self) -> str:\n        \"\"\"\n        Convert the component device representation to PyTorch string format.\n\n        Device maps are not supported.\n\n        :returns:\n            The PyTorch device string representation.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.sentence_transformers_document_embedder.SentenceTransformersDocumentEmbedder::run", "project": "haystack", "func": "SentenceTransformersDocumentEmbedder::run", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/sentence_transformers_document_embedder.py", "test_list": ["test/components/embedders/test_sentence_transformers_document_embedder.py"], "prob_info": {"func_start_lineno": 215, "func_end_lineno": 256, "key_block_start_lineno": 226, "key_block_end_lineno": 256, "new_func_code": "def run(self, documents: List[Document]):\n        \"\"\"\n        Embed a list of documents.\n\n        :param documents:\n            Documents to embed.\n\n        :returns:\n            A dictionary with the following keys:\n            - `documents`: Documents with embeddings.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.sentence_transformers_text_embedder.SentenceTransformersTextEmbedder::to_dict", "project": "haystack", "func": "SentenceTransformersTextEmbedder::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/sentence_transformers_text_embedder.py", "test_list": ["test/components/embedders/test_sentence_transformers_text_embedder.py"], "prob_info": {"func_start_lineno": 133, "func_end_lineno": 161, "key_block_start_lineno": 140, "key_block_end_lineno": 161, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.evaluators.answer_exact_match.AnswerExactMatchEvaluator::run", "project": "haystack", "func": "AnswerExactMatchEvaluator::run", "origin_file": "./Source_Copy/haystack/haystack/components/evaluators/answer_exact_match.py", "test_list": ["test/components/evaluators/test_answer_exact_match.py"], "prob_info": {"func_start_lineno": 39, "func_end_lineno": 69, "key_block_start_lineno": 56, "key_block_end_lineno": 69, "new_func_code": "def run(self, ground_truth_answers: List[str], predicted_answers: List[str]) -> Dict[str, Any]:\n        \"\"\"\n        Run the AnswerExactMatchEvaluator on the given inputs.\n\n        The `ground_truth_answers` and `retrieved_answers` must have the same length.\n\n        :param ground_truth_answers:\n            A list of expected answers.\n        :param predicted_answers:\n            A list of predicted answers.\n        :returns:\n            A dictionary with the following outputs:\n            - `individual_scores` - A list of 0s and 1s, where 1 means that the predicted answer matched one of the\n                ground truth.\n            - `score` - A number from 0.0 to 1.0 that represents the proportion of questions where any predicted\n                         answer matched one of the ground truth answers.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.evaluators.document_mrr.DocumentMRREvaluator::run", "project": "haystack", "func": "DocumentMRREvaluator::run", "origin_file": "./Source_Copy/haystack/haystack/components/evaluators/document_mrr.py", "test_list": ["test/components/evaluators/test_document_mrr.py"], "prob_info": {"func_start_lineno": 46, "func_end_lineno": 84, "key_block_start_lineno": 64, "key_block_end_lineno": 84, "new_func_code": "def run(\n        self, ground_truth_documents: List[List[Document]], retrieved_documents: List[List[Document]]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Run the DocumentMRREvaluator on the given inputs.\n\n        `ground_truth_documents` and `retrieved_documents` must have the same length.\n\n        :param ground_truth_documents:\n            A list of expected documents for each question.\n        :param retrieved_documents:\n            A list of retrieved documents for each question.\n        :returns:\n            A dictionary with the following outputs:\n            - `score` - The average of calculated scores.\n            - `individual_scores` - A list of numbers from 0.0 to 1.0 that represents how high the first retrieved\n                document is ranked.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.evaluators.document_ndcg.DocumentNDCGEvaluator::run", "project": "haystack", "func": "DocumentNDCGEvaluator::run", "origin_file": "./Source_Copy/haystack/haystack/components/evaluators/document_ndcg.py", "test_list": ["test/components/evaluators/test_document_ndcg.py"], "prob_info": {"func_start_lineno": 38, "func_end_lineno": 68, "key_block_start_lineno": 56, "key_block_end_lineno": 68, "new_func_code": "def run(\n        self, ground_truth_documents: List[List[Document]], retrieved_documents: List[List[Document]]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Run the DocumentNDCGEvaluator on the given inputs.\n\n        `ground_truth_documents` and `retrieved_documents` must have the same length.\n        The list items within `ground_truth_documents` and `retrieved_documents` can differ in length.\n\n        :param ground_truth_documents:\n            Lists of expected documents, one list per question. Binary relevance is used if documents have no scores.\n        :param retrieved_documents:\n            Lists of retrieved documents, one list per question.\n        :returns:\n            A dictionary with the following outputs:\n            - `score` - The average of calculated scores.\n            - `individual_scores` - A list of numbers from 0.0 to 1.0 that represents the NDCG for each question.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.evaluators.document_recall.DocumentRecallEvaluator::run", "project": "haystack", "func": "DocumentRecallEvaluator::run", "origin_file": "./Source_Copy/haystack/haystack/components/evaluators/document_recall.py", "test_list": ["test/components/evaluators/test_document_recall.py"], "prob_info": {"func_start_lineno": 98, "func_end_lineno": 124, "key_block_start_lineno": 115, "key_block_end_lineno": 124, "new_func_code": "def run(\n        self, ground_truth_documents: List[List[Document]], retrieved_documents: List[List[Document]]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Run the DocumentRecallEvaluator on the given inputs.\n\n        `ground_truth_documents` and `retrieved_documents` must have the same length.\n\n        :param ground_truth_documents:\n            A list of expected documents for each question.\n        :param retrieved_documents:\n            A list of retrieved documents for each question.\n        A dictionary with the following outputs:\n            - `score` - The average of calculated scores.\n            - `invididual_scores` - A list of numbers from 0.0 to 1.0 that represents the proportion of matching\n                documents retrieved. If the mode is `single_hit`, the individual scores are 0 or 1.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.evaluators.llm_evaluator.LLMEvaluator::prepare_template", "project": "haystack", "func": "LLMEvaluator::prepare_template", "origin_file": "./Source_Copy/haystack/haystack/components/evaluators/llm_evaluator.py", "test_list": ["test/components/evaluators/test_llm_evaluator.py"], "prob_info": {"func_start_lineno": 233, "func_end_lineno": 276, "key_block_start_lineno": 255, "key_block_end_lineno": 276, "new_func_code": "def prepare_template(self) -> str:\n        \"\"\"\n        Prepare the prompt template.\n\n        Combine instructions, inputs, outputs, and examples into one prompt template with the following format:\n        Instructions:\n        <instructions>\n\n        Generate the response in JSON format with the following keys:\n        <list of output keys>\n        Consider the instructions and the examples below to determine those values.\n\n        Examples:\n        <examples>\n\n        Inputs:\n        <inputs>\n        Outputs:\n\n        :returns:\n            The prompt template.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.evaluators.llm_evaluator.LLMEvaluator::to_dict", "project": "haystack", "func": "LLMEvaluator::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/evaluators/llm_evaluator.py", "test_list": ["test/components/evaluators/test_llm_evaluator.py"], "prob_info": {"func_start_lineno": 278, "func_end_lineno": 297, "key_block_start_lineno": 285, "key_block_end_lineno": 297, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n\n        :returns:\n            The serialized component as a dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.evaluators.sas_evaluator.SASEvaluator::to_dict", "project": "haystack", "func": "SASEvaluator::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/evaluators/sas_evaluator.py", "test_list": ["test/components/evaluators/test_sas_evaluator.py"], "prob_info": {"func_start_lineno": 85, "func_end_lineno": 98, "key_block_start_lineno": 92, "key_block_end_lineno": 98, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n\n        :returns:\n            The serialized component as a dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.evaluators.sas_evaluator.SASEvaluator::run", "project": "haystack", "func": "SASEvaluator::run", "origin_file": "./Source_Copy/haystack/haystack/components/evaluators/sas_evaluator.py", "test_list": ["test/components/evaluators/test_sas_evaluator.py"], "prob_info": {"func_start_lineno": 141, "func_end_lineno": 201, "key_block_start_lineno": 157, "key_block_end_lineno": 201, "new_func_code": "def run(self, ground_truth_answers: List[str], predicted_answers: List[str]) -> Dict[str, Any]:\n        \"\"\"\n        SASEvaluator component run method.\n\n        Run the SASEvaluator to compute the Semantic Answer Similarity (SAS) between a list of predicted answers\n        and a list of ground truth answers. Both must be list of strings of same length.\n\n        :param ground_truth_answers:\n            A list of expected answers for each question.\n        :param predicted_answers:\n            A list of generated answers for each question.\n        :returns:\n            A dictionary with the following outputs:\n                - `score`: Mean SAS score over all the predictions/ground-truth pairs.\n                - `individual_scores`: A list of similarity scores for each prediction/ground-truth pair.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.misc.expand_page_range", "project": "haystack", "func": "expand_page_range", "origin_file": "./Source_Copy/haystack/haystack/utils/misc.py", "test_list": ["test/components/extractors/test_llm_metadata_extractor.py"], "prob_info": {"func_start_lineno": 10, "func_end_lineno": 45, "key_block_start_lineno": 21, "key_block_end_lineno": 45, "new_func_code": "def expand_page_range(page_range: List[Union[str, int]]) -> List[int]:\n    \"\"\"\n    Takes a list of page numbers and ranges and expands them into a list of page numbers.\n\n    For example, given a page_range=['1-3', '5', '8', '10-12'] the function will return [1, 2, 3, 5, 8, 10, 11, 12]\n\n    :param page_range: List of page numbers and ranges\n    :returns:\n        An expanded list of page integers\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.extractors.llm_metadata_extractor.LLMMetadataExtractor::to_dict", "project": "haystack", "func": "LLMMetadataExtractor::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/extractors/llm_metadata_extractor.py", "test_list": ["test/components/extractors/test_llm_metadata_extractor.py"], "prob_info": {"func_start_lineno": 239, "func_end_lineno": 258, "key_block_start_lineno": 246, "key_block_end_lineno": 258, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.generators.chat.openai.OpenAIChatGenerator::to_dict", "project": "haystack", "func": "OpenAIChatGenerator::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/generators/chat/openai.py", "test_list": ["test/components/extractors/test_llm_metadata_extractor.py"], "prob_info": {"func_start_lineno": 170, "func_end_lineno": 190, "key_block_start_lineno": 177, "key_block_end_lineno": 190, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n\n        :returns:\n            The serialized component as a dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.hf.resolve_hf_pipeline_kwargs", "project": "haystack", "func": "resolve_hf_pipeline_kwargs", "origin_file": "./Source_Copy/haystack/haystack/utils/hf.py", "test_list": ["test/components/extractors/test_named_entity_extractor.py"], "prob_info": {"func_start_lineno": 169, "func_end_lineno": 210, "key_block_start_lineno": 191, "key_block_end_lineno": 210, "new_func_code": "def resolve_hf_pipeline_kwargs(  # pylint: disable=too-many-positional-arguments\n    huggingface_pipeline_kwargs: Dict[str, Any],\n    model: str,\n    task: Optional[str],\n    supported_tasks: List[str],\n    device: Optional[ComponentDevice],\n    token: Optional[Secret],\n) -> Dict[str, Any]:\n    \"\"\"\n    Resolve the HuggingFace pipeline keyword arguments based on explicit user inputs.\n\n    :param huggingface_pipeline_kwargs: Dictionary containing keyword arguments used to initialize a\n        Hugging Face pipeline.\n    :param model: The name or path of a Hugging Face model for on the HuggingFace Hub.\n    :param task: The task for the Hugging Face pipeline.\n    :param supported_tasks: The list of supported tasks to check the task of the model against. If the task of the model\n        is not present within this list then a ValueError is thrown.\n    :param device: The device on which the model is loaded. If `None`, the default device is automatically\n        selected. If a device/device map is specified in `huggingface_pipeline_kwargs`, it overrides this parameter.\n    :param token: The token to use as HTTP bearer authorization for remote files.\n        If the token is also specified in the `huggingface_pipeline_kwargs`, this parameter will be ignored.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.extractors.named_entity_extractor.NamedEntityExtractor::to_dict", "project": "haystack", "func": "NamedEntityExtractor::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/extractors/named_entity_extractor.py", "test_list": ["test/components/extractors/test_named_entity_extractor.py"], "prob_info": {"func_start_lineno": 212, "func_end_lineno": 232, "key_block_start_lineno": 219, "key_block_end_lineno": 232, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.generators.azure.AzureOpenAIGenerator::to_dict", "project": "haystack", "func": "AzureOpenAIGenerator::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/generators/azure.py", "test_list": ["test/components/generators/test_azure.py"], "prob_info": {"func_start_lineno": 162, "func_end_lineno": 188, "key_block_start_lineno": 169, "key_block_end_lineno": 188, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n\n        :returns:\n            The serialized component as a dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.generators.openai.OpenAIGenerator::to_dict", "project": "haystack", "func": "OpenAIGenerator::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/generators/openai.py", "test_list": ["test/components/generators/test_openai.py"], "prob_info": {"func_start_lineno": 133, "func_end_lineno": 150, "key_block_start_lineno": 140, "key_block_end_lineno": 150, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n\n        :returns:\n            The serialized component as a dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.generators.openai_dalle.DALLEImageGenerator::to_dict", "project": "haystack", "func": "DALLEImageGenerator::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/generators/openai_dalle.py", "test_list": ["test/components/generators/test_openai_dalle.py"], "prob_info": {"func_start_lineno": 129, "func_end_lineno": 145, "key_block_start_lineno": 136, "key_block_end_lineno": 145, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n\n        :returns:\n            The serialized component as a dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.generators.openai_dalle.DALLEImageGenerator::run", "project": "haystack", "func": "DALLEImageGenerator::run", "origin_file": "./Source_Copy/haystack/haystack/components/generators/openai_dalle.py", "test_list": ["test/components/generators/test_openai_dalle.py"], "prob_info": {"func_start_lineno": 93, "func_end_lineno": 127, "key_block_start_lineno": 114, "key_block_end_lineno": 127, "new_func_code": "def run(\n        self,\n        prompt: str,\n        size: Optional[Literal[\"256x256\", \"512x512\", \"1024x1024\", \"1792x1024\", \"1024x1792\"]] = None,\n        quality: Optional[Literal[\"standard\", \"hd\"]] = None,\n        response_format: Optional[Optional[Literal[\"url\", \"b64_json\"]]] = None,\n    ):\n        \"\"\"\n        Invokes the image generation inference based on the provided prompt and generation parameters.\n\n        :param prompt: The prompt to generate the image.\n        :param size: If provided, overrides the size provided during initialization.\n        :param quality: If provided, overrides the quality provided during initialization.\n        :param response_format: If provided, overrides the response format provided during initialization.\n\n        :returns:\n            A dictionary containing the generated list of images and the revised prompt.\n            Depending on the `response_format` parameter, the list of images can be URLs or base64 encoded JSON strings.\n            The revised prompt is the prompt that was used to generate the image, if there was any revision\n            to the prompt made by OpenAI.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tools.tool._check_duplicate_tool_names", "project": "haystack", "func": "_check_duplicate_tool_names", "origin_file": "./Source_Copy/haystack/haystack/tools/tool.py", "test_list": ["test/components/generators/chat/test_azure.py"], "prob_info": {"func_start_lineno": 91, "func_end_lineno": 103, "key_block_start_lineno": 98, "key_block_end_lineno": 103, "new_func_code": "def _check_duplicate_tool_names(tools: Optional[List[Tool]]) -> None:\n    \"\"\"\n    Checks for duplicate tool names and raises a ValueError if they are found.\n\n    :param tools: The list of tools to check.\n    :raises ValueError: If duplicate tool names are found.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.generators.chat.azure.AzureOpenAIChatGenerator::to_dict", "project": "haystack", "func": "AzureOpenAIChatGenerator::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/generators/chat/azure.py", "test_list": ["test/components/generators/chat/test_azure.py"], "prob_info": {"func_start_lineno": 177, "func_end_lineno": 204, "key_block_start_lineno": 184, "key_block_end_lineno": 204, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serialize this component to a dictionary.\n\n        :returns:\n            The serialized component as a dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.joiners.answer_joiner.AnswerJoiner::run", "project": "haystack", "func": "AnswerJoiner::run", "origin_file": "./Source_Copy/haystack/haystack/components/joiners/answer_joiner.py", "test_list": ["test/components/joiners/test_answer_joiner.py"], "prob_info": {"func_start_lineno": 117, "func_end_lineno": 143, "key_block_start_lineno": 131, "key_block_end_lineno": 143, "new_func_code": "def run(self, answers: Variadic[List[AnswerType]], top_k: Optional[int] = None):\n        \"\"\"\n        Joins multiple lists of Answers into a single list depending on the `join_mode` parameter.\n\n        :param answers:\n            Nested list of Answers to be merged.\n\n        :param top_k:\n            The maximum number of Answers to return. Overrides the instance's `top_k` if provided.\n\n        :returns:\n            A dictionary with the following keys:\n            - `answers`: Merged list of Answers\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.joiners.document_joiner.DocumentJoiner::to_dict", "project": "haystack", "func": "DocumentJoiner::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/joiners/document_joiner.py", "test_list": ["test/components/joiners/test_document_joiner.py"], "prob_info": {"func_start_lineno": 265, "func_end_lineno": 278, "key_block_start_lineno": 272, "key_block_end_lineno": 278, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.joiners.document_joiner.DocumentJoiner::run", "project": "haystack", "func": "DocumentJoiner::run", "origin_file": "./Source_Copy/haystack/haystack/components/joiners/document_joiner.py", "test_list": ["test/components/joiners/test_document_joiner.py"], "prob_info": {"func_start_lineno": 130, "func_end_lineno": 163, "key_block_start_lineno": 143, "key_block_end_lineno": 163, "new_func_code": "def run(self, documents: Variadic[List[Document]], top_k: Optional[int] = None):\n        \"\"\"\n        Joins multiple lists of Documents into a single list depending on the `join_mode` parameter.\n\n        :param documents:\n            List of list of documents to be merged.\n        :param top_k:\n            The maximum number of documents to return. Overrides the instance's `top_k` if provided.\n\n        :returns:\n            A dictionary with the following keys:\n            - `documents`: Merged list of Documents\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.type_utils._type_name", "project": "haystack", "func": "_type_name", "origin_file": "./Source_Copy/haystack/haystack/core/type_utils.py", "test_list": ["test/components/joiners/test_list_joiner.py"], "prob_info": {"func_start_lineno": 79, "func_end_lineno": 105, "key_block_start_lineno": 85, "key_block_end_lineno": 105, "new_func_code": "def _type_name(type_):\n    \"\"\"\n    Util methods to get a nice readable representation of a type.\n\n    Handles Optional and Literal in a special way to make it more readable.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.joiners.string_joiner.StringJoiner::run", "project": "haystack", "func": "StringJoiner::run", "origin_file": "./Source_Copy/haystack/haystack/components/joiners/string_joiner.py", "test_list": ["test/components/joiners/test_string_joiner.py"], "prob_info": {"func_start_lineno": 46, "func_end_lineno": 59, "key_block_start_lineno": 57, "key_block_end_lineno": 59, "new_func_code": "def run(self, strings: Variadic[str]):\n        \"\"\"\n        Joins strings into a list of strings\n\n        :param strings:\n            strings from different components\n\n        :returns:\n            A dictionary with the following keys:\n            - `strings`: Merged list of strings\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.csv_document_splitter.CSVDocumentSplitter::_recursive_split", "project": "haystack", "func": "CSVDocumentSplitter::_recursive_split", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/csv_document_splitter.py", "test_list": ["test/components/preprocessors/test_csv_document_splitter.py"], "prob_info": {"func_start_lineno": 209, "func_end_lineno": 244, "key_block_start_lineno": 222, "key_block_end_lineno": 244, "new_func_code": "def _recursive_split(\n        self, df: \"pd.DataFrame\", row_split_threshold: int, column_split_threshold: int\n    ) -> List[\"pd.DataFrame\"]:\n        \"\"\"\n        Recursively splits a DataFrame.\n\n        Recursively splits a DataFrame first by empty rows, then by empty columns, and repeats the process\n        until no more splits are possible. Returns a list of DataFrames, each representing a fully separated sub-table.\n\n        :param df: A Pandas DataFrame representing a table (or multiple tables) extracted from a CSV.\n        :param row_split_threshold: The minimum number of consecutive empty rows required to trigger a split.\n        :param column_split_threshold: The minimum number of consecutive empty columns to trigger a split.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.document_cleaner.DocumentCleaner::_find_and_remove_header_footer", "project": "haystack", "func": "DocumentCleaner::_find_and_remove_header_footer", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/document_cleaner.py", "test_list": ["test/components/preprocessors/test_document_cleaner.py"], "prob_info": {"func_start_lineno": 231, "func_end_lineno": 267, "key_block_start_lineno": 248, "key_block_end_lineno": 267, "new_func_code": "def _find_and_remove_header_footer(\n        self, text: str, n_chars: int, n_first_pages_to_ignore: int, n_last_pages_to_ignore: int\n    ) -> str:\n        \"\"\"\n        Heuristic to find footers and headers across different pages by searching for the longest common string.\n\n        Pages in the text need to be separated by form feed character \"\\f\".\n        For headers, we only search in the first n_chars characters (for footer: last n_chars).\n        Note: This heuristic uses exact matches and therefore works well for footers like \"Copyright 2019 by XXX\",\n         but won't detect \"Page 3 of 4\" or similar.\n\n        :param n_chars: The number of first/last characters where the header/footer shall be searched in.\n        :param n_first_pages_to_ignore: The number of first pages to ignore\n            (e.g. TOCs often don't contain footer/header).\n        :param n_last_pages_to_ignore: The number of last pages to ignore.\n        :returns: The text without the found headers and footers.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.document_cleaner.DocumentCleaner::_find_longest_common_ngram", "project": "haystack", "func": "DocumentCleaner::_find_longest_common_ngram", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/document_cleaner.py", "test_list": ["test/components/preprocessors/test_document_cleaner.py"], "prob_info": {"func_start_lineno": 306, "func_end_lineno": 325, "key_block_start_lineno": 318, "key_block_end_lineno": 325, "new_func_code": "def _find_longest_common_ngram(self, sequences: List[str], min_ngram: int = 3, max_ngram: int = 30) -> str:\n        \"\"\"\n        Find the longest common ngram across a list of text sequences (e.g. start of pages).\n\n        Considering all ngram lengths between the minimum and maximum length. Helpful for finding footers, headers etc.\n        Empty sequences are ignored.\n\n        :param sequences: The list of strings that shall be searched for common n_grams.\n        :param max_ngram: The maximum length of ngram to consider.\n        :param min_ngram: The minimum length of ngram to consider.\n        :returns: The longest ngram that all sequences have in common.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.document_cleaner.DocumentCleaner::_allngram", "project": "haystack", "func": "DocumentCleaner::_allngram", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/document_cleaner.py", "test_list": ["test/components/preprocessors/test_document_cleaner.py"], "prob_info": {"func_start_lineno": 290, "func_end_lineno": 304, "key_block_start_lineno": 301, "key_block_end_lineno": 304, "new_func_code": "def _allngram(self, seq: str, min_ngram: int, max_ngram: int) -> Set[str]:\n        \"\"\"\n        Generates all possible ngrams from a given sequence of text.\n\n        Considering all ngram lengths between the minimum and maximum length.\n\n        :param seq: The sequence to generate ngrams from.\n        :param min_ngram: The minimum length of ngram to consider.\n        :param max_ngram: The maximum length of ngram to consider.\n        :returns: A set of all ngrams from the given sequence.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.document_splitter.DocumentSplitter::run", "project": "haystack", "func": "DocumentSplitter::run", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/document_splitter.py", "test_list": ["test/components/preprocessors/test_document_splitter.py"], "prob_info": {"func_start_lineno": 166, "func_end_lineno": 202, "key_block_start_lineno": 183, "key_block_end_lineno": 202, "new_func_code": "def run(self, documents: List[Document]):\n        \"\"\"\n        Split documents into smaller parts.\n\n        Splits documents by the unit expressed in `split_by`, with a length of `split_length`\n        and an overlap of `split_overlap`.\n\n        :param documents: The documents to split.\n        :returns: A dictionary with the following key:\n            - `documents`: List of documents with the split texts. Each document includes:\n                - A metadata field `source_id` to track the original document.\n                - A metadata field `page_number` to track the original page number.\n                - All other metadata copied from the original document.\n\n        :raises TypeError: if the input is not a list of Documents.\n        :raises ValueError: if the content of a document is None.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.recursive_splitter.RecursiveDocumentSplitter::_chunk_length", "project": "haystack", "func": "RecursiveDocumentSplitter::_chunk_length", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/recursive_splitter.py", "test_list": ["test/components/preprocessors/test_recursive_splitter.py"], "prob_info": {"func_start_lineno": 215, "func_end_lineno": 227, "key_block_start_lineno": 222, "key_block_end_lineno": 227, "new_func_code": "def _chunk_length(self, text: str) -> int:\n        \"\"\"\n        Split the text by whitespace and count non-empty elements.\n\n        :param: The text to be split.\n        :return: The number of words in the text.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.recursive_splitter.RecursiveDocumentSplitter::_split_chunk", "project": "haystack", "func": "RecursiveDocumentSplitter::_split_chunk", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/recursive_splitter.py", "test_list": ["test/components/preprocessors/test_recursive_splitter.py"], "prob_info": {"func_start_lineno": 114, "func_end_lineno": 133, "key_block_start_lineno": 122, "key_block_end_lineno": 133, "new_func_code": "def _split_chunk(self, current_chunk: str) -> Tuple[str, str]:\n        \"\"\"\n        Splits a chunk based on the split_length and split_units attribute.\n\n        :param current_chunk: The current chunk to be split.\n        :returns:\n            A tuple containing the current chunk and the remaining words or characters.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.recursive_splitter.RecursiveDocumentSplitter::_chunk_text", "project": "haystack", "func": "RecursiveDocumentSplitter::_chunk_text", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/recursive_splitter.py", "test_list": ["test/components/preprocessors/test_recursive_splitter.py"], "prob_info": {"func_start_lineno": 229, "func_end_lineno": 311, "key_block_start_lineno": 242, "key_block_end_lineno": 311, "new_func_code": "def _chunk_text(self, text: str) -> List[str]:\n        \"\"\"\n        Recursive chunking algorithm that divides text into smaller chunks based on a list of separator characters.\n\n        It starts with a list of separator characters (e.g., [\"\\n\\n\", \"sentence\", \"\\n\", \" \"]) and attempts to divide\n        the text using the first separator. If the resulting chunks are still larger than the specified chunk size,\n        it moves to the next separator in the list. This process continues recursively, progressively applying each\n        specific separator until the chunks meet the desired size criteria.\n\n        :param text: The text to be split into chunks.\n        :returns:\n            A list of text chunks.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.sentence_tokenizer.SentenceSplitter::split_sentences", "project": "haystack", "func": "SentenceSplitter::split_sentences", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/sentence_tokenizer.py", "test_list": ["test/components/preprocessors/test_recursive_splitter.py"], "prob_info": {"func_start_lineno": 147, "func_end_lineno": 159, "key_block_start_lineno": 154, "key_block_end_lineno": 159, "new_func_code": "def split_sentences(self, text: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Splits a text into sentences including references to original char positions for each split.\n\n        :param text: The text to split.\n        :returns: list of sentences with positions.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.text_cleaner.TextCleaner::run", "project": "haystack", "func": "TextCleaner::run", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/text_cleaner.py", "test_list": ["test/components/preprocessors/test_text_cleaner.py"], "prob_info": {"func_start_lineno": 65, "func_end_lineno": 83, "key_block_start_lineno": 73, "key_block_end_lineno": 83, "new_func_code": "def run(self, texts: List[str]) -> Dict[str, Any]:\n        \"\"\"\n        Cleans up the given list of strings.\n\n        :param texts: List of strings to clean.\n        :returns: A dictionary with the following key:\n            - `texts`:  the cleaned list of strings.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.rankers.lost_in_the_middle.LostInTheMiddleRanker::run", "project": "haystack", "func": "LostInTheMiddleRanker::run", "origin_file": "./Source_Copy/haystack/haystack/components/rankers/lost_in_the_middle.py", "test_list": ["test/components/rankers/test_lost_in_the_middle.py"], "prob_info": {"func_start_lineno": 63, "func_end_lineno": 133, "key_block_start_lineno": 79, "key_block_end_lineno": 133, "new_func_code": "def run(\n        self, documents: List[Document], top_k: Optional[int] = None, word_count_threshold: Optional[int] = None\n    ) -> Dict[str, List[Document]]:\n        \"\"\"\n        Reranks documents based on the \"lost in the middle\" order.\n\n        :param documents: List of Documents to reorder.\n        :param top_k: The maximum number of documents to return.\n        :param word_count_threshold: The maximum total number of words across all documents selected by the ranker.\n        :returns:\n            A dictionary with the following keys:\n            - `documents`: Reranked list of Documents\n\n        :raises ValueError:\n            If any of the documents is not textual.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.logging.patch_make_records_to_use_kwarg_string_interpolation", "project": "haystack", "func": "patch_make_records_to_use_kwarg_string_interpolation", "origin_file": "./Source_Copy/haystack/haystack/logging.py", "test_list": ["test/components/rankers/test_sentence_transformers_diversity.py"], "prob_info": {"func_start_lineno": 187, "func_end_lineno": 199, "key_block_start_lineno": 189, "key_block_end_lineno": 199, "new_func_code": "def patch_make_records_to_use_kwarg_string_interpolation(original_make_records: typing.Callable) -> typing.Callable:\n    \"\"\"A decorator to ensure string interpolation is used.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.rankers.sentence_transformers_diversity.SentenceTransformersDiversityRanker::to_dict", "project": "haystack", "func": "SentenceTransformersDiversityRanker::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/rankers/sentence_transformers_diversity.py", "test_list": ["test/components/rankers/test_sentence_transformers_diversity.py"], "prob_info": {"func_start_lineno": 212, "func_end_lineno": 241, "key_block_start_lineno": 219, "key_block_end_lineno": 241, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.rankers.sentence_transformers_diversity.SentenceTransformersDiversityRanker::run", "project": "haystack", "func": "SentenceTransformersDiversityRanker::run", "origin_file": "./Source_Copy/haystack/haystack/components/rankers/sentence_transformers_diversity.py", "test_list": ["test/components/rankers/test_sentence_transformers_diversity.py"], "prob_info": {"func_start_lineno": 388, "func_end_lineno": 435, "key_block_start_lineno": 410, "key_block_end_lineno": 435, "new_func_code": "def run(\n        self,\n        query: str,\n        documents: List[Document],\n        top_k: Optional[int] = None,\n        lambda_threshold: Optional[float] = None,\n    ) -> Dict[str, List[Document]]:\n        \"\"\"\n        Rank the documents based on their diversity.\n\n        :param query: The search query.\n        :param documents: List of Document objects to be ranker.\n        :param top_k: Optional. An integer to override the top_k set during initialization.\n        :param lambda_threshold: Override the trade-off parameter between relevance and diversity. Only used when\n                                strategy is \"maximum_margin_relevance\".\n\n        :returns: A dictionary with the following key:\n            - `documents`: List of Document objects that have been selected based on the diversity ranking.\n\n        :raises ValueError: If the top_k value is less than or equal to 0.\n        :raises RuntimeError: If the component has not been warmed up.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.device.ComponentDevice::to_torch", "project": "haystack", "func": "ComponentDevice::to_torch", "origin_file": "./Source_Copy/haystack/haystack/utils/device.py", "test_list": ["test/components/rankers/test_transformers_similarity.py"], "prob_info": {"func_start_lineno": 303, "func_end_lineno": 319, "key_block_start_lineno": 312, "key_block_end_lineno": 319, "new_func_code": "def to_torch(self) -> \"torch.device\":\n        \"\"\"\n        Convert the component device representation to PyTorch format.\n\n        Device maps are not supported.\n\n        :returns:\n            The PyTorch device representation.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.readers.extractive.ExtractiveReader::to_dict", "project": "haystack", "func": "ExtractiveReader::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/readers/extractive.py", "test_list": ["test/components/readers/test_extractive.py"], "prob_info": {"func_start_lineno": 136, "func_end_lineno": 160, "key_block_start_lineno": 143, "key_block_end_lineno": 160, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.testing.factory.document_store_class", "project": "haystack", "func": "document_store_class", "origin_file": "./Source_Copy/haystack/haystack/testing/factory.py", "test_list": ["test/components/retrievers/test_filter_retriever.py"], "prob_info": {"func_start_lineno": 13, "func_end_lineno": 124, "key_block_start_lineno": 86, "key_block_end_lineno": 124, "new_func_code": "def document_store_class(\n    name: str,\n    documents: Optional[List[Document]] = None,\n    documents_count: Optional[int] = None,\n    bases: Optional[Tuple[type, ...]] = None,\n    extra_fields: Optional[Dict[str, Any]] = None,\n) -> Type[DocumentStore]:\n    \"\"\"\n    Utility function to create a DocumentStore class with the given name and list of documents.\n\n    If `documents` is set but `documents_count` is not, `documents_count` will be the length\n    of `documents`.\n    If both are set explicitly they don't influence each other.\n\n    `write_documents()` and `delete_documents()` are no-op.\n    You can override them using `extra_fields`.\n\n    ### Usage\n\n    Create a DocumentStore class that returns no documents:\n    ```python\n    MyFakeStore = document_store_class(\"MyFakeComponent\")\n    document_store = MyFakeStore()\n    assert document_store.documents_count() == 0\n    assert document_store.filter_documents() == []\n    ```\n\n    Create a DocumentStore class that returns a single document:\n    ```python\n    doc = Document(id=\"fake_id\", content=\"Fake content\")\n    MyFakeStore = document_store_class(\"MyFakeComponent\", documents=[doc])\n    document_store = MyFakeStore()\n    assert document_store.documents_count() == 1\n    assert document_store.filter_documents() == [doc]\n    ```\n\n    Create a DocumentStore class that returns no document but returns a custom count:\n    ```python\n    MyFakeStore = document_store_class(\"MyFakeComponent\", documents_count=100)\n    document_store = MyFakeStore()\n    assert document_store.documents_count() == 100\n    assert document_store.filter_documents() == []\n    ```\n\n    Create a DocumentStore class that returns a document and a custom count:\n    ```python\n    doc = Document(id=\"fake_id\", content=\"Fake content\")\n    MyFakeStore = document_store_class(\"MyFakeComponent\", documents=[doc], documents_count=100)\n    document_store = MyFakeStore()\n    assert document_store.documents_count() == 100\n    assert document_store.filter_documents() == [doc]\n    ```\n\n    Create a DocumentStore class with a custom base class:\n    ```python\n    MyFakeStore = document_store_class(\n        \"MyFakeStore\",\n        bases=(MyBaseClass,)\n    )\n    document_store = MyFakeStore()\n    assert isinstance(store, MyBaseClass)\n    ```\n\n    Create a DocumentStore class with an extra field `my_field`:\n    ```python\n    MyFakeStore = document_store_class(\n        \"MyFakeStore\",\n        extra_fields={\"my_field\": 10}\n    )\n    document_store = MyFakeStore()\n    assert document_store.my_field == 10\n    ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.document_stores.in_memory.document_store.InMemoryDocumentStore::write_documents", "project": "haystack", "func": "InMemoryDocumentStore::write_documents", "origin_file": "./Source_Copy/haystack/haystack/document_stores/in_memory/document_store.py", "test_list": ["test/components/retrievers/test_filter_retriever.py"], "prob_info": {"func_start_lineno": 432, "func_end_lineno": 473, "key_block_start_lineno": 438, "key_block_end_lineno": 473, "new_func_code": "def write_documents(self, documents: List[Document], policy: DuplicatePolicy = DuplicatePolicy.NONE) -> int:\n        \"\"\"\n        Refer to the DocumentStore.write_documents() protocol documentation.\n\n        If `policy` is set to `DuplicatePolicy.NONE` defaults to `DuplicatePolicy.FAIL`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.document_stores.in_memory.document_store.InMemoryDocumentStore::filter_documents", "project": "haystack", "func": "InMemoryDocumentStore::filter_documents", "origin_file": "./Source_Copy/haystack/haystack/document_stores/in_memory/document_store.py", "test_list": ["test/components/retrievers/test_filter_retriever.py"], "prob_info": {"func_start_lineno": 414, "func_end_lineno": 430, "key_block_start_lineno": 424, "key_block_end_lineno": 430, "new_func_code": "def filter_documents(self, filters: Optional[Dict[str, Any]] = None) -> List[Document]:\n        \"\"\"\n        Returns the documents that match the filters provided.\n\n        For a detailed specification of the filters, refer to the DocumentStore.filter_documents() protocol\n        documentation.\n\n        :param filters: The filters to apply to the document list.\n        :returns: A list of Documents that match the given filters.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.document_stores.in_memory.document_store.InMemoryDocumentStore::_tokenize_bm25", "project": "haystack", "func": "InMemoryDocumentStore::_tokenize_bm25", "origin_file": "./Source_Copy/haystack/haystack/document_stores/in_memory/document_store.py", "test_list": ["test/components/retrievers/test_sentence_window_retriever.py"], "prob_info": {"func_start_lineno": 172, "func_end_lineno": 187, "key_block_start_lineno": 186, "key_block_end_lineno": 187, "new_func_code": "def _tokenize_bm25(self, text: str) -> List[str]:\n        \"\"\"\n        Tokenize text using the BM25 tokenization regex.\n\n        Here we explicitly create a tokenization method to encapsulate\n        all pre-processing logic used to create BM25 tokens, such as\n        lowercasing. This helps track the exact tokenization process\n        used for BM25 scoring at any given time.\n\n        :param text:\n            The text to tokenize.\n        :returns:\n            A list of tokens.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.conditional_router.ConditionalRouter::_validate_template", "project": "haystack", "func": "ConditionalRouter::_validate_template", "origin_file": "./Source_Copy/haystack/haystack/components/routers/conditional_router.py", "test_list": ["test/components/routers/test_conditional_router.py"], "prob_info": {"func_start_lineno": 371, "func_end_lineno": 383, "key_block_start_lineno": 379, "key_block_end_lineno": 383, "new_func_code": "def _validate_template(self, env: Environment, template_text: str):\n        \"\"\"\n        Validates a template string by parsing it with Jinja.\n\n        :param env: A Jinja environment.\n        :param template_text: A Jinja template string.\n        :returns: `True` if the template is valid, `False` otherwise.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.conditional_router.ConditionalRouter::_extract_variables", "project": "haystack", "func": "ConditionalRouter::_extract_variables", "origin_file": "./Source_Copy/haystack/haystack/components/routers/conditional_router.py", "test_list": ["test/components/routers/test_conditional_router.py"], "prob_info": {"func_start_lineno": 357, "func_end_lineno": 369, "key_block_start_lineno": 365, "key_block_end_lineno": 369, "new_func_code": "def _extract_variables(self, env: Environment, templates: List[str]) -> Set[str]:\n        \"\"\"\n        Extracts all variables from a list of Jinja template strings.\n\n        :param env: A Jinja environment.\n        :param templates: A list of Jinja template strings.\n        :returns: A set of variable names.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.conditional_router.ConditionalRouter::run", "project": "haystack", "func": "ConditionalRouter::run", "origin_file": "./Source_Copy/haystack/haystack/components/routers/conditional_router.py", "test_list": ["test/components/routers/test_conditional_router.py"], "prob_info": {"func_start_lineno": 282, "func_end_lineno": 333, "key_block_start_lineno": 303, "key_block_end_lineno": 333, "new_func_code": "def run(self, **kwargs):\n        \"\"\"\n        Executes the routing logic.\n\n        Executes the routing logic by evaluating the specified boolean condition expressions for each route in the\n        order they are listed. The method directs the flow of data to the output specified in the first route whose\n        `condition` is True.\n\n        :param kwargs: All variables used in the `condition` expressed in the routes. When the component is used in a\n            pipeline, these variables are passed from the previous component's output.\n\n        :returns: A dictionary where the key is the `output_name` of the selected route and the value is the `output`\n            of the selected route.\n\n        :raises NoRouteSelectedException:\n            If no `condition' in the routes is `True`.\n        :raises RouteConditionException:\n            If there is an error parsing or evaluating the `condition` expression in the routes.\n        :raises ValueError:\n            If type validation is enabled and route type doesn't match actual value type.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.conditional_router.ConditionalRouter::to_dict", "project": "haystack", "func": "ConditionalRouter::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/routers/conditional_router.py", "test_list": ["test/components/routers/test_conditional_router.py"], "prob_info": {"func_start_lineno": 237, "func_end_lineno": 256, "key_block_start_lineno": 244, "key_block_end_lineno": 256, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.metadata_router.MetadataRouter::run", "project": "haystack", "func": "MetadataRouter::run", "origin_file": "./Source_Copy/haystack/haystack/components/routers/metadata_router.py", "test_list": ["test/components/routers/test_metadata_router.py"], "prob_info": {"func_start_lineno": 86, "func_end_lineno": 111, "key_block_start_lineno": 97, "key_block_end_lineno": 111, "new_func_code": "def run(self, documents: List[Document]):\n        \"\"\"\n        Routes the documents.\n\n        If a document does not match any of the rules, it's routed to a connection named \"unmatched\".\n\n        :param documents: A list of documents to route.\n\n        :returns: A dictionary where the keys are the names of the output connections (including `\"unmatched\"`)\n            and the values are lists of routed documents.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.text_language_router.TextLanguageRouter::run", "project": "haystack", "func": "TextLanguageRouter::run", "origin_file": "./Source_Copy/haystack/haystack/components/routers/text_language_router.py", "test_list": ["test/components/routers/test_text_language_router.py"], "prob_info": {"func_start_lineno": 64, "func_end_lineno": 92, "key_block_start_lineno": 77, "key_block_end_lineno": 92, "new_func_code": "def run(self, text: str) -> Dict[str, str]:\n        \"\"\"\n        Routes the text strings to different output connections based on their language.\n\n        If the document's text doesn't match any of the specified languages, the metadata value is set to \"unmatched\".\n\n        :param text: A text string to route.\n\n        :returns: A dictionary in which the key is the language (or `\"unmatched\"`),\n            and the value is the text.\n\n        :raises TypeError: If the input is not a string.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.transformers_text_router.TransformersTextRouter::to_dict", "project": "haystack", "func": "TransformersTextRouter::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/routers/transformers_text_router.py", "test_list": ["test/components/routers/test_transformers_text_router.py"], "prob_info": {"func_start_lineno": 146, "func_end_lineno": 165, "key_block_start_lineno": 153, "key_block_end_lineno": 165, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.transformers_text_router.TransformersTextRouter::run", "project": "haystack", "func": "TransformersTextRouter::run", "origin_file": "./Source_Copy/haystack/haystack/components/routers/transformers_text_router.py", "test_list": ["test/components/routers/test_transformers_text_router.py"], "prob_info": {"func_start_lineno": 182, "func_end_lineno": 205, "key_block_start_lineno": 195, "key_block_end_lineno": 205, "new_func_code": "def run(self, text: str) -> Dict[str, str]:\n        \"\"\"\n        Routes the text strings to different connections based on a category label.\n\n        :param text: A string of text to route.\n        :returns:\n            A dictionary with the label as key and the text as value.\n\n        :raises TypeError:\n            If the input is not a str.\n        :raises RuntimeError:\n            If the pipeline has not been loaded because warm_up() was not called before.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.zero_shot_text_router.TransformersZeroShotTextRouter::to_dict", "project": "haystack", "func": "TransformersZeroShotTextRouter::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/routers/zero_shot_text_router.py", "test_list": ["test/components/routers/test_zero_shot_text_router.py"], "prob_info": {"func_start_lineno": 159, "func_end_lineno": 177, "key_block_start_lineno": 166, "key_block_end_lineno": 177, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.samplers.top_p.TopPSampler::_get_documents_and_scores", "project": "haystack", "func": "TopPSampler::_get_documents_and_scores", "origin_file": "./Source_Copy/haystack/haystack/components/samplers/top_p.py", "test_list": ["test/components/samplers/test_top_p.py"], "prob_info": {"func_start_lineno": 144, "func_end_lineno": 177, "key_block_start_lineno": 151, "key_block_end_lineno": 177, "new_func_code": "def _get_documents_and_scores(self, documents: List[Document]) -> Tuple[List[Document], List[float]]:\n        \"\"\"\n        Checks if documents have scores in their metadata or score field and returns the documents with scores.\n\n        :param documents: List of Documents.\n        :return: List of scores.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.logging.correlate_logs_with_traces", "project": "haystack", "func": "correlate_logs_with_traces", "origin_file": "./Source_Copy/haystack/haystack/logging.py", "test_list": ["test/components/samplers/test_top_p.py"], "prob_info": {"func_start_lineno": 270, "func_end_lineno": 285, "key_block_start_lineno": 276, "key_block_end_lineno": 285, "new_func_code": "def correlate_logs_with_traces(_: \"WrappedLogger\", __: str, event_dict: \"EventDict\") -> \"EventDict\":\n    \"\"\"\n    Add correlation data for logs.\n\n    This is useful if you want to correlate logs with traces.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.tools.tool_invoker.ToolInvoker::run", "project": "haystack", "func": "ToolInvoker::run", "origin_file": "./Source_Copy/haystack/haystack/components/tools/tool_invoker.py", "test_list": ["test/components/tools/test_tool_invoker.py"], "prob_info": {"func_start_lineno": 166, "func_end_lineno": 214, "key_block_start_lineno": 183, "key_block_end_lineno": 214, "new_func_code": "def run(self, messages: List[ChatMessage]) -> Dict[str, Any]:\n        \"\"\"\n        Processes ChatMessage objects containing tool calls and invokes the corresponding tools, if available.\n\n        :param messages:\n            A list of ChatMessage objects.\n        :returns:\n            A dictionary with the key `tool_messages` containing a list of ChatMessage objects with tool role.\n            Each ChatMessage objects wraps the result of a tool invocation.\n\n        :raises ToolNotFoundException:\n            If the tool is not found in the list of available tools and `raise_on_failure` is True.\n        :raises ToolInvocationError:\n            If the tool invocation fails and `raise_on_failure` is True.\n        :raises StringConversionError:\n            If the conversion of the tool result to a string fails and `raise_on_failure` is True.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.tools.tool_invoker.ToolInvoker::_prepare_tool_result_message", "project": "haystack", "func": "ToolInvoker::_prepare_tool_result_message", "origin_file": "./Source_Copy/haystack/haystack/components/tools/tool_invoker.py", "test_list": ["test/components/tools/test_tool_invoker.py"], "prob_info": {"func_start_lineno": 130, "func_end_lineno": 163, "key_block_start_lineno": 143, "key_block_end_lineno": 163, "new_func_code": "def _prepare_tool_result_message(self, result: Any, tool_call: ToolCall) -> ChatMessage:\n        \"\"\"\n        Prepares a ChatMessage with the result of a tool invocation.\n\n        :param result:\n            The tool result.\n        :returns:\n            A ChatMessage object containing the tool result as a string.\n\n        :raises\n            StringConversionError: If the conversion of the tool result to a string fails\n            and `raise_on_failure` is True.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.tools.tool_invoker.ToolInvoker::to_dict", "project": "haystack", "func": "ToolInvoker::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/tools/tool_invoker.py", "test_list": ["test/components/tools/test_tool_invoker.py"], "prob_info": {"func_start_lineno": 216, "func_end_lineno": 229, "key_block_start_lineno": 223, "key_block_end_lineno": 229, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.validators.json_schema.JsonSchemaValidator::run", "project": "haystack", "func": "JsonSchemaValidator::run", "origin_file": "./Source_Copy/haystack/haystack/components/validators/json_schema.py", "test_list": ["test/components/validators/test_json_schema.py"], "prob_info": {"func_start_lineno": 115, "func_end_lineno": 186, "key_block_start_lineno": 140, "key_block_end_lineno": 186, "new_func_code": "def run(\n        self,\n        messages: List[ChatMessage],\n        json_schema: Optional[Dict[str, Any]] = None,\n        error_template: Optional[str] = None,\n    ) -> Dict[str, List[ChatMessage]]:\n        \"\"\"\n        Validates the last of the provided messages against the specified json schema.\n\n        If it does, the message is passed along the \"validated\" output. If it does not, the message is passed along\n        the \"validation_error\" output.\n\n        :param messages: A list of ChatMessage instances to be validated. The last message in this list is the one\n            that is validated.\n        :param json_schema: A dictionary representing the [JSON schema](https://json-schema.org/)\n            against which the messages' content is validated. If not provided, the schema from the component init\n            is used.\n        :param error_template: A custom template string for formatting the error message in case of validation. If not\n            provided, the `error_template` from the component init is used.\n        :return:  A dictionary with the following keys:\n            - \"validated\": A list of messages if the last message is valid.\n            - \"validation_error\": A list of messages if the last message is invalid.\n        :raises ValueError: If no JSON schema is provided or if the message content is not a dictionary or a list of\n            dictionaries.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.validators.json_schema.is_valid_json", "project": "haystack", "func": "is_valid_json", "origin_file": "./Source_Copy/haystack/haystack/components/validators/json_schema.py", "test_list": ["test/components/validators/test_json_schema.py"], "prob_info": {"func_start_lineno": 14, "func_end_lineno": 25, "key_block_start_lineno": 21, "key_block_end_lineno": 25, "new_func_code": "def is_valid_json(s: str) -> bool:\n    \"\"\"\n    Check if the provided string is a valid JSON.\n\n    :param s: The string to be checked.\n    :returns: `True` if the string is a valid JSON; otherwise, `False`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.websearch.searchapi.SearchApiWebSearch::to_dict", "project": "haystack", "func": "SearchApiWebSearch::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/websearch/searchapi.py", "test_list": ["test/components/websearch/test_searchapi.py"], "prob_info": {"func_start_lineno": 70, "func_end_lineno": 83, "key_block_start_lineno": 77, "key_block_end_lineno": 83, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n              Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.writers.document_writer.DocumentWriter::run", "project": "haystack", "func": "DocumentWriter::run", "origin_file": "./Source_Copy/haystack/haystack/components/writers/document_writer.py", "test_list": ["test/components/writers/test_document_writer.py"], "prob_info": {"func_start_lineno": 85, "func_end_lineno": 103, "key_block_start_lineno": 99, "key_block_end_lineno": 103, "new_func_code": "def run(self, documents: List[Document], policy: Optional[DuplicatePolicy] = None):\n        \"\"\"\n        Run the DocumentWriter on the given input data.\n\n        :param documents:\n            A list of documents to write to the document store.\n        :param policy:\n            The policy to use when encountering duplicate documents.\n        :returns:\n            Number of documents written to the document store.\n\n        :raises ValueError:\n            If the specified document store is not found.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.testing.factory.component_class", "project": "haystack", "func": "component_class", "origin_file": "./Source_Copy/haystack/haystack/testing/factory.py", "test_list": ["test/core/test_serialization.py"], "prob_info": {"func_start_lineno": 127, "func_end_lineno": 233, "key_block_start_lineno": 200, "key_block_end_lineno": 233, "new_func_code": "def component_class(  # pylint: disable=too-many-positional-arguments\n    name: str,\n    input_types: Optional[Dict[str, Any]] = None,\n    output_types: Optional[Dict[str, Any]] = None,\n    output: Optional[Dict[str, Any]] = None,\n    bases: Optional[Tuple[type, ...]] = None,\n    extra_fields: Optional[Dict[str, Any]] = None,\n) -> Type[Component]:\n    \"\"\"\n    Utility class to create a Component class with the given name and input and output types.\n\n    If `output` is set but `output_types` is not, `output_types` will be set to the types of the values in `output`.\n    Though if `output_types` is set but `output` is not the component's `run` method will return a dictionary\n    of the same keys as `output_types` all with a value of None.\n\n    ### Usage\n\n    Create a component class with default input and output types:\n    ```python\n    MyFakeComponent = component_class_factory(\"MyFakeComponent\")\n    component = MyFakeComponent()\n    output = component.run(value=1)\n    assert output == {\"value\": None}\n    ```\n\n    Create a component class with an \"value\" input of type `int` and with a \"value\" output of `10`:\n    ```python\n    MyFakeComponent = component_class_factory(\n        \"MyFakeComponent\",\n        input_types={\"value\": int},\n        output={\"value\": 10}\n    )\n    component = MyFakeComponent()\n    output = component.run(value=1)\n    assert output == {\"value\": 10}\n    ```\n\n    Create a component class with a custom base class:\n    ```python\n    MyFakeComponent = component_class_factory(\n        \"MyFakeComponent\",\n        bases=(MyBaseClass,)\n    )\n    component = MyFakeComponent()\n    assert isinstance(component, MyBaseClass)\n    ```\n\n    Create a component class with an extra field `my_field`:\n    ```python\n    MyFakeComponent = component_class_factory(\n        \"MyFakeComponent\",\n        extra_fields={\"my_field\": 10}\n    )\n    component = MyFakeComponent()\n    assert component.my_field == 10\n    ```\n\n    Args:\n    name: Name of the component class\n    input_types: Dictionary of string and type that defines the inputs of the component,\n        if set to None created component will expect a single input \"value\" of Any type.\n        Defaults to None.\n    output_types: Dictionary of string and type that defines the outputs of the component,\n        if set to None created component will return a single output \"value\" of NoneType and None value.\n        Defaults to None.\n    output: Actual output dictionary returned by the created component run,\n        is set to None it will return a dictionary of string and None values.\n        Keys will be the same as the keys of output_types. Defaults to None.\n    bases: Base classes for this component, if set to None only base is object. Defaults to None.\n    extra_fields: Extra fields for the Component, defaults to None.\n\n    :return: A class definition that can be used as a component.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.component.component._hook_component_init", "project": "haystack", "func": "_hook_component_init", "origin_file": "./Source_Copy/haystack/haystack/core/component/component.py", "test_list": ["test/core/component/test_component.py"], "prob_info": {"func_start_lineno": 111, "func_end_lineno": 125, "key_block_start_lineno": 121, "key_block_end_lineno": 125, "new_func_code": "def _hook_component_init(callback: Callable):\n    \"\"\"\n    Context manager to set a callback that will be invoked before a component's constructor is called.\n\n    The callback receives the component class and the init parameters (as keyword arguments) and can modify the init\n    parameters in place.\n\n    :param callback:\n        Callback function to invoke.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.component_checks.has_socket_received_all_inputs", "project": "haystack", "func": "has_socket_received_all_inputs", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/component_checks.py", "test_list": ["test/core/pipeline/test_component_checks.py"], "prob_info": {"func_start_lineno": 175, "func_end_lineno": 199, "key_block_start_lineno": 182, "key_block_end_lineno": 199, "new_func_code": "def has_socket_received_all_inputs(socket: InputSocket, socket_inputs: List[Dict]) -> bool:\n    \"\"\"\n    Checks if a socket has received all expected inputs.\n\n    :param socket: The InputSocket of a component.\n    :param socket_inputs: Inputs for the socket.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.component_checks.are_all_lazy_variadic_sockets_resolved", "project": "haystack", "func": "are_all_lazy_variadic_sockets_resolved", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/component_checks.py", "test_list": ["test/core/pipeline/test_component_checks.py"], "prob_info": {"func_start_lineno": 215, "func_end_lineno": 237, "key_block_start_lineno": 222, "key_block_end_lineno": 237, "new_func_code": "def are_all_lazy_variadic_sockets_resolved(component: Dict, inputs: Dict) -> bool:\n    \"\"\"\n    Checks if the final state for all lazy variadic sockets of a component is resolved.\n\n    :param component: Component metadata and the component instance.\n    :param inputs: Inputs for the component.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.utils.FIFOPriorityQueue::peek", "project": "haystack", "func": "FIFOPriorityQueue::peek", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/utils.py", "test_list": ["test/core/pipeline/test_utils.py"], "prob_info": {"func_start_lineno": 75, "func_end_lineno": 89, "key_block_start_lineno": 86, "key_block_end_lineno": 89, "new_func_code": "def peek(self) -> Tuple[int, Any]:\n        \"\"\"\n        Return but don't remove the highest priority item from the queue.\n\n        For items with equal priority, returns the one that was inserted first.\n\n        :returns:\n            A tuple containing (priority, item) with the lowest priority number.\n        :raises IndexError:\n            If the queue is empty.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.utils.FIFOPriorityQueue::pop", "project": "haystack", "func": "FIFOPriorityQueue::pop", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/utils.py", "test_list": ["test/core/pipeline/test_utils.py"], "prob_info": {"func_start_lineno": 59, "func_end_lineno": 73, "key_block_start_lineno": 70, "key_block_end_lineno": 73, "new_func_code": "def pop(self) -> Tuple[int, Any]:\n        \"\"\"\n        Remove and return the highest priority item from the queue.\n\n        For items with equal priority, returns the one that was inserted first.\n\n        :returns:\n            A tuple containing (priority, item) with the lowest priority number.\n        :raises IndexError:\n            If the queue is empty.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.evaluation.eval_run_result.EvaluationRunResult::aggregated_report", "project": "haystack", "func": "EvaluationRunResult::aggregated_report", "origin_file": "./Source_Copy/haystack/haystack/evaluation/eval_run_result.py", "test_list": ["test/evaluation/test_eval_run_result.py"], "prob_info": {"func_start_lineno": 121, "func_end_lineno": 136, "key_block_start_lineno": 134, "key_block_end_lineno": 136, "new_func_code": "def aggregated_report(\n        self, output_format: Literal[\"json\", \"csv\", \"df\"] = \"json\", csv_file: Optional[str] = None\n    ) -> Union[Dict[str, List[Any]], \"DataFrame\", str]:\n        \"\"\"\n        Generates a report with aggregated scores for each metric.\n\n        :param output_format: The output format for the report, \"json\", \"csv\", or \"df\", default to \"json\".\n        :param csv_file: Filepath to save CSV output if `output_format` is \"csv\", must be provided.\n\n        :returns:\n            JSON or DataFrame with aggregated scores, in case the output is set to a CSV file, a message confirming the\n            successful write or an error message.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.evaluation.eval_run_result.EvaluationRunResult::detailed_report", "project": "haystack", "func": "EvaluationRunResult::detailed_report", "origin_file": "./Source_Copy/haystack/haystack/evaluation/eval_run_result.py", "test_list": ["test/evaluation/test_eval_run_result.py"], "prob_info": {"func_start_lineno": 138, "func_end_lineno": 162, "key_block_start_lineno": 151, "key_block_end_lineno": 162, "new_func_code": "def detailed_report(\n        self, output_format: Literal[\"json\", \"csv\", \"df\"] = \"json\", csv_file: Optional[str] = None\n    ) -> Union[Dict[str, List[Any]], \"DataFrame\", str]:\n        \"\"\"\n        Generates a report with detailed scores for each metric.\n\n        :param output_format: The output format for the report, \"json\", \"csv\", or \"df\", default to \"json\".\n        :param csv_file: Filepath to save CSV output if `output_format` is \"csv\", must be provided.\n\n        :returns:\n            JSON or DataFrame with the detailed scores, in case the output is set to a CSV file, a message confirming\n            the successful write or an error message.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.websearch.serper_dev.SerperDevWebSearch::to_dict", "project": "haystack", "func": "SerperDevWebSearch::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/websearch/serper_dev.py", "test_list": ["test/tools/test_component_tool.py"], "prob_info": {"func_start_lineno": 67, "func_end_lineno": 80, "key_block_start_lineno": 74, "key_block_end_lineno": 80, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n                Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tools.from_function._remove_title_from_schema", "project": "haystack", "func": "_remove_title_from_schema", "origin_file": "./Source_Copy/haystack/haystack/tools/from_function.py", "test_list": ["test/tools/test_from_function.py"], "prob_info": {"func_start_lineno": 154, "func_end_lineno": 166, "key_block_start_lineno": 161, "key_block_end_lineno": 166, "new_func_code": "def _remove_title_from_schema(schema: Dict[str, Any]):\n    \"\"\"\n    Remove the 'title' keyword from JSON schema and contained property schemas.\n\n    :param schema:\n        The JSON schema to remove the 'title' keyword from.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tools.from_function.tool", "project": "haystack", "func": "tool", "origin_file": "./Source_Copy/haystack/haystack/tools/from_function.py", "test_list": ["test/tools/test_from_function.py"], "prob_info": {"func_start_lineno": 115, "func_end_lineno": 151, "key_block_start_lineno": 151, "key_block_end_lineno": 151, "new_func_code": "def tool(function: Callable) -> Tool:\n    \"\"\"\n    Decorator to convert a function into a Tool.\n\n    Tool name, description, and parameters are inferred from the function.\n    If you need to customize more the Tool, use `create_tool_from_function` instead.\n\n    ### Usage example\n    ```python\n    from typing import Annotated, Literal\n    from haystack.tools import tool\n\n    @tool\n    def get_weather(\n        city: Annotated[str, \"the city for which to get the weather\"] = \"Munich\",\n        unit: Annotated[Literal[\"Celsius\", \"Fahrenheit\"], \"the unit for the temperature\"] = \"Celsius\"):\n        '''A simple function to get the current weather for a location.'''\n        return f\"Weather report for {city}: 20 {unit}, sunny\"\n\n    print(get_weather)\n    >>> Tool(name='get_weather', description='A simple function to get the current weather for a location.',\n    >>> parameters={\n    >>> 'type': 'object',\n    >>> 'properties': {\n    >>>     'city': {'type': 'string', 'description': 'the city for which to get the weather', 'default': 'Munich'},\n    >>>     'unit': {\n    >>>         'type': 'string',\n    >>>         'enum': ['Celsius', 'Fahrenheit'],\n    >>>         'description': 'the unit for the temperature',\n    >>>         'default': 'Celsius',\n    >>>     },\n    >>>     }\n    >>> },\n    >>> function=<function get_weather at 0x7f7b3a8a9b80>)\n    ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.base_serialization.serialize_class_instance", "project": "haystack", "func": "serialize_class_instance", "origin_file": "./Source_Copy/haystack/haystack/utils/base_serialization.py", "test_list": ["test/utils/test_base_serialization.py"], "prob_info": {"func_start_lineno": 11, "func_end_lineno": 26, "key_block_start_lineno": 22, "key_block_end_lineno": 26, "new_func_code": "def serialize_class_instance(obj: Any) -> Dict[str, Any]:\n    \"\"\"\n    Serializes an object that has a `to_dict` method into a dictionary.\n\n    :param obj:\n        The object to be serialized.\n    :returns:\n        A dictionary representation of the object.\n    :raises SerializationError:\n        If the object does not have a `to_dict` method.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.device._split_device_string", "project": "haystack", "func": "_split_device_string", "origin_file": "./Source_Copy/haystack/haystack/utils/device.py", "test_list": ["test/utils/test_device.py"], "prob_info": {"func_start_lineno": 514, "func_end_lineno": 532, "key_block_start_lineno": 523, "key_block_end_lineno": 532, "new_func_code": "def _split_device_string(string: str) -> Tuple[str, Optional[int]]:\n    \"\"\"\n    Split a device string into device type and device id.\n\n    :param string:\n        The device string to split.\n    :returns:\n        The device type and device id, if any.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.device.ComponentDevice::first_device", "project": "haystack", "func": "ComponentDevice::first_device", "origin_file": "./Source_Copy/haystack/haystack/utils/device.py", "test_list": ["test/utils/test_device.py"], "prob_info": {"func_start_lineno": 414, "func_end_lineno": 428, "key_block_start_lineno": 421, "key_block_end_lineno": 428, "new_func_code": "def first_device(self) -> Optional[\"ComponentDevice\"]:\n        \"\"\"\n        Return either the single device or the first device in the device map, if any.\n\n        :returns:\n            The first device.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.device.ComponentDevice::to_spacy", "project": "haystack", "func": "ComponentDevice::to_spacy", "origin_file": "./Source_Copy/haystack/haystack/utils/device.py", "test_list": ["test/utils/test_device.py"], "prob_info": {"func_start_lineno": 338, "func_end_lineno": 357, "key_block_start_lineno": 347, "key_block_end_lineno": 357, "new_func_code": "def to_spacy(self) -> int:\n        \"\"\"\n        Convert the component device representation to spaCy format.\n\n        Device maps are not supported.\n\n        :returns:\n            The spaCy device representation.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.audio.whisper_remote.RemoteWhisperTranscriber::to_dict", "project": "haystack", "func": "RemoteWhisperTranscriber::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/audio/whisper_remote.py", "test_list": ["test/components/audio/test_whisper_remote.py"], "prob_info": {"func_start_lineno": 97, "func_end_lineno": 111, "key_block_start_lineno": 104, "key_block_end_lineno": 111, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.dataclasses.chat_message.ChatMessage::__getattribute__", "project": "haystack", "func": "ChatMessage::__getattribute__", "origin_file": "./Source_Copy/haystack/haystack/dataclasses/chat_message.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 127, "func_end_lineno": 140, "key_block_start_lineno": 131, "key_block_end_lineno": 140, "new_func_code": "def __getattribute__(self, name):\n        \"\"\"\n        This method is reimplemented to make the `content` attribute removal more visible.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.converters.utils.get_bytestream_from_source", "project": "haystack", "func": "get_bytestream_from_source", "origin_file": "./Source_Copy/haystack/haystack/components/converters/utils.py", "test_list": ["test/components/converters/test_json.py"], "prob_info": {"func_start_lineno": 11, "func_end_lineno": 27, "key_block_start_lineno": 20, "key_block_end_lineno": 27, "new_func_code": "def get_bytestream_from_source(source: Union[str, Path, ByteStream]) -> ByteStream:\n    \"\"\"\n    Creates a ByteStream object from a source.\n\n    :param source:\n        A source to convert to a ByteStream. Can be a string (path to a file), a Path object, or a ByteStream.\n    :return:\n        A ByteStream object.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.evaluators.llm_evaluator.LLMEvaluator::is_valid_json_and_has_expected_keys", "project": "haystack", "func": "LLMEvaluator::is_valid_json_and_has_expected_keys", "origin_file": "./Source_Copy/haystack/haystack/components/evaluators/llm_evaluator.py", "test_list": ["test/components/evaluators/test_llm_evaluator.py"], "prob_info": {"func_start_lineno": 354, "func_end_lineno": 387, "key_block_start_lineno": 371, "key_block_end_lineno": 387, "new_func_code": "def is_valid_json_and_has_expected_keys(self, expected: List[str], received: str) -> bool:\n        \"\"\"\n        Output must be a valid JSON with the expected keys.\n\n        :param expected:\n            Names of expected outputs\n        :param received:\n            Names of received outputs\n\n        :raises ValueError:\n            If the output is not a valid JSON with the expected keys:\n            - with `raise_on_failure` set to True a ValueError is raised.\n            - with `raise_on_failure` set to False a warning is issued and False is returned.\n\n        :returns:\n            True if the received output is a valid JSON with the expected keys, False otherwise.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.extractors.llm_metadata_extractor.LLMMetadataExtractor::run", "project": "haystack", "func": "LLMMetadataExtractor::run", "origin_file": "./Source_Copy/haystack/haystack/components/extractors/llm_metadata_extractor.py", "test_list": ["test/components/extractors/test_llm_metadata_extractor.py"], "prob_info": {"func_start_lineno": 380, "func_end_lineno": 442, "key_block_start_lineno": 404, "key_block_end_lineno": 442, "new_func_code": "def run(self, documents: List[Document], page_range: Optional[List[Union[str, int]]] = None):\n        \"\"\"\n        Extract metadata from documents using a Large Language Model.\n\n        If `page_range` is provided, the metadata will be extracted from the specified range of pages. This component\n        will split the documents into pages and extract metadata from the specified range of pages. The metadata will be\n        extracted from the entire document if `page_range` is not provided.\n\n        The original documents will be returned  updated with the extracted metadata.\n\n        :param documents: List of documents to extract metadata from.\n        :param page_range: A range of pages to extract metadata from. For example, page_range=['1', '3'] will extract\n                           metadata from the first and third pages of each document. It also accepts printable range\n                           strings, e.g.: ['1-3', '5', '8', '10-12'] will extract metadata from pages 1, 2, 3, 5, 8, 10,\n                           11, 12.\n                           If None, metadata will be extracted from the entire document for each document in the\n                           documents list.\n        :returns:\n            A dictionary with the keys:\n            - \"documents\": A list of documents that were successfully updated with the extracted metadata.\n            - \"failed_documents\": A list of documents that failed to extract metadata. These documents will have\n            \"metadata_extraction_error\" and \"metadata_extraction_response\" in their metadata. These documents can be\n            re-run with the extractor to extract metadata.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.generators.chat.openai.OpenAIChatGenerator::_convert_chat_completion_chunk_to_streaming_chunk", "project": "haystack", "func": "OpenAIChatGenerator::_convert_chat_completion_chunk_to_streaming_chunk", "origin_file": "./Source_Copy/haystack/haystack/components/generators/chat/openai.py", "test_list": ["test/components/generators/chat/test_openai.py"], "prob_info": {"func_start_lineno": 543, "func_end_lineno": 571, "key_block_start_lineno": 552, "key_block_end_lineno": 571, "new_func_code": "def _convert_chat_completion_chunk_to_streaming_chunk(self, chunk: ChatCompletionChunk) -> StreamingChunk:\n        \"\"\"\n        Converts the streaming response chunk from the OpenAI API to a StreamingChunk.\n\n        :param chunk: The chunk returned by the OpenAI API.\n\n        :returns:\n            The StreamingChunk.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.generators.chat.openai.OpenAIChatGenerator::_convert_streaming_chunks_to_chat_message", "project": "haystack", "func": "OpenAIChatGenerator::_convert_streaming_chunks_to_chat_message", "origin_file": "./Source_Copy/haystack/haystack/components/generators/chat/openai.py", "test_list": ["test/components/generators/chat/test_openai.py"], "prob_info": {"func_start_lineno": 440, "func_end_lineno": 503, "key_block_start_lineno": 451, "key_block_end_lineno": 503, "new_func_code": "def _convert_streaming_chunks_to_chat_message(\n        self, last_chunk: ChatCompletionChunk, chunks: List[StreamingChunk]\n    ) -> ChatMessage:\n        \"\"\"\n        Connects the streaming chunks into a single ChatMessage.\n\n        :param last_chunk: The last chunk returned by the OpenAI API.\n        :param chunks: The list of all `StreamingChunk` objects.\n\n        :returns: The ChatMessage.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.component_checks.has_any_trigger", "project": "haystack", "func": "has_any_trigger", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/component_checks.py", "test_list": ["test/components/joiners/test_list_joiner.py"], "prob_info": {"func_start_lineno": 28, "func_end_lineno": 49, "key_block_start_lineno": 45, "key_block_end_lineno": 49, "new_func_code": "def has_any_trigger(component: Dict, inputs: Dict) -> bool:\n    \"\"\"\n    Checks if a component was triggered to execute.\n\n    There are 3 triggers:\n    1. A predecessor provided input to the component.\n    2. Input to the component was provided from outside the pipeline (e.g. user input).\n    3. The component does not receive input from any other components in the pipeline and `Pipeline.run` was called.\n\n    A trigger can only cause a component to execute ONCE because:\n    1. Components consume inputs from predecessors before execution (they are deleted).\n    2. Inputs from outside the pipeline can only trigger a component when it is executed for the first time.\n    3.  `Pipeline.run` can only trigger a component when it is executed for the first time.\n\n    :param component: Component metadata and the component instance.\n    :param inputs: Inputs for the component.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.document_cleaner.DocumentCleaner::_ascii_only", "project": "haystack", "func": "DocumentCleaner::_ascii_only", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/document_cleaner.py", "test_list": ["test/components/preprocessors/test_document_cleaner.py"], "prob_info": {"func_start_lineno": 158, "func_end_lineno": 171, "key_block_start_lineno": 168, "key_block_end_lineno": 171, "new_func_code": "def _ascii_only(self, text: str) -> str:\n        \"\"\"\n        Convert the text to ASCII only.\n\n        Will remove accents from characters and replace them with ASCII characters.\n        Other non-ASCII characters will be removed.\n\n        :param text: Text to convert to ASCII only.\n        :returns: The text in ASCII only.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.document_splitter.DocumentSplitter::_concatenate_units", "project": "haystack", "func": "DocumentSplitter::_concatenate_units", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/document_splitter.py", "test_list": ["test/components/preprocessors/test_document_splitter.py"], "prob_info": {"func_start_lineno": 263, "func_end_lineno": 306, "key_block_start_lineno": 273, "key_block_end_lineno": 306, "new_func_code": "def _concatenate_units(\n        self, elements: List[str], split_length: int, split_overlap: int, split_threshold: int\n    ) -> Tuple[List[str], List[int], List[int]]:\n        \"\"\"\n        Concatenates the elements into parts of split_length units.\n\n        Keeps track of the original page number that each element belongs. If the length of the current units is less\n        than the pre-defined `split_threshold`, it does not create a new split. Instead, it concatenates the current\n        units with the last split, preventing the creation of excessively small splits.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.rankers.sentence_transformers_diversity.SentenceTransformersDiversityRanker::_maximum_margin_relevance", "project": "haystack", "func": "SentenceTransformersDiversityRanker::_maximum_margin_relevance", "origin_file": "./Source_Copy/haystack/haystack/components/rankers/sentence_transformers_diversity.py", "test_list": ["test/components/rankers/test_sentence_transformers_diversity.py"], "prob_info": {"func_start_lineno": 336, "func_end_lineno": 380, "key_block_start_lineno": 354, "key_block_end_lineno": 380, "new_func_code": "def _maximum_margin_relevance(\n        self, query: str, documents: List[Document], lambda_threshold: float, top_k: int\n    ) -> List[Document]:\n        \"\"\"\n        Orders the given list of documents according to the Maximum Margin Relevance (MMR) scores.\n\n        MMR scores are calculated for each document based on their relevance to the query and diversity from already\n        selected documents.\n\n        The algorithm iteratively selects documents based on their MMR scores, balancing between relevance to the query\n        and diversity from already selected documents. The 'lambda_threshold' controls the trade-off between relevance\n        and diversity.\n\n        A closer value to 0 favors diversity, while a closer value to 1 favors relevance to the query.\n\n        See : \"The Use of MMR, Diversity-Based Reranking for Reordering Documents and Producing Summaries\"\n               https://www.cs.cmu.edu/~jgc/publication/The_Use_MMR_Diversity_Based_LTMIR_1998.pdf\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.rankers.transformers_similarity.TransformersSimilarityRanker::to_dict", "project": "haystack", "func": "TransformersSimilarityRanker::to_dict", "origin_file": "./Source_Copy/haystack/haystack/components/rankers/transformers_similarity.py", "test_list": ["test/components/rankers/test_transformers_similarity.py"], "prob_info": {"func_start_lineno": 157, "func_end_lineno": 182, "key_block_start_lineno": 164, "key_block_end_lineno": 182, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes the component to a dictionary.\n\n        :returns:\n            Dictionary with serialized data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.readers.extractive.ExtractiveReader::run", "project": "haystack", "func": "ExtractiveReader::run", "origin_file": "./Source_Copy/haystack/haystack/components/readers/extractive.py", "test_list": ["test/components/readers/test_extractive.py"], "prob_info": {"func_start_lineno": 532, "func_end_lineno": 660, "key_block_start_lineno": 581, "key_block_end_lineno": 660, "new_func_code": "def run(  # pylint: disable=too-many-positional-arguments\n        self,\n        query: str,\n        documents: List[Document],\n        top_k: Optional[int] = None,\n        score_threshold: Optional[float] = None,\n        max_seq_length: Optional[int] = None,\n        stride: Optional[int] = None,\n        max_batch_size: Optional[int] = None,\n        answers_per_seq: Optional[int] = None,\n        no_answer: Optional[bool] = None,\n        overlap_threshold: Optional[float] = None,\n    ):\n        \"\"\"\n        Locates and extracts answers from the given Documents using the given query.\n\n        :param query:\n            Query string.\n        :param documents:\n            List of Documents in which you want to search for an answer to the query.\n        :param top_k:\n            The maximum number of answers to return.\n            An additional answer is returned if no_answer is set to True (default).\n        :param score_threshold:\n            Returns only answers with the score above this threshold.\n        :param max_seq_length:\n            Maximum number of tokens. If a sequence exceeds it, the sequence is split.\n        :param stride:\n            Number of tokens that overlap when sequence is split because it exceeds max_seq_length.\n        :param max_batch_size:\n            Maximum number of samples that are fed through the model at the same time.\n        :param answers_per_seq:\n            Number of answer candidates to consider per sequence.\n            This is relevant when a Document was split into multiple sequences because of max_seq_length.\n        :param no_answer:\n            Whether to return no answer scores.\n        :param overlap_threshold:\n            If set this will remove duplicate answers if they have an overlap larger than the\n            supplied threshold. For example, for the answers \"in the river in Maine\" and \"the river\" we would remove\n            one of these answers since the second answer has a 100% (1.0) overlap with the first answer.\n            However, for the answers \"the river in\" and \"in Maine\" there is only a max overlap percentage of 25% so\n            both of these answers could be kept if this variable is set to 0.24 or lower.\n            If None is provided then all answers are kept.\n        :returns:\n            List of answers sorted by (desc.) answer score.\n\n        :raises RuntimeError:\n            If the component was not warmed up by calling 'warm_up()' before.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.readers.extractive.ExtractiveReader::_preprocess", "project": "haystack", "func": "ExtractiveReader::_preprocess", "origin_file": "./Source_Copy/haystack/haystack/components/readers/extractive.py", "test_list": ["test/components/readers/test_extractive.py"], "prob_info": {"func_start_lineno": 207, "func_end_lineno": 256, "key_block_start_lineno": 213, "key_block_end_lineno": 256, "new_func_code": "def _preprocess(  # pylint: disable=too-many-positional-arguments\n        self, *, queries: List[str], documents: List[Document], max_seq_length: int, query_ids: List[int], stride: int\n    ) -> Tuple[\"torch.Tensor\", \"torch.Tensor\", \"torch.Tensor\", List[\"Encoding\"], List[int], List[int]]:\n        \"\"\"\n        Splits and tokenizes Documents and preserves structures by returning mappings to query and Document IDs.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.readers.extractive.ExtractiveReader::_postprocess", "project": "haystack", "func": "ExtractiveReader::_postprocess", "origin_file": "./Source_Copy/haystack/haystack/components/readers/extractive.py", "test_list": ["test/components/readers/test_extractive.py"], "prob_info": {"func_start_lineno": 258, "func_end_lineno": 319, "key_block_start_lineno": 274, "key_block_end_lineno": 319, "new_func_code": "def _postprocess(\n        self,\n        *,\n        start: \"torch.Tensor\",\n        end: \"torch.Tensor\",\n        sequence_ids: \"torch.Tensor\",\n        attention_mask: \"torch.Tensor\",\n        answers_per_seq: int,\n        encodings: List[\"Encoding\"],\n    ) -> Tuple[List[List[int]], List[List[int]], \"torch.Tensor\"]:\n        \"\"\"\n        Turns start and end logits into probabilities for each answer span.\n\n        Unlike most other implementations, it doesn't normalize the scores in each split to make them easier to\n        compare across different splits. Returns the top k answer spans.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.readers.extractive.ExtractiveReader::deduplicate_by_overlap", "project": "haystack", "func": "ExtractiveReader::deduplicate_by_overlap", "origin_file": "./Source_Copy/haystack/haystack/components/readers/extractive.py", "test_list": ["test/components/readers/test_extractive.py"], "prob_info": {"func_start_lineno": 494, "func_end_lineno": 529, "key_block_start_lineno": 515, "key_block_end_lineno": 529, "new_func_code": "def deduplicate_by_overlap(\n        self, answers: List[ExtractedAnswer], overlap_threshold: Optional[float]\n    ) -> List[ExtractedAnswer]:\n        \"\"\"\n        De-duplicates overlapping Extractive Answers.\n\n        De-duplicates overlapping Extractive Answers from the same document based on how much the spans of the\n        answers overlap.\n\n        :param answers:\n            List of answers to be deduplicated.\n        :param overlap_threshold:\n            If set this will remove duplicate answers if they have an overlap larger than the\n            supplied threshold. For example, for the answers \"in the river in Maine\" and \"the river\" we would remove\n            one of these answers since the second answer has a 100% (1.0) overlap with the first answer.\n            However, for the answers \"the river in\" and \"in Maine\" there is only a max overlap percentage of 25% so\n            both of these answers could be kept if this variable is set to 0.24 or lower.\n            If None is provided then all answers are kept.\n        :returns:\n            List of deduplicated answers.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.retrievers.in_memory.bm25_retriever.InMemoryBM25Retriever::run", "project": "haystack", "func": "InMemoryBM25Retriever::run", "origin_file": "./Source_Copy/haystack/haystack/components/retrievers/in_memory/bm25_retriever.py", "test_list": ["test/components/retrievers/test_sentence_window_retriever.py"], "prob_info": {"func_start_lineno": 128, "func_end_lineno": 163, "key_block_start_lineno": 153, "key_block_end_lineno": 163, "new_func_code": "def run(\n        self,\n        query: str,\n        filters: Optional[Dict[str, Any]] = None,\n        top_k: Optional[int] = None,\n        scale_score: Optional[bool] = None,\n    ):\n        \"\"\"\n        Run the InMemoryBM25Retriever on the given input data.\n\n        :param query:\n            The query string for the Retriever.\n        :param filters:\n            A dictionary with filters to narrow down the search space when retrieving documents.\n        :param top_k:\n            The maximum number of documents to return.\n        :param scale_score:\n            When `True`, scales the score of retrieved documents to a range of 0 to 1, where 1 means extremely relevant.\n            When `False`, uses raw similarity scores.\n        :returns:\n            The retrieved documents.\n\n        :raises ValueError:\n            If the specified DocumentStore is not found or is not a InMemoryDocumentStore instance.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.document_stores.in_memory.document_store.InMemoryDocumentStore::bm25_retrieval", "project": "haystack", "func": "InMemoryDocumentStore::bm25_retrieval", "origin_file": "./Source_Copy/haystack/haystack/document_stores/in_memory/document_store.py", "test_list": ["test/components/retrievers/test_sentence_window_retriever.py"], "prob_info": {"func_start_lineno": 497, "func_end_lineno": 548, "key_block_start_lineno": 509, "key_block_end_lineno": 548, "new_func_code": "def bm25_retrieval(\n        self, query: str, filters: Optional[Dict[str, Any]] = None, top_k: int = 10, scale_score: bool = False\n    ) -> List[Document]:\n        \"\"\"\n        Retrieves documents that are most relevant to the query using BM25 algorithm.\n\n        :param query: The query string.\n        :param filters: A dictionary with filters to narrow down the search space.\n        :param top_k: The number of top documents to retrieve. Default is 10.\n        :param scale_score: Whether to scale the scores of the retrieved documents. Default is False.\n        :returns: A list of the top_k documents most relevant to the query.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.document_stores.in_memory.document_store.InMemoryDocumentStore::_score_bm25l", "project": "haystack", "func": "InMemoryDocumentStore::_score_bm25l", "origin_file": "./Source_Copy/haystack/haystack/document_stores/in_memory/document_store.py", "test_list": ["test/components/retrievers/test_sentence_window_retriever.py"], "prob_info": {"func_start_lineno": 189, "func_end_lineno": 234, "key_block_start_lineno": 201, "key_block_end_lineno": 234, "new_func_code": "def _score_bm25l(self, query: str, documents: List[Document]) -> List[Tuple[Document, float]]:\n        \"\"\"\n        Calculate BM25L scores for the given query and filtered documents.\n\n        :param query:\n            The query string.\n        :param documents:\n            The list of documents to score, should be produced by\n            the filter_documents method; may be an empty list.\n        :returns:\n            A list of tuples, each containing a Document and its BM25L score.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.component_checks.has_lazy_variadic_socket_received_all_inputs", "project": "haystack", "func": "has_lazy_variadic_socket_received_all_inputs", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/component_checks.py", "test_list": ["test/core/pipeline/test_component_checks.py"], "prob_info": {"func_start_lineno": 149, "func_end_lineno": 163, "key_block_start_lineno": 156, "key_block_end_lineno": 163, "new_func_code": "def has_lazy_variadic_socket_received_all_inputs(socket: InputSocket, socket_inputs: List[Dict]) -> bool:\n    \"\"\"\n    Checks if a lazy variadic socket has received all expected inputs from other components in the pipeline.\n\n    :param socket: The InputSocket of a component.\n    :param socket_inputs: Inputs for the socket.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.base._connections_status", "project": "haystack", "func": "_connections_status", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/base.py", "test_list": ["test/core/pipeline/test_pipeline.py"], "prob_info": {"func_start_lineno": 1207, "func_end_lineno": 1229, "key_block_start_lineno": 1213, "key_block_end_lineno": 1229, "new_func_code": "def _connections_status(\n    sender_node: str, receiver_node: str, sender_sockets: List[OutputSocket], receiver_sockets: List[InputSocket]\n) -> str:\n    \"\"\"\n    Lists the status of the sockets, for error messages.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.dataclasses.answer.ExtractedAnswer::to_dict", "project": "haystack", "func": "ExtractedAnswer::to_dict", "origin_file": "./Source_Copy/haystack/haystack/dataclasses/answer.py", "test_list": ["test/dataclasses/test_answer.py"], "prob_info": {"func_start_lineno": 43, "func_end_lineno": 63, "key_block_start_lineno": 50, "key_block_end_lineno": 63, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serialize the object to a dictionary.\n\n        :returns:\n            Serialized dictionary representation of the object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.hf.resolve_hf_device_map", "project": "haystack", "func": "resolve_hf_device_map", "origin_file": "./Source_Copy/haystack/haystack/utils/hf.py", "test_list": ["test/utils/test_hf.py"], "prob_info": {"func_start_lineno": 135, "func_end_lineno": 166, "key_block_start_lineno": 150, "key_block_end_lineno": 166, "new_func_code": "def resolve_hf_device_map(device: Optional[ComponentDevice], model_kwargs: Optional[Dict[str, Any]]) -> Dict[str, Any]:\n    \"\"\"\n    Update `model_kwargs` to include the keyword argument `device_map`.\n\n    This method is useful you want to force loading a transformers model when using `AutoModel.from_pretrained` to\n    use `device_map`.\n\n    We handle the edge case where `device` and `device_map` is specified by ignoring the `device` parameter and printing\n    a warning.\n\n    :param device: The device on which the model is loaded. If `None`, the default device is automatically\n        selected.\n    :param model_kwargs: Additional HF keyword arguments passed to `AutoModel.from_pretrained`.\n        For details on what kwargs you can pass, see the model's documentation.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.hugging_face_api_document_embedder.HuggingFaceAPIDocumentEmbedder::_prepare_texts_to_embed", "project": "haystack", "func": "HuggingFaceAPIDocumentEmbedder::_prepare_texts_to_embed", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/hugging_face_api_document_embedder.py", "test_list": ["test/components/embedders/test_hugging_face_api_document_embedder.py"], "prob_info": {"func_start_lineno": 219, "func_end_lineno": 234, "key_block_start_lineno": 223, "key_block_end_lineno": 234, "new_func_code": "def _prepare_texts_to_embed(self, documents: List[Document]) -> List[str]:\n        \"\"\"\n        Prepare the texts to embed by concatenating the Document text with the metadata fields to embed.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.joiners.document_joiner.DocumentJoiner::_reciprocal_rank_fusion", "project": "haystack", "func": "DocumentJoiner::_reciprocal_rank_fusion", "origin_file": "./Source_Copy/haystack/haystack/components/joiners/document_joiner.py", "test_list": ["test/components/joiners/test_document_joiner.py"], "prob_info": {"func_start_lineno": 201, "func_end_lineno": 232, "key_block_start_lineno": 208, "key_block_end_lineno": 232, "new_func_code": "def _reciprocal_rank_fusion(self, document_lists: List[List[Document]]) -> List[Document]:\n        \"\"\"\n        Merge multiple lists of Documents and assign scores based on reciprocal rank fusion.\n\n        The constant k is set to 61 (60 was suggested by the original paper,\n        plus 1 as python lists are 0-based and the paper used 1-based ranking).\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.recursive_splitter.RecursiveDocumentSplitter::run", "project": "haystack", "func": "RecursiveDocumentSplitter::run", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/recursive_splitter.py", "test_list": ["test/components/preprocessors/test_recursive_splitter.py"], "prob_info": {"func_start_lineno": 405, "func_end_lineno": 421, "key_block_start_lineno": 414, "key_block_end_lineno": 421, "new_func_code": "def run(self, documents: List[Document]) -> Dict[str, List[Document]]:\n        \"\"\"\n        Split a list of documents into documents with smaller chunks of text.\n\n        :param documents: List of Documents to split.\n        :returns:\n            A dictionary containing a key \"documents\" with a List of Documents with smaller chunks of text corresponding\n            to the input documents.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.component_checks.can_component_run", "project": "haystack", "func": "can_component_run", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/component_checks.py", "test_list": ["test/core/pipeline/test_component_checks.py"], "prob_info": {"func_start_lineno": 12, "func_end_lineno": 25, "key_block_start_lineno": 22, "key_block_end_lineno": 25, "new_func_code": "def can_component_run(component: Dict, inputs: Dict) -> bool:\n    \"\"\"\n    Checks if the component can run, given the current state of its inputs.\n\n    A component needs to pass two gates so that it is ready to run:\n    1. It has received all mandatory inputs.\n    2. It has received a trigger.\n    :param component: Component metadata and the component instance.\n    :param inputs: Inputs for the component.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.builders.answer_builder.AnswerBuilder::run", "project": "haystack", "func": "AnswerBuilder::run", "origin_file": "./Source_Copy/haystack/haystack/components/builders/answer_builder.py", "test_list": ["test/components/builders/test_answer_builder.py"], "prob_info": {"func_start_lineno": 61, "func_end_lineno": 147, "key_block_start_lineno": 103, "key_block_end_lineno": 147, "new_func_code": "def run(  # pylint: disable=too-many-positional-arguments\n        self,\n        query: str,\n        replies: Union[List[str], List[ChatMessage]],\n        meta: Optional[List[Dict[str, Any]]] = None,\n        documents: Optional[List[Document]] = None,\n        pattern: Optional[str] = None,\n        reference_pattern: Optional[str] = None,\n    ):\n        \"\"\"\n        Turns the output of a Generator into `GeneratedAnswer` objects using regular expressions.\n\n        :param query:\n            The input query used as the Generator prompt.\n        :param replies:\n            The output of the Generator. Can be a list of strings or a list of `ChatMessage` objects.\n        :param meta:\n            The metadata returned by the Generator. If not specified, the generated answer will contain no metadata.\n        :param documents:\n            The documents used as the Generator inputs. If specified, they are added to\n            the`GeneratedAnswer` objects.\n            If both `documents` and `reference_pattern` are specified, the documents referenced in the\n            Generator output are extracted from the input documents and added to the `GeneratedAnswer` objects.\n        :param pattern:\n            The regular expression pattern to extract the answer text from the Generator.\n            If not specified, the entire response is used as the answer.\n            The regular expression can have one capture group at most.\n            If present, the capture group text\n            is used as the answer. If no capture group is present, the whole match is used as the answer.\n                Examples:\n                    `[^\\\\n]+$` finds \"this is an answer\" in a string \"this is an argument.\\\\nthis is an answer\".\n                    `Answer: (.*)` finds \"this is an answer\" in a string\n                    \"this is an argument. Answer: this is an answer\".\n        :param reference_pattern:\n            The regular expression pattern used for parsing the document references.\n            If not specified, no parsing is done, and all documents are referenced.\n            References need to be specified as indices of the input documents and start at [1].\n            Example: `\\\\[(\\\\d+)\\\\]` finds \"1\" in a string \"this is an answer[1]\".\n\n        :returns: A dictionary with the following keys:\n            - `answers`: The answers received from the output of the Generator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.builders.chat_prompt_builder.ChatPromptBuilder::run", "project": "haystack", "func": "ChatPromptBuilder::run", "origin_file": "./Source_Copy/haystack/haystack/components/builders/chat_prompt_builder.py", "test_list": ["test/components/builders/test_chat_prompt_builder.py"], "prob_info": {"func_start_lineno": 156, "func_end_lineno": 217, "key_block_start_lineno": 182, "key_block_end_lineno": 217, "new_func_code": "def run(\n        self,\n        template: Optional[List[ChatMessage]] = None,\n        template_variables: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Renders the prompt template with the provided variables.\n\n        It applies the template variables to render the final prompt. You can provide variables with pipeline kwargs.\n        To overwrite the default template, you can set the `template` parameter.\n        To overwrite pipeline kwargs, you can set the `template_variables` parameter.\n\n        :param template:\n            An optional list of `ChatMessage` objects to overwrite ChatPromptBuilder's default template.\n            If `None`, the default template provided at initialization is used.\n        :param template_variables:\n            An optional dictionary of template variables to overwrite the pipeline variables.\n        :param kwargs:\n            Pipeline variables used for rendering the prompt.\n\n        :returns: A dictionary with the following keys:\n            - `prompt`: The updated list of `ChatMessage` objects after rendering the templates.\n        :raises ValueError:\n            If `chat_messages` is empty or contains elements that are not instances of `ChatMessage`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.connectors.openapi_service.OpenAPIServiceConnector::run", "project": "haystack", "func": "OpenAPIServiceConnector::run", "origin_file": "./Source_Copy/haystack/haystack/components/connectors/openapi_service.py", "test_list": ["test/components/connectors/test_openapi_service.py"], "prob_info": {"func_start_lineno": 211, "func_end_lineno": 263, "key_block_start_lineno": 236, "key_block_end_lineno": 263, "new_func_code": "def run(\n        self,\n        messages: List[ChatMessage],\n        service_openapi_spec: Dict[str, Any],\n        service_credentials: Optional[Union[dict, str]] = None,\n    ) -> Dict[str, List[ChatMessage]]:\n        \"\"\"\n        Processes a list of chat messages to invoke a method on an OpenAPI service.\n\n        It parses the last message in the list, expecting it to contain tool calls.\n\n        :param messages: A list of `ChatMessage` objects containing the messages to be processed. The last message\n        should contain the tool calls.\n        :param service_openapi_spec: The OpenAPI JSON specification object of the service to be invoked. All the refs\n        should already be resolved.\n        :param service_credentials: The credentials to be used for authentication with the service.\n        Currently, only the http and apiKey OpenAPI security schemes are supported.\n\n        :return: A dictionary with the following keys:\n            - `service_response`:  a list of `ChatMessage` objects, each containing the response from the service. The\n                                   response is in JSON format, and the `content` attribute of the `ChatMessage` contains\n                                   the JSON string.\n\n        :raises ValueError: If the last message is not from the assistant or if it does not contain tool calls.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.connectors.openapi_service.OpenAPIServiceConnector::_invoke_method", "project": "haystack", "func": "OpenAPIServiceConnector::_invoke_method", "origin_file": "./Source_Copy/haystack/haystack/components/connectors/openapi_service.py", "test_list": ["test/components/connectors/test_openapi_service.py"], "prob_info": {"func_start_lineno": 341, "func_end_lineno": 399, "key_block_start_lineno": 354, "key_block_end_lineno": 399, "new_func_code": "def _invoke_method(self, openapi_service: \"OpenAPI\", method_invocation_descriptor: Dict[str, Any]) -> Any:\n        \"\"\"\n        Invokes the specified method on the OpenAPI service.\n\n        The method name and arguments are passed in the method_invocation_descriptor.\n\n        :param openapi_service: The OpenAPI service instance.\n        :param method_invocation_descriptor: The method name and arguments to be passed to the method. The payload\n        should contain the method name (key: \"name\") and the arguments (key: \"arguments\"). The name is a string, and\n        the arguments are a dictionary of key-value pairs.\n        :return: A service JSON response.\n        :raises RuntimeError: If the method is not found or invocation fails.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.serialization.component_to_dict", "project": "haystack", "func": "component_to_dict", "origin_file": "./Source_Copy/haystack/haystack/core/serialization.py", "test_list": ["test/components/connectors/test_openapi_service.py"], "prob_info": {"func_start_lineno": 36, "func_end_lineno": 82, "key_block_start_lineno": 54, "key_block_end_lineno": 82, "new_func_code": "def component_to_dict(obj: Any, name: str) -> Dict[str, Any]:\n    \"\"\"\n    Converts a component instance into a dictionary.\n\n    If a `to_dict` method is present in the component instance, that will be used instead of the default method.\n\n    :param obj:\n        The component to be serialized.\n    :param name:\n        The name of the component.\n    :returns:\n        A dictionary representation of the component.\n\n    :raises SerializationError:\n        If the component doesn't have a `to_dict` method.\n        If the values of the init parameters can't be determined.\n        If a non-basic Python type is used in the serialized data.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.converters.json.JSONConverter::run", "project": "haystack", "func": "JSONConverter::run", "origin_file": "./Source_Copy/haystack/haystack/components/converters/json.py", "test_list": ["test/components/converters/test_json.py"], "prob_info": {"func_start_lineno": 250, "func_end_lineno": 291, "key_block_start_lineno": 271, "key_block_end_lineno": 291, "new_func_code": "def run(\n        self,\n        sources: List[Union[str, Path, ByteStream]],\n        meta: Optional[Union[Dict[str, Any], List[Dict[str, Any]]]] = None,\n    ):\n        \"\"\"\n        Converts a list of JSON files to documents.\n\n        :param sources:\n            A list of file paths or ByteStream objects.\n        :param meta:\n            Optional metadata to attach to the documents.\n            This value can be either a list of dictionaries or a single dictionary.\n            If it's a single dictionary, its content is added to the metadata of all produced documents.\n            If it's a list, the length of the list must match the number of sources.\n            If `sources` contain ByteStream objects, their `meta` will be added to the output documents.\n\n        :returns:\n            A dictionary with the following keys:\n            - `documents`: A list of created documents.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.converters.openapi_functions.OpenAPIServiceToFunctions::run", "project": "haystack", "func": "OpenAPIServiceToFunctions::run", "origin_file": "./Source_Copy/haystack/haystack/components/converters/openapi_functions.py", "test_list": ["test/components/converters/test_openapi_functions.py"], "prob_info": {"func_start_lineno": 56, "func_end_lineno": 115, "key_block_start_lineno": 73, "key_block_end_lineno": 115, "new_func_code": "def run(self, sources: List[Union[str, Path, ByteStream]]) -> Dict[str, Any]:\n        \"\"\"\n        Converts OpenAPI definitions in OpenAI function calling format.\n\n        :param sources:\n            File paths or ByteStream objects of OpenAPI definitions (in JSON or YAML format).\n\n        :returns:\n            A dictionary with the following keys:\n            - functions: Function definitions in JSON object format\n            - openapi_specs: OpenAPI specs in JSON/YAML object format with resolved references\n\n        :raises RuntimeError:\n            If the OpenAPI definitions cannot be downloaded or processed.\n        :raises ValueError:\n            If the source type is not recognized or no functions are found in the OpenAPI definitions.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.type_serialization.serialize_type", "project": "haystack", "func": "serialize_type", "origin_file": "./Source_Copy/haystack/haystack/utils/type_serialization.py", "test_list": ["test/components/converters/test_output_adapter.py"], "prob_info": {"func_start_lineno": 19, "func_end_lineno": 52, "key_block_start_lineno": 31, "key_block_end_lineno": 52, "new_func_code": "def serialize_type(target: Any) -> str:\n    \"\"\"\n    Serializes a type or an instance to its string representation, including the module name.\n\n    This function handles types, instances of types, and special typing objects.\n    It assumes that non-typing objects will have a '__name__' attribute.\n\n    :param target:\n        The object to serialize, can be an instance or a type.\n    :return:\n        The string representation of the type.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.hugging_face_api_text_embedder.HuggingFaceAPITextEmbedder::run", "project": "haystack", "func": "HuggingFaceAPITextEmbedder::run", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/hugging_face_api_text_embedder.py", "test_list": ["test/components/embedders/test_hugging_face_api_text_embedder.py"], "prob_info": {"func_start_lineno": 182, "func_end_lineno": 224, "key_block_start_lineno": 193, "key_block_end_lineno": 224, "new_func_code": "def run(self, text: str):\n        \"\"\"\n        Embeds a single string.\n\n        :param text:\n            Text to embed.\n\n        :returns:\n            A dictionary with the following keys:\n            - `embedding`: The embedding of the input text.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.embedders.sentence_transformers_text_embedder.SentenceTransformersTextEmbedder::run", "project": "haystack", "func": "SentenceTransformersTextEmbedder::run", "origin_file": "./Source_Copy/haystack/haystack/components/embedders/sentence_transformers_text_embedder.py", "test_list": ["test/components/embedders/test_sentence_transformers_text_embedder.py"], "prob_info": {"func_start_lineno": 201, "func_end_lineno": 229, "key_block_start_lineno": 212, "key_block_end_lineno": 229, "new_func_code": "def run(self, text: str):\n        \"\"\"\n        Embed a single string.\n\n        :param text:\n            Text to embed.\n\n        :returns:\n            A dictionary with the following keys:\n            - `embedding`: The embedding of the input text.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.evaluators.document_map.DocumentMAPEvaluator::run", "project": "haystack", "func": "DocumentMAPEvaluator::run", "origin_file": "./Source_Copy/haystack/haystack/components/evaluators/document_map.py", "test_list": ["test/components/evaluators/test_document_map.py"], "prob_info": {"func_start_lineno": 48, "func_end_lineno": 90, "key_block_start_lineno": 66, "key_block_end_lineno": 90, "new_func_code": "def run(\n        self, ground_truth_documents: List[List[Document]], retrieved_documents: List[List[Document]]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Run the DocumentMAPEvaluator on the given inputs.\n\n        All lists must have the same length.\n\n        :param ground_truth_documents:\n            A list of expected documents for each question.\n        :param retrieved_documents:\n            A list of retrieved documents for each question.\n        :returns:\n            A dictionary with the following outputs:\n            - `score` - The average of calculated scores.\n            - `individual_scores` - A list of numbers from 0.0 to 1.0 that represents how high retrieved documents\n                are ranked.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tools.tool.deserialize_tools_inplace", "project": "haystack", "func": "deserialize_tools_inplace", "origin_file": "./Source_Copy/haystack/haystack/tools/tool.py", "test_list": ["test/components/generators/chat/test_azure.py"], "prob_info": {"func_start_lineno": 106, "func_end_lineno": 136, "key_block_start_lineno": 115, "key_block_end_lineno": 136, "new_func_code": "def deserialize_tools_inplace(data: Dict[str, Any], key: str = \"tools\"):\n    \"\"\"\n    Deserialize Tools in a dictionary inplace.\n\n    :param data:\n        The dictionary with the serialized data.\n    :param key:\n        The key in the dictionary where the Tools are stored.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.serialization.import_class_by_name", "project": "haystack", "func": "import_class_by_name", "origin_file": "./Source_Copy/haystack/haystack/core/serialization.py", "test_list": ["test/components/generators/chat/test_azure.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 264, "key_block_start_lineno": 255, "key_block_end_lineno": 264, "new_func_code": "def import_class_by_name(fully_qualified_name: str) -> Type[object]:\n    \"\"\"\n    Utility function to import (load) a class object based on its fully qualified class name.\n\n    This function dynamically imports a class based on its string name.\n    It splits the name into module path and class name, imports the module,\n    and returns the class object.\n\n    :param fully_qualified_name: the fully qualified class name as a string\n    :returns: the class object.\n    :raises ImportError: If the class cannot be imported or found.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.csv_document_cleaner.CSVDocumentCleaner::run", "project": "haystack", "func": "CSVDocumentCleaner::run", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/csv_document_cleaner.py", "test_list": ["test/components/preprocessors/test_csv_document_cleaner.py"], "prob_info": {"func_start_lineno": 58, "func_end_lineno": 119, "key_block_start_lineno": 74, "key_block_end_lineno": 119, "new_func_code": "def run(self, documents: List[Document]) -> Dict[str, List[Document]]:\n        \"\"\"\n        Cleans CSV documents by removing empty rows and columns while preserving specified ignored rows and columns.\n\n        :param documents: List of Documents containing CSV-formatted content.\n        :return: A dictionary with a list of cleaned Documents under the key \"documents\".\n\n        Processing steps:\n        1. Reads each document's content as a CSV table.\n        2. Retains the specified number of `ignore_rows` from the top and `ignore_columns` from the left.\n        3. Drops any rows and columns that are entirely empty (if enabled by `remove_empty_rows` and\n            `remove_empty_columns`).\n        4. Reattaches the ignored rows and columns to maintain their original positions.\n        5. Returns the cleaned CSV content as a new `Document` object, with an option to retain the original\n            document ID.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.csv_document_cleaner.CSVDocumentCleaner::_clean_df", "project": "haystack", "func": "CSVDocumentCleaner::_clean_df", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/csv_document_cleaner.py", "test_list": ["test/components/preprocessors/test_csv_document_cleaner.py"], "prob_info": {"func_start_lineno": 121, "func_end_lineno": 154, "key_block_start_lineno": 129, "key_block_end_lineno": 154, "new_func_code": "def _clean_df(self, df: \"pd.DataFrame\", ignore_rows: int, ignore_columns: int) -> \"pd.DataFrame\":\n        \"\"\"\n        Cleans a DataFrame by removing empty rows and columns while preserving ignored sections.\n\n        :param df: The input DataFrame representing the CSV data.\n        :param ignore_rows: Number of top rows to ignore.\n        :param ignore_columns: Number of left columns to ignore.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.csv_document_splitter.CSVDocumentSplitter::run", "project": "haystack", "func": "CSVDocumentSplitter::run", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/csv_document_splitter.py", "test_list": ["test/components/preprocessors/test_csv_document_splitter.py"], "prob_info": {"func_start_lineno": 59, "func_end_lineno": 131, "key_block_start_lineno": 86, "key_block_end_lineno": 131, "new_func_code": "def run(self, documents: List[Document]) -> Dict[str, List[Document]]:\n        \"\"\"\n        Processes and splits a list of CSV documents into multiple sub-tables.\n\n        **Splitting Process:**\n        1. Applies a row-based split if `row_split_threshold` is provided.\n        2. Applies a column-based split if `column_split_threshold` is provided.\n        3. If both thresholds are specified, performs a recursive split by rows first, then columns, ensuring\n           further fragmentation of any sub-tables that still contain empty sections.\n        4. Sorts the resulting sub-tables based on their original positions within the document.\n\n        :param documents: A list of Documents containing CSV-formatted content.\n            Each document is assumed to contain one or more tables separated by empty rows or columns.\n\n        :return:\n            A dictionary with a key `\"documents\"`, mapping to a list of new `Document` objects,\n            each representing an extracted sub-table from the original CSV.\n            The metadata of each document includes:\n                - A field `source_id` to track the original document.\n                - A field `row_idx_start` to indicate the starting row index of the sub-table in the original table.\n                - A field `col_idx_start` to indicate the starting column index of the sub-table in the original table.\n                - A field `split_id` to indicate the order of the split in the original document.\n                - All other metadata copied from the original document.\n\n        - If a document cannot be processed, it is returned unchanged.\n        - The `meta` field from the original document is preserved in the split documents.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.csv_document_splitter.CSVDocumentSplitter::_split_dataframe", "project": "haystack", "func": "CSVDocumentSplitter::_split_dataframe", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/csv_document_splitter.py", "test_list": ["test/components/preprocessors/test_csv_document_splitter.py"], "prob_info": {"func_start_lineno": 174, "func_end_lineno": 207, "key_block_start_lineno": 185, "key_block_end_lineno": 207, "new_func_code": "def _split_dataframe(\n        self, df: \"pd.DataFrame\", split_threshold: int, axis: Literal[\"row\", \"column\"]\n    ) -> List[\"pd.DataFrame\"]:\n        \"\"\"\n        Splits a DataFrame into sub-tables based on consecutive empty rows or columns exceeding `split_threshold`.\n\n        :param df: DataFrame to split.\n        :param split_threshold: Minimum number of consecutive empty rows or columns to trigger a split.\n        :param axis: Axis along which to split. Either \"row\" or \"column\".\n        :return: List of split DataFrames.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.document_cleaner.DocumentCleaner::run", "project": "haystack", "func": "DocumentCleaner::run", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/document_cleaner.py", "test_list": ["test/components/preprocessors/test_document_cleaner.py"], "prob_info": {"func_start_lineno": 93, "func_end_lineno": 145, "key_block_start_lineno": 104, "key_block_end_lineno": 145, "new_func_code": "def run(self, documents: List[Document]):\n        \"\"\"\n        Cleans up the documents.\n\n        :param documents: List of Documents to clean.\n\n        :returns: A dictionary with the following key:\n            - `documents`: List of cleaned Documents.\n\n        :raises TypeError: if documents is not a list of Documents.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.document_splitter.DocumentSplitter::_create_docs_from_splits", "project": "haystack", "func": "DocumentSplitter::_create_docs_from_splits", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/document_splitter.py", "test_list": ["test/components/preprocessors/test_document_splitter.py"], "prob_info": {"func_start_lineno": 308, "func_end_lineno": 337, "key_block_start_lineno": 314, "key_block_end_lineno": 337, "new_func_code": "def _create_docs_from_splits(\n        self, text_splits: List[str], splits_pages: List[int], splits_start_idxs: List[int], meta: Dict[str, Any]\n    ) -> List[Document]:\n        \"\"\"\n        Creates Document objects from splits enriching them with page number and the metadata of the original document.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.preprocessors.recursive_splitter.RecursiveDocumentSplitter::_apply_overlap", "project": "haystack", "func": "RecursiveDocumentSplitter::_apply_overlap", "origin_file": "./Source_Copy/haystack/haystack/components/preprocessors/recursive_splitter.py", "test_list": ["test/components/preprocessors/test_recursive_splitter.py"], "prob_info": {"func_start_lineno": 135, "func_end_lineno": 202, "key_block_start_lineno": 147, "key_block_end_lineno": 202, "new_func_code": "def _apply_overlap(self, chunks: List[str]) -> List[str]:\n        \"\"\"\n        Applies an overlap between consecutive chunks if the chunk_overlap attribute is greater than zero.\n\n        Works for both word- and character-level splitting. It trims the last chunk if it exceeds the split_length and\n        adds the trimmed content to the next chunk. If the last chunk is still too long after trimming, it splits it\n        and adds the first chunk to the list. This process continues until the last chunk is within the split_length.\n\n        :param chunks: A list of text chunks.\n        :returns:\n            A list of text chunks with the overlap applied.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.rankers.meta_field_grouping_ranker.MetaFieldGroupingRanker::run", "project": "haystack", "func": "MetaFieldGroupingRanker::run", "origin_file": "./Source_Copy/haystack/haystack/components/rankers/meta_field_grouping_ranker.py", "test_list": ["test/components/rankers/test_meta_field_grouping_ranker.py"], "prob_info": {"func_start_lineno": 78, "func_end_lineno": 117, "key_block_start_lineno": 89, "key_block_end_lineno": 117, "new_func_code": "def run(self, documents: List[Document]) -> Dict[str, Any]:\n        \"\"\"\n        Groups the provided list of documents based on the `group_by` parameter and optionally the `subgroup_by`.\n\n        The output is a list of documents reordered based on how they were grouped.\n\n        :param documents: The list of documents to group.\n        :returns:\n            A dictionary with the following keys:\n            - documents: The list of documents ordered by the `group_by` and `subgroup_by` metadata values.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.pipeline.Pipeline::_run_component", "project": "haystack", "func": "Pipeline::_run_component", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/pipeline.py", "test_list": ["test/components/rankers/test_meta_field_grouping_ranker.py"], "prob_info": {"func_start_lineno": 24, "func_end_lineno": 91, "key_block_start_lineno": 42, "key_block_end_lineno": 91, "new_func_code": "def _run_component(\n        self,\n        component: Dict[str, Any],\n        inputs: Dict[str, Any],\n        component_visits: Dict[str, int],\n        parent_span: Optional[tracing.Span] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Runs a Component with the given inputs.\n\n        :param component: Component with component metadata.\n        :param inputs: Inputs for the Component.\n        :param component_visits: Current state of component visits.\n        :param parent_span: The parent span to use for the newly created span.\n            This is to allow tracing to be correctly linked to the pipeline run.\n        :raises PipelineRuntimeError: If Component doesn't return a dictionary.\n        :return: The output of the Component.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.retrievers.sentence_window_retriever.SentenceWindowRetriever::run", "project": "haystack", "func": "SentenceWindowRetriever::run", "origin_file": "./Source_Copy/haystack/haystack/components/retrievers/sentence_window_retriever.py", "test_list": ["test/components/retrievers/test_sentence_window_retriever.py"], "prob_info": {"func_start_lineno": 147, "func_end_lineno": 198, "key_block_start_lineno": 166, "key_block_end_lineno": 198, "new_func_code": "def run(self, retrieved_documents: List[Document], window_size: Optional[int] = None):\n        \"\"\"\n        Based on the `source_id` and on the `doc.meta['split_id']` get surrounding documents from the document store.\n\n        Implements the logic behind the sentence-window technique, retrieving the surrounding documents of a given\n        document from the document store.\n\n        :param retrieved_documents: List of retrieved documents from the previous retriever.\n        :param window_size: The number of documents to retrieve before and after the relevant one. This will overwrite\n                            the `window_size` parameter set in the constructor.\n        :returns:\n            A dictionary with the following keys:\n                - `context_windows`: A list of strings, where each string represents the concatenated text from the\n                                     context window of the corresponding document in `retrieved_documents`.\n                - `context_documents`: A list `Document` objects, containing the retrieved documents plus the context\n                                      document surrounding them. The documents are sorted by the `split_idx_start`\n                                      meta field.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.conditional_router.ConditionalRouter::_validate_routes", "project": "haystack", "func": "ConditionalRouter::_validate_routes", "origin_file": "./Source_Copy/haystack/haystack/components/routers/conditional_router.py", "test_list": ["test/components/routers/test_conditional_router.py"], "prob_info": {"func_start_lineno": 335, "func_end_lineno": 355, "key_block_start_lineno": 341, "key_block_end_lineno": 355, "new_func_code": "def _validate_routes(self, routes: List[Dict]):\n        \"\"\"\n        Validates a list of routes.\n\n        :param routes: A list of routes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.routers.zero_shot_text_router.TransformersZeroShotTextRouter::run", "project": "haystack", "func": "TransformersZeroShotTextRouter::run", "origin_file": "./Source_Copy/haystack/haystack/components/routers/zero_shot_text_router.py", "test_list": ["test/components/routers/test_zero_shot_text_router.py"], "prob_info": {"func_start_lineno": 194, "func_end_lineno": 219, "key_block_start_lineno": 207, "key_block_end_lineno": 219, "new_func_code": "def run(self, text: str) -> Dict[str, str]:\n        \"\"\"\n        Routes the text strings to different connections based on a category label.\n\n        :param text: A string of text to route.\n        :returns:\n            A dictionary with the label as key and the text as value.\n\n        :raises TypeError:\n            If the input is not a str.\n        :raises RuntimeError:\n            If the pipeline has not been loaded because warm_up() was not called before.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.samplers.top_p.TopPSampler::run", "project": "haystack", "func": "TopPSampler::run", "origin_file": "./Source_Copy/haystack/haystack/components/samplers/top_p.py", "test_list": ["test/components/samplers/test_top_p.py"], "prob_info": {"func_start_lineno": 65, "func_end_lineno": 122, "key_block_start_lineno": 79, "key_block_end_lineno": 122, "new_func_code": "def run(self, documents: List[Document], top_p: Optional[float] = None):\n        \"\"\"\n        Filters documents using top-p sampling based on their scores.\n\n        If the specified top_p results in no documents being selected (especially in cases of a low top_p value), the\n        method returns the document with the highest score.\n\n        :param documents: List of Document objects to be filtered.\n        :param top_p: If specified, a float to override the cumulative probability threshold set during initialization.\n\n        :returns: A dictionary with the following key:\n            - `documents`: List of Document objects that have been selected based on the top-p sampling.\n        :raises ValueError: If the top_p value is not within the range [0, 1].\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.validators.json_schema.JsonSchemaValidator::_recursive_json_to_object", "project": "haystack", "func": "JsonSchemaValidator::_recursive_json_to_object", "origin_file": "./Source_Copy/haystack/haystack/components/validators/json_schema.py", "test_list": ["test/components/validators/test_json_schema.py"], "prob_info": {"func_start_lineno": 226, "func_end_lineno": 257, "key_block_start_lineno": 235, "key_block_end_lineno": 257, "new_func_code": "def _recursive_json_to_object(self, data: Any) -> Any:\n        \"\"\"\n        Convert any string values that are valid JSON objects into dictionary objects.\n\n        Returns a new data structure.\n\n        :param data: The data structure to be traversed.\n        :return: A new data structure with JSON strings converted to dictionary objects.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.websearch.searchapi.SearchApiWebSearch::run", "project": "haystack", "func": "SearchApiWebSearch::run", "origin_file": "./Source_Copy/haystack/haystack/components/websearch/searchapi.py", "test_list": ["test/components/websearch/test_searchapi.py"], "prob_info": {"func_start_lineno": 99, "func_end_lineno": 179, "key_block_start_lineno": 110, "key_block_end_lineno": 179, "new_func_code": "def run(self, query: str) -> Dict[str, Union[List[Document], List[str]]]:\n        \"\"\"\n        Uses [SearchApi](https://www.searchapi.io/) to search the web.\n\n        :param query: Search query.\n        :returns: A dictionary with the following keys:\n            - \"documents\": List of documents returned by the search engine.\n            - \"links\": List of links returned by the search engine.\n        :raises TimeoutError: If the request to the SearchApi API times out.\n        :raises SearchApiError: If an error occurs while querying the SearchApi API.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.dataclasses.chat_message.ChatMessage::to_openai_dict_format", "project": "haystack", "func": "ChatMessage::to_openai_dict_format", "origin_file": "./Source_Copy/haystack/haystack/dataclasses/chat_message.py", "test_list": ["test/dataclasses/test_chat_message.py"], "prob_info": {"func_start_lineno": 357, "func_end_lineno": 403, "key_block_start_lineno": 361, "key_block_end_lineno": 403, "new_func_code": "def to_openai_dict_format(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert a ChatMessage to the dictionary format expected by OpenAI's Chat API.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.evaluation.eval_run_result.EvaluationRunResult::comparative_detailed_report", "project": "haystack", "func": "EvaluationRunResult::comparative_detailed_report", "origin_file": "./Source_Copy/haystack/haystack/evaluation/eval_run_result.py", "test_list": ["test/evaluation/test_eval_run_result.py"], "prob_info": {"func_start_lineno": 164, "func_end_lineno": 222, "key_block_start_lineno": 183, "key_block_end_lineno": 222, "new_func_code": "def comparative_detailed_report(\n        self,\n        other: \"EvaluationRunResult\",\n        keep_columns: Optional[List[str]] = None,\n        output_format: Literal[\"json\", \"csv\", \"df\"] = \"json\",\n        csv_file: Optional[str] = None,\n    ) -> Union[str, \"DataFrame\", None]:\n        \"\"\"\n        Generates a report with detailed scores for each metric from two evaluation runs for comparison.\n\n        :param other: Results of another evaluation run to compare with.\n        :param keep_columns: List of common column names to keep from the inputs of the evaluation runs to compare.\n        :param output_format: The output format for the report, \"json\", \"csv\", or \"df\", default to \"json\".\n        :param csv_file: Filepath to save CSV output if `output_format` is \"csv\", must be provided.\n\n        :returns:\n            JSON or DataFrame with a comparison of the detailed scores, in case the output is set to a CSV file,\n             a message confirming the successful write or an error message.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tools.component_tool.ComponentTool::_create_tool_parameters_schema", "project": "haystack", "func": "ComponentTool::_create_tool_parameters_schema", "origin_file": "./Source_Copy/haystack/haystack/tools/component_tool.py", "test_list": ["test/tools/test_component_tool.py"], "prob_info": {"func_start_lineno": 180, "func_end_lineno": 217, "key_block_start_lineno": 188, "key_block_end_lineno": 217, "new_func_code": "def _create_tool_parameters_schema(self, component: Component) -> Dict[str, Any]:\n        \"\"\"\n        Creates an OpenAI tools schema from a component's run method parameters.\n\n        :param component: The component to create the schema from.\n        :raises SchemaGenerationError: If schema generation fails\n        :returns: OpenAI tools schema for the component's run method parameters.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tools.component_tool.ComponentTool::_create_property_schema", "project": "haystack", "func": "ComponentTool::_create_property_schema", "origin_file": "./Source_Copy/haystack/haystack/tools/component_tool.py", "test_list": ["test/tools/test_component_tool.py"], "prob_info": {"func_start_lineno": 297, "func_end_lineno": 328, "key_block_start_lineno": 307, "key_block_end_lineno": 328, "new_func_code": "def _create_property_schema(self, python_type: Any, description: str, default: Any = None) -> Dict[str, Any]:\n        \"\"\"\n        Creates a property schema for a given Python type, recursively if necessary.\n\n        :param python_type: The Python type to create a property schema for.\n        :param description: The description of the property.\n        :param default: The default value of the property.\n        :returns: A dictionary representing the property schema.\n        :raises SchemaGenerationError: If schema generation fails, e.g., for unsupported types like Pydantic v2 models\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tools.component_tool.ComponentTool::_create_dataclass_schema", "project": "haystack", "func": "ComponentTool::_create_dataclass_schema", "origin_file": "./Source_Copy/haystack/haystack/tools/component_tool.py", "test_list": ["test/tools/test_component_tool.py"], "prob_info": {"func_start_lineno": 269, "func_end_lineno": 283, "key_block_start_lineno": 277, "key_block_end_lineno": 283, "new_func_code": "def _create_dataclass_schema(self, python_type: Any, description: str) -> Dict[str, Any]:\n        \"\"\"\n        Creates a schema for a dataclass.\n\n        :param python_type: The dataclass type.\n        :param description: The description of the dataclass.\n        :returns: A dictionary representing the dataclass schema.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tools.from_function.create_tool_from_function", "project": "haystack", "func": "create_tool_from_function", "origin_file": "./Source_Copy/haystack/haystack/tools/from_function.py", "test_list": ["test/tools/test_from_function.py"], "prob_info": {"func_start_lineno": 14, "func_end_lineno": 112, "key_block_start_lineno": 74, "key_block_end_lineno": 112, "new_func_code": "def create_tool_from_function(\n    function: Callable, name: Optional[str] = None, description: Optional[str] = None\n) -> \"Tool\":\n    \"\"\"\n    Create a Tool instance from a function.\n\n    Allows customizing the Tool name and description.\n    For simpler use cases, consider using the `@tool` decorator.\n\n    ### Usage example\n\n    ```python\n    from typing import Annotated, Literal\n    from haystack.tools import create_tool_from_function\n\n    def get_weather(\n        city: Annotated[str, \"the city for which to get the weather\"] = \"Munich\",\n        unit: Annotated[Literal[\"Celsius\", \"Fahrenheit\"], \"the unit for the temperature\"] = \"Celsius\"):\n        '''A simple function to get the current weather for a location.'''\n        return f\"Weather report for {city}: 20 {unit}, sunny\"\n\n    tool = create_tool_from_function(get_weather)\n\n    print(tool)\n    >>> Tool(name='get_weather', description='A simple function to get the current weather for a location.',\n    >>> parameters={\n    >>> 'type': 'object',\n    >>> 'properties': {\n    >>>     'city': {'type': 'string', 'description': 'the city for which to get the weather', 'default': 'Munich'},\n    >>>     'unit': {\n    >>>         'type': 'string',\n    >>>         'enum': ['Celsius', 'Fahrenheit'],\n    >>>         'description': 'the unit for the temperature',\n    >>>         'default': 'Celsius',\n    >>>     },\n    >>>     }\n    >>> },\n    >>> function=<function get_weather at 0x7f7b3a8a9b80>)\n    ```\n\n    :param function:\n        The function to be converted into a Tool.\n        The function must include type hints for all parameters.\n        The function is expected to have basic python input types (str, int, float, bool, list, dict, tuple).\n        Other input types may work but are not guaranteed.\n        If a parameter is annotated using `typing.Annotated`, its metadata will be used as parameter description.\n    :param name:\n        The name of the Tool. If not provided, the name of the function will be used.\n    :param description:\n        The description of the Tool. If not provided, the docstring of the function will be used.\n        To intentionally leave the description empty, pass an empty string.\n\n    :returns:\n        The Tool created from the function.\n\n    :raises ValueError:\n        If any parameter of the function lacks a type hint.\n    :raises SchemaGenerationError:\n        If there is an error generating the JSON schema for the Tool.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tracing.logging_tracer.LoggingTracer::trace", "project": "haystack", "func": "LoggingTracer::trace", "origin_file": "./Source_Copy/haystack/haystack/tracing/logging_tracer.py", "test_list": ["test/tracing/test_logging_tracer.py"], "prob_info": {"func_start_lineno": 52, "func_end_lineno": 80, "key_block_start_lineno": 63, "key_block_end_lineno": 80, "new_func_code": "def trace(\n        self, operation_name: str, tags: Optional[Dict[str, Any]] = None, parent_span: Optional[Span] = None\n    ) -> Iterator[Span]:\n        \"\"\"\n        Trace the execution of a block of code.\n\n        :param operation_name: the name of the operation being traced.\n        :param tags: tags to apply to the newly created span.\n        :param parent_span: the parent span to use for the newly created span. Not used in this simple tracer.\n        :returns: the newly created span.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tracing.utils.coerce_tag_value", "project": "haystack", "func": "coerce_tag_value", "origin_file": "./Source_Copy/haystack/haystack/tracing/utils.py", "test_list": ["test/tracing/test_opentelemetry.py"], "prob_info": {"func_start_lineno": 15, "func_end_lineno": 39, "key_block_start_lineno": 25, "key_block_end_lineno": 39, "new_func_code": "def coerce_tag_value(value: Any) -> Union[bool, str, int, float]:\n    \"\"\"\n    Coerces span tag values to compatible types for the tracing backend.\n\n    Most tracing libraries don't support sending complex types to the backend. Hence, we need to convert them to\n    compatible types.\n\n    :param value: an arbitrary value which should be coerced to a compatible type\n    :return: the value coerced to a compatible type\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.base_serialization.deserialize_class_instance", "project": "haystack", "func": "deserialize_class_instance", "origin_file": "./Source_Copy/haystack/haystack/utils/base_serialization.py", "test_list": ["test/utils/test_base_serialization.py"], "prob_info": {"func_start_lineno": 29, "func_end_lineno": 54, "key_block_start_lineno": 41, "key_block_end_lineno": 54, "new_func_code": "def deserialize_class_instance(data: Dict[str, Any]) -> Any:\n    \"\"\"\n    Deserializes an object from a dictionary representation generated by `auto_serialize_class_instance`.\n\n    :param data:\n        The dictionary to deserialize from.\n    :returns:\n        The deserialized object.\n    :raises DeserializationError:\n        If the serialization data is malformed, the class type cannot be imported, or the\n        class does not have a `from_dict` method.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.docstore_deserialization.deserialize_document_store_in_init_params_inplace", "project": "haystack", "func": "deserialize_document_store_in_init_params_inplace", "origin_file": "./Source_Copy/haystack/haystack/utils/docstore_deserialization.py", "test_list": ["test/utils/test_docstore_deserialization.py"], "prob_info": {"func_start_lineno": 11, "func_end_lineno": 39, "key_block_start_lineno": 25, "key_block_end_lineno": 39, "new_func_code": "def deserialize_document_store_in_init_params_inplace(data: Dict[str, Any], key: str = \"document_store\"):\n    \"\"\"\n    Deserializes a generic document store from the init_parameters of a serialized component in place.\n\n    :param data:\n        The dictionary to deserialize from.\n    :param key:\n        The key in the `data[\"init_parameters\"]` dictionary where the document store is specified.\n    :returns:\n        The dictionary, with the document store deserialized.\n\n    :raises DeserializationError:\n        If the document store is not properly specified in the serialization data or its type cannot be imported.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.jinja2_extensions.Jinja2TimeExtension::parse", "project": "haystack", "func": "Jinja2TimeExtension::parse", "origin_file": "./Source_Copy/haystack/haystack/utils/jinja2_extensions.py", "test_list": ["test/utils/test_jinja2_extensions.py"], "prob_info": {"func_start_lineno": 73, "func_end_lineno": 96, "key_block_start_lineno": 80, "key_block_end_lineno": 96, "new_func_code": "def parse(self, parser: Any) -> Union[nodes.Node, List[nodes.Node]]:\n        \"\"\"\n        Parse the template expression to determine how to handle the datetime formatting.\n\n        :param parser: The parser object that processes the template expressions and manages the syntax tree.\n            It's used to interpret the template's structure.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.utils.type_serialization.deserialize_type", "project": "haystack", "func": "deserialize_type", "origin_file": "./Source_Copy/haystack/haystack/utils/type_serialization.py", "test_list": ["test/utils/test_type_serialization.py"], "prob_info": {"func_start_lineno": 78, "func_end_lineno": 156, "key_block_start_lineno": 93, "key_block_end_lineno": 156, "new_func_code": "def deserialize_type(type_str: str) -> Any:  # pylint: disable=too-many-return-statements\n    \"\"\"\n    Deserializes a type given its full import path as a string, including nested generic types.\n\n    This function will dynamically import the module if it's not already imported\n    and then retrieve the type object from it. It also handles nested generic types like\n    `typing.List[typing.Dict[int, str]]`.\n\n    :param type_str:\n        The string representation of the type's full import path.\n    :returns:\n        The deserialized type object.\n    :raises DeserializationError:\n        If the type cannot be deserialized due to missing module or type.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.components.validators.json_schema.JsonSchemaValidator::_construct_error_recovery_message", "project": "haystack", "func": "JsonSchemaValidator::_construct_error_recovery_message", "origin_file": "./Source_Copy/haystack/haystack/components/validators/json_schema.py", "test_list": ["test/components/validators/test_json_schema.py"], "prob_info": {"func_start_lineno": 188, "func_end_lineno": 215, "key_block_start_lineno": 207, "key_block_end_lineno": 215, "new_func_code": "def _construct_error_recovery_message(  # pylint: disable=too-many-positional-arguments\n        self,\n        error_template: str,\n        error_message: str,\n        error_path: str,\n        error_schema_path: str,\n        json_schema: Dict[str, Any],\n        failing_json: str,\n    ) -> str:\n        \"\"\"\n        Constructs an error recovery message using a specified template or the default one if none is provided.\n\n        :param error_template: A custom template string for formatting the error message in case of validation failure.\n        :param error_message: The error message returned by the JSON schema validator.\n        :param error_path: The path in the JSON content where the error occurred.\n        :param error_schema_path: The path in the JSON schema where the error occurred.\n        :param json_schema: The JSON schema against which the content is validated.\n        :param failing_json: The generated invalid JSON string.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.core.pipeline.component_checks.are_all_sockets_ready", "project": "haystack", "func": "are_all_sockets_ready", "origin_file": "./Source_Copy/haystack/haystack/core/pipeline/component_checks.py", "test_list": ["test/core/pipeline/test_component_checks.py"], "prob_info": {"func_start_lineno": 52, "func_end_lineno": 83, "key_block_start_lineno": 60, "key_block_end_lineno": 83, "new_func_code": "def are_all_sockets_ready(component: Dict, inputs: Dict, only_check_mandatory: bool = False) -> bool:\n    \"\"\"\n    Checks if all sockets of a component have enough inputs for the component to execute.\n\n    :param component: Component metadata and the component instance.\n    :param inputs: Inputs for the component.\n    :param only_check_mandatory: If only mandatory sockets should be checked.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "haystack.haystack.tracing.tracer.auto_enable_tracing", "project": "haystack", "func": "auto_enable_tracing", "origin_file": "./Source_Copy/haystack/haystack/tracing/tracer.py", "test_list": ["test/tracing/test_tracer.py"], "prob_info": {"func_start_lineno": 180, "func_end_lineno": 199, "key_block_start_lineno": 187, "key_block_end_lineno": 199, "new_func_code": "def auto_enable_tracing() -> None:\n    \"\"\"\n    Auto-enable the right tracing backend.\n\n    This behavior can be disabled by setting the environment variable `HAYSTACK_AUTO_TRACE_ENABLED` to `false`.\n    Note that it will only work correctly if tracing was configured _before_ Haystack is imported.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.cache.memory.MemoryCache::get", "project": "inference", "func": "MemoryCache::get", "origin_file": "./Source_Copy/inference/inference/core/cache/memory.py", "test_list": ["tests/inference/unit_tests/core/test_roboflow_api.py"], "prob_info": {"func_start_lineno": 58, "func_end_lineno": 73, "key_block_start_lineno": 68, "key_block_end_lineno": 73, "new_func_code": "def get(self, key: str):\n        \"\"\"\n        Gets the value associated with the given key.\n\n        Args:\n            key (str): The key to retrieve the value.\n\n        Returns:\n            str: The value associated with the key, or None if the key does not exist or is expired.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.cache.memory.MemoryCache::set", "project": "inference", "func": "MemoryCache::set", "origin_file": "./Source_Copy/inference/inference/core/cache/memory.py", "test_list": ["tests/inference/unit_tests/core/test_roboflow_api.py"], "prob_info": {"func_start_lineno": 75, "func_end_lineno": 86, "key_block_start_lineno": 84, "key_block_end_lineno": 86, "new_func_code": "def set(self, key: str, value: str, expire: float = None):\n        \"\"\"\n        Sets a value for a given key with an optional expire time.\n\n        Args:\n            key (str): The key to store the value.\n            value (str): The value to store.\n            expire (float, optional): The time, in seconds, after which the key will expire. Defaults to None.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.active_learning.accounting.get_matching_labeling_batch", "project": "inference", "func": "get_matching_labeling_batch", "origin_file": "./Source_Copy/inference/inference/core/active_learning/accounting.py", "test_list": ["tests/inference/unit_tests/core/active_learning/test_accounting.py"], "prob_info": {"func_start_lineno": 55, "func_end_lineno": 74, "key_block_start_lineno": 69, "key_block_end_lineno": 74, "new_func_code": "def get_matching_labeling_batch(\n    all_labeling_batches: List[dict],\n    batch_name: str,\n) -> Optional[dict]:\n    \"\"\"Get the matching labeling batch.\n\n    Args:\n        all_labeling_batches: All labeling batches.\n        batch_name: Name of the batch.\n\n    Returns:\n        The matching labeling batch if found, None otherwise.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.active_learning.accounting.get_images_in_labeling_jobs_of_specific_batch", "project": "inference", "func": "get_images_in_labeling_jobs_of_specific_batch", "origin_file": "./Source_Copy/inference/inference/core/active_learning/accounting.py", "test_list": ["tests/inference/unit_tests/core/active_learning/test_accounting.py"], "prob_info": {"func_start_lineno": 77, "func_end_lineno": 96, "key_block_start_lineno": 91, "key_block_end_lineno": 96, "new_func_code": "def get_images_in_labeling_jobs_of_specific_batch(\n    all_labeling_jobs: List[dict],\n    batch_id: str,\n) -> int:\n    \"\"\"Get the number of images in labeling jobs of a specific batch.\n\n    Args:\n        all_labeling_jobs: All labeling jobs.\n        batch_id: ID of the batch.\n\n    Returns:\n        The number of images in labeling jobs of the batch.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.encode_image_to_jpeg_bytes", "project": "inference", "func": "encode_image_to_jpeg_bytes", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/active_learning/test_core.py"], "prob_info": {"func_start_lineno": 586, "func_end_lineno": 599, "key_block_start_lineno": 597, "key_block_end_lineno": 599, "new_func_code": "def encode_image_to_jpeg_bytes(image: np.ndarray, jpeg_quality: int = 90) -> bytes:\n    \"\"\"\n    Encode a numpy image to JPEG format in bytes.\n\n    Args:\n        image (np.ndarray): The numpy array representing a BGR image.\n        jpeg_quality (int): Quality of the JPEG image.\n\n    Returns:\n        bytes: The JPEG encoded image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.load_image", "project": "inference", "func": "load_image", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/active_learning/test_middlewares.py"], "prob_info": {"func_start_lineno": 71, "func_end_lineno": 104, "key_block_start_lineno": 88, "key_block_end_lineno": 104, "new_func_code": "def load_image(\n    value: Any,\n    disable_preproc_auto_orient: bool = False,\n) -> Tuple[np.ndarray, bool]:\n    \"\"\"Loads an image based on the specified type and value.\n\n    Args:\n        value (Any): Image value which could be an instance of InferenceRequestImage,\n            a dict with 'type' and 'value' keys, or inferred based on the value's content.\n\n    Returns:\n        Image.Image: The loaded PIL image, converted to RGB.\n\n    Raises:\n        NotImplementedError: If the specified image type is not supported.\n        InvalidNumpyInput: If the numpy input method is used and the input data is invalid.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.load_image_with_inferred_type", "project": "inference", "func": "load_image_with_inferred_type", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/active_learning/test_middlewares.py"], "prob_info": {"func_start_lineno": 180, "func_end_lineno": 212, "key_block_start_lineno": 196, "key_block_end_lineno": 212, "new_func_code": "def load_image_with_inferred_type(\n    value: Any,\n    cv_imread_flags: int = cv2.IMREAD_COLOR,\n) -> Tuple[np.ndarray, bool]:\n    \"\"\"Load an image by inferring its type.\n\n    Args:\n        value (Any): The image data.\n        cv_imread_flags (int): Flags used for OpenCV's imread function.\n\n    Returns:\n        Tuple[np.ndarray, bool]: Loaded image as a numpy array and a boolean indicating if the image is in BGR format.\n\n    Raises:\n        NotImplementedError: If the image type could not be inferred.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.validate_numpy_image", "project": "inference", "func": "validate_numpy_image", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/active_learning/test_middlewares.py"], "prob_info": {"func_start_lineno": 353, "func_end_lineno": 377, "key_block_start_lineno": 363, "key_block_end_lineno": 377, "new_func_code": "def validate_numpy_image(data: np.ndarray) -> None:\n    \"\"\"\n    Validate if the provided data is a valid numpy image.\n\n    Args:\n        data (np.ndarray): The numpy array representing an image.\n\n    Raises:\n        InvalidNumpyInput: If the provided data is not a valid numpy image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.convert_gray_image_to_bgr", "project": "inference", "func": "convert_gray_image_to_bgr", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/active_learning/test_middlewares.py"], "prob_info": {"func_start_lineno": 530, "func_end_lineno": 543, "key_block_start_lineno": 540, "key_block_end_lineno": 543, "new_func_code": "def convert_gray_image_to_bgr(image: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Convert a grayscale image to BGR format.\n\n    Args:\n        image (np.ndarray): The grayscale image.\n\n    Returns:\n        np.ndarray: The converted BGR image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.cache.model_artifacts.clear_cache", "project": "inference", "func": "clear_cache", "origin_file": "./Source_Copy/inference/inference/core/cache/model_artifacts.py", "test_list": ["tests/inference/unit_tests/core/cache/test_model_artifacts.py"], "prob_info": {"func_start_lineno": 142, "func_end_lineno": 207, "key_block_start_lineno": 149, "key_block_end_lineno": 207, "new_func_code": "def clear_cache(model_id: Optional[str] = None, delete_from_disk: bool = True) -> None:\n    \"\"\"Clear the cache for a specific model or the entire cache directory.\n\n    Args:\n        model_id (Optional[str], optional): The model ID to clear cache for. If None, clears entire cache. Defaults to None.\n        delete_from_disk (bool, optional): Whether to delete cached files from disk. Defaults to False.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.interfaces.camera.video_source.VideoSource::__next__", "project": "inference", "func": "VideoSource::__next__", "origin_file": "./Source_Copy/inference/inference/core/interfaces/camera/video_source.py", "test_list": ["tests/inference/unit_tests/core/interfaces/camera/test_utils.py"], "prob_info": {"func_start_lineno": 720, "func_end_lineno": 738, "key_block_start_lineno": 735, "key_block_end_lineno": 738, "new_func_code": "def __next__(self) -> VideoFrame:\n        \"\"\"\n        Method allowing to use `VideoSource` convenient to read frames\n\n        Returns: VideoFrame\n\n        Example:\n            ```python\n            source = VideoSource.init(video_reference=\"./some.mp4\")\n            source.start()\n\n            for frame in source:\n                 pass\n            ```\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.interfaces.camera.video_source.VideoSource::read_frame", "project": "inference", "func": "VideoSource::read_frame", "origin_file": "./Source_Copy/inference/inference/core/interfaces/camera/video_source.py", "test_list": ["tests/inference/unit_tests/core/interfaces/camera/test_utils.py"], "prob_info": {"func_start_lineno": 526, "func_end_lineno": 555, "key_block_start_lineno": 534, "key_block_end_lineno": 555, "new_func_code": "def read_frame(self, timeout: Optional[float] = None) -> Optional[VideoFrame]:\n        \"\"\"\n        Method to be used by the consumer to get decoded source frame.\n\n        Returns: VideoFrame object with decoded frame and its metadata.\n        Throws:\n            * EndOfStreamError: when trying to get the frame from closed source.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.interfaces.camera.utils.get_video_frames_generator", "project": "inference", "func": "get_video_frames_generator", "origin_file": "./Source_Copy/inference/inference/core/interfaces/camera/utils.py", "test_list": ["tests/inference/unit_tests/core/interfaces/camera/test_utils.py"], "prob_info": {"func_start_lineno": 46, "func_end_lineno": 97, "key_block_start_lineno": 76, "key_block_end_lineno": 97, "new_func_code": "def get_video_frames_generator(\n    video: Union[VideoSource, str, int],\n    max_fps: Optional[Union[float, int]] = None,\n    limiter_strategy: Optional[FPSLimiterStrategy] = None,\n) -> Generator[VideoFrame, None, None]:\n    \"\"\"\n    Util function to create a frames generator from `VideoSource` with possibility to\n    limit FPS of consumed frames and dictate what to do if frames are produced to fast.\n\n    Args:\n        video (Union[VideoSource, str, int]): Either instance of VideoSource or video reference accepted\n            by VideoSource.init(...)\n        max_fps (Optional[Union[float, int]]): value of maximum FPS rate of generated frames - can be used to limit\n            generation frequency\n        limiter_strategy (Optional[FPSLimiterStrategy]): strategy used to deal with frames decoding exceeding\n            limit of `max_fps`. By default - for files, in the interest of processing all frames -\n            generation will be awaited, for streams - frames will be dropped on the floor.\n    Returns: generator of `VideoFrame`\n\n    Example:\n        ```python\n        from inference.core.interfaces.camera.utils import get_video_frames_generator\n\n        for frame in get_video_frames_generator(\n            video=\"./some.mp4\",\n            max_fps=50,\n        ):\n             pass\n        ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.preprocess.letterbox_image", "project": "inference", "func": "letterbox_image", "origin_file": "./Source_Copy/inference/inference/core/utils/preprocess.py", "test_list": ["tests/inference/unit_tests/core/interfaces/stream/test_sinks.py"], "prob_info": {"func_start_lineno": 190, "func_end_lineno": 241, "key_block_start_lineno": 206, "key_block_end_lineno": 241, "new_func_code": "def letterbox_image(\n    image: ImageMetaType,\n    desired_size: Tuple[int, int],\n    color: Tuple[int, int, int] = (0, 0, 0),\n) -> ImageMetaType:\n    \"\"\"\n    Resize and pad image to fit the desired size, preserving its aspect ratio.\n\n    Parameters:\n    - image: numpy array representing the image.\n    - desired_size: tuple (width, height) representing the target dimensions.\n    - color: tuple (B, G, R) representing the color to pad with.\n\n    Returns:\n    - letterboxed image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.interfaces.stream.sinks.UDPSink::send_predictions", "project": "inference", "func": "UDPSink::send_predictions", "origin_file": "./Source_Copy/inference/inference/core/interfaces/stream/sinks.py", "test_list": ["tests/inference/unit_tests/core/interfaces/stream/test_sinks.py"], "prob_info": {"func_start_lineno": 258, "func_end_lineno": 318, "key_block_start_lineno": 299, "key_block_end_lineno": 318, "new_func_code": "def send_predictions(\n        self,\n        predictions: Union[dict, List[Optional[dict]]],\n        video_frame: Union[VideoFrame, List[Optional[VideoFrame]]],\n    ) -> None:\n        \"\"\"\n        Method to send predictions via UDP socket. Useful in combination with `InferencePipeline` as\n        a sink for predictions.\n\n        Args:\n            predictions (Union[dict, List[Optional[dict]]]): Roboflow predictions, the function support single prediction\n                processing and batch processing since version `0.9.18`. Batch predictions elements are optional, but\n                should occur at the same position as `video_frame` list. Order is expected to match with `video_frame`.\n            video_frame (Union[VideoFrame, List[Optional[VideoFrame]]]): frame of video with its basic metadata emitted\n                by `VideoSource` or list of frames from (it is possible for empty batch frames at corresponding positions\n                to `predictions` list). Order is expected to match with `predictions`\n\n        Returns: None\n        Side effects: Sends serialised `predictions` and `video_frame` metadata via the UDP socket as\n            JSON string. It adds key named \"inference_metadata\" into `predictions` dict (mutating its\n            state). \"inference_metadata\" contain id of the frame, frame grabbing timestamp and message\n            emission time in datetime iso format.\n\n        Example:\n            ```python\n            import cv2\n            from inference.core.interfaces.stream.inference_pipeline import InferencePipeline\n            from inference.core.interfaces.stream.sinks import UDPSink\n\n            udp_sink = UDPSink.init(ip_address=\"127.0.0.1\", port=9090)\n\n            pipeline = InferencePipeline.init(\n                 model_id=\"your-model/3\",\n                 video_reference=\"./some_file.mp4\",\n                 on_prediction=udp_sink.send_predictions,\n            )\n            pipeline.start()\n            pipeline.join()\n            ```\n            `UDPSink` used in this way will emit predictions to receiver automatically.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.managers.base.ModelManager::make_response", "project": "inference", "func": "ModelManager::make_response", "origin_file": "./Source_Copy/inference/inference/core/managers/base.py", "test_list": ["tests/inference/unit_tests/core/managers/test_base.py"], "prob_info": {"func_start_lineno": 238, "func_end_lineno": 251, "key_block_start_lineno": 250, "key_block_end_lineno": 251, "new_func_code": "def make_response(\n        self, model_id: str, predictions: List[List[float]], *args, **kwargs\n    ) -> InferenceResponse:\n        \"\"\"Creates a response object from the model's predictions.\n\n        Args:\n            model_id (str): The identifier of the model.\n            predictions (List[List[float]]): The model's predictions.\n\n        Returns:\n            InferenceResponse: The created response object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.managers.base.ModelManager::postprocess", "project": "inference", "func": "ModelManager::postprocess", "origin_file": "./Source_Copy/inference/inference/core/managers/base.py", "test_list": ["tests/inference/unit_tests/core/managers/test_base.py"], "prob_info": {"func_start_lineno": 253, "func_end_lineno": 273, "key_block_start_lineno": 270, "key_block_end_lineno": 273, "new_func_code": "def postprocess(\n        self,\n        model_id: str,\n        predictions: Tuple[np.ndarray, ...],\n        preprocess_return_metadata: PreprocessReturnMetadata,\n        *args,\n        **kwargs,\n    ) -> List[List[float]]:\n        \"\"\"Processes the model's predictions after inference.\n\n        Args:\n            model_id (str): The identifier of the model.\n            predictions (np.ndarray): The model's predictions.\n\n        Returns:\n            List[List[float]]: The post-processed predictions.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.managers.base.ModelManager::preprocess", "project": "inference", "func": "ModelManager::preprocess", "origin_file": "./Source_Copy/inference/inference/core/managers/base.py", "test_list": ["tests/inference/unit_tests/core/managers/test_base.py"], "prob_info": {"func_start_lineno": 292, "func_end_lineno": 305, "key_block_start_lineno": 304, "key_block_end_lineno": 305, "new_func_code": "def preprocess(\n        self, model_id: str, request: InferenceRequest\n    ) -> Tuple[np.ndarray, PreprocessReturnMetadata]:\n        \"\"\"Preprocesses the request before inference.\n\n        Args:\n            model_id (str): The identifier of the model.\n            request (InferenceRequest): The request to preprocess.\n\n        Returns:\n            Tuple[np.ndarray, List[Tuple[int, int]]]: The preprocessed data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.managers.base.ModelManager::predict", "project": "inference", "func": "ModelManager::predict", "origin_file": "./Source_Copy/inference/inference/core/managers/base.py", "test_list": ["tests/inference/unit_tests/core/managers/test_base.py"], "prob_info": {"func_start_lineno": 275, "func_end_lineno": 290, "key_block_start_lineno": 284, "key_block_end_lineno": 290, "new_func_code": "def predict(self, model_id: str, *args, **kwargs) -> Tuple[np.ndarray, ...]:\n        \"\"\"Runs prediction on the specified model.\n\n        Args:\n            model_id (str): The identifier of the model.\n\n        Returns:\n            np.ndarray: The predictions from the model.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.managers.base.ModelManager::remove", "project": "inference", "func": "ModelManager::remove", "origin_file": "./Source_Copy/inference/inference/core/managers/base.py", "test_list": ["tests/inference/unit_tests/core/managers/test_base.py"], "prob_info": {"func_start_lineno": 331, "func_end_lineno": 345, "key_block_start_lineno": 337, "key_block_end_lineno": 345, "new_func_code": "def remove(self, model_id: str, delete_from_disk: bool = True) -> None:\n        \"\"\"Removes a model from the manager.\n\n        Args:\n            model_id (str): The identifier of the model.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.registries.base.ModelRegistry::get_model", "project": "inference", "func": "ModelRegistry::get_model", "origin_file": "./Source_Copy/inference/inference/core/registries/base.py", "test_list": ["tests/inference/unit_tests/core/registries/test_base.py"], "prob_info": {"func_start_lineno": 20, "func_end_lineno": 37, "key_block_start_lineno": 33, "key_block_end_lineno": 37, "new_func_code": "def get_model(self, model_type: str, model_id: str) -> Model:\n        \"\"\"Returns the model class based on the given model type.\n\n        Args:\n            model_type (str): The type of the model to be retrieved.\n            model_id (str): The ID of the model to be retrieved (unused in the current implementation).\n\n        Returns:\n            Model: The model class corresponding to the given model type.\n\n        Raises:\n            ModelNotRecognisedError: If the model_type is not found in the registry_dict.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.registries.roboflow.get_model_type", "project": "inference", "func": "get_model_type", "origin_file": "./Source_Copy/inference/inference/core/registries/roboflow.py", "test_list": ["tests/inference/unit_tests/core/registries/test_roboflow.py"], "prob_info": {"func_start_lineno": 111, "func_end_lineno": 198, "key_block_start_lineno": 130, "key_block_end_lineno": 198, "new_func_code": "def get_model_type(\n    model_id: ModelID,\n    api_key: Optional[str] = None,\n) -> Tuple[TaskType, ModelType]:\n    \"\"\"Retrieves the model type based on the given model ID and API key.\n\n    Args:\n        model_id (str): The ID of the model.\n        api_key (str): The API key used to authenticate.\n\n    Returns:\n        tuple: The project task type and the model type.\n\n    Raises:\n        WorkspaceLoadError: If the workspace could not be loaded or if the API key is invalid.\n        DatasetLoadError: If the dataset could not be loaded due to invalid ID, workspace ID or version ID.\n        MissingDefaultModelError: If default model is not configured and API does not provide this info\n        MalformedRoboflowAPIResponseError: Roboflow API responds in invalid format.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.registries.roboflow.RoboflowModelRegistry::get_model", "project": "inference", "func": "RoboflowModelRegistry::get_model", "origin_file": "./Source_Copy/inference/inference/core/registries/roboflow.py", "test_list": ["tests/inference/unit_tests/core/registries/test_roboflow.py"], "prob_info": {"func_start_lineno": 67, "func_end_lineno": 84, "key_block_start_lineno": 80, "key_block_end_lineno": 84, "new_func_code": "def get_model(self, model_id: ModelID, api_key: str) -> Model:\n        \"\"\"Returns the model class based on the given model id and API key.\n\n        Args:\n            model_id (str): The ID of the model to be retrieved.\n            api_key (str): The API key used to authenticate.\n\n        Returns:\n            Model: The model class corresponding to the given model ID and type.\n\n        Raises:\n            ModelNotRecognisedError: If the model type is not supported or found.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.preprocess.resize_image_keeping_aspect_ratio", "project": "inference", "func": "resize_image_keeping_aspect_ratio", "origin_file": "./Source_Copy/inference/inference/core/utils/preprocess.py", "test_list": ["tests/inference/unit_tests/core/utils/test_drawing.py"], "prob_info": {"func_start_lineno": 253, "func_end_lineno": 298, "key_block_start_lineno": 264, "key_block_end_lineno": 298, "new_func_code": "def resize_image_keeping_aspect_ratio(\n    image: ImageMetaType,\n    desired_size: Tuple[int, int],\n) -> ImageMetaType:\n    \"\"\"\n    Resize reserving its aspect ratio.\n\n    Parameters:\n    - image: numpy array representing the image.\n    - desired_size: tuple (width, height) representing the target dimensions.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.environment.str2bool", "project": "inference", "func": "str2bool", "origin_file": "./Source_Copy/inference/inference/core/utils/environment.py", "test_list": ["tests/inference/unit_tests/core/utils/test_environment.py"], "prob_info": {"func_start_lineno": 26, "func_end_lineno": 52, "key_block_start_lineno": 39, "key_block_end_lineno": 52, "new_func_code": "def str2bool(value: Any) -> bool:\n    \"\"\"\n    Converts an environment variable to a boolean value.\n\n    Args:\n        value (str or bool): The environment variable value to be converted.\n\n    Returns:\n        bool: The converted boolean value.\n\n    Raises:\n        InvalidEnvironmentVariableError: If the value is not 'true', 'false', or a boolean.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.environment.safe_split_value", "project": "inference", "func": "safe_split_value", "origin_file": "./Source_Copy/inference/inference/core/utils/environment.py", "test_list": ["tests/inference/unit_tests/core/utils/test_environment.py"], "prob_info": {"func_start_lineno": 55, "func_end_lineno": 69, "key_block_start_lineno": 66, "key_block_end_lineno": 69, "new_func_code": "def safe_split_value(value: Optional[str], delimiter: str = \",\") -> Optional[List[str]]:\n    \"\"\"\n    Splits a separated environment variable into a list.\n\n    Args:\n        value (str): The environment variable value to be split.\n        delimiter(str): Delimiter to be used\n\n    Returns:\n        list or None: The split values as a list, or None if the input is None.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.load_image_from_encoded_bytes", "project": "inference", "func": "load_image_from_encoded_bytes", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/utils/test_image_utils.py"], "prob_info": {"func_start_lineno": 496, "func_end_lineno": 516, "key_block_start_lineno": 509, "key_block_end_lineno": 516, "new_func_code": "def load_image_from_encoded_bytes(\n    value: bytes, cv_imread_flags: int = cv2.IMREAD_COLOR\n) -> np.ndarray:\n    \"\"\"\n    Load an image from encoded bytes.\n\n    Args:\n        value (bytes): The byte sequence representing the image.\n        cv_imread_flags (int): OpenCV flags used for image reading.\n\n    Returns:\n        np.ndarray: The loaded image as a numpy array.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.load_image_from_numpy_str", "project": "inference", "func": "load_image_from_numpy_str", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/utils/test_image_utils.py"], "prob_info": {"func_start_lineno": 318, "func_end_lineno": 345, "key_block_start_lineno": 330, "key_block_end_lineno": 345, "new_func_code": "def load_image_from_numpy_str(value: Union[bytes, str]) -> np.ndarray:\n    \"\"\"Loads an image from a numpy array string.\n\n    Args:\n        value (Union[bytes, str]): Base64 string or byte sequence representing the pickled numpy array of the image.\n\n    Returns:\n        Image.Image: The loaded PIL image.\n\n    Raises:\n        InvalidNumpyInput: If the numpy data is invalid.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.load_image_from_buffer", "project": "inference", "func": "load_image_from_buffer", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/utils/test_image_utils.py"], "prob_info": {"func_start_lineno": 295, "func_end_lineno": 315, "key_block_start_lineno": 307, "key_block_end_lineno": 315, "new_func_code": "def load_image_from_buffer(\n    value: _IOBase,\n    cv_imread_flags: int = cv2.IMREAD_COLOR,\n) -> np.ndarray:\n    \"\"\"Loads an image from a multipart-encoded input.\n\n    Args:\n        value (Any): Multipart-encoded input representing the image.\n\n    Returns:\n        Image.Image: The loaded PIL image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.load_image_base64", "project": "inference", "func": "load_image_base64", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/utils/test_image_utils.py"], "prob_info": {"func_start_lineno": 258, "func_end_lineno": 292, "key_block_start_lineno": 269, "key_block_end_lineno": 292, "new_func_code": "def load_image_base64(\n    value: Union[str, bytes], cv_imread_flags=cv2.IMREAD_COLOR\n) -> np.ndarray:\n    \"\"\"Loads an image from a base64 encoded string using OpenCV.\n\n    Args:\n        value (str): Base64 encoded string representing the image.\n\n    Returns:\n        np.ndarray: The loaded image as a numpy array.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.postprocess.cosine_similarity", "project": "inference", "func": "cosine_similarity", "origin_file": "./Source_Copy/inference/inference/core/utils/postprocess.py", "test_list": ["tests/inference/unit_tests/core/utils/test_postprocess.py"], "prob_info": {"func_start_lineno": 14, "func_end_lineno": 25, "key_block_start_lineno": 25, "key_block_end_lineno": 25, "new_func_code": "def cosine_similarity(a: np.ndarray, b: np.ndarray) -> Union[np.number, np.ndarray]:\n    \"\"\"\n    Compute the cosine similarity between two vectors.\n\n    Args:\n        a (np.ndarray): Vector A.\n        b (np.ndarray): Vector B.\n\n    Returns:\n        float: Cosine similarity between vectors A and B.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.postprocess.crop_mask", "project": "inference", "func": "crop_mask", "origin_file": "./Source_Copy/inference/inference/core/utils/postprocess.py", "test_list": ["tests/inference/unit_tests/core/utils/test_postprocess.py"], "prob_info": {"func_start_lineno": 374, "func_end_lineno": 390, "key_block_start_lineno": 383, "key_block_end_lineno": 390, "new_func_code": "def crop_mask(masks: np.ndarray, boxes: np.ndarray) -> np.ndarray:\n    \"\"\"\n    \"Crop\" predicted masks by zeroing out everything not in the predicted bbox.\n    Vectorized by Chong (thanks Chong).\n\n    Args:\n        - masks should be a size [h, w, n] tensor of masks\n        - boxes should be a size [n, 4] tensor of bbox coords in relative point form\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.postprocess.get_static_crop_dimensions", "project": "inference", "func": "get_static_crop_dimensions", "origin_file": "./Source_Copy/inference/inference/core/utils/postprocess.py", "test_list": ["tests/inference/unit_tests/core/utils/test_postprocess.py"], "prob_info": {"func_start_lineno": 473, "func_end_lineno": 513, "key_block_start_lineno": 489, "key_block_end_lineno": 513, "new_func_code": "def get_static_crop_dimensions(\n    orig_shape: Tuple[int, int],\n    preproc: dict,\n    disable_preproc_static_crop: bool = False,\n) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Generates a transformation based on preprocessing configuration.\n\n    Args:\n        orig_shape (tuple): The original shape of the object (e.g., image) - (height, width).\n        preproc (dict): Preprocessing configuration dictionary, containing information such as static cropping.\n        disable_preproc_static_crop (bool, optional): If true, the static crop preprocessing step is disabled for this call. Default is False.\n\n    Returns:\n        tuple: A tuple containing the shift in the x and y directions, and the updated original shape after cropping.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.postprocess.post_process_bboxes", "project": "inference", "func": "post_process_bboxes", "origin_file": "./Source_Copy/inference/inference/core/utils/postprocess.py", "test_list": ["tests/inference/unit_tests/core/utils/test_postprocess.py"], "prob_info": {"func_start_lineno": 98, "func_end_lineno": 163, "key_block_start_lineno": 120, "key_block_end_lineno": 163, "new_func_code": "def post_process_bboxes(\n    predictions: List[List[List[float]]],\n    infer_shape: Tuple[int, int],\n    img_dims: List[Tuple[int, int]],\n    preproc: dict,\n    disable_preproc_static_crop: bool = False,\n    resize_method: str = \"Stretch to\",\n) -> List[List[List[float]]]:\n    \"\"\"\n    Postprocesses each patch of detections by scaling them to the original image coordinates and by shifting them based on a static crop preproc (if applied).\n\n    Args:\n        predictions (List[List[List[float]]]): The predictions output from NMS, indices are: batch x prediction x [x1, y1, x2, y2, ...].\n        infer_shape (Tuple[int, int]): The shape of the inference image.\n        img_dims (List[Tuple[int, int]]): The dimensions of the original image for each batch, indices are: batch x [height, width].\n        preproc (dict): Preprocessing configuration dictionary.\n        disable_preproc_static_crop (bool, optional): If true, the static crop preprocessing step is disabled for this call. Default is False.\n        resize_method (str, optional): Resize method for image. Defaults to \"Stretch to\".\n\n    Returns:\n        List[List[List[float]]]: The scaled and shifted predictions, indices are: batch x prediction x [x1, y1, x2, y2, ...].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.postprocess.sigmoid", "project": "inference", "func": "sigmoid", "origin_file": "./Source_Copy/inference/inference/core/utils/postprocess.py", "test_list": ["tests/inference/unit_tests/core/utils/test_postprocess.py"], "prob_info": {"func_start_lineno": 646, "func_end_lineno": 658, "key_block_start_lineno": 658, "key_block_end_lineno": 658, "new_func_code": "def sigmoid(x: Union[float, np.ndarray]) -> Union[float, np.number, np.ndarray]:\n    \"\"\"Computes the sigmoid function for the given input.\n\n    The sigmoid function is defined as:\n    f(x) = 1 / (1 + exp(-x))\n\n    Args:\n        x (float or numpy.ndarray): Input value or array for which the sigmoid function is to be computed.\n\n    Returns:\n        float or numpy.ndarray: The computed sigmoid value(s).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.postprocess.post_process_keypoints", "project": "inference", "func": "post_process_keypoints", "origin_file": "./Source_Copy/inference/inference/core/utils/postprocess.py", "test_list": ["tests/inference/unit_tests/core/utils/test_postprocess.py"], "prob_info": {"func_start_lineno": 522, "func_end_lineno": 585, "key_block_start_lineno": 547, "key_block_end_lineno": 585, "new_func_code": "def post_process_keypoints(\n    predictions: List[List[List[float]]],\n    keypoints_start_index: int,\n    infer_shape: Tuple[int, int],\n    img_dims: List[Tuple[int, int]],\n    preproc: dict,\n    disable_preproc_static_crop: bool = False,\n    resize_method: str = \"Stretch to\",\n) -> List[List[List[float]]]:\n    \"\"\"Scales and shifts keypoints based on the given image shapes and preprocessing method.\n\n    This function performs polygon scaling and shifting based on the specified resizing method and\n    pre-processing steps. The polygons are transformed according to the ratio and padding between two images.\n\n    Args:\n        predictions: predictions from model\n        keypoints_start_index: offset in the 3rd dimension pointing where in the prediction start keypoints [(x, y, cfg), ...] for each keypoint class\n        img_dims list of (tuple of int): Shape of the source image (height, width).\n        infer_shape (tuple of int): Shape of the target image (height, width).\n        preproc (object): Preprocessing details used for generating the transformation.\n        resize_method (str, optional): Resizing method, either \"Stretch to\", \"Fit (black edges) in\", \"Fit (white edges) in\", or \"Fit (grey edges) in\". Defaults to \"Stretch to\".\n        disable_preproc_static_crop: flag to disable static crop\n    Returns:\n        list of list of list: predictions with post-processed keypoints\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.preprocess.prepare", "project": "inference", "func": "prepare", "origin_file": "./Source_Copy/inference/inference/core/utils/preprocess.py", "test_list": ["tests/inference/unit_tests/core/utils/test_preprocess.py"], "prob_info": {"func_start_lineno": 35, "func_end_lineno": 104, "key_block_start_lineno": 67, "key_block_end_lineno": 104, "new_func_code": "def prepare(\n    image: np.ndarray,\n    preproc,\n    disable_preproc_contrast: bool = False,\n    disable_preproc_grayscale: bool = False,\n    disable_preproc_static_crop: bool = False,\n) -> Tuple[np.ndarray, Tuple[int, int]]:\n    \"\"\"\n    Prepares an image by applying a series of preprocessing steps defined in the `preproc` dictionary.\n\n    Args:\n        image (PIL.Image.Image): The input PIL image object.\n        preproc (dict): Dictionary containing preprocessing steps. Example:\n            {\n                \"resize\": {\"enabled\": true, \"width\": 416, \"height\": 416, \"format\": \"Stretch to\"},\n                \"static-crop\": {\"y_min\": 25, \"x_max\": 75, \"y_max\": 75, \"enabled\": true, \"x_min\": 25},\n                \"auto-orient\": {\"enabled\": true},\n                \"grayscale\": {\"enabled\": true},\n                \"contrast\": {\"enabled\": true, \"type\": \"Adaptive Equalization\"}\n            }\n        disable_preproc_contrast (bool, optional): If true, the contrast preprocessing step is disabled for this call. Default is False.\n        disable_preproc_grayscale (bool, optional): If true, the grayscale preprocessing step is disabled for this call. Default is False.\n        disable_preproc_static_crop (bool, optional): If true, the static crop preprocessing step is disabled for this call. Default is False.\n\n    Returns:\n        PIL.Image.Image: The preprocessed image object.\n        tuple: The dimensions of the image.\n\n    Note:\n        The function uses global flags like `DISABLE_PREPROC_AUTO_ORIENT`, `DISABLE_PREPROC_STATIC_CROP`, etc.\n        to conditionally enable or disable certain preprocessing steps.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.choose_image_decoding_flags", "project": "inference", "func": "choose_image_decoding_flags", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/active_learning/test_middlewares.py"], "prob_info": {"func_start_lineno": 107, "func_end_lineno": 119, "key_block_start_lineno": 116, "key_block_end_lineno": 119, "new_func_code": "def choose_image_decoding_flags(disable_preproc_auto_orient: bool) -> int:\n    \"\"\"Choose the appropriate OpenCV image decoding flags.\n\n    Args:\n        disable_preproc_auto_orient (bool): Flag to disable preprocessing auto-orientation.\n\n    Returns:\n        int: OpenCV image decoding flags.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.extract_image_payload_and_type", "project": "inference", "func": "extract_image_payload_and_type", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/active_learning/test_middlewares.py"], "prob_info": {"func_start_lineno": 122, "func_end_lineno": 149, "key_block_start_lineno": 134, "key_block_end_lineno": 149, "new_func_code": "def extract_image_payload_and_type(value: Any) -> Tuple[Any, Optional[ImageType]]:\n    \"\"\"Extract the image payload and type from the given value.\n\n    This function supports different types of image inputs (e.g., InferenceRequestImage, dict, etc.)\n    and extracts the relevant data and image type for further processing.\n\n    Args:\n        value (Any): The input value which can be an image or information to derive the image.\n\n    Returns:\n        Tuple[Any, Optional[ImageType]]: A tuple containing the extracted image data and the corresponding image type.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.interfaces.camera.video_source.get_from_queue", "project": "inference", "func": "get_from_queue", "origin_file": "./Source_Copy/inference/inference/core/interfaces/camera/video_source.py", "test_list": ["tests/inference/unit_tests/core/interfaces/camera/test_utils.py"], "prob_info": {"func_start_lineno": 1064, "func_end_lineno": 1089, "key_block_start_lineno": 1077, "key_block_end_lineno": 1089, "new_func_code": "def get_from_queue(\n    queue: Queue,\n    timeout: Optional[float] = None,\n    on_successful_read: Callable[[], None] = lambda: None,\n    purge: bool = False,\n) -> Optional[Any]:\n    \"\"\"\n    Function is supposed to take element from the queue waiting on the first element to appear using `timeout`\n    parameter. One may ask to go to the very last element of the queue and return it - then `purge` should be set\n    to True. No additional wait on new elements to appear happen and the purge stops once queue is free returning last\n    element consumed.\n    queue.task_done() and on_successful_read(...) will be called on each received element.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.interfaces.camera.utils.multiplex_videos", "project": "inference", "func": "multiplex_videos", "origin_file": "./Source_Copy/inference/inference/core/interfaces/camera/utils.py", "test_list": ["tests/inference/unit_tests/core/interfaces/camera/test_utils.py"], "prob_info": {"func_start_lineno": 239, "func_end_lineno": 324, "key_block_start_lineno": 302, "key_block_end_lineno": 324, "new_func_code": "def multiplex_videos(\n    videos: List[Union[VideoSource, str, int]],\n    max_fps: Optional[Union[float, int]] = None,\n    limiter_strategy: Optional[FPSLimiterStrategy] = None,\n    batch_collection_timeout: Optional[float] = None,\n    force_stream_reconnection: bool = True,\n    should_stop: Callable[[], bool] = never_stop,\n    on_reconnection_error: Callable[\n        [Optional[int], SourceConnectionError], None\n    ] = log_error,\n) -> Generator[List[VideoFrame], None, None]:\n    \"\"\"\n    Function that is supposed to provide a generator over frames from multiple video sources. It is capable to\n    initialise `VideoSource` from references to video files or streams and grab frames from all the sources -\n    each running individual decoding on separate thread. In each cycle it attempts to grab frames from all sources\n    (and wait at max `batch_collection_timeout` for whole batch to be collected). If frame from specific source\n    cannot be collected in that time - it is simply not included in returned list. If after batch collection list of\n    frames is empty - new collection start immediately. Collection does not account for\n    sources that lost connectivity (example: streams that went offline). If that does not happen and stream has\n    large latency - without reasonable `batch_collection_timeout` it will slow down processing - so please\n    set it up in PROD solutions. In case of video streams (not video files) - given that\n    `force_stream_reconnection=True` function will attempt to re-connect to disconnected source using background thread,\n    not impairing batch frames collection and that source is not going to block frames retrieval even if infinite\n    `batch_collection_timeout=None` is set. Similarly, when processing files - video file that is shorter than other\n    passed into processing will not block the whole flow after End Of Stream (EOS).\n\n    All sources must be accessible on start - if that's not the case - logic function raises `SourceConnectionError`\n    and closes all video sources it opened on it own. Disconnections at later stages are handled by re-connection\n    mechanism.\n\n    Args:\n        videos (List[Union[VideoSource, str, int]]): List with references to video sources. Elements can be\n            pre-initialised `VideoSource` instances, str with stream URI or file location or int representing\n            camera device attached to the PC/server running the code.\n        max_fps (Optional[Union[float, int]]): Upper-bound of processing speed - to be used when one wants at max\n            `max_fps` video frames per second to be yielded from all sources by the generator.\n        limiter_strategy (Optional[FPSLimiterStrategy]): strategy used to deal with frames decoding exceeding\n            limit of `max_fps`. For video files, in the interest of processing all frames - we recommend WAIT mode,\n             for streams - frames should be dropped on the floor with DROP strategy. Not setting the strategy equals\n             using automatic mode - WAIT if all sources are files and DROP otherwise\n        batch_collection_timeout (Optional[float]): maximum await time to get batch of predictions from all sources.\n            `None` means infinite timeout.\n        force_stream_reconnection (bool): Flag to decide on reconnection to streams (files are never re-connected)\n        should_stop (Callable[[], bool]): external stop signal that is periodically checked - to denote that\n            video consumption stopped - make the function to return True\n        on_reconnection_error (Callable[[Optional[int], SourceConnectionError], None]): Function that will be\n            called whenever source cannot re-connect after disconnection. First parameter is source_id, second\n            is connection error instance.\n\n    Returns Generator[List[VideoFrame], None, None]: allowing to iterate through frames from multiple video sources.\n\n    Raises:\n        SourceConnectionError: when one or more source is not reachable at start of generation\n\n    Example:\n        ```python\n        from inference.core.interfaces.camera.utils import multiplex_videos\n\n        for frames in multiplex_videos(videos=[\"./some.mp4\", \"./other.mp4\"]):\n             for frame in frames:\n                pass  # do something with frame\n        ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.managers.base.ModelManager::add_model", "project": "inference", "func": "ModelManager::add_model", "origin_file": "./Source_Copy/inference/inference/core/managers/base.py", "test_list": ["tests/inference/unit_tests/core/managers/test_base.py"], "prob_info": {"func_start_lineno": 42, "func_end_lineno": 66, "key_block_start_lineno": 51, "key_block_end_lineno": 66, "new_func_code": "def add_model(\n        self, model_id: str, api_key: str, model_id_alias: Optional[str] = None\n    ) -> None:\n        \"\"\"Adds a new model to the manager.\n\n        Args:\n            model_id (str): The identifier of the model.\n            model (Model): The model instance.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.load_image_with_known_type", "project": "inference", "func": "load_image_with_known_type", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/utils/test_image_utils.py"], "prob_info": {"func_start_lineno": 152, "func_end_lineno": 177, "key_block_start_lineno": 169, "key_block_end_lineno": 177, "new_func_code": "def load_image_with_known_type(\n    value: Any,\n    image_type: ImageType,\n    cv_imread_flags: int = cv2.IMREAD_COLOR,\n) -> Tuple[np.ndarray, bool]:\n    \"\"\"Load an image using the known image type.\n\n    Supports various image types (e.g., NUMPY, PILLOW, etc.) and loads them into a numpy array format.\n\n    Args:\n        value (Any): The image data.\n        image_type (ImageType): The type of the image.\n        cv_imread_flags (int): Flags used for OpenCV's imread function.\n\n    Returns:\n        Tuple[np.ndarray, bool]: A tuple of the loaded image as a numpy array and a boolean indicating if the image is in BGR format.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.active_learning.accounting.image_can_be_submitted_to_batch", "project": "inference", "func": "image_can_be_submitted_to_batch", "origin_file": "./Source_Copy/inference/inference/core/active_learning/accounting.py", "test_list": ["tests/inference/unit_tests/core/active_learning/test_accounting.py"], "prob_info": {"func_start_lineno": 10, "func_end_lineno": 52, "key_block_start_lineno": 29, "key_block_end_lineno": 52, "new_func_code": "def image_can_be_submitted_to_batch(\n    batch_name: str,\n    workspace_id: WorkspaceID,\n    dataset_id: DatasetID,\n    max_batch_images: Optional[int],\n    api_key: str,\n) -> bool:\n    \"\"\"Check if an image can be submitted to a batch.\n\n    Args:\n        batch_name: Name of the batch.\n        workspace_id: ID of the workspace.\n        dataset_id: ID of the dataset.\n        max_batch_images: Maximum number of images allowed in the batch.\n        api_key: API key to use for the request.\n\n    Returns:\n        True if the image can be submitted to the batch, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.interfaces.stream.sinks.render_boxes", "project": "inference", "func": "render_boxes", "origin_file": "./Source_Copy/inference/inference/core/interfaces/stream/sinks.py", "test_list": ["tests/inference/unit_tests/core/interfaces/stream/test_sinks.py"], "prob_info": {"func_start_lineno": 40, "func_end_lineno": 152, "key_block_start_lineno": 116, "key_block_end_lineno": 152, "new_func_code": "def render_boxes(\n    predictions: Union[dict, List[Optional[dict]]],\n    video_frame: Union[VideoFrame, List[Optional[VideoFrame]]],\n    annotator: Union[BaseAnnotator, List[BaseAnnotator]] = None,\n    display_size: Optional[Tuple[int, int]] = (1280, 720),\n    fps_monitor: Optional[sv.FPSMonitor] = DEFAULT_FPS_MONITOR,\n    display_statistics: bool = False,\n    on_frame_rendered: Callable[\n        [Union[ImageWithSourceID, List[ImageWithSourceID]]], None\n    ] = display_image,\n) -> None:\n    \"\"\"\n    Helper tool to render object detection predictions on top of video frame. It is designed\n    to be used with `InferencePipeline`, as sink for predictions. By default, it uses\n    standard `sv.BoxAnnotator()` chained with `sv.LabelAnnotator()`\n    to draw bounding boxes and resizes prediction to 1280x720 (keeping aspect ratio and adding black padding).\n    One may configure default behaviour, for instance to display latency and throughput statistics.\n    In batch mode it will display tiles of frames and overlay predictions.\n\n    This sink is only partially compatible with stubs and classification models (it will not fail,\n    although predictions will not be displayed).\n\n    Since version `0.9.18`, when multi-source InferencePipeline was introduced - it support batch input, without\n    changes to old functionality when single (predictions, video_frame) is used.\n\n    Args:\n        predictions (Union[dict, List[Optional[dict]]]): Roboflow predictions, the function support single prediction\n            processing and batch processing since version `0.9.18`. Batch predictions elements are optional, but\n            should occur at the same position as `video_frame` list. Order is expected to match with `video_frame`.\n        video_frame (Union[VideoFrame, List[Optional[VideoFrame]]]): frame of video with its basic metadata emitted\n            by `VideoSource` or list of frames from (it is possible for empty batch frames at corresponding positions\n            to `predictions` list). Order is expected to match with `predictions`\n        annotator (Union[BaseAnnotator, List[BaseAnnotator]]): instance of class inheriting from supervision BaseAnnotator\n            or list of such instances. If nothing is passed chain of `sv.BoxAnnotator()` and `sv.LabelAnnotator()` is used.\n        display_size (Tuple[int, int]): tuple in format (width, height) to resize visualisation output\n        fps_monitor (Optional[sv.FPSMonitor]): FPS monitor used to monitor throughput\n        display_statistics (bool): Flag to decide if throughput and latency can be displayed in the result image,\n            if enabled, throughput will only be presented if `fps_monitor` is not None\n        on_frame_rendered (Callable[[Union[ImageWithSourceID, List[ImageWithSourceID]]], None]): callback to be\n            called once frame is rendered - by default, function will display OpenCV window. It expects optional integer\n            identifier with np.ndarray or list of those elements. Identifier is supposed to refer to either source_id\n            (for sequential input) or position in the batch (from 0 to batch_size-1).\n\n    Returns: None\n    Side effects: on_frame_rendered() is called against the tuple (stream_id, np.ndarray) produced from video\n        frame and predictions.\n\n    Example:\n        ```python\n        from functools import partial\n        import cv2\n        from inference import InferencePipeline\n        from inference.core.interfaces.stream.sinks import render_boxes\n\n        output_size = (640, 480)\n        video_sink = cv2.VideoWriter(\"output.avi\", cv2.VideoWriter_fourcc(*\"MJPG\"), 25.0, output_size)\n        on_prediction = partial(\n            render_boxes,\n            display_size=output_size,\n            on_frame_rendered=lambda frame_data: video_sink.write(frame_data[1])\n        )\n\n        pipeline = InferencePipeline.init(\n             model_id=\"your-model/3\",\n             video_reference=\"./some_file.mp4\",\n             on_prediction=on_prediction,\n        )\n        pipeline.start()\n        pipeline.join()\n        video_sink.release()\n        ```\n\n        In this example, `render_boxes()` is used as a sink for `InferencePipeline` predictions - making frames with\n        predictions displayed to be saved into video file. Please note that this is oversimplified example of usage\n        which will not be robust against multiple streams - better implementation available in `VideoFileSink` class.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.interfaces.stream.sinks.multi_sink", "project": "inference", "func": "multi_sink", "origin_file": "./Source_Copy/inference/inference/core/interfaces/stream/sinks.py", "test_list": ["tests/inference/unit_tests/core/interfaces/stream/test_sinks.py"], "prob_info": {"func_start_lineno": 321, "func_end_lineno": 366, "key_block_start_lineno": 360, "key_block_end_lineno": 366, "new_func_code": "def multi_sink(\n    predictions: Union[dict, List[Optional[dict]]],\n    video_frame: Union[VideoFrame, List[Optional[VideoFrame]]],\n    sinks: List[SinkHandler],\n) -> None:\n    \"\"\"\n    Helper util useful to combine multiple sinks together, while using `InferencePipeline`.\n\n    Args:\n        video_frame (VideoFrame): frame of video with its basic metadata emitted by `VideoSource`\n        predictions (dict): Roboflow object detection predictions with Bounding Boxes\n        sinks (List[Callable[[VideoFrame, dict], None]]): list of sinks to be used. Each will be executed\n            one-by-one in the order pointed in input list, all errors will be caught and reported via logger,\n            without re-raising.\n\n    Returns: None\n    Side effects: Uses all sinks in context if (video_frame, predictions) input.\n\n    Example:\n        ```python\n        from functools import partial\n        import cv2\n        from inference import InferencePipeline\n        from inference.core.interfaces.stream.sinks import UDPSink, render_boxes\n\n        udp_sink = UDPSink(ip_address=\"127.0.0.1\", port=9090)\n        on_prediction = partial(multi_sink, sinks=[udp_sink.send_predictions, render_boxes])\n\n        pipeline = InferencePipeline.init(\n            model_id=\"your-model/3\",\n            video_reference=\"./some_file.mp4\",\n            on_prediction=on_prediction,\n        )\n        pipeline.start()\n        pipeline.join()\n        ```\n\n        As a result, predictions will both be sent via UDP socket and displayed in the screen.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.interfaces.stream.sinks.active_learning_sink", "project": "inference", "func": "active_learning_sink", "origin_file": "./Source_Copy/inference/inference/core/interfaces/stream/sinks.py", "test_list": ["tests/inference/unit_tests/core/interfaces/stream/test_sinks.py"], "prob_info": {"func_start_lineno": 369, "func_end_lineno": 403, "key_block_start_lineno": 394, "key_block_end_lineno": 403, "new_func_code": "def active_learning_sink(\n    predictions: Union[dict, List[Optional[dict]]],\n    video_frame: Union[VideoFrame, List[Optional[VideoFrame]]],\n    active_learning_middleware: ActiveLearningMiddleware,\n    model_type: str,\n    disable_preproc_auto_orient: bool = False,\n) -> None:\n    \"\"\"\n    Function to serve as Active Learning sink for InferencePipeline.\n\n    Args:\n        predictions (Union[dict, List[Optional[dict]]]): Roboflow predictions, the function support single prediction\n            processing and batch processing since version `0.9.18`. Batch predictions elements are optional, but\n            should occur at the same position as `video_frame` list. Order is expected to match with `video_frame`.\n        video_frame (Union[VideoFrame, List[Optional[VideoFrame]]]): frame of video with its basic metadata emitted\n            by `VideoSource` or list of frames from (it is possible for empty batch frames at corresponding positions\n            to `predictions` list). Order is expected to match with `predictions`\n        active_learning_middleware (ActiveLearningMiddleware): instance of middleware to register data.\n        model_type (str): Type of Roboflow model in use\n        disable_preproc_auto_orient (bool): Flag to denote how image is preprocessed which is important in\n            Active Learning.\n\n    Returns: None\n    Side effects: Can register data and predictions in Roboflow backend if that's the evaluation of sampling engine.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.load_image_from_url", "project": "inference", "func": "load_image_from_url", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/utils/test_image_utils.py"], "prob_info": {"func_start_lineno": 380, "func_end_lineno": 425, "key_block_start_lineno": 391, "key_block_end_lineno": 425, "new_func_code": "def load_image_from_url(\n    value: str, cv_imread_flags: int = cv2.IMREAD_COLOR\n) -> np.ndarray:\n    \"\"\"Loads an image from a given URL.\n\n    Args:\n        value (str): URL of the image.\n\n    Returns:\n        Image.Image: The loaded PIL image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.image_utils.attempt_loading_image_from_string", "project": "inference", "func": "attempt_loading_image_from_string", "origin_file": "./Source_Copy/inference/inference/core/utils/image_utils.py", "test_list": ["tests/inference/unit_tests/core/utils/test_image_utils.py"], "prob_info": {"func_start_lineno": 215, "func_end_lineno": 255, "key_block_start_lineno": 229, "key_block_end_lineno": 255, "new_func_code": "def attempt_loading_image_from_string(\n    value: Union[str, bytes, bytearray, _IOBase],\n    cv_imread_flags: int = cv2.IMREAD_COLOR,\n) -> Tuple[np.ndarray, bool]:\n    \"\"\"\n    Attempt to load an image from a string.\n\n    Args:\n        value (Union[str, bytes, bytearray, _IOBase]): The image data in string format.\n        cv_imread_flags (int): OpenCV flags used for image reading.\n\n    Returns:\n        Tuple[np.ndarray, bool]: A tuple of the loaded image in numpy array format and a boolean flag indicating if the image is in BGR format.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "inference.inference.core.utils.postprocess.post_process_polygons", "project": "inference", "func": "post_process_polygons", "origin_file": "./Source_Copy/inference/inference/core/utils/postprocess.py", "test_list": ["tests/inference/unit_tests/core/utils/test_postprocess.py"], "prob_info": {"func_start_lineno": 393, "func_end_lineno": 441, "key_block_start_lineno": 415, "key_block_end_lineno": 441, "new_func_code": "def post_process_polygons(\n    origin_shape: Tuple[int, int],\n    polys: List[List[Tuple[float, float]]],\n    infer_shape: Tuple[int, int],\n    preproc: dict,\n    resize_method: str = \"Stretch to\",\n) -> List[List[Tuple[float, float]]]:\n    \"\"\"Scales and shifts polygons based on the given image shapes and preprocessing method.\n\n    This function performs polygon scaling and shifting based on the specified resizing method and\n    pre-processing steps. The polygons are transformed according to the ratio and padding between two images.\n\n    Args:\n        origin_shape (tuple of int): Shape of the source image (height, width).\n        infer_shape (tuple of int): Shape of the target image (height, width).\n        polys (list of list of tuple): List of polygons, where each polygon is represented by a list of (x, y) coordinates.\n        preproc (object): Preprocessing details used for generating the transformation.\n        resize_method (str, optional): Resizing method, either \"Stretch to\", \"Fit (black edges) in\", \"Fit (white edges) in\", or \"Fit (grey edges) in\". Defaults to \"Stretch to\".\n\n    Returns:\n        list of list of tuple: A list of shifted and scaled polygons.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain._api.module_import.create_importer", "project": "langchain", "func": "create_importer", "origin_file": "langchain/_api/module_import.py", "test_list": ["tests/unit_tests/test_globals.py"], "prob_info": {"func_start_lineno": 15, "func_end_lineno": 148, "key_block_start_lineno": 55, "key_block_end_lineno": 148, "new_func_code": "def create_importer(\n    package: str,\n    *,\n    module_lookup: Optional[Dict[str, str]] = None,\n    deprecated_lookups: Optional[Dict[str, str]] = None,\n    fallback_module: Optional[str] = None,\n) -> Callable[[str], Any]:\n    \"\"\"Create a function that helps retrieve objects from their new locations.\n\n    The goal of this function is to help users transition from deprecated\n    imports to new imports.\n\n    The function will raise deprecation warning on loops using\n    deprecated_lookups or fallback_module.\n\n    Module lookups will import without deprecation warnings (used to speed\n    up imports from large namespaces like llms or chat models).\n\n    This function should ideally only be used with deprecated imports not with\n    existing imports that are valid, as in addition to raising deprecation warnings\n    the dynamic imports can create other issues for developers (e.g.,\n    loss of type information, IDE support for going to definition etc).\n\n    Args:\n        package: current package. Use __package__\n        module_lookup: maps name of object to the module where it is defined.\n            e.g.,\n            {\n                \"MyDocumentLoader\": (\n                    \"langchain_community.document_loaders.my_document_loader\"\n                )\n            }\n        deprecated_lookups: same as module look up, but will raise\n            deprecation warnings.\n        fallback_module: module to import from if the object is not found in\n            module_lookup or if module_lookup is not provided.\n\n    Returns:\n        A function that imports objects from the specified modules.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.agent.AgentExecutor::validate_tools", "project": "langchain", "func": "AgentExecutor::validate_tools", "origin_file": "langchain/agents/agent.py", "test_list": ["tests/unit_tests/agents/test_agent.py"], "prob_info": {"func_start_lineno": 1122, "func_end_lineno": 1143, "key_block_start_lineno": 1134, "key_block_end_lineno": 1143, "new_func_code": "def validate_tools(self) -> Self:\n        \"\"\"Validate that tools are compatible with agent.\n\n        Args:\n            values: Values to validate.\n\n        Returns:\n            Dict: Validated values.\n\n        Raises:\n            ValueError: If allowed tools are different than provided tools.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.agent.AgentExecutor::_action_agent", "project": "langchain", "func": "AgentExecutor::_action_agent", "origin_file": "langchain/agents/agent.py", "test_list": ["tests/unit_tests/agents/test_agent.py"], "prob_info": {"func_start_lineno": 1177, "func_end_lineno": 1189, "key_block_start_lineno": 1186, "key_block_end_lineno": 1189, "new_func_code": "def _action_agent(self) -> Union[BaseSingleActionAgent, BaseMultiActionAgent]:\n        \"\"\"Type cast self.agent.\n\n        If the `agent` attribute is a Runnable, it will be converted one of\n        RunnableAgentType in the validate_runnable_agent root_validator.\n\n        To support instantiating with a Runnable, here we explicitly cast the type\n        to reflect the changes made in the root_validator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.agent.AgentExecutor::iter", "project": "langchain", "func": "AgentExecutor::iter", "origin_file": "langchain/agents/agent.py", "test_list": ["tests/unit_tests/agents/test_agent_iterator.py"], "prob_info": {"func_start_lineno": 1214, "func_end_lineno": 1239, "key_block_start_lineno": 1233, "key_block_end_lineno": 1239, "new_func_code": "def iter(\n        self,\n        inputs: Any,\n        callbacks: Callbacks = None,\n        *,\n        include_run_info: bool = False,\n        async_: bool = False,  # arg kept for backwards compat, but ignored\n    ) -> AgentExecutorIterator:\n        \"\"\"Enables iteration over steps taken to reach final output.\n\n        Args:\n            inputs: Inputs to the agent.\n            callbacks: Callbacks to run.\n            include_run_info: Whether to include run info.\n            async_: Whether to run async. (Ignored)\n\n        Returns:\n            AgentExecutorIterator: Agent executor iterator object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.chains.llm.LLMChain::predict", "project": "langchain", "func": "LLMChain::predict", "origin_file": "langchain/chains/llm.py", "test_list": ["tests/unit_tests/agents/test_agent_iterator.py"], "prob_info": {"func_start_lineno": 303, "func_end_lineno": 318, "key_block_start_lineno": 318, "key_block_end_lineno": 318, "new_func_code": "def predict(self, callbacks: Callbacks = None, **kwargs: Any) -> str:\n        \"\"\"Format prompt with kwargs and pass to LLM.\n\n        Args:\n            callbacks: Callbacks to pass to LLMChain\n            **kwargs: Keys to pass to prompt template.\n\n        Returns:\n            Completion from LLM.\n\n        Example:\n            .. code-block:: python\n\n                completion = llm.predict(adjective=\"funny\")\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.mrkl.output_parser.MRKLOutputParser::parse", "project": "langchain", "func": "MRKLOutputParser::parse", "origin_file": "langchain/agents/mrkl/output_parser.py", "test_list": ["tests/unit_tests/agents/test_agent_iterator.py"], "prob_info": {"func_start_lineno": 32, "func_end_lineno": 95, "key_block_start_lineno": 45, "key_block_end_lineno": 95, "new_func_code": "def parse(self, text: str) -> Union[AgentAction, AgentFinish]:\n        \"\"\"Parse the output from the agent into\n        an AgentAction or AgentFinish object.\n\n        Args:\n            text: The text to parse.\n\n        Returns:\n            An AgentAction or AgentFinish object.\n\n        Raises:\n            OutputParserException: If the output could not be parsed.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.format_scratchpad.log.format_log_to_str", "project": "langchain", "func": "format_log_to_str", "origin_file": "langchain/agents/format_scratchpad/log.py", "test_list": ["tests/unit_tests/agents/format_scratchpad/test_log.py"], "prob_info": {"func_start_lineno": 6, "func_end_lineno": 27, "key_block_start_lineno": 23, "key_block_end_lineno": 27, "new_func_code": "def format_log_to_str(\n    intermediate_steps: List[Tuple[AgentAction, str]],\n    observation_prefix: str = \"Observation: \",\n    llm_prefix: str = \"Thought: \",\n) -> str:\n    \"\"\"Construct the scratchpad that lets the agent continue its thought process.\n\n    Args:\n        intermediate_steps: List of tuples of AgentAction and observation strings.\n        observation_prefix: Prefix to append the observation with.\n             Defaults to \"Observation: \".\n        llm_prefix: Prefix to append the llm call with.\n                Defaults to \"Thought: \".\n\n    Returns:\n        str: The scratchpad.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.format_scratchpad.log_to_messages.format_log_to_messages", "project": "langchain", "func": "format_log_to_messages", "origin_file": "langchain/agents/format_scratchpad/log_to_messages.py", "test_list": ["tests/unit_tests/agents/format_scratchpad/test_log_to_messages.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 28, "key_block_start_lineno": 21, "key_block_end_lineno": 28, "new_func_code": "def format_log_to_messages(\n    intermediate_steps: List[Tuple[AgentAction, str]],\n    template_tool_response: str = \"{observation}\",\n) -> List[BaseMessage]:\n    \"\"\"Construct the scratchpad that lets the agent continue its thought process.\n\n    Args:\n        intermediate_steps: List of tuples of AgentAction and observation strings.\n        template_tool_response: Template to format the observation with.\n             Defaults to \"{observation}\".\n\n    Returns:\n        List[BaseMessage]: The scratchpad.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.format_scratchpad.openai_functions.format_to_openai_function_messages", "project": "langchain", "func": "format_to_openai_function_messages", "origin_file": "langchain/agents/format_scratchpad/openai_functions.py", "test_list": ["tests/unit_tests/agents/format_scratchpad/test_openai_functions.py"], "prob_info": {"func_start_lineno": 56, "func_end_lineno": 74, "key_block_start_lineno": 69, "key_block_end_lineno": 74, "new_func_code": "def format_to_openai_function_messages(\n    intermediate_steps: Sequence[Tuple[AgentAction, str]],\n) -> List[BaseMessage]:\n    \"\"\"Convert (AgentAction, tool output) tuples into FunctionMessages.\n\n    Args:\n        intermediate_steps: Steps the LLM has taken to date, along with observations\n\n    Returns:\n        list of messages to send to the LLM for the next prediction\n    Raises:\n        ValueError: if the observation cannot be converted to a string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.format_scratchpad.openai_functions._convert_agent_action_to_messages", "project": "langchain", "func": "_convert_agent_action_to_messages", "origin_file": "langchain/agents/format_scratchpad/openai_functions.py", "test_list": ["tests/unit_tests/agents/format_scratchpad/test_openai_functions.py"], "prob_info": {"func_start_lineno": 8, "func_end_lineno": 27, "key_block_start_lineno": 22, "key_block_end_lineno": 27, "new_func_code": "def _convert_agent_action_to_messages(\n    agent_action: AgentAction, observation: str\n) -> List[BaseMessage]:\n    \"\"\"Convert an agent action to a message.\n\n    This code is used to reconstruct the original AI message from the agent action.\n\n    Args:\n        agent_action: Agent action to convert.\n\n    Returns:\n        AIMessage or the previous messages plus a FunctionMessage that corresponds to\n            the original tool invocation\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.format_scratchpad.openai_functions._create_function_message", "project": "langchain", "func": "_create_function_message", "origin_file": "langchain/agents/format_scratchpad/openai_functions.py", "test_list": ["tests/unit_tests/agents/format_scratchpad/test_openai_functions.py"], "prob_info": {"func_start_lineno": 30, "func_end_lineno": 53, "key_block_start_lineno": 43, "key_block_end_lineno": 53, "new_func_code": "def _create_function_message(\n    agent_action: AgentAction, observation: str\n) -> FunctionMessage:\n    \"\"\"Convert agent action and observation into a function message.\n    Args:\n        agent_action: the tool invocation request from the agent.\n        observation: the result of the tool invocation.\n    Returns:\n        FunctionMessage that corresponds to the original tool invocation.\n\n    Raises:\n        ValueError: if the observation cannot be converted to a string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.output_parsers.tools.parse_ai_message_to_tool_action", "project": "langchain", "func": "parse_ai_message_to_tool_action", "origin_file": "langchain/agents/output_parsers/tools.py", "test_list": ["tests/unit_tests/agents/format_scratchpad/test_openai_tools.py"], "prob_info": {"func_start_lineno": 22, "func_end_lineno": 77, "key_block_start_lineno": 26, "key_block_end_lineno": 77, "new_func_code": "def parse_ai_message_to_tool_action(\n    message: BaseMessage,\n) -> Union[List[AgentAction], AgentFinish]:\n    \"\"\"Parse an AI message potentially containing tool_calls.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.format_scratchpad.tools.format_to_tool_messages", "project": "langchain", "func": "format_to_tool_messages", "origin_file": "langchain/agents/format_scratchpad/tools.py", "test_list": ["tests/unit_tests/agents/format_scratchpad/test_openai_tools.py"], "prob_info": {"func_start_lineno": 42, "func_end_lineno": 63, "key_block_start_lineno": 54, "key_block_end_lineno": 63, "new_func_code": "def format_to_tool_messages(\n    intermediate_steps: Sequence[Tuple[AgentAction, str]],\n) -> List[BaseMessage]:\n    \"\"\"Convert (AgentAction, tool output) tuples into ToolMessages.\n\n    Args:\n        intermediate_steps: Steps the LLM has taken to date, along with observations.\n\n    Returns:\n        list of messages to send to the LLM for the next prediction.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.format_scratchpad.tools._create_tool_message", "project": "langchain", "func": "_create_tool_message", "origin_file": "langchain/agents/format_scratchpad/tools.py", "test_list": ["tests/unit_tests/agents/format_scratchpad/test_openai_tools.py"], "prob_info": {"func_start_lineno": 14, "func_end_lineno": 39, "key_block_start_lineno": 28, "key_block_end_lineno": 39, "new_func_code": "def _create_tool_message(\n    agent_action: ToolAgentAction, observation: str\n) -> ToolMessage:\n    \"\"\"Convert agent action and observation into a tool message.\n\n    Args:\n        agent_action: the tool invocation request from the agent.\n        observation: the result of the tool invocation.\n    Returns:\n        ToolMessage that corresponds to the original tool invocation.\n\n    Raises:\n        ValueError: if the observation cannot be converted to a string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.format_scratchpad.xml.format_xml", "project": "langchain", "func": "format_xml", "origin_file": "langchain/agents/format_scratchpad/xml.py", "test_list": ["tests/unit_tests/agents/format_scratchpad/test_xml.py"], "prob_info": {"func_start_lineno": 6, "func_end_lineno": 23, "key_block_start_lineno": 17, "key_block_end_lineno": 23, "new_func_code": "def format_xml(\n    intermediate_steps: List[Tuple[AgentAction, str]],\n) -> str:\n    \"\"\"Format the intermediate steps as XML.\n\n    Args:\n        intermediate_steps: The intermediate steps.\n\n    Returns:\n        The intermediate steps as XML.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.chains.history_aware_retriever.create_history_aware_retriever", "project": "langchain", "func": "create_history_aware_retriever", "origin_file": "langchain/chains/history_aware_retriever.py", "test_list": ["tests/unit_tests/chains/test_history_aware_retriever.py"], "prob_info": {"func_start_lineno": 10, "func_end_lineno": 67, "key_block_start_lineno": 51, "key_block_end_lineno": 67, "new_func_code": "def create_history_aware_retriever(\n    llm: LanguageModelLike,\n    retriever: RetrieverLike,\n    prompt: BasePromptTemplate,\n) -> RetrieverOutputLike:\n    \"\"\"Create a chain that takes conversation history and returns documents.\n\n    If there is no `chat_history`, then the `input` is just passed directly to the\n    retriever. If there is `chat_history`, then the prompt and LLM will be used\n    to generate a search query. That search query is then passed to the retriever.\n\n    Args:\n        llm: Language model to use for generating a search term given chat history\n        retriever: RetrieverLike object that takes a string as input and outputs\n            a list of Documents.\n        prompt: The prompt used to generate the search query for the retriever.\n\n    Returns:\n        An LCEL Runnable. The runnable input must take in `input`, and if there\n        is chat history should take it in the form of `chat_history`.\n        The Runnable output is a list of Documents\n\n    Example:\n        .. code-block:: python\n\n            # pip install -U langchain langchain-community\n\n            from langchain_community.chat_models import ChatOpenAI\n            from langchain.chains import create_history_aware_retriever\n            from langchain import hub\n\n            rephrase_prompt = hub.pull(\"langchain-ai/chat-langchain-rephrase\")\n            llm = ChatOpenAI()\n            retriever = ...\n            chat_retriever_chain = create_history_aware_retriever(\n                llm, retriever, rephrase_prompt\n            )\n\n            chain.invoke({\"input\": \"...\", \"chat_history\": })\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.memory.utils.get_prompt_input_key", "project": "langchain", "func": "get_prompt_input_key", "origin_file": "langchain/memory/utils.py", "test_list": ["tests/unit_tests/chains/test_sequential.py"], "prob_info": {"func_start_lineno": 4, "func_end_lineno": 20, "key_block_start_lineno": 15, "key_block_end_lineno": 20, "new_func_code": "def get_prompt_input_key(inputs: Dict[str, Any], memory_variables: List[str]) -> str:\n    \"\"\"\n    Get the prompt input key.\n\n    Args:\n        inputs: Dict[str, Any]\n        memory_variables: List[str]\n\n    Returns:\n        A prompt input key.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.globals.get_verbose", "project": "langchain", "func": "get_verbose", "origin_file": "langchain/globals.py", "test_list": ["tests/unit_tests/chains/test_transform.py"], "prob_info": {"func_start_lineno": 44, "func_end_lineno": 71, "key_block_start_lineno": 46, "key_block_end_lineno": 71, "new_func_code": "def get_verbose() -> bool:\n    \"\"\"Get the value of the `verbose` global setting.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.embeddings.base._parse_model_string", "project": "langchain", "func": "_parse_model_string", "origin_file": "langchain/embeddings/base.py", "test_list": ["tests/unit_tests/embeddings/test_base.py"], "prob_info": {"func_start_lineno": 28, "func_end_lineno": 76, "key_block_start_lineno": 52, "key_block_end_lineno": 76, "new_func_code": "def _parse_model_string(model_name: str) -> Tuple[str, str]:\n    \"\"\"Parse a model string into provider and model name components.\n\n    The model string should be in the format 'provider:model-name', where provider\n    is one of the supported providers.\n\n    Args:\n        model_name: A model string in the format 'provider:model-name'\n\n    Returns:\n        A tuple of (provider, model_name)\n\n    .. code-block:: python\n\n        _parse_model_string(\"openai:text-embedding-3-small\")\n        # Returns: (\"openai\", \"text-embedding-3-small\")\n\n        _parse_model_string(\"bedrock:amazon.titan-embed-text-v1\")\n        # Returns: (\"bedrock\", \"amazon.titan-embed-text-v1\")\n\n    Raises:\n        ValueError: If the model string is not in the correct format or\n            the provider is unsupported\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.comparison.eval_chain.resolve_pairwise_criteria", "project": "langchain", "func": "resolve_pairwise_criteria", "origin_file": "langchain/evaluation/comparison/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/comparison/test_eval_chain.py"], "prob_info": {"func_start_lineno": 51, "func_end_lineno": 95, "key_block_start_lineno": 64, "key_block_end_lineno": 95, "new_func_code": "def resolve_pairwise_criteria(\n    criteria: Optional[Union[CRITERIA_TYPE, str, List[CRITERIA_TYPE]]],\n) -> dict:\n    \"\"\"Resolve the criteria for the pairwise evaluator.\n\n    Args:\n        criteria (Union[CRITERIA_TYPE, str, List[CRITERIA_TYPE]], optional):\n        The criteria to use.\n\n    Returns:\n        dict: The resolved criteria.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.comparison.eval_chain.PairwiseStringResultOutputParser::parse", "project": "langchain", "func": "PairwiseStringResultOutputParser::parse", "origin_file": "langchain/evaluation/comparison/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/comparison/test_eval_chain.py"], "prob_info": {"func_start_lineno": 116, "func_end_lineno": 151, "key_block_start_lineno": 129, "key_block_end_lineno": 151, "new_func_code": "def parse(self, text: str) -> Dict[str, Any]:\n        \"\"\"Parse the output text.\n\n        Args:\n            text (str): The output text to parse.\n\n        Returns:\n            Dict: The parsed output.\n\n        Raises:\n            ValueError: If the verdict is invalid.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.comparison.eval_chain.PairwiseStringEvalChain::_skip_reference_warning", "project": "langchain", "func": "PairwiseStringEvalChain::_skip_reference_warning", "origin_file": "langchain/evaluation/comparison/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/comparison/test_eval_chain.py"], "prob_info": {"func_start_lineno": 219, "func_end_lineno": 230, "key_block_start_lineno": 226, "key_block_end_lineno": 230, "new_func_code": "def _skip_reference_warning(self) -> str:\n        \"\"\"Return the warning to show when reference is ignored.\n\n        Returns:\n            str: The warning to show when reference is ignored.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.comparison.eval_chain.PairwiseStringEvalChain::_evaluate_string_pairs", "project": "langchain", "func": "PairwiseStringEvalChain::_evaluate_string_pairs", "origin_file": "langchain/evaluation/comparison/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/comparison/test_eval_chain.py"], "prob_info": {"func_start_lineno": 309, "func_end_lineno": 349, "key_block_start_lineno": 341, "key_block_end_lineno": 349, "new_func_code": "def _evaluate_string_pairs(\n        self,\n        *,\n        prediction: str,\n        prediction_b: str,\n        input: Optional[str] = None,\n        reference: Optional[str] = None,\n        callbacks: Callbacks = None,\n        tags: Optional[List[str]] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        include_run_info: bool = False,\n        **kwargs: Any,\n    ) -> dict:\n        \"\"\"Evaluate whether output A is preferred to output B.\n\n        Args:\n            prediction (str): The output string from the first model.\n            prediction_b (str): The output string from the second model.\n            input (str, optional): The input or task string.\n            callbacks (Callbacks, optional): The callbacks to use.\n            reference (str, optional): The reference string, if any.\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            dict: A dictionary containing:\n                - reasoning: The reasoning for the preference.\n                - value: The preference value, which is either 'A', 'B', or None\n                    for no preference.\n                - score: The preference score, which is 1 for 'A', 0 for 'B',\n                    and 0.5 for None.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.comparison.eval_chain.PairwiseStringEvalChain::_prepare_input", "project": "langchain", "func": "PairwiseStringEvalChain::_prepare_input", "origin_file": "langchain/evaluation/comparison/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/comparison/test_eval_chain.py"], "prob_info": {"func_start_lineno": 274, "func_end_lineno": 300, "key_block_start_lineno": 293, "key_block_end_lineno": 300, "new_func_code": "def _prepare_input(\n        self,\n        prediction: str,\n        prediction_b: str,\n        input: Optional[str],\n        reference: Optional[str],\n    ) -> dict:\n        \"\"\"Prepare the input for the chain.\n\n        Args:\n            prediction (str): The output string from the first model.\n            prediction_b (str): The output string from the second model.\n            input (str, optional): The input or task string.\n            reference (str, optional): The reference string, if any.\n\n        Returns:\n            dict: The prepared input for the chain.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.criteria.eval_chain.resolve_criteria", "project": "langchain", "func": "resolve_criteria", "origin_file": "langchain/evaluation/criteria/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/criteria/test_eval_chain.py"], "prob_info": {"func_start_lineno": 122, "func_end_lineno": 164, "key_block_start_lineno": 146, "key_block_end_lineno": 164, "new_func_code": "def resolve_criteria(\n    criteria: Optional[Union[CRITERIA_TYPE, str]],\n) -> Dict[str, str]:\n    \"\"\"Resolve the criteria to evaluate.\n\n    Parameters\n    ----------\n    criteria : CRITERIA_TYPE\n        The criteria to evaluate the runs against. It can be:\n            -  a mapping of a criterion name to its description\n            -  a single criterion name present in one of the default criteria\n            -  a single `ConstitutionalPrinciple` instance\n\n    Returns\n    -------\n    Dict[str, str]\n        A dictionary mapping criterion names to descriptions.\n\n    Examples\n    --------\n    >>> criterion = \"relevance\"\n    >>> CriteriaEvalChain.resolve_criteria(criteria)\n    {'relevance': 'Is the submission referring to a real quote from the text?'}\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.criteria.eval_chain.CriteriaResultOutputParser::parse", "project": "langchain", "func": "CriteriaResultOutputParser::parse", "origin_file": "langchain/evaluation/criteria/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/criteria/test_eval_chain.py"], "prob_info": {"func_start_lineno": 71, "func_end_lineno": 112, "key_block_start_lineno": 80, "key_block_end_lineno": 112, "new_func_code": "def parse(self, text: str) -> Dict[str, Any]:\n        \"\"\"Parse the output text.\n\n        Args:\n            text (str): The output text to parse.\n\n        Returns:\n            Dict: The parsed output.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.exact_match.base.ExactMatchStringEvaluator::_evaluate_strings", "project": "langchain", "func": "ExactMatchStringEvaluator::_evaluate_strings", "origin_file": "langchain/evaluation/exact_match/base.py", "test_list": ["tests/unit_tests/evaluation/exact_match/test_base.py"], "prob_info": {"func_start_lineno": 71, "func_end_lineno": 97, "key_block_start_lineno": 88, "key_block_end_lineno": 97, "new_func_code": "def _evaluate_strings(  # type: ignore[arg-type,override]\n        self,\n        *,\n        prediction: str,\n        reference: str,\n        **kwargs: Any,\n    ) -> dict:\n        \"\"\"\n        Evaluate the exact match between the prediction and the reference.\n\n        Args:\n            prediction (str): The prediction string.\n            reference (Optional[str], optional): The reference string.\n\n        Returns:\n            dict: The evaluation results containing the score.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.parsing.base.JsonValidityEvaluator::_evaluate_strings", "project": "langchain", "func": "JsonValidityEvaluator::_evaluate_strings", "origin_file": "langchain/evaluation/parsing/base.py", "test_list": ["tests/unit_tests/evaluation/parsing/test_base.py"], "prob_info": {"func_start_lineno": 52, "func_end_lineno": 77, "key_block_start_lineno": 73, "key_block_end_lineno": 77, "new_func_code": "def _evaluate_strings(\n        self,\n        prediction: str,\n        input: Optional[str] = None,\n        reference: Optional[str] = None,\n        **kwargs: Any,\n    ) -> dict:\n        \"\"\"Evaluate the prediction string.\n\n        Args:\n            prediction (str): The prediction string to evaluate.\n            input (str, optional): Not used in this evaluator. Defaults to None.\n            reference (str, optional): Not used in this evaluator. Defaults to None.\n\n        Returns:\n            dict: A dictionary containing the evaluation score. The score is 1 if\n            the prediction is valid JSON, and 0 otherwise.\n                If the prediction is not valid JSON, the dictionary also contains\n                a \"reasoning\" field with the error message.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.parsing.base.JsonEqualityEvaluator::_evaluate_strings", "project": "langchain", "func": "JsonEqualityEvaluator::_evaluate_strings", "origin_file": "langchain/evaluation/parsing/base.py", "test_list": ["tests/unit_tests/evaluation/parsing/test_base.py"], "prob_info": {"func_start_lineno": 135, "func_end_lineno": 159, "key_block_start_lineno": 152, "key_block_end_lineno": 159, "new_func_code": "def _evaluate_strings(\n        self,\n        prediction: str,\n        input: Optional[str] = None,\n        reference: Optional[str] = None,\n        **kwargs: Any,\n    ) -> dict:\n        \"\"\"Evaluate the prediction string.\n\n        Args:\n            prediction (str): The prediction string to evaluate.\n            input (str, optional): Not used in this evaluator.\n            reference (str): The reference string to compare against.\n\n        Returns:\n            dict: A dictionary containing the evaluation score.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.qa.eval_chain.QAEvalChain::_evaluate_strings", "project": "langchain", "func": "QAEvalChain::_evaluate_strings", "origin_file": "langchain/evaluation/qa/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/qa/test_eval_chain.py"], "prob_info": {"func_start_lineno": 155, "func_end_lineno": 188, "key_block_start_lineno": 179, "key_block_end_lineno": 188, "new_func_code": "def _evaluate_strings(\n        self,\n        *,\n        prediction: str,\n        reference: Optional[str] = None,\n        input: Optional[str] = None,\n        callbacks: Callbacks = None,\n        include_run_info: bool = False,\n        **kwargs: Any,\n    ) -> dict:\n        \"\"\"Evaluate Chain or LLM output, based on optional input and label.\n\n        Args:\n            prediction (str): the LLM or chain prediction to evaluate.\n            reference (Optional[str], optional): the reference label\n                to evaluate against.\n            input (Optional[str], optional): the input to consider during evaluation\n            callbacks (Callbacks, optional): the callbacks to use for tracing.\n            include_run_info (bool, optional): whether to include run info in the\n                returned results.\n            **kwargs: additional keyword arguments, including callbacks, tags, etc.\n        Returns:\n            dict: The evaluation results containing the score or value.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.regex_match.base.RegexMatchStringEvaluator::_evaluate_strings", "project": "langchain", "func": "RegexMatchStringEvaluator::_evaluate_strings", "origin_file": "langchain/evaluation/regex_match/base.py", "test_list": ["tests/unit_tests/evaluation/regex_match/test_base.py"], "prob_info": {"func_start_lineno": 68, "func_end_lineno": 86, "key_block_start_lineno": 85, "key_block_end_lineno": 86, "new_func_code": "def _evaluate_strings(  # type: ignore[arg-type,override]\n        self,\n        *,\n        prediction: str,\n        reference: str,\n        **kwargs: Any,\n    ) -> dict:\n        \"\"\"\n        Evaluate the regex match between the prediction and the reference.\n\n        Args:\n            prediction (str): The prediction string.\n            reference (Optional[str], optional): The reference regex pattern.\n\n        Returns:\n            dict: The evaluation results containing the score.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.scoring.eval_chain.ScoreStringResultOutputParser::parse", "project": "langchain", "func": "ScoreStringResultOutputParser::parse", "origin_file": "langchain/evaluation/scoring/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/scoring/test_eval_chain.py"], "prob_info": {"func_start_lineno": 116, "func_end_lineno": 144, "key_block_start_lineno": 129, "key_block_end_lineno": 144, "new_func_code": "def parse(self, text: str) -> Dict[str, Any]:\n        \"\"\"Parse the output text.\n\n        Args:\n            text (str): The output text to parse.\n\n        Returns:\n            Dict: The parsed output.\n\n        Raises:\n            ValueError: If the verdict is invalid.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.scoring.eval_chain.resolve_criteria", "project": "langchain", "func": "resolve_criteria", "origin_file": "langchain/evaluation/scoring/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/scoring/test_eval_chain.py"], "prob_info": {"func_start_lineno": 52, "func_end_lineno": 95, "key_block_start_lineno": 64, "key_block_end_lineno": 95, "new_func_code": "def resolve_criteria(\n    criteria: Optional[Union[CRITERIA_TYPE, str, List[CRITERIA_TYPE]]],\n) -> dict:\n    \"\"\"Resolve the criteria for the pairwise evaluator.\n\n    Args:\n        criteria (Union[CRITERIA_TYPE, str], optional): The criteria to use.\n\n    Returns:\n        dict: The resolved criteria.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.scoring.eval_chain.ScoreStringEvalChain::_skip_reference_warning", "project": "langchain", "func": "ScoreStringEvalChain::_skip_reference_warning", "origin_file": "langchain/evaluation/scoring/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/scoring/test_eval_chain.py"], "prob_info": {"func_start_lineno": 222, "func_end_lineno": 233, "key_block_start_lineno": 229, "key_block_end_lineno": 233, "new_func_code": "def _skip_reference_warning(self) -> str:\n        \"\"\"Return the warning to show when reference is ignored.\n\n        Returns:\n            str: The warning to show when reference is ignored.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.scoring.eval_chain.ScoreStringEvalChain::_evaluate_strings", "project": "langchain", "func": "ScoreStringEvalChain::_evaluate_strings", "origin_file": "langchain/evaluation/scoring/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/scoring/test_eval_chain.py"], "prob_info": {"func_start_lineno": 324, "func_end_lineno": 359, "key_block_start_lineno": 351, "key_block_end_lineno": 359, "new_func_code": "def _evaluate_strings(\n        self,\n        *,\n        prediction: str,\n        input: Optional[str] = None,\n        reference: Optional[str] = None,\n        callbacks: Callbacks = None,\n        tags: Optional[List[str]] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        include_run_info: bool = False,\n        **kwargs: Any,\n    ) -> dict:\n        \"\"\"Score the output string.\n\n        Args:\n            prediction (str): The output string from the first model.\n            input (str, optional): The input or task string.\n            callbacks (Callbacks, optional): The callbacks to use.\n            reference (str, optional): The reference string, if any.\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            dict: A dictionary containing:\n                - reasoning: The reasoning for the preference.\n                - score: A score between 1 and 10.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.evaluation.scoring.eval_chain.ScoreStringEvalChain::_prepare_input", "project": "langchain", "func": "ScoreStringEvalChain::_prepare_input", "origin_file": "langchain/evaluation/scoring/eval_chain.py", "test_list": ["tests/unit_tests/evaluation/scoring/test_eval_chain.py"], "prob_info": {"func_start_lineno": 289, "func_end_lineno": 313, "key_block_start_lineno": 307, "key_block_end_lineno": 313, "new_func_code": "def _prepare_input(\n        self,\n        prediction: str,\n        input: Optional[str],\n        reference: Optional[str],\n    ) -> dict:\n        \"\"\"Prepare the input for the chain.\n\n        Args:\n            prediction (str): The output string from the first model.\n            prediction_b (str): The output string from the second model.\n            input (str, optional): The input or task string.\n            reference (str, optional): The reference string, if any.\n\n        Returns:\n            dict: The prepared input for the chain.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.output_parsers.retry.RetryOutputParser::parse_with_prompt", "project": "langchain", "func": "RetryOutputParser::parse_with_prompt", "origin_file": "langchain/output_parsers/retry.py", "test_list": ["tests/unit_tests/output_parsers/test_retry.py"], "prob_info": {"func_start_lineno": 92, "func_end_lineno": 125, "key_block_start_lineno": 102, "key_block_end_lineno": 125, "new_func_code": "def parse_with_prompt(self, completion: str, prompt_value: PromptValue) -> T:\n        \"\"\"Parse the output of an LLM call using a wrapped parser.\n\n        Args:\n            completion: The chain completion to parse.\n            prompt_value: The prompt to use to parse the completion.\n\n        Returns:\n            The parsed completion.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.retrievers.ensemble.EnsembleRetriever::rank_fusion", "project": "langchain", "func": "EnsembleRetriever::rank_fusion", "origin_file": "langchain/retrievers/ensemble.py", "test_list": ["tests/unit_tests/retrievers/test_ensemble.py"], "prob_info": {"func_start_lineno": 203, "func_end_lineno": 242, "key_block_start_lineno": 220, "key_block_end_lineno": 242, "new_func_code": "def rank_fusion(\n        self,\n        query: str,\n        run_manager: CallbackManagerForRetrieverRun,\n        *,\n        config: Optional[RunnableConfig] = None,\n    ) -> List[Document]:\n        \"\"\"\n        Retrieve the results of the retrievers and use rank_fusion_func to get\n        the final result.\n\n        Args:\n            query: The query to search for.\n\n        Returns:\n            A list of reranked documents.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.retrievers.ensemble.unique_by_key", "project": "langchain", "func": "unique_by_key", "origin_file": "langchain/retrievers/ensemble.py", "test_list": ["tests/unit_tests/retrievers/test_ensemble.py"], "prob_info": {"func_start_lineno": 40, "func_end_lineno": 54, "key_block_start_lineno": 50, "key_block_end_lineno": 54, "new_func_code": "def unique_by_key(iterable: Iterable[T], key: Callable[[T], H]) -> Iterator[T]:\n    \"\"\"Yield unique elements of an iterable based on a key function.\n\n    Args:\n        iterable: The iterable to filter.\n        key: A function that returns a hashable key for each element.\n\n    Yields:\n        Unique elements of the iterable based on the key function.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.smith.evaluation.runner_utils._get_messages", "project": "langchain", "func": "_get_messages", "origin_file": "langchain/smith/evaluation/runner_utils.py", "test_list": ["tests/unit_tests/smith/evaluation/test_runner_utils.py"], "prob_info": {"func_start_lineno": 292, "func_end_lineno": 328, "key_block_start_lineno": 303, "key_block_end_lineno": 328, "new_func_code": "def _get_messages(inputs: Dict[str, Any]) -> dict:\n    \"\"\"Get Chat Messages from inputs.\n\n    Args:\n        inputs: The input dictionary.\n\n    Returns:\n        A list of chat messages.\n    Raises:\n        InputFormatError: If the input format is invalid.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.smith.evaluation.runner_utils._get_prompt", "project": "langchain", "func": "_get_prompt", "origin_file": "langchain/smith/evaluation/runner_utils.py", "test_list": ["tests/unit_tests/smith/evaluation/test_runner_utils.py"], "prob_info": {"func_start_lineno": 232, "func_end_lineno": 279, "key_block_start_lineno": 243, "key_block_end_lineno": 279, "new_func_code": "def _get_prompt(inputs: Dict[str, Any]) -> str:\n    \"\"\"Get prompt from inputs.\n\n    Args:\n        inputs: The input dictionary.\n\n    Returns:\n        A string prompt.\n    Raises:\n        InputFormatError: If the input format is invalid.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.smith.evaluation.runner_utils._run_llm_or_chain", "project": "langchain", "func": "_run_llm_or_chain", "origin_file": "langchain/smith/evaluation/runner_utils.py", "test_list": ["tests/unit_tests/smith/evaluation/test_runner_utils.py"], "prob_info": {"func_start_lineno": 910, "func_end_lineno": 963, "key_block_start_lineno": 930, "key_block_end_lineno": 963, "new_func_code": "def _run_llm_or_chain(\n    example: Example,\n    config: RunnableConfig,\n    *,\n    llm_or_chain_factory: MCF,\n    input_mapper: Optional[Callable[[Dict], Any]] = None,\n) -> Union[dict, str, LLMResult, ChatResult]:\n    \"\"\"\n    Run the Chain or language model synchronously.\n\n    Args:\n        example: The example to run.\n        llm_or_chain_factory: The Chain or language model constructor to run.\n        tags: Optional tags to add to the run.\n        callbacks: Optional callbacks to use during the run.\n\n    Returns:\n        Union[List[dict], List[str], List[LLMResult], List[ChatResult]]:\n          The outputs of the model or chain.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.smith.evaluation.runner_utils._run_llm", "project": "langchain", "func": "_run_llm", "origin_file": "langchain/smith/evaluation/runner_utils.py", "test_list": ["tests/unit_tests/smith/evaluation/test_runner_utils.py"], "prob_info": {"func_start_lineno": 816, "func_end_lineno": 875, "key_block_start_lineno": 840, "key_block_end_lineno": 875, "new_func_code": "def _run_llm(\n    llm: BaseLanguageModel,\n    inputs: Dict[str, Any],\n    callbacks: Callbacks,\n    *,\n    tags: Optional[List[str]] = None,\n    input_mapper: Optional[Callable[[Dict], Any]] = None,\n    metadata: Optional[Dict[str, Any]] = None,\n) -> Union[str, BaseMessage]:\n    \"\"\"\n    Run the language model on the example.\n\n    Args:\n        llm: The language model to run.\n        inputs: The input dictionary.\n        callbacks: The callbacks to use during the run.\n        tags: Optional tags to add to the run.\n        input_mapper: function to map to the inputs dictionary from an Example\n    Returns:\n        The LLMResult or ChatResult.\n    Raises:\n        ValueError: If the LLM type is unsupported.\n        InputFormatError: If the input format is invalid.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.agent.AgentExecutor::stream", "project": "langchain", "func": "AgentExecutor::stream", "origin_file": "langchain/agents/agent.py", "test_list": ["tests/unit_tests/agents/test_agent.py"], "prob_info": {"func_start_lineno": 1745, "func_end_lineno": 1774, "key_block_start_lineno": 1761, "key_block_end_lineno": 1774, "new_func_code": "def stream(\n        self,\n        input: Union[Dict[str, Any], Any],\n        config: Optional[RunnableConfig] = None,\n        **kwargs: Any,\n    ) -> Iterator[AddableDict]:\n        \"\"\"Enables streaming over steps taken to reach final output.\n\n        Args:\n            input: Input to the agent.\n            config: Config to use.\n            kwargs: Additional arguments.\n\n        Yields:\n            AddableDict: Addable dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.agents.agent_iterator.AgentExecutorIterator::_process_next_step_output", "project": "langchain", "func": "AgentExecutorIterator::_process_next_step_output", "origin_file": "langchain/agents/agent_iterator.py", "test_list": ["tests/unit_tests/agents/test_agent_iterator.py"], "prob_info": {"func_start_lineno": 312, "func_end_lineno": 338, "key_block_start_lineno": 321, "key_block_end_lineno": 338, "new_func_code": "def _process_next_step_output(\n        self,\n        next_step_output: Union[AgentFinish, List[Tuple[AgentAction, str]]],\n        run_manager: CallbackManagerForChainRun,\n    ) -> AddableDict:\n        \"\"\"\n        Process the output of the next step,\n        handling AgentFinish and tool return cases.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.output_parsers.datetime._generate_random_datetime_strings", "project": "langchain", "func": "_generate_random_datetime_strings", "origin_file": "langchain/output_parsers/datetime.py", "test_list": ["tests/unit_tests/output_parsers/test_fix.py"], "prob_info": {"func_start_lineno": 10, "func_end_lineno": 30, "key_block_start_lineno": 23, "key_block_end_lineno": 30, "new_func_code": "def _generate_random_datetime_strings(\n    pattern: str,\n    n: int = 3,\n    start_date: datetime = datetime(1, 1, 1),\n    end_date: datetime = datetime.now() + timedelta(days=3650),\n) -> List[str]:\n    \"\"\"Generates n random datetime strings conforming to the\n    given pattern within the specified date range.\n\n    Pattern should be a string containing the desired format codes.\n    start_date and end_date should be datetime objects representing\n    the start and end of the date range.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain.libs.langchain.langchain.chains.llm.LLMChain::prep_prompts", "project": "langchain", "func": "LLMChain::prep_prompts", "origin_file": "langchain/chains/llm.py", "test_list": ["tests/unit_tests/agents/test_agent_iterator.py"], "prob_info": {"func_start_lineno": 183, "func_end_lineno": 207, "key_block_start_lineno": 189, "key_block_end_lineno": 207, "new_func_code": "def prep_prompts(\n        self,\n        input_list: List[Dict[str, Any]],\n        run_manager: Optional[CallbackManagerForChainRun] = None,\n    ) -> Tuple[List[PromptValue], Optional[List[str]]]:\n        \"\"\"Prepare prompts from inputs.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.common.getgrids", "project": "open-iris", "func": "getgrids", "origin_file": "iris/nodes/normalization/common.py", "test_list": ["../tests/unit_tests/nodes/normalization/test_nonlinear_normalization.py"], "prob_info": {"func_start_lineno": 53, "func_end_lineno": 67, "key_block_start_lineno": 63, "key_block_end_lineno": 67, "new_func_code": "def getgrids(res_in_r: NonNegativeInt, p2i_ratio: NonNegativeInt) -> np.ndarray:\n    \"\"\"Generate radius grids for nonlinear normalization based on p2i_ratio (pupil_to_iris ratio).\n\n    Args:\n        res_in_r (NonNegativeInt): Normalized image r resolution.\n        p2i_ratio (NonNegativeInt): pupil_to_iris ratio, range in [0,100]\n\n    Returns:\n        np.ndarray: nonlinear sampling grids for normalization\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.nonlinear_normalization.NonlinearNormalization::_generate_correspondences", "project": "open-iris", "func": "NonlinearNormalization::_generate_correspondences", "origin_file": "iris/nodes/normalization/nonlinear_normalization.py", "test_list": ["../tests/unit_tests/nodes/normalization/test_nonlinear_normalization.py"], "prob_info": {"func_start_lineno": 89, "func_end_lineno": 113, "key_block_start_lineno": 99, "key_block_end_lineno": 113, "new_func_code": "def _generate_correspondences(self, pupil_points: np.ndarray, iris_points: np.ndarray) -> np.ndarray:\n        \"\"\"Generate corresponding positions in original image.\n\n        Args:\n            pupil_points (np.ndarray): Pupil bounding points. NumPy array of shape (num_points x 2).\n            iris_points (np.ndarray): Iris bounding points. NumPy array of shape (num_points x 2).\n\n        Returns:\n            np.ndarray: generated corresponding points.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.utils.math.estimate_diameter", "project": "open-iris", "func": "estimate_diameter", "origin_file": "iris/utils/math.py", "test_list": ["../tests/unit_tests/nodes/normalization/test_nonlinear_normalization.py"], "prob_info": {"func_start_lineno": 38, "func_end_lineno": 50, "key_block_start_lineno": 50, "key_block_end_lineno": 50, "new_func_code": "def estimate_diameter(polygon: np.ndarray) -> float:\n    \"\"\"Estimates the diameter of an arbitrary arc by evaluating the maximum distance between any two points on the arc.\n\n    Args:\n        polygon (np.ndarray): Polygon points.\n\n    Returns:\n        float: Estimated diameter length.\n\n    Reference:\n        [1] https://sparrow.dev/pairwise-distance-in-numpy/\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.validators.is_binary", "project": "open-iris", "func": "is_binary", "origin_file": "iris/io/validators.py", "test_list": ["../tests/unit_tests/io/test_validators.py"], "prob_info": {"func_start_lineno": 40, "func_end_lineno": 57, "key_block_start_lineno": 54, "key_block_end_lineno": 57, "new_func_code": "def is_binary(cls: type, v: np.ndarray, field: fields.ModelField) -> np.ndarray:\n    \"\"\"Check if array has only boolean values, i.e. is binary.\n\n    Args:\n        cls (type): Class type.\n        v (np.ndarray): Value to check.\n        field (fields.ModelField): Field descriptor.\n\n    Raises:\n        ValueError: Exception raised if array doesn't contain bool datatypes.\n\n    Returns:\n        np.ndarray: `v` sent for further processing.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.validators.is_list_of_points", "project": "open-iris", "func": "is_list_of_points", "origin_file": "iris/io/validators.py", "test_list": ["../tests/unit_tests/io/test_validators.py"], "prob_info": {"func_start_lineno": 60, "func_end_lineno": 77, "key_block_start_lineno": 74, "key_block_end_lineno": 77, "new_func_code": "def is_list_of_points(cls: type, v: np.ndarray, field: fields.ModelField) -> np.ndarray:\n    \"\"\"Check if np.ndarray has shape (_, 2).\n\n    Args:\n        cls (type): Class type.\n        v (np.ndarray): Value to check.\n        field (fields.ModelField): Field descriptor.\n\n    Raises:\n        ValueError: Exception raised if array doesn't contain 2D points.\n\n    Returns:\n        np.ndarray: `v` sent for further processing.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.validators.is_not_empty", "project": "open-iris", "func": "is_not_empty", "origin_file": "iris/io/validators.py", "test_list": ["../tests/unit_tests/io/test_validators.py"], "prob_info": {"func_start_lineno": 80, "func_end_lineno": 97, "key_block_start_lineno": 94, "key_block_end_lineno": 97, "new_func_code": "def is_not_empty(cls: type, v: List[Any], field: fields.ModelField) -> List[Any]:\n    \"\"\"Check that both inputs are not empty.\n\n    Args:\n        cls (type): Class type.\n        v (List[Any]): Value to check.\n        field (fields.ModelField): Field descriptor.\n\n    Raises:\n        ValueError: Exception raised if list is empty.\n\n    Returns:\n        List[Any]: `v` sent for further processing.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.validators.are_all_positive", "project": "open-iris", "func": "are_all_positive", "origin_file": "iris/io/validators.py", "test_list": ["../tests/unit_tests/io/test_validators.py"], "prob_info": {"func_start_lineno": 120, "func_end_lineno": 140, "key_block_start_lineno": 134, "key_block_end_lineno": 140, "new_func_code": "def are_all_positive(cls: type, v: Any, field: fields.ModelField) -> Any:\n    \"\"\"Check that all values are positive.\n\n    Args:\n        cls (type): Class type.\n        v (Any): Value to check.\n        field (fields.ModelField): Field descriptor.\n\n    Raises:\n        ValueError: Raise if not all values in are positive.\n\n    Returns:\n        Any: `v` sent for further processing.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.validators.is_array_n_dimensions", "project": "open-iris", "func": "is_array_n_dimensions", "origin_file": "iris/io/validators.py", "test_list": ["../tests/unit_tests/io/test_validators.py"], "prob_info": {"func_start_lineno": 181, "func_end_lineno": 201, "key_block_start_lineno": 190, "key_block_end_lineno": 201, "new_func_code": "def is_array_n_dimensions(nb_dimensions: int) -> Callable:\n    \"\"\"Create a pydantic validator checking if an array is n-dimensional.\n\n    Args:\n        nb_dimensions (int): number of dimensions the array must have\n\n    Returns:\n        Callable: the validator.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.validators.are_lengths_equal", "project": "open-iris", "func": "are_lengths_equal", "origin_file": "iris/io/validators.py", "test_list": ["../tests/unit_tests/io/test_validators.py"], "prob_info": {"func_start_lineno": 207, "func_end_lineno": 228, "key_block_start_lineno": 217, "key_block_end_lineno": 228, "new_func_code": "def are_lengths_equal(field1: str, field2: str) -> Callable:\n    \"\"\"Create a pydantic validator checking if the two fields have the same length.\n\n    Args:\n        field1 (str): name of the first field\n        field2 (str): name of the first field\n\n    Returns:\n        Callable: the validator.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.validators.are_shapes_equal", "project": "open-iris", "func": "are_shapes_equal", "origin_file": "iris/io/validators.py", "test_list": ["../tests/unit_tests/io/test_validators.py"], "prob_info": {"func_start_lineno": 231, "func_end_lineno": 248, "key_block_start_lineno": 241, "key_block_end_lineno": 248, "new_func_code": "def are_shapes_equal(field1: str, field2: str) -> Callable:\n    \"\"\"Create a pydantic validator checking if the two fields have the same shape.\n\n    Args:\n        field1 (str): name of the first field\n        field2 (str): name of the first field\n\n    Returns:\n        Callable: the validator.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.validators.are_all_shapes_equal", "project": "open-iris", "func": "are_all_shapes_equal", "origin_file": "iris/io/validators.py", "test_list": ["../tests/unit_tests/io/test_validators.py"], "prob_info": {"func_start_lineno": 251, "func_end_lineno": 277, "key_block_start_lineno": 264, "key_block_end_lineno": 277, "new_func_code": "def are_all_shapes_equal(field1: str, field2: str) -> Callable:\n    \"\"\"Create a pydantic validator checking if two lists of array have the same shape per element.\n\n    This function creates a pydantic validator for two lists of np.ndarrays which checks if they have the same length,\n    and if all of their element have the same shape one by one.\n\n    Args:\n        field1 (str): name of the first field\n        field2 (str): name of the first field\n\n    Returns:\n        Callable: the validator.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.validators.to_dtype_float32", "project": "open-iris", "func": "to_dtype_float32", "origin_file": "iris/io/validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_cross_object_validators.py"], "prob_info": {"func_start_lineno": 150, "func_end_lineno": 161, "key_block_start_lineno": 161, "key_block_end_lineno": 161, "new_func_code": "def to_dtype_float32(cls: type, v: np.ndarray, field: fields.ModelField) -> np.ndarray:\n    \"\"\"Convert input np.ndarray to dtype np.float32.\n\n    Args:\n        cls (type): Class type.\n        v (np.ndarray): Value to convert\n        field (fields.ModelField): Field descriptor.\n\n    Returns:\n        np.ndarray: `v` sent for further processing.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.cross_object_validators.EyeCentersInsideImageValidator::run", "project": "open-iris", "func": "EyeCentersInsideImageValidator::run", "origin_file": "iris/nodes/validators/cross_object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_cross_object_validators.py"], "prob_info": {"func_start_lineno": 33, "func_end_lineno": 47, "key_block_start_lineno": 43, "key_block_end_lineno": 47, "new_func_code": "def run(self, ir_image: IRImage, eye_centers: EyeCenters) -> None:\n        \"\"\"Validate if eye centers are within proper image boundaries.\n\n        Args:\n            ir_image (IRImage): IR image\n            eye_centers (EyeCenters): Eye centers\n\n        Raises:\n            EyeCentersInsideImageValidatorError: Raised if pupil or iris center is not in within correct image boundary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.cross_object_validators.ExtrapolatedPolygonsInsideImageValidator::run", "project": "open-iris", "func": "ExtrapolatedPolygonsInsideImageValidator::run", "origin_file": "iris/nodes/validators/cross_object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_cross_object_validators.py"], "prob_info": {"func_start_lineno": 105, "func_end_lineno": 128, "key_block_start_lineno": 115, "key_block_end_lineno": 128, "new_func_code": "def run(self, ir_image: IRImage, extrapolated_polygons: GeometryPolygons) -> None:\n        \"\"\"Perform validation.\n\n        Args:\n            ir_image (IRImage): IR image.\n            extrapolated_polygons (GeometryPolygons): Extrapolated polygons.\n\n        Raises:\n            ExtrapolatedPolygonsInsideImageValidatorError: Raised if not enough points of the pupil/iris/eyeball are within an image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.cross_object_validators.ExtrapolatedPolygonsInsideImageValidator::_check_correct_percentage", "project": "open-iris", "func": "ExtrapolatedPolygonsInsideImageValidator::_check_correct_percentage", "origin_file": "iris/nodes/validators/cross_object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_cross_object_validators.py"], "prob_info": {"func_start_lineno": 130, "func_end_lineno": 147, "key_block_start_lineno": 141, "key_block_end_lineno": 147, "new_func_code": "def _check_correct_percentage(self, polygon: np.ndarray, min_allowed_percentage: float, ir_image: IRImage) -> bool:\n        \"\"\"Check percentage of points withing image based on minimal specified threshold.\n\n        Args:\n            polygon (np.ndarray): polygon to verify.\n            min_allowed_percentage (float): minimal allowed percentage of points that must be within an image.\n            ir_image (IRImage): ir image object.\n\n        Returns:\n            bool: Check result.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.image_filters.gabor_filters.GaborFilter::compute_kernel_values", "project": "open-iris", "func": "GaborFilter::compute_kernel_values", "origin_file": "iris/nodes/iris_response/image_filters/gabor_filters.py", "test_list": ["../tests/unit_tests/nodes/iris_response/image_filters/test_gabor_filters.py"], "prob_info": {"func_start_lineno": 214, "func_end_lineno": 246, "key_block_start_lineno": 220, "key_block_end_lineno": 246, "new_func_code": "def compute_kernel_values(self) -> np.ndarray:\n        \"\"\"Compute 2D Gabor filter kernel values.\n\n        Returns:\n            np.ndarray: Kernel values.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.image_filters.gabor_filters.rotate", "project": "open-iris", "func": "rotate", "origin_file": "iris/nodes/iris_response/image_filters/gabor_filters.py", "test_list": ["../tests/unit_tests/nodes/iris_response/image_filters/test_gabor_filters.py"], "prob_info": {"func_start_lineno": 99, "func_end_lineno": 116, "key_block_start_lineno": 110, "key_block_end_lineno": 116, "new_func_code": "def rotate(x: np.ndarray, y: np.ndarray, angle: float) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Rotate a given array of relative positions (x,y) by a given angle.\n\n    Args:\n        x (np.ndarray): x position.\n        y (np.ndarray): y position.\n        angle (float): angle for rotation (in degrees).\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: rotated x, y positions.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.image_filters.gabor_filters.normalize_kernel_values", "project": "open-iris", "func": "normalize_kernel_values", "origin_file": "iris/nodes/iris_response/image_filters/gabor_filters.py", "test_list": ["../tests/unit_tests/nodes/iris_response/image_filters/test_gabor_filters.py"], "prob_info": {"func_start_lineno": 119, "func_end_lineno": 137, "key_block_start_lineno": 128, "key_block_end_lineno": 137, "new_func_code": "def normalize_kernel_values(kernel_values: np.ndarray) -> np.ndarray:\n    \"\"\"Normalize the kernel values so that the square sum is 1.\n\n    Args:\n        kernel_values (np.ndarray): Kernel values (complex numbers).\n\n    Returns:\n        np.ndarray: normalized Kernel values.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.image_filters.gabor_filters.LogGaborFilter::compute_kernel_values", "project": "open-iris", "func": "LogGaborFilter::compute_kernel_values", "origin_file": "iris/nodes/iris_response/image_filters/gabor_filters.py", "test_list": ["../tests/unit_tests/nodes/iris_response/image_filters/test_gabor_filters.py"], "prob_info": {"func_start_lineno": 300, "func_end_lineno": 335, "key_block_start_lineno": 306, "key_block_end_lineno": 335, "new_func_code": "def compute_kernel_values(self) -> np.ndarray:\n        \"\"\"Compute 2D LogGabor filter kernel values.\n\n        Returns:\n            np.ndarray: Kernel values.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.image_filters.gabor_filters.get_radius", "project": "open-iris", "func": "get_radius", "origin_file": "iris/nodes/iris_response/image_filters/gabor_filters.py", "test_list": ["../tests/unit_tests/nodes/iris_response/image_filters/test_gabor_filters.py"], "prob_info": {"func_start_lineno": 84, "func_end_lineno": 96, "key_block_start_lineno": 94, "key_block_end_lineno": 96, "new_func_code": "def get_radius(x: np.ndarray, y: np.ndarray) -> np.ndarray:\n    \"\"\"Get radius to the image center for a given array of relative positions (x,y).\n\n    Args:\n        x (np.ndarray): x position relative to the image center.\n        y (np.ndarray): y position relative to the image center.\n\n    Returns:\n        np.ndarray: radius to the image center.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.vectorization.contouring.filter_polygon_areas", "project": "open-iris", "func": "filter_polygon_areas", "origin_file": "iris/nodes/vectorization/contouring.py", "test_list": ["../tests/unit_tests/nodes/vectorization/test_contouring.py"], "prob_info": {"func_start_lineno": 13, "func_end_lineno": 35, "key_block_start_lineno": 26, "key_block_end_lineno": 35, "new_func_code": "def filter_polygon_areas(\n    polygons: List[np.ndarray], rel_tr: NonNegativeFloat = 0.03, abs_tr: NonNegativeFloat = 0.0\n) -> List[np.ndarray]:\n    \"\"\"Filter out polygons whose area is below either an absolute threshold or a fraction of the largest area.\n\n    Args:\n        polygons (List[np.ndarray]): List of polygons to filter.\n        rel_tr (NonNegativeFloat, optional): Relative threshold. Defaults to 0.03.\n        abs_tr (NonNegativeFloat, optional): Absolute threshold. Defaults to 0.0.\n\n    Returns:\n        List[np.ndarray]: Filtered polygons' list.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.utils.math.area", "project": "open-iris", "func": "area", "origin_file": "iris/utils/math.py", "test_list": ["../tests/unit_tests/nodes/vectorization/test_contouring.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 35, "key_block_start_lineno": 27, "key_block_end_lineno": 35, "new_func_code": "def area(array: np.ndarray, signed: bool = False) -> float:\n    \"\"\"Shoelace formula for simple polygon area calculation.\n\n    WARNING: This formula only works for \"simple polygons\", i.e planar polygon without self-intersection nor holes.\n    These conditions are not checked within this function.\n\n    Args:\n        array (np.ndarray): np array representing a polygon as a list of points, i.e. of shape (_, 2).\n        signed (bool): If True, the area is signed, i.e. negative if the polygon is oriented clockwise.\n\n    Returns:\n        float: Polygon area\n\n    Raises:\n        ValueError: if the input array does not have shape (_, 2)\n\n    References:\n        [1] https://en.wikipedia.org/wiki/Shoelace_formula\n        [2] https://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.dataclasses.GeometryMask::filled_eyeball_mask", "project": "open-iris", "func": "GeometryMask::filled_eyeball_mask", "origin_file": "iris/io/dataclasses.py", "test_list": ["../tests/unit_tests/nodes/vectorization/test_contouring.py"], "prob_info": {"func_start_lineno": 179, "func_end_lineno": 191, "key_block_start_lineno": 185, "key_block_end_lineno": 191, "new_func_code": "def filled_eyeball_mask(self) -> np.ndarray:\n        \"\"\"Fill eyeball mask.\n\n        Returns:\n            np.ndarray: Eyeball mask with filled iris/pupil \"holes\".\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.dataclasses.GeometryMask::filled_iris_mask", "project": "open-iris", "func": "GeometryMask::filled_iris_mask", "origin_file": "iris/io/dataclasses.py", "test_list": ["../tests/unit_tests/nodes/vectorization/test_contouring.py"], "prob_info": {"func_start_lineno": 194, "func_end_lineno": 205, "key_block_start_lineno": 200, "key_block_end_lineno": 205, "new_func_code": "def filled_iris_mask(self) -> np.ndarray:\n        \"\"\"Fill iris mask.\n\n        Returns:\n            np.ndarray: Iris mask with filled pupil \"holes\".\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.vectorization.contouring.ContouringAlgorithm::_filter_contours", "project": "open-iris", "func": "ContouringAlgorithm::_filter_contours", "origin_file": "iris/nodes/vectorization/contouring.py", "test_list": ["../tests/unit_tests/nodes/vectorization/test_contouring.py"], "prob_info": {"func_start_lineno": 121, "func_end_lineno": 133, "key_block_start_lineno": 130, "key_block_end_lineno": 133, "new_func_code": "def _filter_contours(self, contours: List[np.ndarray]) -> List[np.ndarray]:\n        \"\"\"Filter contours based on predefined filters.\n\n        Args:\n            contours (List[np.ndarray]): Contours list.\n\n        Returns:\n            List[np.ndarray]: Filtered list of contours.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.utils.math.cartesian2polar", "project": "open-iris", "func": "cartesian2polar", "origin_file": "iris/utils/math.py", "test_list": ["../tests/unit_tests/nodes/geometry_estimation/test_linear_extrapolation.py"], "prob_info": {"func_start_lineno": 53, "func_end_lineno": 73, "key_block_start_lineno": 65, "key_block_end_lineno": 73, "new_func_code": "def cartesian2polar(xs: np.ndarray, ys: np.ndarray, center_x: float, center_y: float) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Convert xs and ys cartesian coordinates to polar coordinates.\n\n    Args:\n        xs (np.ndarray): x values.\n        ys (np.ndarray): y values.\n        center_x (float): center's x.\n        center_y (float): center's y.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: Converted coordinates (rhos, phis).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.utils.math.polar2cartesian", "project": "open-iris", "func": "polar2cartesian", "origin_file": "iris/utils/math.py", "test_list": ["../tests/unit_tests/nodes/geometry_estimation/test_linear_extrapolation.py"], "prob_info": {"func_start_lineno": 76, "func_end_lineno": 93, "key_block_start_lineno": 90, "key_block_end_lineno": 93, "new_func_code": "def polar2cartesian(\n    rhos: np.ndarray, phis: np.ndarray, center_x: float, center_y: float\n) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Convert polar coordinates to cartesian coordinates.\n\n    Args:\n        rho (np.ndarray): rho values.\n        phi (np.ndarray): phi values.\n        center_x (float): center's x.\n        center_y (float): center's y.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: Converted coordinates (xs, ys).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.validators.is_odd", "project": "open-iris", "func": "is_odd", "origin_file": "iris/io/validators.py", "test_list": ["../tests/unit_tests/nodes/eye_properties_estimation/test_sharpness_estimation.py"], "prob_info": {"func_start_lineno": 12, "func_end_lineno": 29, "key_block_start_lineno": 26, "key_block_end_lineno": 29, "new_func_code": "def is_odd(cls: type, v: int, field: fields.ModelField) -> int:\n    \"\"\"Check that kernel size are odd numbers.\n\n    Args:\n        cls (type): Class type.\n        v (int): Value to check.\n        field (fields.ModelField): Field descriptor.\n\n    Raises:\n        ValueError: Exception raised if number isn't odd.\n\n    Returns:\n        int: `v` sent for further processing.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.common.correct_orientation", "project": "open-iris", "func": "correct_orientation", "origin_file": "iris/nodes/normalization/common.py", "test_list": ["../tests/unit_tests/nodes/normalization/test_normalization_utils.py"], "prob_info": {"func_start_lineno": 31, "func_end_lineno": 50, "key_block_start_lineno": 44, "key_block_end_lineno": 50, "new_func_code": "def correct_orientation(\n    pupil_points: np.ndarray, iris_points: np.ndarray, eye_orientation: float\n) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Correct orientation by changing the starting angle in pupil and iris points' arrays.\n\n    Args:\n        pupil_points (np.ndarray): Pupil boundary points' array. NumPy array of shape (num_points = 360, xy_coords = 2).\n        iris_points (np.ndarray): Iris boundary points' array. NumPy array of shape (num_points = 360, xy_coords = 2).\n        eye_orientation (float): Eye orientation angle in radians.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: Tuple with rotated based on eye_orientation angle boundary points (pupil_points, iris_points).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.common.interpolate_pixel_intensity", "project": "open-iris", "func": "interpolate_pixel_intensity", "origin_file": "iris/nodes/normalization/common.py", "test_list": ["../tests/unit_tests/nodes/normalization/test_normalization_utils.py"], "prob_info": {"func_start_lineno": 89, "func_end_lineno": 154, "key_block_start_lineno": 102, "key_block_end_lineno": 154, "new_func_code": "def interpolate_pixel_intensity(image: np.ndarray, pixel_coords: Tuple[float, float]) -> float:\n    \"\"\"Perform bilinear interpolation to estimate pixel intensity in a given location.\n\n    Args:\n        image (np.ndarray): Original, not normalized image.\n        pixel_coords (Tuple[float, float]): Pixel coordinates.\n\n    Returns:\n        float: Interpolated pixel intensity.\n\n    Reference:\n        [1] https://en.wikipedia.org/wiki/Bilinear_interpolation\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.common.get_pixel_or_default", "project": "open-iris", "func": "get_pixel_or_default", "origin_file": "iris/nodes/normalization/common.py", "test_list": ["../tests/unit_tests/nodes/normalization/test_normalization_utils.py"], "prob_info": {"func_start_lineno": 70, "func_end_lineno": 86, "key_block_start_lineno": 84, "key_block_end_lineno": 86, "new_func_code": "def get_pixel_or_default(\n    image: np.ndarray, pixel_x: float, pixel_y: float, default: Union[bool, int]\n) -> Union[bool, int]:\n    \"\"\"Get the value of a pixel in the image 2D array.\n\n    Args:\n        image (np.ndarray): 2D Array.\n        pixel_x (float): Pixel x coordinate.\n        pixel_y (float): Pixel y coordinate.\n        default (Union[bool, int]): Default value to return when (pixel_x, pixel_y) is out-of-bounds\n\n    Returns:\n        Union[bool, int]: Pixel value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.common.to_uint8", "project": "open-iris", "func": "to_uint8", "origin_file": "iris/nodes/normalization/common.py", "test_list": ["../tests/unit_tests/nodes/normalization/test_normalization_utils.py"], "prob_info": {"func_start_lineno": 191, "func_end_lineno": 203, "key_block_start_lineno": 200, "key_block_end_lineno": 203, "new_func_code": "def to_uint8(image: np.ndarray) -> np.ndarray:\n    \"\"\"Map normalized image values from [0, 1] range to [0, 255] and cast dtype to np.uint8.\n\n    Args:\n        image (np.ndarray): Normalized iris.\n\n    Returns:\n        np.ndarray: Normalized iris with modified values.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.object_validators.Pupil2IrisPropertyValidator::run", "project": "open-iris", "func": "Pupil2IrisPropertyValidator::run", "origin_file": "iris/nodes/validators/object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_object_validators.py"], "prob_info": {"func_start_lineno": 48, "func_end_lineno": 70, "key_block_start_lineno": 59, "key_block_end_lineno": 70, "new_func_code": "def run(self, val_arguments: PupilToIrisProperty) -> None:\n        \"\"\"Validate of pupil to iris calculation.\n\n        Args:\n            p2i_property (PupilToIrisProperty): Computation result.\n\n        Raises:\n            E.Pupil2IrisValidatorErrorConstriction: Raised if pupil is constricted.\n            E.Pupil2IrisValidatorErrorDilation: Raised if pupil is dilated.\n            E.Pupil2IrisValidatorErrorOffcenter: Raised if pupil and iris are offcenter.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.object_validators.OffgazeValidator::run", "project": "open-iris", "func": "OffgazeValidator::run", "origin_file": "iris/nodes/validators/object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_object_validators.py"], "prob_info": {"func_start_lineno": 104, "func_end_lineno": 116, "key_block_start_lineno": 113, "key_block_end_lineno": 116, "new_func_code": "def run(self, val_arguments: Offgaze) -> None:\n        \"\"\"Validate of offgaze estimation algorithm.\n\n        Args:\n            val_arguments (Offgaze): Computed result.\n\n        Raises:\n            E.OffgazeEstimationError: Raised if result isn't greater then specified threshold.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.object_validators.OcclusionValidator::run", "project": "open-iris", "func": "OcclusionValidator::run", "origin_file": "iris/nodes/validators/object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_object_validators.py"], "prob_info": {"func_start_lineno": 150, "func_end_lineno": 162, "key_block_start_lineno": 159, "key_block_end_lineno": 162, "new_func_code": "def run(self, val_arguments: EyeOcclusion) -> None:\n        \"\"\"Validate of occlusion estimation algorithm.\n\n        Args:\n            val_arguments (EyeOcclusion): Computed result.\n\n        Raises:\n            E.OcclusionError: Raised if result isn't greater then specified threshold.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.object_validators.IsPupilInsideIrisValidator::run", "project": "open-iris", "func": "IsPupilInsideIrisValidator::run", "origin_file": "iris/nodes/validators/object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_object_validators.py"], "prob_info": {"func_start_lineno": 180, "func_end_lineno": 193, "key_block_start_lineno": 189, "key_block_end_lineno": 193, "new_func_code": "def run(self, val_arguments: GeometryPolygons) -> None:\n        \"\"\"Validate if extrapolated pupil polygons are withing extrapolated iris boundaries.\n\n        Args:\n            val_arguments (GeometryPolygons): Computed result.\n\n        Raises:\n            E.IsPupilInsideIrisValidatorError: Raised if the pupil polygon is not fully contained within the iris polygon.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.object_validators.PolygonsLengthValidator::run", "project": "open-iris", "func": "PolygonsLengthValidator::run", "origin_file": "iris/nodes/validators/object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_object_validators.py"], "prob_info": {"func_start_lineno": 291, "func_end_lineno": 310, "key_block_start_lineno": 300, "key_block_end_lineno": 310, "new_func_code": "def run(self, val_arguments: GeometryPolygons) -> None:\n        \"\"\"Validate that the total iris and pupil polygon length is above the desired threshold.\n\n        Args:\n            val_arguments (GeometryPolygons): GeometryPolygons to be validated.\n\n        Raises:\n            E.GeometryEstimationError: Raised if the total iris or pupil polygon length is below the desired threshold.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.utils.math.polygon_length", "project": "open-iris", "func": "polygon_length", "origin_file": "iris/utils/math.py", "test_list": ["../tests/unit_tests/nodes/validators/test_object_validators.py"], "prob_info": {"func_start_lineno": 179, "func_end_lineno": 203, "key_block_start_lineno": 197, "key_block_end_lineno": 203, "new_func_code": "def polygon_length(polygon: np.ndarray, max_point_distance: int = 20) -> float:\n    \"\"\"Compute the length of a polygon represented as a (_, 2)-dimensionnal numpy array.\n\n    One polygon can include several disjoint arcs, which should be identified as separate so that the distance\n    between them is not counted. If a polygon is made of two small arc separated by a large distance, then the large\n    distance between the two arcs will not be discounted in the polygon's length\n\n    WARNING: The input polygon is assumed to be non-looped, i.e. if the first and last point are not equal,\n    which is the case for all ou GeometryPolygons. The last implicit segment looping back from the\n    last to the first point is therefore not included in the computed polygon length.\n\n    Args:\n        polygon (np.ndarray): (_, 2) - shaped numpy array representing a polygon.\n        max_point_distance (int): Maximum distance between two points for them to be considered part of the same arc.\n\n    Returns:\n        float: length of the polygon, in pixels.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.object_validators.SharpnessValidator::run", "project": "open-iris", "func": "SharpnessValidator::run", "origin_file": "iris/nodes/validators/object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_object_validators.py"], "prob_info": {"func_start_lineno": 343, "func_end_lineno": 355, "key_block_start_lineno": 352, "key_block_end_lineno": 355, "new_func_code": "def run(self, val_arguments: Sharpness) -> None:\n        \"\"\"Validate of sharpness estimation algorithm.\n\n        Args:\n            val_arguments (Sharpness): Computed result.\n\n        Raises:\n            E.SharpnessEstimationError: Raised if the sharpness score is below the desired threshold.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.object_validators.IsMaskTooSmallValidator::run", "project": "open-iris", "func": "IsMaskTooSmallValidator::run", "origin_file": "iris/nodes/validators/object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_object_validators.py"], "prob_info": {"func_start_lineno": 390, "func_end_lineno": 404, "key_block_start_lineno": 399, "key_block_end_lineno": 404, "new_func_code": "def run(self, val_arguments: IrisTemplate) -> None:\n        \"\"\"Validate that the total mask codes size is above the desired threshold.\n\n        Args:\n            val_arguments (IrisTemplate): IrisTemplate to be validated.\n\n        Raises:\n            E.MaskTooSmallError: Raised if the total mask codes size is below the desired threshold.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.probe_schemas.regular_probe_schema.RegularProbeSchema::generate_schema", "project": "open-iris", "func": "RegularProbeSchema::generate_schema", "origin_file": "iris/nodes/iris_response/probe_schemas/regular_probe_schema.py", "test_list": ["../tests/unit_tests/nodes/iris_response/test_conv_filter_bank.py"], "prob_info": {"func_start_lineno": 94, "func_end_lineno": 138, "key_block_start_lineno": 100, "key_block_end_lineno": 138, "new_func_code": "def generate_schema(self) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Generate rhos and phis.\n\n        Return:\n            Tuple[np.ndarray, np.ndarray]: the rhos and phis.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.matcher.utils.hamming_distance", "project": "open-iris", "func": "hamming_distance", "origin_file": "iris/nodes/matcher/utils.py", "test_list": ["../tests/unit_tests/nodes/matcher/test_matcher_utils.py"], "prob_info": {"func_start_lineno": 134, "func_end_lineno": 215, "key_block_start_lineno": 162, "key_block_end_lineno": 215, "new_func_code": "def hamming_distance(\n    template_probe: IrisTemplate,\n    template_gallery: IrisTemplate,\n    rotation_shift: int,\n    normalise: bool = False,\n    norm_mean: float = 0.45,\n    norm_gradient: float = 0.00005,\n    separate_half_matching: bool = False,\n    weights: Optional[List[np.ndarray]] = None,\n) -> Tuple[float, int]:\n    \"\"\"Compute Hamming distance.\n\n    Args:\n        template_probe (IrisTemplate): Iris template from probe.\n        template_gallery (IrisTemplate): Iris template from gallery.\n        rotation_shift (int): Rotation allowed in matching, converted to columns.\n        normalise (bool, optional): Flag to normalize HD. Defaults to False.\n        norm_mean (float, optional): Nonmatch mean distance for normalized HD. Defaults to 0.45.\n        norm_gradient (float): Gradient for linear approximation of normalization term. Defaults to 0.00005.\n        separate_half_matching (bool, optional): Separate the upper and lower halves for matching. Defaults to False.\n        weights (Optional[List[np.ndarray]], optional): List of weights table. Optional paremeter for weighted HD. Defaults to None.\n\n    Raises:\n        MatcherError: If probe and gallery iris codes are of different sizes or number of columns of iris codes is not even or If weights (when defined) and iris codes are of different sizes.\n\n    Returns:\n        Tuple[float, int]: Miminum Hamming distance and corresonding rotation shift.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.matcher.utils.count_nonmatchbits", "project": "open-iris", "func": "count_nonmatchbits", "origin_file": "iris/nodes/matcher/utils.py", "test_list": ["../tests/unit_tests/nodes/matcher/test_matcher_utils.py"], "prob_info": {"func_start_lineno": 49, "func_end_lineno": 84, "key_block_start_lineno": 66, "key_block_end_lineno": 84, "new_func_code": "def count_nonmatchbits(\n    irisbits: np.ndarray,\n    maskbits: np.ndarray,\n    half_width: Optional[List[int]] = None,\n    weights: Optional[List[np.ndarray]] = None,\n) -> Union[Tuple[int, int], Tuple[List[int], List[int]]]:\n    \"\"\"Count nonmatch bits for Hammming distance.\n\n    Args:\n        irisbits (np.ndarray): Nonmatch irisbits.\n        maskbits (np.ndarray): Common maskbits.\n        half_width (Optional[np.ndarray] = None): List of half of code width. Optional paremeter for scoring the upper and lower halves separately. Defaults to None.\n        weights (Optional[np.ndarray] = None): List of weights table. Optional paremeter for weighted HD. Defaults to None.\n\n    Returns:\n        Tuple[int, int]: Total nonmatch iriscode bit count and common maskcode bit count, could be a list for top and bottom iris separately.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.matcher.utils.normalized_HD", "project": "open-iris", "func": "normalized_HD", "origin_file": "iris/nodes/matcher/utils.py", "test_list": ["../tests/unit_tests/nodes/matcher/test_matcher_utils.py"], "prob_info": {"func_start_lineno": 9, "func_end_lineno": 24, "key_block_start_lineno": 21, "key_block_end_lineno": 24, "new_func_code": "def normalized_HD(irisbitcount: int, maskbitcount: int, norm_mean: float, norm_gradient: float) -> float:\n    \"\"\"Perform normalized HD calculation.\n\n    Args:\n        irisbitcount (int): Nonmatched iriscode bit count.\n        maskbitcount (int): Common maskcode bit count.\n        norm_mean (float): Nonmatch distance used for normalized HD.\n        norm_gradient (float): Gradient for linear approximation of normalization term.\n\n    Returns:\n        float: Normalized Hamming distance.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.iris_bbox_calculator.IrisBBoxCalculator::run", "project": "open-iris", "func": "IrisBBoxCalculator::run", "origin_file": "iris/nodes/eye_properties_estimation/iris_bbox_calculator.py", "test_list": ["../tests/unit_tests/nodes/eye_properties_estimation/test_iris_bbox_calculator.py"], "prob_info": {"func_start_lineno": 43, "func_end_lineno": 97, "key_block_start_lineno": 56, "key_block_end_lineno": 97, "new_func_code": "def run(self, ir_image: IRImage, geometry_polygons: GeometryPolygons) -> BoundingBox:\n        \"\"\"Compute the bounding box around the iris with an additional buffer. Works best on extrapolated polygons.\n\n        The buffer's behaviour is explained in the constructor's docstring.\n        The bounding box will be cropped to the shape of the input IR Image.\n\n        Args:\n            ir_image (IRImage): IR image.\n            geometry_polygons (GeometryPolygons): polygons, from which the iris polygon (respectively the image shape) used to compute the bounding box (resp. crop the bounding box).\n\n        Returns:\n            BoundingBox: Estimated iris bounding box.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_estimation.lsq_ellipse_fit_with_refinement.LSQEllipseFitWithRefinement::_find_correspondence", "project": "open-iris", "func": "LSQEllipseFitWithRefinement::_find_correspondence", "origin_file": "iris/nodes/geometry_estimation/lsq_ellipse_fit_with_refinement.py", "test_list": ["../tests/unit_tests/nodes/geometry_estimation/test_lsq_ellipse_fit_with_refinement.py"], "prob_info": {"func_start_lineno": 76, "func_end_lineno": 90, "key_block_start_lineno": 86, "key_block_end_lineno": 90, "new_func_code": "def _find_correspondence(self, src_point: np.ndarray, dst_points: np.ndarray) -> int:\n        \"\"\"Find correspondence with Euclidean distance.\n\n        Args:\n            src_point (np.ndarray): Source points.\n            dst_points (np.ndarray): Destination points.\n\n        Returns:\n            int: Source point index the closes one to the destination points.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.callbacks.pipeline_trace.PipelineCallTraceStorage::_init_storage", "project": "open-iris", "func": "PipelineCallTraceStorage::_init_storage", "origin_file": "iris/callbacks/pipeline_trace.py", "test_list": ["../tests/unit_tests/callbacks/test_pipeline_trace.py"], "prob_info": {"func_start_lineno": 115, "func_end_lineno": 128, "key_block_start_lineno": 124, "key_block_end_lineno": 128, "new_func_code": "def _init_storage(self, results_names: Iterable[str]) -> Dict[str, None]:\n        \"\"\"Initialize storage (dict) with proper names and None values as results.\n\n        Args:\n            results_names (Iterable[str]): Result names.\n\n        Returns:\n            Dict[str, None]: Storage dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.callbacks.pipeline_trace.PipelineCallTraceStorage::get", "project": "open-iris", "func": "PipelineCallTraceStorage::get", "origin_file": "iris/callbacks/pipeline_trace.py", "test_list": ["../tests/unit_tests/callbacks/test_pipeline_trace.py"], "prob_info": {"func_start_lineno": 52, "func_end_lineno": 67, "key_block_start_lineno": 64, "key_block_end_lineno": 67, "new_func_code": "def get(self, result_name: str) -> Any:\n        \"\"\"Get result_name result.\n\n        Args:\n            result_name (str): Result name.\n\n        Raises:\n            PipelineCallTraceStorageError: Raised if result_name is not found.\n\n        Returns:\n            Any: Result object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.callbacks.pipeline_trace.PipelineCallTraceStorage::__getitem__", "project": "open-iris", "func": "PipelineCallTraceStorage::__getitem__", "origin_file": "iris/callbacks/pipeline_trace.py", "test_list": ["../tests/unit_tests/callbacks/test_pipeline_trace.py"], "prob_info": {"func_start_lineno": 30, "func_end_lineno": 42, "key_block_start_lineno": 42, "key_block_end_lineno": 42, "new_func_code": "def __getitem__(self, result_name: str) -> Any:\n        \"\"\"Get result_name result.\n\n        Args:\n            result_name (str): Result name.\n\n        Raises:\n            PipelineCallTraceStorageError: Raised if result_name is not found.\n\n        Returns:\n            Any: Result object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.occlusion_calculator.OcclusionCalculator::run", "project": "open-iris", "func": "OcclusionCalculator::run", "origin_file": "iris/nodes/eye_properties_estimation/occlusion_calculator.py", "test_list": ["../tests/unit_tests/nodes/eye_properties_estimation/test_occlusion_calculator.py"], "prob_info": {"func_start_lineno": 42, "func_end_lineno": 97, "key_block_start_lineno": 60, "key_block_end_lineno": 97, "new_func_code": "def run(\n        self,\n        extrapolated_polygons: GeometryPolygons,\n        noise_mask: NoiseMask,\n        eye_orientation: EyeOrientation,\n        eye_centers: EyeCenters,\n    ) -> EyeOcclusion:\n        \"\"\"Compute the iris visible fraction.\n\n        Args:\n            extrapolated_polygons (GeometryPolygons): Extrapolated polygons contours.\n            noise_mask (NoiseMask): Noise mask.\n            eye_orientation (EyeOrientation): Eye orientation angle.\n            eye_centers (EyeCenters): Eye centers.\n\n        Returns:\n            EyeOcclusion: Visible iris fraction.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.utils.common.contour_to_mask", "project": "open-iris", "func": "contour_to_mask", "origin_file": "iris/utils/common.py", "test_list": ["../tests/unit_tests/nodes/eye_properties_estimation/test_occlusion_calculator.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 26, "key_block_start_lineno": 17, "key_block_end_lineno": 26, "new_func_code": "def contour_to_mask(vertices: np.ndarray, mask_shape: Tuple[int, int]) -> np.ndarray:\n    \"\"\"Generate binary mask based on polygon's vertices.\n\n    Args:\n        vertices (np.ndarray): Vertices points array.\n        mask_shape (Tuple[int, int]): Tuple with output mask dimension (weight, height).\n\n    Returns:\n        np.ndarray: Binary mask.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.dataclasses.SegmentationMap::index_of", "project": "open-iris", "func": "SegmentationMap::index_of", "origin_file": "iris/io/dataclasses.py", "test_list": ["../tests/unit_tests/io/test_dataclasses.py"], "prob_info": {"func_start_lineno": 129, "func_end_lineno": 145, "key_block_start_lineno": 141, "key_block_end_lineno": 145, "new_func_code": "def index_of(self, class_name: str) -> int:\n        \"\"\"Get class index based on its name.\n\n        Args:\n            class_name (str): Class name\n\n        Raises:\n            ValueError: Index of a class\n\n        Returns:\n            int: Raised if `class_name` not found in `index2class` dictionary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.io.dataclasses.IrisTemplate::serialize", "project": "open-iris", "func": "IrisTemplate::serialize", "origin_file": "iris/io/dataclasses.py", "test_list": ["../tests/unit_tests/io/test_dataclasses.py"], "prob_info": {"func_start_lineno": 610, "func_end_lineno": 622, "key_block_start_lineno": 616, "key_block_end_lineno": 622, "new_func_code": "def serialize(self) -> Dict[str, bytes]:\n        \"\"\"Serialize IrisTemplate object.\n\n        Returns:\n            Dict[str, bytes]: Serialized object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.utils.base64_encoding.base64_encode_array", "project": "open-iris", "func": "base64_encode_array", "origin_file": "iris/utils/base64_encoding.py", "test_list": ["../tests/unit_tests/io/test_dataclasses.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 18, "key_block_start_lineno": 16, "key_block_end_lineno": 18, "new_func_code": "def base64_encode_array(array2encode: np.ndarray) -> bytes:\n    \"\"\"Convert a numpy array to a packed base64 string.\n\n    Args:\n        array2encode (np.ndarray): The array to convert.\n\n    Returns:\n        bytes: The packed base64 string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.utils.base64_encoding.base64_decode_array", "project": "open-iris", "func": "base64_decode_array", "origin_file": "iris/utils/base64_encoding.py", "test_list": ["../tests/unit_tests/io/test_dataclasses.py"], "prob_info": {"func_start_lineno": 21, "func_end_lineno": 36, "key_block_start_lineno": 31, "key_block_end_lineno": 36, "new_func_code": "def base64_decode_array(bytes_array: str, array_shape: Tuple[int, int, int, int] = (16, 256, 2, 2)) -> np.ndarray:\n    \"\"\"Convert a packed base64 string to a numpy array.\n\n    Args:\n        bytes_array (bytes): The packed base64 byte string.\n        shape (Tuple[int, int, int, int], optional): The shape of the array. Defaults to (16, 256, 2, 2).\n\n    Returns:\n        np.ndarray: The array.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.bisectors_method.BisectorsMethod::run", "project": "open-iris", "func": "BisectorsMethod::run", "origin_file": "iris/nodes/eye_properties_estimation/bisectors_method.py", "test_list": ["../tests/unit_tests/nodes/eye_properties_estimation/test_bisectors_method.py"], "prob_info": {"func_start_lineno": 52, "func_end_lineno": 64, "key_block_start_lineno": 61, "key_block_end_lineno": 64, "new_func_code": "def run(self, geometries: GeometryPolygons) -> EyeCenters:\n        \"\"\"Estimate eye's iris and pupil centers.\n\n        Args:\n            geometries (GeometryPolygons): Geometry polygons.\n\n        Returns:\n            EyeCenters: Eye's centers object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.bisectors_method.BisectorsMethod::_find_center_coords", "project": "open-iris", "func": "BisectorsMethod::_find_center_coords", "origin_file": "iris/nodes/eye_properties_estimation/bisectors_method.py", "test_list": ["../tests/unit_tests/nodes/eye_properties_estimation/test_bisectors_method.py"], "prob_info": {"func_start_lineno": 66, "func_end_lineno": 82, "key_block_start_lineno": 76, "key_block_end_lineno": 82, "new_func_code": "def _find_center_coords(self, polygon: np.ndarray, diameter: float) -> Tuple[float, float]:\n        \"\"\"Find center coordinates of a polygon.\n\n        Args:\n            polygon (np.ndarray): np.ndarray.\n            diameter (float): diameter of the polygon.\n\n        Returns:\n            Tuple[float, float]: Tuple with the center location coordinates (x, y).\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.smoothing.Smoothing::_cut_into_arcs", "project": "open-iris", "func": "Smoothing::_cut_into_arcs", "origin_file": "iris/nodes/geometry_refinement/smoothing.py", "test_list": ["../tests/unit_tests/nodes/geometry_refinement/test_smoothing.py"], "prob_info": {"func_start_lineno": 84, "func_end_lineno": 119, "key_block_start_lineno": 94, "key_block_end_lineno": 119, "new_func_code": "def _cut_into_arcs(self, polygon: np.ndarray, center_xy: Tuple[float, float]) -> Tuple[List[np.ndarray], int]:\n        \"\"\"Cut contour into arcs.\n\n        Args:\n            polygon (np.ndarray): Contour polygon.\n            center_xy (Tuple[float, float]): Polygon's center.\n\n        Returns:\n            Tuple[List[np.ndarray], int]: Tuple with: (list of list of vertices, number of gaps detected in a contour).\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.smoothing.Smoothing::_sort_two_arrays", "project": "open-iris", "func": "Smoothing::_sort_two_arrays", "origin_file": "iris/nodes/geometry_refinement/smoothing.py", "test_list": ["../tests/unit_tests/nodes/geometry_refinement/test_smoothing.py"], "prob_info": {"func_start_lineno": 191, "func_end_lineno": 207, "key_block_start_lineno": 201, "key_block_end_lineno": 207, "new_func_code": "def _sort_two_arrays(self, first_list: np.ndarray, second_list: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Sort both numpy arrays based on values from the first_list.\n\n        Args:\n            first_list (np.ndarray): First array.\n            second_list (np.ndarray): Second array.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: Tuple with (sorted first array, sorted second array).\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.smoothing.Smoothing::_rolling_median", "project": "open-iris", "func": "Smoothing::_rolling_median", "origin_file": "iris/nodes/geometry_refinement/smoothing.py", "test_list": ["../tests/unit_tests/nodes/geometry_refinement/test_smoothing.py"], "prob_info": {"func_start_lineno": 231, "func_end_lineno": 256, "key_block_start_lineno": 244, "key_block_end_lineno": 256, "new_func_code": "def _rolling_median(self, signal: np.ndarray, kernel_offset: int) -> np.ndarray:\n        \"\"\"Compute rolling median of a 1D signal.\n\n        Args:\n            signal (np.ndarray): Signal values.\n            kernel_size (int): Kernel size.\n\n        Raises:\n            GeometryRefinementError: Raised if signal is not 1D.\n\n        Returns:\n            np.ndarray: Rolling median result.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.smoothing.Smoothing::_smooth_arc", "project": "open-iris", "func": "Smoothing::_smooth_arc", "origin_file": "iris/nodes/geometry_refinement/smoothing.py", "test_list": ["../tests/unit_tests/nodes/geometry_refinement/test_smoothing.py"], "prob_info": {"func_start_lineno": 121, "func_end_lineno": 144, "key_block_start_lineno": 131, "key_block_end_lineno": 144, "new_func_code": "def _smooth_arc(self, vertices: np.ndarray, center_xy: Tuple[float, float]) -> np.ndarray:\n        \"\"\"Smooth a single contour arc.\n\n        Args:\n            vertices (np.ndarray): Arc's vertices.\n            center_xy (Tuple[float, float]): Center of an entire contour.\n\n        Returns:\n            np.ndarray: Smoothed arc's vertices.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.orchestration.validators.pipeline_config_duplicate_node_name_check", "project": "open-iris", "func": "pipeline_config_duplicate_node_name_check", "origin_file": "iris/orchestration/validators.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 10, "func_end_lineno": 29, "key_block_start_lineno": 24, "key_block_end_lineno": 29, "new_func_code": "def pipeline_config_duplicate_node_name_check(cls: type, v: List[Any], field: fields.ModelField) -> List[Any]:\n    \"\"\"Check if all pipeline nodes have distinct names.\n\n    Args:\n        cls (type): Class type.\n        v (List[Any]): Value to check.\n        field (fields.ModelField): Field descriptor.\n\n    Raises:\n        IRISPipelineError: Raised if pipeline nodes aren't unique.\n\n    Returns:\n        List[Any]: `v` sent for further processing.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.pipelines.iris_pipeline.IRISPipeline::_check_pipeline_coherency", "project": "open-iris", "func": "IRISPipeline::_check_pipeline_coherency", "origin_file": "iris/pipelines/iris_pipeline.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 247, "func_end_lineno": 269, "key_block_start_lineno": 253, "key_block_end_lineno": 269, "new_func_code": "def _check_pipeline_coherency(self) -> None:\n        \"\"\"Check the pipeline configuration coherency.\n\n        Raises:\n            IRISPipelineError: Raised if a node's inputs are not declared beforehands\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.pipelines.iris_pipeline.IRISPipeline::instanciate_nodes", "project": "open-iris", "func": "IRISPipeline::instanciate_nodes", "origin_file": "iris/pipelines/iris_pipeline.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 159, "func_end_lineno": 177, "key_block_start_lineno": 167, "key_block_end_lineno": 177, "new_func_code": "def instanciate_nodes(self) -> Dict[str, Algorithm]:\n        \"\"\"Given a list of PipelineNode, return the associated instanciated nodes.\n\n        NOTE: All nodes of type listed in self.env.disabled_qa will be filtered out. This allows one config file to be used in various QA standards levels.\n\n        Returns:\n            Dict[str, Algorithm]: instanciated nodes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.pipelines.iris_pipeline.IRISPipeline::instanciate_pipeline", "project": "open-iris", "func": "IRISPipeline::instanciate_pipeline", "origin_file": "iris/pipelines/iris_pipeline.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 179, "func_end_lineno": 200, "key_block_start_lineno": 185, "key_block_end_lineno": 200, "new_func_code": "def instanciate_pipeline(self) -> List[PipelineNode]:\n        \"\"\"Given a list of PipelineNodes, crawl the parameters and instanciate the PipelineClass available.\n\n        Returns:\n            List[PipelineNode]: pipeline with instanciated parameters\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.pipelines.iris_pipeline.IRISPipeline::instanciate_class", "project": "open-iris", "func": "IRISPipeline::instanciate_class", "origin_file": "iris/pipelines/iris_pipeline.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 225, "func_end_lineno": 245, "key_block_start_lineno": 240, "key_block_end_lineno": 245, "new_func_code": "def instanciate_class(self, class_name: str, kwargs: Dict[str, Any]) -> Callable:\n        \"\"\"Instanciate a class from its string definition and its kwargs.\n\n        This function relies on pydoc.locate, a safe way to instanciate a class from its string definition, which itself relies on pydoc.safe_import.\n\n        Args:\n            class_name (str): name of the class.\n            kwargs (Dict): kwargs to pass to the class at instanciation time\n\n        Returns:\n            Callable: the instanciated class\n\n        Raises:\n            IRISPipelineError: Raised if the class cannot be located.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.contour_interpolation.ContourInterpolation::_interpolate_polygon_points", "project": "open-iris", "func": "ContourInterpolation::_interpolate_polygon_points", "origin_file": "iris/nodes/geometry_refinement/contour_interpolation.py", "test_list": ["../tests/unit_tests/nodes/geometry_refinement/test_contour_interpolation.py"], "prob_info": {"func_start_lineno": 53, "func_end_lineno": 77, "key_block_start_lineno": 63, "key_block_end_lineno": 77, "new_func_code": "def _interpolate_polygon_points(self, polygon: np.ndarray, max_distance_between_points_px: float) -> np.ndarray:\n        \"\"\"Interpolate contours points, so that the distance between two is no greater than `self.params.max_distance_between_boundary_points` in pixel space.\n\n        Args:\n            polygon (np.ndarray): Contour polygons.\n            max_distance_between_points_px (float): `self.params.max_distance_between_boundary_points` expressed in pixel length relative to iris diameter.\n\n        Returns:\n            np.ndarray: Interpolated polygon points.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.perspective_normalization.PerspectiveNormalization::_bbox_coords", "project": "open-iris", "func": "PerspectiveNormalization::_bbox_coords", "origin_file": "iris/nodes/normalization/perspective_normalization.py", "test_list": ["../tests/unit_tests/nodes/normalization/test_perspective_normalization.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 255, "key_block_start_lineno": 252, "key_block_end_lineno": 255, "new_func_code": "def _bbox_coords(self, norm_dst_points: np.ndarray) -> Tuple[int, int, int, int]:\n        \"\"\"Extract the bounding box of currently processed normalized image ROI.\n\n        Args:\n            norm_dst_points (np.ndarray): Normalized image ROI coordinates.\n\n        Returns:\n            Tuple[int, int, int, int]: Bounding box coordinates in form (xmin, ymin, xmax, ymax).\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.perspective_normalization.PerspectiveNormalization::_correspondence_rois_coords", "project": "open-iris", "func": "PerspectiveNormalization::_correspondence_rois_coords", "origin_file": "iris/nodes/normalization/perspective_normalization.py", "test_list": ["../tests/unit_tests/nodes/normalization/test_perspective_normalization.py"], "prob_info": {"func_start_lineno": 257, "func_end_lineno": 288, "key_block_start_lineno": 285, "key_block_end_lineno": 288, "new_func_code": "def _correspondence_rois_coords(\n        self,\n        angle_idx: int,\n        ring_idx: int,\n        src_points: np.ndarray,\n        dst_points: np.ndarray,\n    ) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Generate a single correspondence ROIs between original image and normalized one based on angle index and ring index.\n\n        Args:\n            angle_idx (int): Boundary point angle index.\n            ring_idx (int): Intermediate ring index.\n            src_points (np.ndarray): All mapping points from an original image.\n                NumPy array of shape (\n                    num_intermediate_rings = self.intermediate_radiuses,\n                    num_boundary_points = 360 // self.skip_boundary_points,\n                    xy_coords = 2\n                ).\n            dst_points (np.ndarray): All mapping points from an normalized image.\n                NumPy array of shape (\n                    num_intermediate_rings = self.intermediate_radiuses,\n                    num_boundary_points = 360 // self.skip_boundary_points,\n                    xy_coords = 2\n                ).\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: Tuple with extracted from src_points and dst_points ROIs.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.binarization.specular_reflection_detection.SpecularReflectionDetection::run", "project": "open-iris", "func": "SpecularReflectionDetection::run", "origin_file": "iris/nodes/binarization/specular_reflection_detection.py", "test_list": ["../tests/unit_tests/nodes/binarization/test_specular_reflection_detection.py"], "prob_info": {"func_start_lineno": 26, "func_end_lineno": 40, "key_block_start_lineno": 35, "key_block_end_lineno": 40, "new_func_code": "def run(self, ir_image: IRImage) -> NoiseMask:\n        \"\"\"Thresholds an IRImage to detect Specular Reflection.\n\n        Args:\n            ir_image (IRImage): Infrared image object.\n\n        Returns:\n            NoiseMask: a binary map of the thresholded IRImage.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.pupil_iris_property_calculator.PupilIrisPropertyCalculator::run", "project": "open-iris", "func": "PupilIrisPropertyCalculator::run", "origin_file": "iris/nodes/eye_properties_estimation/pupil_iris_property_calculator.py", "test_list": ["../tests/unit_tests/nodes/eye_properties_estimation/test_pupil_iris_property_calculator.py"], "prob_info": {"func_start_lineno": 50, "func_end_lineno": 78, "key_block_start_lineno": 63, "key_block_end_lineno": 78, "new_func_code": "def run(self, geometries: GeometryPolygons, eye_centers: EyeCenters) -> PupilToIrisProperty:\n        \"\"\"Calculate pupil-to-iris property.\n\n        Args:\n            geometries (GeometryPolygons): polygons used for calculating pupil-ro-iris property.\n            eye_centers (EyeCenters): eye centers used for calculating pupil-ro-iris property.\n\n        Raises:\n            PupilIrisPropertyEstimationError: Raised if 1) the pupil or iris diameter is too small, 2) pupil diameter is larger than or equal to iris diameter, 3) pupil center is outside iris.\n\n        Returns:\n            PupilToIrisProperty: pupil-ro-iris property object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.linear_normalization.LinearNormalization::_generate_correspondences", "project": "open-iris", "func": "LinearNormalization::_generate_correspondences", "origin_file": "iris/nodes/normalization/linear_normalization.py", "test_list": ["../tests/unit_tests/nodes/normalization/test_linear_normalization.py"], "prob_info": {"func_start_lineno": 84, "func_end_lineno": 98, "key_block_start_lineno": 94, "key_block_end_lineno": 98, "new_func_code": "def _generate_correspondences(self, pupil_points: np.ndarray, iris_points: np.ndarray) -> np.ndarray:\n        \"\"\"Generate correspondences between points in original image and normalized image.\n\n        Args:\n            pupil_points (np.ndarray): Pupil bounding points. NumPy array of shape (num_points = 512, xy_coords = 2).\n            iris_points (np.ndarray): Iris bounding points. NumPy array of shape (num_points = 512, xy_coords = 2).\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: Tuple with generated correspondences.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.validators.cross_object_validators.EyeCentersInsideImageValidator::_check_center_valid", "project": "open-iris", "func": "EyeCentersInsideImageValidator::_check_center_valid", "origin_file": "iris/nodes/validators/cross_object_validators.py", "test_list": ["../tests/unit_tests/nodes/validators/test_cross_object_validators.py"], "prob_info": {"func_start_lineno": 49, "func_end_lineno": 63, "key_block_start_lineno": 60, "key_block_end_lineno": 63, "new_func_code": "def _check_center_valid(self, center_x: float, center_y: float, ir_image: IRImage) -> bool:\n        \"\"\"Check if center point is within proper image bound.\n\n        Args:\n            center_x (float): Center x\n            center_y (float): Center y\n            ir_image (IRImage): IR image object\n\n        Returns:\n            bool: Result of the check.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.image_filters.gabor_filters.upper_bound_Gabor_parameters", "project": "open-iris", "func": "upper_bound_Gabor_parameters", "origin_file": "iris/nodes/iris_response/image_filters/gabor_filters.py", "test_list": ["../tests/unit_tests/nodes/iris_response/image_filters/test_gabor_filters.py"], "prob_info": {"func_start_lineno": 11, "func_end_lineno": 38, "key_block_start_lineno": 24, "key_block_end_lineno": 38, "new_func_code": "def upper_bound_Gabor_parameters(cls: type, values: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Check upper bounds of Gabor filter parameters such as sigma_phi, sigma_rho and lambda_phi for the given kernel_size.\n\n    Args:\n        cls (type): class type.\n        values (Dict[str, Any]): values to be checked.\n\n    Raises:\n        ImageFilterError: Raised if 1) sigma_phi is greater than kernel_size[0], 2) sigma_rho is greater than kernel_size[1], 3) lambda_phi greater than kernel_size[0].\n\n    Returns:\n        Dict[str, Any]:  values of checked parameters.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.image_filters.gabor_filters.get_xy_mesh", "project": "open-iris", "func": "get_xy_mesh", "origin_file": "iris/nodes/iris_response/image_filters/gabor_filters.py", "test_list": ["../tests/unit_tests/nodes/iris_response/image_filters/test_gabor_filters.py"], "prob_info": {"func_start_lineno": 62, "func_end_lineno": 81, "key_block_start_lineno": 71, "key_block_end_lineno": 81, "new_func_code": "def get_xy_mesh(kernel_size: Tuple[int, int]) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Get (x,y) meshgrids for a given kernel size.\n\n    Args:\n        kernel_size (Tuple[int, int]): Kernel width and height.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: meshgrid of (x, y) positions.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.image_filters.gabor_filters.upper_bound_LogGabor_parameters", "project": "open-iris", "func": "upper_bound_LogGabor_parameters", "origin_file": "iris/nodes/iris_response/image_filters/gabor_filters.py", "test_list": ["../tests/unit_tests/nodes/iris_response/image_filters/test_gabor_filters.py"], "prob_info": {"func_start_lineno": 41, "func_end_lineno": 59, "key_block_start_lineno": 54, "key_block_end_lineno": 59, "new_func_code": "def upper_bound_LogGabor_parameters(cls: type, values: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Check upper bound of LogGabor filter parameter lambda_rho for the given kernel_size.\n\n    Args:\n        cls (type): class type.\n        values (Dict[str, Any]): values to be checked.\n\n    Raises:\n        ImageFilterError: lambda_phi can not be greater than kernel_size[1].\n\n    Returns:\n        Dict[str, Any]: values of checked parameters.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.smoothing.Smoothing::_find_start_index", "project": "open-iris", "func": "Smoothing::_find_start_index", "origin_file": "iris/nodes/geometry_refinement/smoothing.py", "test_list": ["../tests/unit_tests/nodes/geometry_refinement/test_smoothing.py"], "prob_info": {"func_start_lineno": 209, "func_end_lineno": 229, "key_block_start_lineno": 221, "key_block_end_lineno": 229, "new_func_code": "def _find_start_index(self, phi: np.ndarray) -> int:\n        \"\"\"Find the start index by checking the largest gap. phi needs to be sorted.\n\n        Args:\n            phi (np.ndarray): phi angle values.\n\n        Raises:\n            GeometryRefinementError: Raised if phi values are not sorted ascendingly.\n\n        Returns:\n            int: Index value.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.image_filters.gabor_filters.convert_to_fixpoint_kernelvalues", "project": "open-iris", "func": "convert_to_fixpoint_kernelvalues", "origin_file": "iris/nodes/iris_response/image_filters/gabor_filters.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 140, "func_end_lineno": 155, "key_block_start_lineno": 149, "key_block_end_lineno": 155, "new_func_code": "def convert_to_fixpoint_kernelvalues(kernel_values: np.ndarray) -> np.ndarray:\n    \"\"\"Convert the kernel values (both real and imaginary) to fix points.\n\n    Args:\n        kernel_values (np.ndarray): Kernel values.\n\n    Returns:\n        np.ndarray: fix-point Kernel values.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.pipelines.iris_pipeline.IRISPipeline::run", "project": "open-iris", "func": "IRISPipeline::run", "origin_file": "iris/pipelines/iris_pipeline.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 99, "func_end_lineno": 144, "key_block_start_lineno": 109, "key_block_end_lineno": 144, "new_func_code": "def run(self, img_data: np.ndarray, eye_side: Literal[\"left\", \"right\"]) -> Any:\n        \"\"\"Generate template.\n\n        Args:\n            img_data (np.ndarray): Infrared image as a numpy array.\n            eye_side (Literal[\"left\", \"right\"]): Eye side.\n\n        Returns:\n            Any: Output created by builder specified in environment.pipeline_output_builder.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.segmentation.onnx_multilabel_segmentation.ONNXMultilabelSegmentation::_postprocess", "project": "open-iris", "func": "ONNXMultilabelSegmentation::_postprocess", "origin_file": "iris/nodes/segmentation/onnx_multilabel_segmentation.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 126, "func_end_lineno": 144, "key_block_start_lineno": 136, "key_block_end_lineno": 144, "new_func_code": "def _postprocess(self, nn_output: List[np.ndarray], original_image_resolution: Tuple[int, int]) -> SegmentationMap:\n        \"\"\"Postprocess model prediction and wrap it within SegmentationMap object for further processing.\n\n        Args:\n            nn_output (List[np.ndarray]): Neural Network output. Should be of length equal to 2.\n            original_image_resolution (Tuple[int, int]): Original image resolution used to resize predicted semantic segmentation maps.\n\n        Returns:\n            SegmentationMap: Postprocessed model predictions.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.binarization.multilabel_binarization.MultilabelSegmentationBinarization::run", "project": "open-iris", "func": "MultilabelSegmentationBinarization::run", "origin_file": "iris/nodes/binarization/multilabel_binarization.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 48, "func_end_lineno": 69, "key_block_start_lineno": 57, "key_block_end_lineno": 69, "new_func_code": "def run(self, segmentation_map: SegmentationMap) -> Tuple[GeometryMask, NoiseMask]:\n        \"\"\"Perform segmentation binarization.\n\n        Args:\n            segmentation_map (SegmentationMap): Predictions.\n\n        Returns:\n            Tuple[GeometryMask, NoiseMask]: Binarized geometry mask and noise mask.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.vectorization.contouring.ContouringAlgorithm::run", "project": "open-iris", "func": "ContouringAlgorithm::run", "origin_file": "iris/nodes/vectorization/contouring.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 60, "func_end_lineno": 77, "key_block_start_lineno": 72, "key_block_end_lineno": 77, "new_func_code": "def run(self, geometry_mask: GeometryMask) -> GeometryPolygons:\n        \"\"\"Contouring vectorization algorithm implementation.\n\n        Args:\n            geometry_mask (GeometryMask): Geometry segmentation map.\n\n        Raises:\n            VectorizationError: Raised if iris region not segmented or an error occur during iris region processing.\n\n        Returns:\n            GeometryPolygons: Geometry polygons points.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.vectorization.contouring.ContouringAlgorithm::_find_contours", "project": "open-iris", "func": "ContouringAlgorithm::_find_contours", "origin_file": "iris/nodes/vectorization/contouring.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 79, "func_end_lineno": 92, "key_block_start_lineno": 88, "key_block_end_lineno": 92, "new_func_code": "def _find_contours(self, mask: GeometryMask) -> GeometryPolygons:\n        \"\"\"Find raw contours for different classes in raster.\n\n        Args:\n            mask (GeometryMask): Raster object.\n\n        Returns:\n            GeometryPolygons: Raw contours indicating polygons of different classes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.vectorization.contouring.ContouringAlgorithm::_find_class_contours", "project": "open-iris", "func": "ContouringAlgorithm::_find_class_contours", "origin_file": "iris/nodes/vectorization/contouring.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 94, "func_end_lineno": 119, "key_block_start_lineno": 106, "key_block_end_lineno": 119, "new_func_code": "def _find_class_contours(self, binary_mask: np.ndarray) -> np.ndarray:\n        \"\"\"Find contour between two different contours.\n\n        Args:\n            binary_mask (np.ndarray): Raster object.\n\n        Raises:\n            VectorizationError: Raised if number of contours found is different than 1.\n\n        Returns:\n            np.ndarray: Contour points array.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.contour_interpolation.ContourInterpolation::run", "project": "open-iris", "func": "ContourInterpolation::run", "origin_file": "iris/nodes/geometry_refinement/contour_interpolation.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 32, "func_end_lineno": 51, "key_block_start_lineno": 41, "key_block_end_lineno": 51, "new_func_code": "def run(self, polygons: GeometryPolygons) -> GeometryPolygons:\n        \"\"\"Refine polygons by interpolating contour points.\n\n        Args:\n            polygons (GeometryPolygons): Polygons to refine.\n\n        Returns:\n            GeometryPolygons: Refined polygons.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.contour_points_filter.ContourPointNoiseEyeballDistanceFilter::run", "project": "open-iris", "func": "ContourPointNoiseEyeballDistanceFilter::run", "origin_file": "iris/nodes/geometry_refinement/contour_points_filter.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 35, "func_end_lineno": 68, "key_block_start_lineno": 45, "key_block_end_lineno": 68, "new_func_code": "def run(self, polygons: GeometryPolygons, geometry_mask: NoiseMask) -> GeometryPolygons:\n        \"\"\"Perform polygon refinement by filtering out those iris/pupil polygons points which are to close to eyeball or noise.\n\n        Args:\n            polygons (GeometryPolygons): Polygons to refine.\n            geometry_mask (NoiseMask): Geometry noise mask.\n\n        Returns:\n            GeometryPolygons: Refined geometry polygons.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.contour_points_filter.ContourPointNoiseEyeballDistanceFilter::_filter_polygon_points", "project": "open-iris", "func": "ContourPointNoiseEyeballDistanceFilter::_filter_polygon_points", "origin_file": "iris/nodes/geometry_refinement/contour_points_filter.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 70, "func_end_lineno": 84, "key_block_start_lineno": 80, "key_block_end_lineno": 84, "new_func_code": "def _filter_polygon_points(self, forbidden_touch_map: np.ndarray, polygon_points: np.ndarray) -> np.ndarray:\n        \"\"\"Filter polygon's points.\n\n        Args:\n            forbidden_touch_map (np.ndarray): Forbidden touch map. If value of an element is greater then 0 then it means that point is to close to noise or eyeball.\n            polygon_points (np.ndarray): Polygon's points.\n\n        Returns:\n            np.ndarray: Filtered polygon's points.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.smoothing.Smoothing::run", "project": "open-iris", "func": "Smoothing::run", "origin_file": "iris/nodes/geometry_refinement/smoothing.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 49, "func_end_lineno": 62, "key_block_start_lineno": 59, "key_block_end_lineno": 62, "new_func_code": "def run(self, polygons: GeometryPolygons, eye_centers: EyeCenters) -> GeometryPolygons:\n        \"\"\"Perform smoothing refinement.\n\n        Args:\n            polygons (GeometryPolygons): Contours to refine.\n            eye_centers (EyeCenters): Eye center used when performing a coordinates mapping from cartesian space to polar space.\n\n        Returns:\n            GeometryPolygons: Smoothed contours.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.smoothing.Smoothing::_smooth", "project": "open-iris", "func": "Smoothing::_smooth", "origin_file": "iris/nodes/geometry_refinement/smoothing.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 64, "func_end_lineno": 82, "key_block_start_lineno": 74, "key_block_end_lineno": 82, "new_func_code": "def _smooth(self, polygon: np.ndarray, center_xy: Tuple[float, float]) -> np.ndarray:\n        \"\"\"Smooth a single contour.\n\n        Args:\n            polygon (np.ndarray): Contour to smooth.\n            center_xy (Tuple[float, float]): Contour's center.\n\n        Returns:\n            np.ndarray: Smoothed contour's vertices.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_estimation.fusion_extrapolation.FusionExtrapolation::run", "project": "open-iris", "func": "FusionExtrapolation::run", "origin_file": "iris/nodes/geometry_estimation/fusion_extrapolation.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 50, "func_end_lineno": 74, "key_block_start_lineno": 60, "key_block_end_lineno": 74, "new_func_code": "def run(self, input_polygons: GeometryPolygons, eye_center: EyeCenters) -> GeometryPolygons:\n        \"\"\"Perform extrapolation algorithm.\n\n        Args:\n            input_polygons (GeometryPolygons): Smoothed polygons.\n            eye_center (EyeCenters): Computed eye centers.\n\n        Returns:\n            GeometryPolygons: Extrapolated polygons\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_estimation.linear_extrapolation.LinearExtrapolation::run", "project": "open-iris", "func": "LinearExtrapolation::run", "origin_file": "iris/nodes/geometry_estimation/linear_extrapolation.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 41, "func_end_lineno": 56, "key_block_start_lineno": 51, "key_block_end_lineno": 56, "new_func_code": "def run(self, input_polygons: GeometryPolygons, eye_center: EyeCenters) -> GeometryPolygons:\n        \"\"\"Estimate contours.\n\n        Args:\n            input_polygons (GeometryPolygons): Input contours.\n            eye_center (EyeCenters): Eye's centers.\n\n        Returns:\n            GeometryPolygons: Extrapolated contours.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.eccentricity_offgaze_estimation.EccentricityOffgazeEstimation::run", "project": "open-iris", "func": "EccentricityOffgazeEstimation::run", "origin_file": "iris/nodes/eye_properties_estimation/eccentricity_offgaze_estimation.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 141, "func_end_lineno": 162, "key_block_start_lineno": 150, "key_block_end_lineno": 162, "new_func_code": "def run(self, geometries: GeometryPolygons) -> Offgaze:\n        \"\"\"Calculate offgaze estimation.\n\n        Args:\n            geometries (GeometryPolygons): polygons used for offgaze estimation.\n\n        Returns:\n            Offgaze: offgaze object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.eccentricity_offgaze_estimation.get_eccentricity_through_moments", "project": "open-iris", "func": "get_eccentricity_through_moments", "origin_file": "iris/nodes/eye_properties_estimation/eccentricity_offgaze_estimation.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 12, "func_end_lineno": 23, "key_block_start_lineno": 21, "key_block_end_lineno": 23, "new_func_code": "def get_eccentricity_through_moments(shape_array: np.ndarray) -> float:\n    \"\"\"Determine the eccentricity of the shape through its second order image moments.\n\n    Args:\n        shape_array (np.ndarray): Shape array.\n\n    Returns:\n        float: Computed eccentricity.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.aggregation.noise_mask_union.NoiseMaskUnion::run", "project": "open-iris", "func": "NoiseMaskUnion::run", "origin_file": "iris/nodes/aggregation/noise_mask_union.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 12, "func_end_lineno": 32, "key_block_start_lineno": 24, "key_block_end_lineno": 32, "new_func_code": "def run(self, elements: List[NoiseMask]) -> NoiseMask:\n        \"\"\"Compute the union of a list of NoiseMask.\n\n        Args:\n            elements (List[NoiseMask]): input NoiseMasks.\n\n        Raises:\n            ValueError: if not all NoiseMask.mask do not have the same shape.\n\n        Returns:\n            NoiseMask: aggregated NoiseMasks\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.linear_normalization.LinearNormalization::run", "project": "open-iris", "func": "LinearNormalization::run", "origin_file": "iris/nodes/normalization/linear_normalization.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 43, "func_end_lineno": 82, "key_block_start_lineno": 61, "key_block_end_lineno": 82, "new_func_code": "def run(\n        self,\n        image: IRImage,\n        noise_mask: NoiseMask,\n        extrapolated_contours: GeometryPolygons,\n        eye_orientation: EyeOrientation,\n    ) -> NormalizedIris:\n        \"\"\"Normalize iris using linear transformation when sampling points from cartisian to polar coordinates.\n\n        Args:\n            image (IRImage): Input image to normalize.\n            noise_mask (NoiseMask): Noise mask.\n            extrapolated_contours (GeometryPolygons): Extrapolated contours.\n            eye_orientation (EyeOrientation): Eye orientation angle.\n\n        Returns:\n            NormalizedIris: NormalizedIris object containing normalized image and iris mask.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.common.generate_iris_mask", "project": "open-iris", "func": "generate_iris_mask", "origin_file": "iris/nodes/normalization/common.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 10, "func_end_lineno": 28, "key_block_start_lineno": 20, "key_block_end_lineno": 28, "new_func_code": "def generate_iris_mask(extrapolated_contours: GeometryPolygons, noise_mask: np.ndarray) -> np.ndarray:\n    \"\"\"Generate iris mask by first finding the intersection region between extrapolated iris contours and eyeball contours. Then remove from the outputted mask those pixels for which noise_mask is equal to True.\n\n    Args:\n        extrapolated_contours (GeometryPolygons): Iris polygon vertices.\n        noise_mask (np.ndarray): Noise mask.\n\n    Returns:\n        np.ndarray: Iris mask.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.normalization.common.normalize_all", "project": "open-iris", "func": "normalize_all", "origin_file": "iris/nodes/normalization/common.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 157, "func_end_lineno": 188, "key_block_start_lineno": 172, "key_block_end_lineno": 188, "new_func_code": "def normalize_all(\n    image: np.ndarray,\n    iris_mask: np.ndarray,\n    src_points: np.ndarray,\n) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Normalize all points of an image using nearest neighbor.\n\n    Args:\n        image (np.ndarray): Original, not normalized image.\n        iris_mask (np.ndarray): Iris class segmentation mask.\n        src_points (np.ndarray): original input image points.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: Tuple with normalized image and mask.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.sharpness_estimation.SharpnessEstimation::run", "project": "open-iris", "func": "SharpnessEstimation::run", "origin_file": "iris/nodes/eye_properties_estimation/sharpness_estimation.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 53, "func_end_lineno": 67, "key_block_start_lineno": 62, "key_block_end_lineno": 67, "new_func_code": "def run(self, normalization_output: NormalizedIris) -> Sharpness:\n        \"\"\"Calculate sharpness of the normalized iris.\n\n        Args:\n            normalization_output (NormalizedIris): Normalized iris.\n\n        Returns:\n            Sharpness: Sharpness object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.conv_filter_bank.ConvFilterBank::run", "project": "open-iris", "func": "ConvFilterBank::run", "origin_file": "iris/nodes/iris_response/conv_filter_bank.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 96, "func_end_lineno": 117, "key_block_start_lineno": 105, "key_block_end_lineno": 117, "new_func_code": "def run(self, normalization_output: NormalizedIris) -> IrisFilterResponse:\n        \"\"\"Apply filters to a normalized iris image.\n\n        Args:\n            normalization_output (NormalizedIris): Output of the normalization process.\n\n        Returns:\n            IrisFilterResponse: filter responses.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.conv_filter_bank.ConvFilterBank::_convolve", "project": "open-iris", "func": "ConvFilterBank::_convolve", "origin_file": "iris/nodes/iris_response/conv_filter_bank.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 119, "func_end_lineno": 167, "key_block_start_lineno": 132, "key_block_end_lineno": 167, "new_func_code": "def _convolve(\n        self, img_filter: ImageFilter, probe_schema: ProbeSchema, normalization_output: NormalizedIris\n    ) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Apply convolution to a given normalized iris image with the filter and probe schema.\n\n        Args:\n            img_filter (ImageFilter): filter used for convolution.\n            probe_schema (ProbeSchema): probe schema used for convolution.\n            normalization_output (NormalizedIris): Output of the normalization process.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: iris response and mask response.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response.conv_filter_bank.polar_img_padding", "project": "open-iris", "func": "polar_img_padding", "origin_file": "iris/nodes/iris_response/conv_filter_bank.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 15, "func_end_lineno": 33, "key_block_start_lineno": 26, "key_block_end_lineno": 33, "new_func_code": "def polar_img_padding(img: np.ndarray, p_rows: int, p_cols: int) -> np.ndarray:\n    \"\"\"Apply zero-padding vertically and rotate-padding horizontally to a normalized image in polar coordinates.\n\n    Args:\n        img (np.ndarray): normalized image in polar coordinates.\n        p_rows (int): padding size on top and bottom.\n        p_cols (int): padding size on left and right.\n\n    Returns:\n        np.ndarray: padded image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.iris_response_refinement.fragile_bits_refinement.FragileBitRefinement::run", "project": "open-iris", "func": "FragileBitRefinement::run", "origin_file": "iris/nodes/iris_response_refinement/fragile_bits_refinement.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 53, "func_end_lineno": 111, "key_block_start_lineno": 63, "key_block_end_lineno": 111, "new_func_code": "def run(self, response: IrisFilterResponse) -> IrisFilterResponse:\n        \"\"\"Generate refined IrisFilterResponse.\n\n\n        Args:\n            response (IrisFilterResponse): Filter bank response\n\n        Returns:\n            IrisFilterResponse: Filter bank response.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.encoder.iris_encoder.IrisEncoder::run", "project": "open-iris", "func": "IrisEncoder::run", "origin_file": "iris/nodes/encoder/iris_encoder.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 38, "func_end_lineno": 61, "key_block_start_lineno": 47, "key_block_end_lineno": 61, "new_func_code": "def run(self, response: IrisFilterResponse) -> IrisTemplate:\n        \"\"\"Encode iris code and mask code.\n\n        Args:\n            response (IrisFilterResponse): Filter responses.\n\n        Returns:\n            IrisTemplate: Final iris template.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.orchestration.output_builders.build_orb_output", "project": "open-iris", "func": "build_orb_output", "origin_file": "iris/orchestration/output_builders.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 35, "func_end_lineno": 51, "key_block_start_lineno": 48, "key_block_end_lineno": 51, "new_func_code": "def build_orb_output(call_trace: PipelineCallTraceStorage) -> Dict[str, Any]:\n    \"\"\"Build the output for the Orb.\n\n    Args:\n        call_trace (PipelineCallTraceStorage): Pipeline call results storage.\n\n    Returns:\n        Dict[str, Any]: {\n        \"iris_template\": (Optional[Dict]) the iris template dict if the pipeline succeeded.\n        \"error\": (Optional[Dict]) the error dict if the pipeline returned an error.\n        \"metadata\": (Dict) the metadata dict.\n        }.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.orchestration.output_builders.build_simple_orb_output", "project": "open-iris", "func": "build_simple_orb_output", "origin_file": "iris/orchestration/output_builders.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 9, "func_end_lineno": 32, "key_block_start_lineno": 22, "key_block_end_lineno": 32, "new_func_code": "def build_simple_orb_output(call_trace: PipelineCallTraceStorage) -> Dict[str, Any]:\n    \"\"\"Build the output for the Orb.\n\n    Args:\n        call_trace (PipelineCallTraceStorage): Pipeline call results storage.\n\n    Returns:\n        Dict[str, Any]: {\n        \"iris_template\": (Optional[IrisTemplate]) the iris template object if the pipeline succeeded,\n        \"error\": (Optional[Dict]) the error dict if the pipeline returned an error,\n        \"metadata\": (Dict) the metadata dict,\n        }.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.orchestration.output_builders.__get_metadata", "project": "open-iris", "func": "__get_metadata", "origin_file": "iris/orchestration/output_builders.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 115, "func_end_lineno": 138, "key_block_start_lineno": 124, "key_block_end_lineno": 138, "new_func_code": "def __get_metadata(call_trace: PipelineCallTraceStorage) -> Dict[str, Any]:\n    \"\"\"Produce metadata output from a call_trace.\n\n    Args:\n        call_trace (PipelineCallTraceStorage): Pipeline call trace.\n\n    Returns:\n        Dict[str, Any]: Metadata dictionary.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.orchestration.output_builders.__safe_serialize", "project": "open-iris", "func": "__safe_serialize", "origin_file": "iris/orchestration/output_builders.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 93, "func_end_lineno": 112, "key_block_start_lineno": 105, "key_block_end_lineno": 112, "new_func_code": "def __safe_serialize(object: Optional[ImmutableModel]) -> Optional[Dict[str, Any]]:\n    \"\"\"Serialize an object.\n\n    Args:\n        object (Optional[ImmutableModel]): Object to be serialized.\n\n    Raises:\n        NotImplementedError: Raised if object is not serializable.\n\n    Returns:\n        Optional[Dict[str, Any]]: Serialized object.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.orchestration.output_builders.__get_error", "project": "open-iris", "func": "__get_error", "origin_file": "iris/orchestration/output_builders.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 158, "func_end_lineno": 177, "key_block_start_lineno": 167, "key_block_end_lineno": 177, "new_func_code": "def __get_error(call_trace: PipelineCallTraceStorage) -> Optional[Dict[str, Any]]:\n    \"\"\"Produce error output from a call_trace.\n\n    Args:\n        call_trace (PipelineCallTraceStorage): Pipeline call trace.\n\n    Returns:\n        Optional[Dict[str, Any]]: Optional error dictionary if such occured.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.orchestration.output_builders.build_simple_debugging_output", "project": "open-iris", "func": "build_simple_debugging_output", "origin_file": "iris/orchestration/output_builders.py", "test_list": ["../tests/unit_tests/pipelines/test_iris_pipeline.py"], "prob_info": {"func_start_lineno": 54, "func_end_lineno": 90, "key_block_start_lineno": 63, "key_block_end_lineno": 90, "new_func_code": "def build_simple_debugging_output(call_trace: PipelineCallTraceStorage) -> Dict[str, Any]:\n    \"\"\"Build the simplest output for debugging purposes.\n\n    Args:\n        call_trace (PipelineCallTraceStorage): Pipeline call results storage.\n\n    Returns:\n        Dict[str, Any]: Returns data to be stored in MongoDB.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_estimation.linear_extrapolation.LinearExtrapolation::_estimate", "project": "open-iris", "func": "LinearExtrapolation::_estimate", "origin_file": "iris/nodes/geometry_estimation/linear_extrapolation.py", "test_list": ["../tests/unit_tests/nodes/geometry_estimation/test_linear_extrapolation.py"], "prob_info": {"func_start_lineno": 58, "func_end_lineno": 82, "key_block_start_lineno": 68, "key_block_end_lineno": 82, "new_func_code": "def _estimate(self, vertices: np.ndarray, center_xy: Tuple[float, float]) -> np.ndarray:\n        \"\"\"Estimate a circle fit for a single contour.\n\n        Args:\n            vertices (np.ndarray): Contour's vertices.\n            center_xy (Tuple[float, float]): Contour's center position.\n\n        Returns:\n            np.ndarray: Estimated polygon.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.matcher.utils.get_bitcounts", "project": "open-iris", "func": "get_bitcounts", "origin_file": "iris/nodes/matcher/utils.py", "test_list": ["../tests/unit_tests/nodes/matcher/test_matcher_utils.py"], "prob_info": {"func_start_lineno": 27, "func_end_lineno": 46, "key_block_start_lineno": 38, "key_block_end_lineno": 46, "new_func_code": "def get_bitcounts(template_probe: IrisTemplate, template_gallery: IrisTemplate, shift: int) -> np.ndarray:\n    \"\"\"Get bitcounts in iris and mask codes.\n\n    Args:\n        template_probe (IrisTemplate): Iris template from probe.\n        template_gallery (IrisTemplate): Iris template from gallery.\n        shift (int): Rotation shift (in columns)\n\n    Returns:\n        np.ndarray: Bitcounts in iris and mask codes.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.occlusion_calculator.OcclusionCalculator::_get_quantile_points", "project": "open-iris", "func": "OcclusionCalculator::_get_quantile_points", "origin_file": "iris/nodes/eye_properties_estimation/occlusion_calculator.py", "test_list": ["../tests/unit_tests/nodes/eye_properties_estimation/test_occlusion_calculator.py"], "prob_info": {"func_start_lineno": 99, "func_end_lineno": 142, "key_block_start_lineno": 112, "key_block_end_lineno": 142, "new_func_code": "def _get_quantile_points(\n        self, iris_coords: np.ndarray, eye_orientation: EyeOrientation, eye_centers: EyeCenters\n    ) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Get those iris's points which fall into a specified quantile.\n\n        Args:\n            iris_coords (np.ndarray): Iris polygon coordinates.\n            eye_orientation: (EyeOrientation): Eye orientation.\n            eye_centers: (EyeCenters): Eye centers.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: Tuple with xs and ys that falls into quantile region.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.bisectors_method.BisectorsMethod::_find_best_intersection", "project": "open-iris", "func": "BisectorsMethod::_find_best_intersection", "origin_file": "iris/nodes/eye_properties_estimation/bisectors_method.py", "test_list": ["../tests/unit_tests/nodes/eye_properties_estimation/test_bisectors_method.py"], "prob_info": {"func_start_lineno": 142, "func_end_lineno": 170, "key_block_start_lineno": 157, "key_block_end_lineno": 170, "new_func_code": "def _find_best_intersection(self, fst_points: np.ndarray, sec_points: np.ndarray) -> Tuple[float, float]:\n        \"\"\"fst_points and sec_points are NxD arrays defining N lines. D is the dimension of the space.\n            This function returns the least squares intersection of the N lines from the system given by eq. 13 in\n            http://cal.cs.illinois.edu/~johannes/research/LS_line_intersecpdf.\n\n        Args:\n            fst_points (np.ndarray): First bisectors points.\n            sec_points (np.ndarray): Second bisectors points.\n\n        Returns:\n            Tuple[float, float]: Best intersection point.\n\n        Reference:\n            [1] http://cal.cs.illinois.edu/~johannes/research/LS_line_intersecpdf\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.eye_properties_estimation.moment_of_area.MomentOfArea::run", "project": "open-iris", "func": "MomentOfArea::run", "origin_file": "iris/nodes/eye_properties_estimation/moment_of_area.py", "test_list": ["../tests/unit_tests/nodes/eye_properties_estimation/test_moment_of_area.py"], "prob_info": {"func_start_lineno": 40, "func_end_lineno": 65, "key_block_start_lineno": 55, "key_block_end_lineno": 65, "new_func_code": "def run(self, geometries: GeometryPolygons) -> EyeOrientation:\n        \"\"\"Compute the eye orientation using the second order moments or the eyeball.\n\n        WARNING: cv2.moments MUST only receive np.float32 arrays. Otherwise, the array will be interpreted as a sparse\n        matrix instead of a list of points. See https://github.com/opencv/opencv/issues/6643#issuecomment-224204774.\n\n        Args:\n            geometries (GeometryPolygons): segmentation map used for eye orientation estimation.\n\n        Raises:\n            EyeOrientationEstimationError if the eyeball's eccentricity is below `eccentricity_threshold` i.e. if the eyeball shape is not circular enough to reliably estimate the orientation.\n\n        Returns:\n            EyeOrientation: eye orientation object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.smoothing.Smoothing::_smooth_array", "project": "open-iris", "func": "Smoothing::_smooth_array", "origin_file": "iris/nodes/geometry_refinement/smoothing.py", "test_list": ["../tests/unit_tests/nodes/geometry_refinement/test_smoothing.py"], "prob_info": {"func_start_lineno": 170, "func_end_lineno": 189, "key_block_start_lineno": 180, "key_block_end_lineno": 189, "new_func_code": "def _smooth_array(self, phis: np.ndarray, rhos: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Smooth coordinates expressed in polar space.\n\n        Args:\n            phis (np.ndarray): phi values.\n            rhos (np.ndarray): rho values.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: Tuple with smoothed coordinates (phis, rhos).\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "open-iris.src.iris.nodes.geometry_refinement.smoothing.Smoothing::_smooth_circular_shape", "project": "open-iris", "func": "Smoothing::_smooth_circular_shape", "origin_file": "iris/nodes/geometry_refinement/smoothing.py", "test_list": ["../tests/unit_tests/nodes/geometry_refinement/test_smoothing.py"], "prob_info": {"func_start_lineno": 146, "func_end_lineno": 168, "key_block_start_lineno": 156, "key_block_end_lineno": 168, "new_func_code": "def _smooth_circular_shape(self, vertices: np.ndarray, center_xy: Tuple[float, float]) -> np.ndarray:\n        \"\"\"Smooth arc in a form of a circular shape.\n\n        Args:\n            vertices (np.ndarray): Arc's vertices.\n            center_xy (Tuple[float, float]): Center of an entire contour.\n\n        Returns:\n            np.ndarray: Smoothed arc's vertices.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.utils.WarnDict::get", "project": "rdt", "func": "WarnDict::get", "origin_file": "./Source_Copy/rdt/rdt/transformers/utils.py", "test_list": ["tests/unit/transformers/test___init__.py"], "prob_info": {"func_start_lineno": 348, "func_end_lineno": 363, "key_block_start_lineno": 354, "key_block_end_lineno": 363, "new_func_code": "def get(self, sdtype):\n        \"\"\"Return the value for sdtype if sdtype is in the dictionary, else default.\n\n        If the sdtype is `text` raises a `DeprecationWarning` stating that it will be\n        phased out.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.base.set_random_states", "project": "rdt", "func": "set_random_states", "origin_file": "./Source_Copy/rdt/rdt/transformers/base.py", "test_list": ["tests/unit/transformers/test_base.py"], "prob_info": {"func_start_lineno": 17, "func_end_lineno": 39, "key_block_start_lineno": 28, "key_block_end_lineno": 39, "new_func_code": "def set_random_states(random_states, method_name, set_model_random_state):\n    \"\"\"Context manager for managing the random state.\n\n    Args:\n        random_states (dict):\n            Dictionary mapping each method to its current random state.\n        method_name (str):\n            Name of the method to set the random state for.\n        set_model_random_state (function):\n            Function to set the random state for the method.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.base.BaseTransformer::set_random_state", "project": "rdt", "func": "BaseTransformer::set_random_state", "origin_file": "./Source_Copy/rdt/rdt/transformers/base.py", "test_list": ["tests/unit/transformers/test_base.py"], "prob_info": {"func_start_lineno": 90, "func_end_lineno": 104, "key_block_start_lineno": 99, "key_block_end_lineno": 104, "new_func_code": "def set_random_state(self, state, method_name):\n        \"\"\"Set the random state for a transformer.\n\n        Args:\n            state (numpy.random.RandomState):\n                The numpy random state to set.\n            method_name (str):\n                The method to set it for.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.base.BaseTransformer::__repr__", "project": "rdt", "func": "BaseTransformer::__repr__", "origin_file": "./Source_Copy/rdt/rdt/transformers/base.py", "test_list": ["tests/unit/transformers/test_base.py"], "prob_info": {"func_start_lineno": 319, "func_end_lineno": 346, "key_block_start_lineno": 326, "key_block_end_lineno": 346, "new_func_code": "def __repr__(self):\n        \"\"\"Represent initialization of transformer as text.\n\n        Returns:\n            str:\n                The name of the transformer followed by any non-default parameters.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.base.BaseTransformer::_transform", "project": "rdt", "func": "BaseTransformer::_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/base.py", "test_list": ["tests/unit/transformers/test_base.py"], "prob_info": {"func_start_lineno": 386, "func_end_lineno": 397, "key_block_start_lineno": 397, "key_block_end_lineno": 397, "new_func_code": "def _transform(self, columns_data):\n        \"\"\"Transform the data.\n\n        Args:\n            columns_data (pandas.DataFrame or pandas.Series):\n                Data to transform.\n\n        Returns:\n            pandas.DataFrame or pandas.Series:\n                Transformed data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.base.BaseTransformer::fit_transform", "project": "rdt", "func": "BaseTransformer::fit_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/base.py", "test_list": ["tests/unit/transformers/test_base.py"], "prob_info": {"func_start_lineno": 423, "func_end_lineno": 437, "key_block_start_lineno": 436, "key_block_end_lineno": 437, "new_func_code": "def fit_transform(self, data, column):\n        \"\"\"Fit the transformer to a `column` of the `data` and then transform it.\n\n        Args:\n            data (pandas.DataFrame):\n                The entire table.\n            column (str):\n                A column name.\n\n        Returns:\n            pd.DataFrame:\n                The entire table, containing the transformed data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.base.BaseTransformer::_reverse_transform", "project": "rdt", "func": "BaseTransformer::_reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/base.py", "test_list": ["tests/unit/transformers/test_base.py"], "prob_info": {"func_start_lineno": 439, "func_end_lineno": 450, "key_block_start_lineno": 450, "key_block_end_lineno": 450, "new_func_code": "def _reverse_transform(self, columns_data):\n        \"\"\"Revert the transformations to the original values.\n\n        Args:\n            columns_data (pandas.DataFrame or pandas.Series):\n                Data to revert.\n\n        Returns:\n            pandas.DataFrame or pandas.Series:\n                Reverted data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.base.BaseTransformer::reverse_transform", "project": "rdt", "func": "BaseTransformer::reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/base.py", "test_list": ["tests/unit/transformers/test_base.py"], "prob_info": {"func_start_lineno": 453, "func_end_lineno": 485, "key_block_start_lineno": 464, "key_block_end_lineno": 485, "new_func_code": "def reverse_transform(self, data):\n        \"\"\"Revert the transformations to the original values.\n\n        Args:\n            data (pandas.DataFrame):\n                The entire table.\n\n        Returns:\n            pandas.DataFrame:\n                The entire table, containing the reverted data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.base.BaseMultiColumnTransformer::fit", "project": "rdt", "func": "BaseMultiColumnTransformer::fit", "origin_file": "./Source_Copy/rdt/rdt/transformers/base.py", "test_list": ["tests/unit/transformers/test_base.py"], "prob_info": {"func_start_lineno": 568, "func_end_lineno": 583, "key_block_start_lineno": 577, "key_block_end_lineno": 583, "new_func_code": "def fit(self, data, columns_to_sdtypes):\n        \"\"\"Fit the transformer to a ``column`` of the ``data``.\n\n        Args:\n            data (pandas.DataFrame):\n                The entire table.\n            columns_to_sdtypes (dict):\n                Dictionary mapping each column to its sdtype.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.base.BaseMultiColumnTransformer::fit_transform", "project": "rdt", "func": "BaseMultiColumnTransformer::fit_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/base.py", "test_list": ["tests/unit/transformers/test_base.py"], "prob_info": {"func_start_lineno": 585, "func_end_lineno": 599, "key_block_start_lineno": 598, "key_block_end_lineno": 599, "new_func_code": "def fit_transform(self, data, columns_to_sdtypes):\n        \"\"\"Fit the transformer to a `column` of the `data` and then transform it.\n\n        Args:\n            data (pandas.DataFrame):\n                The entire table.\n            columns_to_sdtypes (dict):\n                Dictionary mapping each column to its sdtype.\n\n        Returns:\n            pd.DataFrame:\n                The entire table, containing the transformed data.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.null.NullTransformer::fit", "project": "rdt", "func": "NullTransformer::fit", "origin_file": "./Source_Copy/rdt/rdt/transformers/null.py", "test_list": ["tests/unit/transformers/test_boolean.py"], "prob_info": {"func_start_lineno": 95, "func_end_lineno": 122, "key_block_start_lineno": 104, "key_block_end_lineno": 122, "new_func_code": "def fit(self, data):\n        \"\"\"Fit the transformer to the data.\n\n        Evaluate if the transformer has to create the null column or not.\n\n        Args:\n            data (pandas.Series):\n                Data to transform.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.null.NullTransformer::_get_missing_value_replacement", "project": "rdt", "func": "NullTransformer::_get_missing_value_replacement", "origin_file": "./Source_Copy/rdt/rdt/transformers/null.py", "test_list": ["tests/unit/transformers/test_boolean.py"], "prob_info": {"func_start_lineno": 60, "func_end_lineno": 93, "key_block_start_lineno": 76, "key_block_end_lineno": 93, "new_func_code": "def _get_missing_value_replacement(self, data):\n        \"\"\"Get the fill value to use for the given data.\n\n        Args:\n            data (pd.Series):\n                The data that is being transformed.\n\n        Return:\n            object:\n                The fill value that needs to be used.\n\n        Raise:\n            TransformerInputError:\n                Error raised when data only contains nans and ``_missing_value_replacement``\n                is set to 'mean' or  'mode'.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.boolean.BinaryEncoder::_set_fitted_parameters", "project": "rdt", "func": "BinaryEncoder::_set_fitted_parameters", "origin_file": "./Source_Copy/rdt/rdt/transformers/boolean.py", "test_list": ["tests/unit/transformers/test_boolean.py"], "prob_info": {"func_start_lineno": 114, "func_end_lineno": 129, "key_block_start_lineno": 124, "key_block_end_lineno": 129, "new_func_code": "def _set_fitted_parameters(self, column_name, null_transformer):\n        \"\"\"Manually set the parameters on the transformer to get it into a fitted state.\n\n        Args:\n            column_name (str):\n                The name of the column to use for the transformer.\n            null_transformer (NullTransformer):\n                A fitted null transformer instance that can be used to generate\n                null values for the column.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.categorical.UniformEncoder::_set_fitted_parameters", "project": "rdt", "func": "UniformEncoder::_set_fitted_parameters", "origin_file": "./Source_Copy/rdt/rdt/transformers/categorical.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 138, "func_end_lineno": 154, "key_block_start_lineno": 150, "key_block_end_lineno": 154, "new_func_code": "def _set_fitted_parameters(self, column_name, intervals, dtype='object'):\n        \"\"\"Manually set the parameters on the transformer to get it into a fitted state.\n\n        Args:\n            column_name (str):\n                The name of the column for this transformer.\n            intervals (dict[str, tuple]):\n                A dictionary mapping categories to the interval in the range [0, 1]\n                it should map to.\n            dtype (str, optional):\n                The dtype to convert the reverse transformed data back to. Defaults to 'object'.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.categorical.UniformEncoder::_reverse_transform", "project": "rdt", "func": "UniformEncoder::_reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/categorical.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 192, "func_end_lineno": 223, "key_block_start_lineno": 202, "key_block_end_lineno": 223, "new_func_code": "def _reverse_transform(self, data):\n        \"\"\"Convert float values back to the original categorical values.\n\n        Args:\n            data (pandas.Series):\n                Data to revert.\n\n        Returns:\n            pandas.Series\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.utils.check_nan_in_transform", "project": "rdt", "func": "check_nan_in_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/utils.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 208, "func_end_lineno": 228, "key_block_start_lineno": 217, "key_block_end_lineno": 228, "new_func_code": "def check_nan_in_transform(data, dtype):\n    \"\"\"Check if there are null values in the transformed data.\n\n    Args:\n        data (pd.Series or numpy.ndarray):\n            Data that has been transformed.\n        dtype (str):\n            Data type of the transformed data.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.utils.try_convert_to_dtype", "project": "rdt", "func": "try_convert_to_dtype", "origin_file": "./Source_Copy/rdt/rdt/transformers/utils.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 231, "func_end_lineno": 253, "key_block_start_lineno": 244, "key_block_end_lineno": 253, "new_func_code": "def try_convert_to_dtype(data, dtype):\n    \"\"\"Try to convert data to a given dtype.\n\n    Args:\n        data (pd.Series or numpy.ndarray):\n            Data to convert.\n        dtype (str):\n            Data type to convert to.\n\n    Returns:\n        data:\n            Data converted to the given dtype.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.categorical.FrequencyEncoder::_reverse_transform", "project": "rdt", "func": "FrequencyEncoder::_reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/categorical.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 540, "func_end_lineno": 559, "key_block_start_lineno": 550, "key_block_end_lineno": 559, "new_func_code": "def _reverse_transform(self, data):\n        \"\"\"Convert float values back to the original categorical values.\n\n        Args:\n            data (pd.Series):\n                Data to revert.\n\n        Returns:\n            pandas.Series\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.categorical.FrequencyEncoder::_transform", "project": "rdt", "func": "FrequencyEncoder::_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/categorical.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 491, "func_end_lineno": 518, "key_block_start_lineno": 501, "key_block_end_lineno": 518, "new_func_code": "def _transform(self, data):\n        \"\"\"Transform the categorical values to float representatives.\n\n        Args:\n            data (pandas.Series):\n                Data to transform.\n\n        Returns:\n            numpy.ndarray\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.categorical.OneHotEncoder::_fit", "project": "rdt", "func": "OneHotEncoder::_fit", "origin_file": "./Source_Copy/rdt/rdt/transformers/categorical.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 609, "func_end_lineno": 637, "key_block_start_lineno": 618, "key_block_end_lineno": 637, "new_func_code": "def _fit(self, data):\n        \"\"\"Fit the transformer to the data.\n\n        Get the pandas `dummies` which will be used later on for OneHotEncoding.\n\n        Args:\n            data (pandas.Series or pandas.DataFrame):\n                Data to fit the transformer to.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.categorical.OneHotEncoder::_reverse_transform", "project": "rdt", "func": "OneHotEncoder::_reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/categorical.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 684, "func_end_lineno": 705, "key_block_start_lineno": 694, "key_block_end_lineno": 705, "new_func_code": "def _reverse_transform(self, data):\n        \"\"\"Convert float values back to the original categorical values.\n\n        Args:\n            data (pd.Series or numpy.ndarray):\n                Data to revert.\n\n        Returns:\n            pandas.Series\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.null.NullTransformer::reverse_transform", "project": "rdt", "func": "NullTransformer::reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/null.py", "test_list": ["tests/unit/transformers/test_datetime.py"], "prob_info": {"func_start_lineno": 165, "func_end_lineno": 194, "key_block_start_lineno": 179, "key_block_end_lineno": 194, "new_func_code": "def reverse_transform(self, data):\n        \"\"\"Restore null values to the data.\n\n        If a null indicator column was created during fit, use it as a reference.\n        Otherwise, randomly replace values with ``np.nan``. The percentage of values\n        that will be replaced is the percentage of null values seen in the fitted data.\n\n        Args:\n            data (numpy.ndarray):\n                Data to transform.\n\n        Returns:\n            pandas.Series\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.datetime.UnixTimestampEncoder::_transform", "project": "rdt", "func": "UnixTimestampEncoder::_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/datetime.py", "test_list": ["tests/unit/transformers/test_datetime.py"], "prob_info": {"func_start_lineno": 190, "func_end_lineno": 201, "key_block_start_lineno": 200, "key_block_end_lineno": 201, "new_func_code": "def _transform(self, data):\n        \"\"\"Transform datetime values to float values.\n\n        Args:\n            data (pandas.Series):\n                Data to transform.\n\n        Returns:\n            numpy.ndarray\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.id.IndexGenerator::_reverse_transform", "project": "rdt", "func": "IndexGenerator::_reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/id.py", "test_list": ["tests/unit/transformers/test_id.py"], "prob_info": {"func_start_lineno": 58, "func_end_lineno": 75, "key_block_start_lineno": 68, "key_block_end_lineno": 75, "new_func_code": "def _reverse_transform(self, data):\n        \"\"\"Generate new id column.\n\n        Args:\n            data (pd.Series or numpy.ndarray):\n                Data to transform.\n\n        Returns:\n            pd.Series\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.id.RegexGenerator::_reverse_transform", "project": "rdt", "func": "RegexGenerator::_reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/id.py", "test_list": ["tests/unit/transformers/test_id.py"], "prob_info": {"func_start_lineno": 221, "func_end_lineno": 285, "key_block_start_lineno": 231, "key_block_end_lineno": 285, "new_func_code": "def _reverse_transform(self, data):\n        \"\"\"Generate new data using the provided ``regex_format``.\n\n        Args:\n            data (pd.Series or numpy.ndarray):\n                Data to transform.\n\n        Returns:\n            pandas.Series\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.id.RegexGenerator::_warn_not_enough_unique_values", "project": "rdt", "func": "RegexGenerator::_warn_not_enough_unique_values", "origin_file": "./Source_Copy/rdt/rdt/transformers/id.py", "test_list": ["tests/unit/transformers/test_id.py"], "prob_info": {"func_start_lineno": 186, "func_end_lineno": 219, "key_block_start_lineno": 195, "key_block_end_lineno": 219, "new_func_code": "def _warn_not_enough_unique_values(self, sample_size, unique_condition):\n        \"\"\"Warn the user that the regex cannot generate enough unique values.\n\n        Args:\n            sample_size (int):\n                Number of samples to be generated.\n            unique_condition (bool):\n                Whether or not to enforce uniqueness.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.null.NullTransformer::_set_fitted_parameters", "project": "rdt", "func": "NullTransformer::_set_fitted_parameters", "origin_file": "./Source_Copy/rdt/rdt/transformers/null.py", "test_list": ["tests/unit/transformers/test_null.py"], "prob_info": {"func_start_lineno": 124, "func_end_lineno": 136, "key_block_start_lineno": 131, "key_block_end_lineno": 136, "new_func_code": "def _set_fitted_parameters(self, null_ratio):\n        \"\"\"Manually set the parameters on the transformer to get it into a fitted state.\n\n        Args:\n            null_ratio (float):\n                The fraction of values to replace with null values.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.utils.learn_rounding_digits", "project": "rdt", "func": "learn_rounding_digits", "origin_file": "./Source_Copy/rdt/rdt/transformers/utils.py", "test_list": ["tests/unit/transformers/test_numerical.py"], "prob_info": {"func_start_lineno": 256, "func_end_lineno": 294, "key_block_start_lineno": 267, "key_block_end_lineno": 294, "new_func_code": "def learn_rounding_digits(data):\n    \"\"\"Learn the number of digits to round data to.\n\n    Args:\n        data (pd.Series):\n            Data to learn the number of digits to round to.\n\n    Returns:\n        int or None:\n            Number of digits to round to.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.numerical.FloatFormatter::_reverse_transform", "project": "rdt", "func": "FloatFormatter::_reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/numerical.py", "test_list": ["tests/unit/transformers/test_numerical.py"], "prob_info": {"func_start_lineno": 170, "func_end_lineno": 201, "key_block_start_lineno": 180, "key_block_end_lineno": 201, "new_func_code": "def _reverse_transform(self, data):\n        \"\"\"Convert data back into the original format.\n\n        Args:\n            data (pd.Series or numpy.ndarray):\n                Data to transform.\n\n        Returns:\n            numpy.ndarray\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.utils.flatten_column_list", "project": "rdt", "func": "flatten_column_list", "origin_file": "./Source_Copy/rdt/rdt/transformers/utils.py", "test_list": ["tests/unit/transformers/test_utils.py"], "prob_info": {"func_start_lineno": 187, "func_end_lineno": 205, "key_block_start_lineno": 198, "key_block_end_lineno": 205, "new_func_code": "def flatten_column_list(column_list):\n    \"\"\"Flatten a list of columns.\n\n    Args:\n        column_list (list):\n            List of columns to flatten.\n\n    Returns:\n        list:\n            Flattened list of columns.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.utils.sigmoid", "project": "rdt", "func": "sigmoid", "origin_file": "./Source_Copy/rdt/rdt/transformers/utils.py", "test_list": ["tests/unit/transformers/test_utils.py"], "prob_info": {"func_start_lineno": 318, "func_end_lineno": 338, "key_block_start_lineno": 332, "key_block_end_lineno": 338, "new_func_code": "def sigmoid(data, low, high):\n    \"\"\"Apply a sigmoid function to the data using ``low`` and ``high``.\n\n    Args:\n        data (pd.Series, pd.DataFrame, np.array, int, float or datetime):\n            Data to apply the logit function to.\n        low (pd.Series, np.array, int, float or datetime):\n            Low value/s to use when scaling.\n        high (pd.Series, np.array, int, float or datetime):\n            High value/s to use when scaling.\n\n    Returns:\n        Sigmoid transform of the input data.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.pii.anonymization.get_anonymized_transformer", "project": "rdt", "func": "get_anonymized_transformer", "origin_file": "./Source_Copy/rdt/rdt/transformers/pii/anonymization.py", "test_list": ["tests/unit/transformers/pii/test_anonymization.py"], "prob_info": {"func_start_lineno": 69, "func_end_lineno": 90, "key_block_start_lineno": 78, "key_block_end_lineno": 90, "new_func_code": "def get_anonymized_transformer(function_name, transformer_kwargs=None):\n    \"\"\"Get an instance with an ``AnonymizedFaker`` for the given ``function_name``.\n\n    Args:\n        function_name (str):\n            String representing predefined ``sdtype`` or a ``faker`` function.\n        transformer_kwargs (dict):\n            Keyword args to pass into AnonymizedFaker transformer. Optional.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.pii.anonymization.is_faker_function", "project": "rdt", "func": "is_faker_function", "origin_file": "./Source_Copy/rdt/rdt/transformers/pii/anonymization.py", "test_list": ["tests/unit/transformers/pii/test_anonymization.py"], "prob_info": {"func_start_lineno": 40, "func_end_lineno": 57, "key_block_start_lineno": 50, "key_block_end_lineno": 57, "new_func_code": "def is_faker_function(function_name):\n    \"\"\"Return whether or not the function name is a valid Faker function.\n\n    Args:\n        function_name (str):\n            String representing predefined ``sdtype`` or a ``faker`` function.\n\n    Returns:\n        True if the ``function_name`` is know to ``Faker``, otherwise False.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.pii.anonymizer.AnonymizedFaker::_fit", "project": "rdt", "func": "AnonymizedFaker::_fit", "origin_file": "./Source_Copy/rdt/rdt/transformers/pii/anonymizer.py", "test_list": ["tests/unit/transformers/pii/test_anonymizer.py"], "prob_info": {"func_start_lineno": 211, "func_end_lineno": 225, "key_block_start_lineno": 218, "key_block_end_lineno": 225, "new_func_code": "def _fit(self, data):\n        \"\"\"Fit the transformer to the data.\n\n        Args:\n            data (pandas.Series):\n                Data to fit to.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.pii.anonymizer.AnonymizedFaker::_set_fitted_parameters", "project": "rdt", "func": "AnonymizedFaker::_set_fitted_parameters", "origin_file": "./Source_Copy/rdt/rdt/transformers/pii/anonymizer.py", "test_list": ["tests/unit/transformers/pii/test_anonymizer.py"], "prob_info": {"func_start_lineno": 315, "func_end_lineno": 338, "key_block_start_lineno": 328, "key_block_end_lineno": 338, "new_func_code": "def _set_fitted_parameters(self, column_name, nan_frequency=0.0, cardinality=None):\n        \"\"\"Manually set the parameters on the transformer to get it into a fitted state.\n\n        Args:\n            column_name (str):\n                The name of the column to use for the transformer.\n            nan_frequency (float):\n                The fraction of values that should be replaced with nan values\n                if self.missing_value_generation is 'random'.\n            cardinality (int or None):\n                The number of unique values to generate if cardinality rule is set to\n                'match'.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.pii.anonymizer.PseudoAnonymizedFaker::_transform", "project": "rdt", "func": "PseudoAnonymizedFaker::_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/pii/anonymizer.py", "test_list": ["tests/unit/transformers/pii/test_anonymizer.py"], "prob_info": {"func_start_lineno": 451, "func_end_lineno": 488, "key_block_start_lineno": 465, "key_block_end_lineno": 488, "new_func_code": "def _transform(self, columns_data):\n        \"\"\"Replace each category with a numerical representation.\n\n        Map the input ``columns_data`` using the previously generated values for each one.\n        If the  ``columns_data`` contain unknown values, an error will be raised with the\n        unknown categories.\n\n        Args:\n            data (pandas.Series):\n                Data to transform.\n\n        Returns:\n            pd.Series\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.categorical.LabelEncoder::_fit", "project": "rdt", "func": "LabelEncoder::_fit", "origin_file": "./Source_Copy/rdt/rdt/transformers/categorical.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 773, "func_end_lineno": 790, "key_block_start_lineno": 784, "key_block_end_lineno": 790, "new_func_code": "def _fit(self, data):\n        \"\"\"Fit the transformer to the data.\n\n        Generate a unique integer representation for each category and\n        store them in the ``categories_to_values`` dict and its reverse\n        ``values_to_categories``.\n\n        Args:\n            data (pandas.Series):\n                Data to fit the transformer to.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.categorical.LabelEncoder::_transform", "project": "rdt", "func": "LabelEncoder::_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/categorical.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 792, "func_end_lineno": 825, "key_block_start_lineno": 807, "key_block_end_lineno": 825, "new_func_code": "def _transform(self, data):\n        \"\"\"Replace each category with its corresponding integer value.\n\n        If a category has not been seen before, a random value is assigned.\n\n        If ``add_noise`` is True, the integer values will be replaced by a\n        random number between the value and the value + 1.\n\n        Args:\n            data (pandas.Series):\n                Data to transform.\n\n        Returns:\n            pd.Series\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.categorical.OrderedLabelEncoder::__repr__", "project": "rdt", "func": "OrderedLabelEncoder::__repr__", "origin_file": "./Source_Copy/rdt/rdt/transformers/categorical.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 876, "func_end_lineno": 890, "key_block_start_lineno": 883, "key_block_end_lineno": 890, "new_func_code": "def __repr__(self):\n        \"\"\"Represent initialization of transformer as text.\n\n        Returns:\n            str:\n                The name of the transformer followed by any non-default parameters.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.categorical.OrderedLabelEncoder::_fit", "project": "rdt", "func": "OrderedLabelEncoder::_fit", "origin_file": "./Source_Copy/rdt/rdt/transformers/categorical.py", "test_list": ["tests/unit/transformers/test_categorical.py"], "prob_info": {"func_start_lineno": 892, "func_end_lineno": 916, "key_block_start_lineno": 903, "key_block_end_lineno": 916, "new_func_code": "def _fit(self, data):\n        \"\"\"Fit the transformer to the data.\n\n        Generate a unique integer representation for each category and\n        store them in the ``categories_to_values`` dict and its reverse\n        ``values_to_categories``.\n\n        Args:\n            data (pandas.Series):\n                Data to fit the transformer to.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.datetime.UnixTimestampEncoder::_reverse_transform", "project": "rdt", "func": "UnixTimestampEncoder::_reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/datetime.py", "test_list": ["tests/unit/transformers/test_datetime.py"], "prob_info": {"func_start_lineno": 203, "func_end_lineno": 230, "key_block_start_lineno": 213, "key_block_end_lineno": 230, "new_func_code": "def _reverse_transform(self, data):\n        \"\"\"Convert float values back to datetimes.\n\n        Args:\n            data (pandas.Series or numpy.ndarray):\n                Data to transform.\n\n        Returns:\n            pandas.Series\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.datetime.UnixTimestampEncoder::_set_fitted_parameters", "project": "rdt", "func": "UnixTimestampEncoder::_set_fitted_parameters", "origin_file": "./Source_Copy/rdt/rdt/transformers/datetime.py", "test_list": ["tests/unit/transformers/test_datetime.py"], "prob_info": {"func_start_lineno": 155, "func_end_lineno": 188, "key_block_start_lineno": 174, "key_block_end_lineno": 188, "new_func_code": "def _set_fitted_parameters(\n        self, column_name, null_transformer, min_max_values=None, dtype='object'\n    ):\n        \"\"\"Manually set the parameters on the transformer to get it into a fitted state.\n\n        Args:\n            column_name (str):\n                The name of the column for this transformer.\n            null_transformer (NullTransformer):\n                A fitted null transformer instance that can be used to generate\n                null values for the column.\n            min_max_values (tuple or None):\n                None or a tuple containing the (min, max) values for the transformer.\n                Should be used to set self._min_value and self._max_value and must be\n                provided if self.enforce_min_max_values is True.\n                Defaults to None.\n            dtype (str, optional):\n                The dtype to convert the reverse transformed data back to. Defaults to 'object'.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.numerical.FloatFormatter::_set_fitted_parameters", "project": "rdt", "func": "FloatFormatter::_set_fitted_parameters", "origin_file": "./Source_Copy/rdt/rdt/transformers/numerical.py", "test_list": ["tests/unit/transformers/test_numerical.py"], "prob_info": {"func_start_lineno": 203, "func_end_lineno": 245, "key_block_start_lineno": 226, "key_block_end_lineno": 245, "new_func_code": "def _set_fitted_parameters(\n        self,\n        column_name,\n        null_transformer,\n        rounding_digits=None,\n        min_max_values=None,\n        dtype='object',\n    ):\n        \"\"\"Manually set the parameters on the transformer to get it into a fitted state.\n\n        Args:\n            column_name (str):\n                The name of the column to use for the transformer.\n            null_transformer (NullTransformer):\n                A fitted null transformer instance that can be used to generate\n                null values for the column.\n            min_max_values (Tuple(float) or None):\n                None or a tuple containing the (min, max) values for the transformer.\n            rounding_digits (int or None):\n                The number of digits to round to.\n            dtype (str):\n                The pandas dtype the reversed data will be converted into.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.numerical.FloatFormatter::_transform", "project": "rdt", "func": "FloatFormatter::_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/numerical.py", "test_list": ["tests/unit/transformers/test_numerical.py"], "prob_info": {"func_start_lineno": 153, "func_end_lineno": 168, "key_block_start_lineno": 166, "key_block_end_lineno": 168, "new_func_code": "def _transform(self, data):\n        \"\"\"Transform numerical data.\n\n        Integer values are replaced by their float equivalent. Non null float values\n        are left unmodified.\n\n        Args:\n            data (pandas.Series):\n                Data to transform.\n\n        Returns:\n            numpy.ndarray\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.numerical.GaussianNormalizer::_fit", "project": "rdt", "func": "GaussianNormalizer::_fit", "origin_file": "./Source_Copy/rdt/rdt/transformers/numerical.py", "test_list": ["tests/unit/transformers/test_numerical.py"], "prob_info": {"func_start_lineno": 377, "func_end_lineno": 393, "key_block_start_lineno": 384, "key_block_end_lineno": 393, "new_func_code": "def _fit(self, data):\n        \"\"\"Fit the transformer to the data.\n\n        Args:\n            data (pandas.Series):\n                Data to fit to.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.numerical.GaussianNormalizer::_reverse_transform", "project": "rdt", "func": "GaussianNormalizer::_reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/numerical.py", "test_list": ["tests/unit/transformers/test_numerical.py"], "prob_info": {"func_start_lineno": 417, "func_end_lineno": 435, "key_block_start_lineno": 427, "key_block_end_lineno": 435, "new_func_code": "def _reverse_transform(self, data):\n        \"\"\"Convert data back into the original format.\n\n        Args:\n            data (pd.Series or numpy.ndarray):\n                Data to transform.\n\n        Returns:\n            pandas.Series\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.numerical.ClusterBasedNormalizer::_fit", "project": "rdt", "func": "ClusterBasedNormalizer::_fit", "origin_file": "./Source_Copy/rdt/rdt/transformers/numerical.py", "test_list": ["tests/unit/transformers/test_numerical.py"], "prob_info": {"func_start_lineno": 521, "func_end_lineno": 546, "key_block_start_lineno": 528, "key_block_end_lineno": 546, "new_func_code": "def _fit(self, data):\n        \"\"\"Fit the transformer to the data.\n\n        Args:\n            data (pandas.Series):\n                Data to fit to.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "rdt.rdt.transformers.numerical.ClusterBasedNormalizer::_reverse_transform", "project": "rdt", "func": "ClusterBasedNormalizer::_reverse_transform", "origin_file": "./Source_Copy/rdt/rdt/transformers/numerical.py", "test_list": ["tests/unit/transformers/test_numerical.py"], "prob_info": {"func_start_lineno": 610, "func_end_lineno": 627, "key_block_start_lineno": 620, "key_block_end_lineno": 627, "new_func_code": "def _reverse_transform(self, data):\n        \"\"\"Convert data back into the original format.\n\n        Args:\n            data (pd.DataFrame or numpy.ndarray):\n                Data to transform.\n\n        Returns:\n            pandas.Series.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.center_crop", "project": "transformers", "func": "center_crop", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/test_image_transforms.py"], "prob_info": {"func_start_lineno": 413, "func_end_lineno": 509, "key_block_start_lineno": 448, "key_block_end_lineno": 509, "new_func_code": "def center_crop(\n    image: np.ndarray,\n    size: Tuple[int, int],\n    data_format: Optional[Union[str, ChannelDimension]] = None,\n    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    return_numpy: Optional[bool] = None,\n) -> np.ndarray:\n    \"\"\"\n    Crops the `image` to the specified `size` using a center crop. Note that if the image is too small to be cropped to\n    the size given, it will be padded (so the returned result will always be of size `size`).\n\n    Args:\n        image (`np.ndarray`):\n            The image to crop.\n        size (`Tuple[int, int]`):\n            The target size for the cropped image.\n        data_format (`str` or `ChannelDimension`, *optional*):\n            The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            If unset, will use the inferred format of the input image.\n        input_data_format (`str` or `ChannelDimension`, *optional*):\n            The channel dimension format for the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            If unset, will use the inferred format of the input image.\n        return_numpy (`bool`, *optional*):\n            Whether or not to return the cropped image as a numpy array. Used for backwards compatibility with the\n            previous ImageFeatureExtractionMixin method.\n                - Unset: will return the same type as the input image.\n                - `True`: will return a numpy array.\n                - `False`: will return a `PIL.Image.Image` object.\n    Returns:\n        `np.ndarray`: The cropped image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_utils.infer_channel_dimension_format", "project": "transformers", "func": "infer_channel_dimension_format", "origin_file": "transformers/image_utils.py", "test_list": ["../tests/test_image_transforms.py"], "prob_info": {"func_start_lineno": 220, "func_end_lineno": 254, "key_block_start_lineno": 235, "key_block_end_lineno": 254, "new_func_code": "def infer_channel_dimension_format(\n    image: np.ndarray, num_channels: Optional[Union[int, Tuple[int, ...]]] = None\n) -> ChannelDimension:\n    \"\"\"\n    Infers the channel dimension format of `image`.\n\n    Args:\n        image (`np.ndarray`):\n            The image to infer the channel dimension of.\n        num_channels (`int` or `Tuple[int, ...]`, *optional*, defaults to `(1, 3)`):\n            The number of channels of the image.\n\n    Returns:\n        The channel dimension of the image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.to_channel_dimension_format", "project": "transformers", "func": "to_channel_dimension_format", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/test_image_transforms.py"], "prob_info": {"func_start_lineno": 58, "func_end_lineno": 94, "key_block_start_lineno": 77, "key_block_end_lineno": 94, "new_func_code": "def to_channel_dimension_format(\n    image: np.ndarray,\n    channel_dim: Union[ChannelDimension, str],\n    input_channel_dim: Optional[Union[ChannelDimension, str]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Converts `image` to the channel dimension format specified by `channel_dim`.\n\n    Args:\n        image (`numpy.ndarray`):\n            The image to have its channel dimension set.\n        channel_dim (`ChannelDimension`):\n            The channel dimension format to use.\n        input_channel_dim (`ChannelDimension`, *optional*):\n            The channel dimension format of the input image. If not provided, it will be inferred from the input image.\n\n    Returns:\n        `np.ndarray`: The image with the channel dimension set to `channel_dim`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_utils.get_image_size", "project": "transformers", "func": "get_image_size", "origin_file": "transformers/image_utils.py", "test_list": ["../tests/test_image_transforms.py"], "prob_info": {"func_start_lineno": 281, "func_end_lineno": 302, "key_block_start_lineno": 294, "key_block_end_lineno": 302, "new_func_code": "def get_image_size(image: np.ndarray, channel_dim: ChannelDimension = None) -> Tuple[int, int]:\n    \"\"\"\n    Returns the (height, width) dimensions of the image.\n\n    Args:\n        image (`np.ndarray`):\n            The image to get the dimensions of.\n        channel_dim (`ChannelDimension`, *optional*):\n            Which dimension the channel dimension is in. If `None`, will infer the channel dimension from the image.\n\n    Returns:\n        A tuple of the image's height and width.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.testing_utils.get_tests_dir", "project": "transformers", "func": "get_tests_dir", "origin_file": "transformers/testing_utils.py", "test_list": ["../tests/agents/test_agent_types.py"], "prob_info": {"func_start_lineno": 1268, "func_end_lineno": 1288, "key_block_start_lineno": 1278, "key_block_end_lineno": 1288, "new_func_code": "def get_tests_dir(append_path=None):\n    \"\"\"\n    Args:\n        append_path: optional path to append to the tests dir path\n\n    Return:\n        The full path to the `tests` dir, so that the tests can be invoked from anywhere. Optionally `append_path` is\n        joined after the `tests` dir the former is provided.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.hub.cached_file", "project": "transformers", "func": "cached_file", "origin_file": "transformers/utils/hub.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 270, "func_end_lineno": 472, "key_block_start_lineno": 343, "key_block_end_lineno": 472, "new_func_code": "def cached_file(\n    path_or_repo_id: Union[str, os.PathLike],\n    filename: str,\n    cache_dir: Optional[Union[str, os.PathLike]] = None,\n    force_download: bool = False,\n    resume_download: Optional[bool] = None,\n    proxies: Optional[Dict[str, str]] = None,\n    token: Optional[Union[bool, str]] = None,\n    revision: Optional[str] = None,\n    local_files_only: bool = False,\n    subfolder: str = \"\",\n    repo_type: Optional[str] = None,\n    user_agent: Optional[Union[str, Dict[str, str]]] = None,\n    _raise_exceptions_for_gated_repo: bool = True,\n    _raise_exceptions_for_missing_entries: bool = True,\n    _raise_exceptions_for_connection_errors: bool = True,\n    _commit_hash: Optional[str] = None,\n    **deprecated_kwargs,\n) -> Optional[str]:\n    \"\"\"\n    Tries to locate a file in a local folder and repo, downloads and cache it if necessary.\n\n    Args:\n        path_or_repo_id (`str` or `os.PathLike`):\n            This can be either:\n\n            - a string, the *model id* of a model repo on huggingface.co.\n            - a path to a *directory* potentially containing the file.\n        filename (`str`):\n            The name of the file to locate in `path_or_repo`.\n        cache_dir (`str` or `os.PathLike`, *optional*):\n            Path to a directory in which a downloaded pretrained model configuration should be cached if the standard\n            cache should not be used.\n        force_download (`bool`, *optional*, defaults to `False`):\n            Whether or not to force to (re-)download the configuration files and override the cached versions if they\n            exist.\n        resume_download:\n            Deprecated and ignored. All downloads are now resumed by default when possible.\n            Will be removed in v5 of Transformers.\n        proxies (`Dict[str, str]`, *optional*):\n            A dictionary of proxy servers to use by protocol or endpoint, e.g., `{'http': 'foo.bar:3128',\n            'http://hostname': 'foo.bar:4012'}.` The proxies are used on each request.\n        token (`str` or *bool*, *optional*):\n            The token to use as HTTP bearer authorization for remote files. If `True`, will use the token generated\n            when running `huggingface-cli login` (stored in `~/.huggingface`).\n        revision (`str`, *optional*, defaults to `\"main\"`):\n            The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a\n            git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any\n            identifier allowed by git.\n        local_files_only (`bool`, *optional*, defaults to `False`):\n            If `True`, will only try to load the tokenizer configuration from local files.\n        subfolder (`str`, *optional*, defaults to `\"\"`):\n            In case the relevant files are located inside a subfolder of the model repo on huggingface.co, you can\n            specify the folder name here.\n        repo_type (`str`, *optional*):\n            Specify the repo type (useful when downloading from a space for instance).\n\n    <Tip>\n\n    Passing `token=True` is required when you want to use a private model.\n\n    </Tip>\n\n    Returns:\n        `Optional[str]`: Returns the resolved file (to the cache folder if downloaded from a repo).\n\n    Examples:\n\n    ```python\n    # Download a model weight from the Hub and cache it.\n    model_weights_file = cached_file(\"google-bert/bert-base-uncased\", \"pytorch_model.bin\")\n    ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.configuration_utils.PretrainedConfig::to_dict", "project": "transformers", "func": "PretrainedConfig::to_dict", "origin_file": "transformers/configuration_utils.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 830, "func_end_lineno": 870, "key_block_start_lineno": 837, "key_block_end_lineno": 870, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes this instance to a Python dictionary.\n\n        Returns:\n            `Dict[str, Any]`: Dictionary of all the attributes that make up this configuration instance.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.benchmark.benchmark_utils.separate_process_wrapper_fn", "project": "transformers", "func": "separate_process_wrapper_fn", "origin_file": "transformers/benchmark/benchmark_utils.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 76, "func_end_lineno": 109, "key_block_start_lineno": 85, "key_block_end_lineno": 109, "new_func_code": "def separate_process_wrapper_fn(func: Callable[[], None], do_multi_processing: bool) -> Callable[[], None]:\n    \"\"\"\n    This function wraps another function into its own separated process. In order to ensure accurate memory\n    measurements it is important that the function is executed in a separate process\n\n    Args:\n        - `func`: (`callable`): function() -> ... generic function which will be executed in its own separate process\n        - `do_multi_processing`: (`bool`) Whether to run function on separate process or not\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.doc._prepare_output_docstrings", "project": "transformers", "func": "_prepare_output_docstrings", "origin_file": "transformers/utils/doc.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 111, "func_end_lineno": 151, "key_block_start_lineno": 115, "key_block_end_lineno": 151, "new_func_code": "def _prepare_output_docstrings(output_type, config_class, min_indent=None):\n    \"\"\"\n    Prepares the return part of the docstring using `output_type`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.generation.configuration_utils.GenerationConfig::to_dict", "project": "transformers", "func": "GenerationConfig::to_dict", "origin_file": "transformers/generation/configuration_utils.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 1132, "func_end_lineno": 1151, "key_block_start_lineno": 1139, "key_block_end_lineno": 1151, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes this instance to a Python dictionary.\n\n        Returns:\n            `Dict[str, Any]`: Dictionary of all the attributes that make up this configuration instance.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.generation.configuration_utils.GenerationConfig::to_json_string", "project": "transformers", "func": "GenerationConfig::to_json_string", "origin_file": "transformers/generation/configuration_utils.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 1153, "func_end_lineno": 1195, "key_block_start_lineno": 1167, "key_block_end_lineno": 1195, "new_func_code": "def to_json_string(self, use_diff: bool = True, ignore_metadata: bool = False) -> str:\n        \"\"\"\n        Serializes this instance to a JSON string.\n\n        Args:\n            use_diff (`bool`, *optional*, defaults to `True`):\n                If set to `True`, only the difference between the config instance and the default `GenerationConfig()`\n                is serialized to JSON string.\n            ignore_metadata (`bool`, *optional*, defaults to `False`):\n                Whether to ignore the metadata fields present in the instance\n\n        Returns:\n            `str`: String containing all the attributes that make up this configuration instance in JSON format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.generation.configuration_utils.GenerationConfig::to_diff_dict", "project": "transformers", "func": "GenerationConfig::to_diff_dict", "origin_file": "transformers/generation/configuration_utils.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 1109, "func_end_lineno": 1130, "key_block_start_lineno": 1117, "key_block_end_lineno": 1130, "new_func_code": "def to_diff_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Removes all attributes from config which correspond to the default config attributes for better readability and\n        serializes to a Python dictionary.\n\n        Returns:\n            `Dict[str, Any]`: Dictionary of all the attributes that make up this configuration instance,\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.benchmark.benchmark_utils.start_memory_tracing", "project": "transformers", "func": "start_memory_tracing", "origin_file": "transformers/benchmark/benchmark_utils.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 322, "func_end_lineno": 471, "key_block_start_lineno": 362, "key_block_end_lineno": 471, "new_func_code": "def start_memory_tracing(\n    modules_to_trace: Optional[Union[str, Iterable[str]]] = None,\n    modules_not_to_trace: Optional[Union[str, Iterable[str]]] = None,\n    events_to_trace: str = \"line\",\n    gpus_to_trace: Optional[List[int]] = None,\n) -> MemoryTrace:\n    \"\"\"\n    Setup line-by-line tracing to record rss mem (RAM) at each line of a module or sub-module. See `./benchmark.py` for\n    usage examples. Current memory consumption is returned using psutil and in particular is the RSS memory \"Resident\n    Set Size (the non-swapped physical memory the process is using). See\n    https://psutil.readthedocs.io/en/latest/#psutil.Process.memory_info\n\n    Args:\n        - `modules_to_trace`: (None, string, list/tuple of string) if None, all events are recorded if string or list\n          of strings: only events from the listed module/sub-module will be recorded (e.g. 'fairseq' or\n          'transformers.models.gpt2.modeling_gpt2')\n        - `modules_not_to_trace`: (None, string, list/tuple of string) if None, no module is avoided if string or list\n          of strings: events from the listed module/sub-module will not be recorded (e.g. 'torch')\n        - `events_to_trace`: string or list of string of events to be recorded (see official python doc for\n          `sys.settrace` for the list of events) default to line\n        - `gpus_to_trace`: (optional list, default None) list of GPUs to trace. Default to tracing all GPUs\n\n    Return:\n\n        - `memory_trace` is a list of `UsedMemoryState` for each event (default each line of the traced script).\n\n            - `UsedMemoryState` are named tuples with the following fields:\n\n                - 'frame': a `Frame` namedtuple (see below) storing information on the current tracing frame (current\n                  file, location in current file)\n                - 'cpu_memory': CPU RSS memory state *before* executing the line\n                - 'gpu_memory': GPU used memory *before* executing the line (sum for all GPUs or for only\n                  `gpus_to_trace` if provided)\n\n    `Frame` is a namedtuple used by `UsedMemoryState` to list the current frame state. `Frame` has the following\n    fields: - 'filename' (string): Name of the file currently executed - 'module' (string): Name of the module\n    currently executed - 'line_number' (int): Number of the line currently executed - 'event' (string): Event that\n    triggered the tracing (default will be \"line\") - 'line_text' (string): Text of the line in the python script\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.benchmark.benchmark_utils.measure_peak_memory_cpu", "project": "transformers", "func": "measure_peak_memory_cpu", "origin_file": "transformers/benchmark/benchmark_utils.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 204, "func_end_lineno": 319, "key_block_start_lineno": 223, "key_block_end_lineno": 319, "new_func_code": "def measure_peak_memory_cpu(function: Callable[[], None], interval=0.5, device_idx=None) -> int:\n    \"\"\"\n    measures peak cpu memory consumption of a given `function` running the function for at least interval seconds and\n    at most 20 * interval seconds. This function is heavily inspired by: `memory_usage` of the package\n    `memory_profiler`:\n    https://github.com/pythonprofilers/memory_profiler/blob/895c4ac7a08020d66ae001e24067da6dcea42451/memory_profiler.py#L239\n\n    Args:\n        - `function`: (`callable`): function() -> ... function without any arguments to measure for which to measure\n          the peak memory\n\n        - `interval`: (`float`, `optional`, defaults to `0.5`) interval in second for which to measure the memory usage\n\n        - `device_idx`: (`int`, `optional`, defaults to `None`) device id for which to measure gpu usage\n\n    Returns:\n\n        - `max_memory`: (`int`) consumed memory peak in Bytes\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bart.modeling_bart.BartForConditionalGeneration::forward", "project": "transformers", "func": "BartForConditionalGeneration::forward", "origin_file": "transformers/models/bart/modeling_bart.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 1603, "func_end_lineno": 1682, "key_block_start_lineno": 1630, "key_block_end_lineno": 1682, "new_func_code": "def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        decoder_input_ids: Optional[torch.LongTensor] = None,\n        decoder_attention_mask: Optional[torch.LongTensor] = None,\n        head_mask: Optional[torch.Tensor] = None,\n        decoder_head_mask: Optional[torch.Tensor] = None,\n        cross_attn_head_mask: Optional[torch.Tensor] = None,\n        encoder_outputs: Optional[List[torch.FloatTensor]] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        decoder_inputs_embeds: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, Seq2SeqLMOutput]:\n        r\"\"\"\n        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n\n        Returns:\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bart.modeling_bart.BartEncoder::forward", "project": "transformers", "func": "BartEncoder::forward", "origin_file": "transformers/models/bart/modeling_bart.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 995, "func_end_lineno": 1133, "key_block_start_lineno": 1041, "key_block_end_lineno": 1133, "new_func_code": "def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        head_mask: Optional[torch.Tensor] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, BaseModelOutput]:\n        r\"\"\"\n        Args:\n            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you\n                provide it.\n\n                Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n                [`PreTrainedTokenizer.__call__`] for details.\n\n                [What are input IDs?](../glossary#input-ids)\n            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n                - 1 for tokens that are **not masked**,\n                - 0 for tokens that are **masked**.\n\n                [What are attention masks?](../glossary#attention-mask)\n            head_mask (`torch.Tensor` of shape `(encoder_layers, encoder_attention_heads)`, *optional*):\n                Mask to nullify selected heads of the attention modules. Mask values selected in `[0, 1]`:\n\n                - 1 indicates the head is **not masked**,\n                - 0 indicates the head is **masked**.\n\n            inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n                Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation.\n                This is useful if you want more control over how to convert `input_ids` indices into associated vectors\n                than the model's internal embedding lookup matrix.\n            output_attentions (`bool`, *optional*):\n                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n                returned tensors for more detail.\n            output_hidden_states (`bool`, *optional*):\n                Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors\n                for more detail.\n            return_dict (`bool`, *optional*):\n                Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bart.modeling_bart.BartDecoder::forward", "project": "transformers", "func": "BartDecoder::forward", "origin_file": "transformers/models/bart/modeling_bart.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 1180, "func_end_lineno": 1420, "key_block_start_lineno": 1260, "key_block_end_lineno": 1420, "new_func_code": "def forward(\n        self,\n        input_ids: torch.LongTensor = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        encoder_hidden_states: Optional[torch.FloatTensor] = None,\n        encoder_attention_mask: Optional[torch.LongTensor] = None,\n        head_mask: Optional[torch.Tensor] = None,\n        cross_attn_head_mask: Optional[torch.Tensor] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, BaseModelOutputWithPastAndCrossAttentions]:\n        r\"\"\"\n        Args:\n            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you\n                provide it.\n\n                Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n                [`PreTrainedTokenizer.__call__`] for details.\n\n                [What are input IDs?](../glossary#input-ids)\n            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n                - 1 for tokens that are **not masked**,\n                - 0 for tokens that are **masked**.\n\n                [What are attention masks?](../glossary#attention-mask)\n            encoder_hidden_states (`torch.FloatTensor` of shape `(batch_size, encoder_sequence_length, hidden_size)`, *optional*):\n                Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention\n                of the decoder.\n            encoder_attention_mask (`torch.LongTensor` of shape `(batch_size, encoder_sequence_length)`, *optional*):\n                Mask to avoid performing cross-attention on padding tokens indices of encoder input_ids. Mask values\n                selected in `[0, 1]`:\n\n                - 1 for tokens that are **not masked**,\n                - 0 for tokens that are **masked**.\n\n                [What are attention masks?](../glossary#attention-mask)\n            head_mask (`torch.Tensor` of shape `(decoder_layers, decoder_attention_heads)`, *optional*):\n                Mask to nullify selected heads of the attention modules. Mask values selected in `[0, 1]`:\n\n                - 1 indicates the head is **not masked**,\n                - 0 indicates the head is **masked**.\n\n            cross_attn_head_mask (`torch.Tensor` of shape `(decoder_layers, decoder_attention_heads)`, *optional*):\n                Mask to nullify selected heads of the cross-attention modules in the decoder to avoid performing\n                cross-attention on hidden heads. Mask values selected in `[0, 1]`:\n\n                - 1 indicates the head is **not masked**,\n                - 0 indicates the head is **masked**.\n\n            past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n                Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of\n                shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and 2 additional tensors of\n                shape `(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`.\n\n                Contains pre-computed hidden-states (key and values in the self-attention blocks and in the\n                cross-attention blocks) that can be used (see `past_key_values` input) to speed up sequential decoding.\n\n                If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those\n                that don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of\n                all `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n            inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n                Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation.\n                This is useful if you want more control over how to convert `input_ids` indices into associated vectors\n                than the model's internal embedding lookup matrix.\n            output_attentions (`bool`, *optional*):\n                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n                returned tensors for more detail.\n            output_hidden_states (`bool`, *optional*):\n                Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors\n                for more detail.\n            return_dict (`bool`, *optional*):\n                Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bart.modeling_bart.BartDecoderLayer::forward", "project": "transformers", "func": "BartDecoderLayer::forward", "origin_file": "transformers/models/bart/modeling_bart.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 629, "func_end_lineno": 716, "key_block_start_lineno": 659, "key_block_end_lineno": 716, "new_func_code": "def forward(\n        self,\n        hidden_states: torch.Tensor,\n        attention_mask: Optional[torch.Tensor] = None,\n        encoder_hidden_states: Optional[torch.Tensor] = None,\n        encoder_attention_mask: Optional[torch.Tensor] = None,\n        layer_head_mask: Optional[torch.Tensor] = None,\n        cross_attn_layer_head_mask: Optional[torch.Tensor] = None,\n        past_key_value: Optional[Tuple[torch.Tensor]] = None,\n        output_attentions: Optional[bool] = False,\n        use_cache: Optional[bool] = True,\n    ) -> Tuple[torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]]:\n        \"\"\"\n        Args:\n            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n            attention_mask (`torch.FloatTensor`): attention mask of size\n                `(batch, 1, tgt_len, src_len)` where padding elements are indicated by very large negative values.\n            encoder_hidden_states (`torch.FloatTensor`):\n                cross attention input to the layer of shape `(batch, seq_len, embed_dim)`\n            encoder_attention_mask (`torch.FloatTensor`): encoder attention mask of size\n                `(batch, 1, tgt_len, src_len)` where padding elements are indicated by very large negative values.\n            layer_head_mask (`torch.FloatTensor`): mask for attention heads in a given layer of size\n                `(encoder_attention_heads,)`.\n            cross_attn_layer_head_mask (`torch.FloatTensor`): mask for cross-attention heads in a given layer of\n                size `(decoder_attention_heads,)`.\n            past_key_value (`Tuple(torch.FloatTensor)`): cached past key and value projection states\n            output_attentions (`bool`, *optional*):\n                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n                returned tensors for more detail.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.gpt2.modeling_gpt2.GPT2LMHeadModel::forward", "project": "transformers", "func": "GPT2LMHeadModel::forward", "origin_file": "transformers/models/gpt2/modeling_gpt2.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 1290, "func_end_lineno": 1361, "key_block_start_lineno": 1313, "key_block_end_lineno": 1361, "new_func_code": "def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[Tuple[Tuple[torch.Tensor]]] = None,\n        attention_mask: Optional[torch.FloatTensor] = None,\n        token_type_ids: Optional[torch.LongTensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        head_mask: Optional[torch.FloatTensor] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        encoder_hidden_states: Optional[torch.Tensor] = None,\n        encoder_attention_mask: Optional[torch.FloatTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, CausalLMOutputWithCrossAttentions]:\n        r\"\"\"\n        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Labels for language modeling. Note that the labels **are shifted** inside the model, i.e. you can set\n            `labels = input_ids` Indices are selected in `[-100, 0, ..., config.vocab_size]` All labels set to `-100`\n            are ignored (masked), the loss is only computed for labels in `[0, ..., config.vocab_size]`\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.distilbert.modeling_distilbert.Embeddings::forward", "project": "transformers", "func": "Embeddings::forward", "origin_file": "transformers/models/distilbert/modeling_distilbert.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 97, "func_end_lineno": 128, "key_block_start_lineno": 109, "key_block_end_lineno": 128, "new_func_code": "def forward(self, input_ids: torch.Tensor, input_embeds: Optional[torch.Tensor] = None) -> torch.Tensor:\n        \"\"\"\n        Parameters:\n            input_ids (torch.Tensor):\n                torch.tensor(bs, max_seq_length) The token ids to embed.\n            input_embeds (*optional*, torch.Tensor):\n                The pre-computed word embeddings. Can only be passed if the input ids are `None`.\n\n\n        Returns: torch.tensor(bs, max_seq_length, dim) The embedded tokens (plus position embeddings, no token_type\n        embeddings)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.distilbert.modeling_distilbert.Transformer::forward", "project": "transformers", "func": "Transformer::forward", "origin_file": "transformers/models/distilbert/modeling_distilbert.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 424, "func_end_lineno": 491, "key_block_start_lineno": 447, "key_block_end_lineno": 491, "new_func_code": "def forward(\n        self,\n        x: torch.Tensor,\n        attn_mask: Optional[torch.Tensor] = None,\n        head_mask: Optional[torch.Tensor] = None,\n        output_attentions: bool = False,\n        output_hidden_states: bool = False,\n        return_dict: Optional[bool] = None,\n    ) -> Union[BaseModelOutput, Tuple[torch.Tensor, ...]]:  # docstyle-ignore\n        \"\"\"\n        Parameters:\n            x: torch.tensor(bs, seq_length, dim) Input sequence embedded.\n            attn_mask: torch.tensor(bs, seq_length) Attention mask on the sequence.\n\n        Returns:\n            hidden_state: torch.tensor(bs, seq_length, dim) Sequence of hidden states in the last (top)\n            layer all_hidden_states: Tuple[torch.tensor(bs, seq_length, dim)]\n                Tuple of length n_layers with the hidden states from each layer.\n                Optional: only if output_hidden_states=True\n            all_attentions: Tuple[torch.tensor(bs, n_heads, seq_length, seq_length)]\n                Tuple of length n_layers with the attention weights from each layer\n                Optional: only if output_attentions=True\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.distilbert.modeling_distilbert.TransformerBlock::forward", "project": "transformers", "func": "TransformerBlock::forward", "origin_file": "transformers/models/distilbert/modeling_distilbert.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 373, "func_end_lineno": 414, "key_block_start_lineno": 389, "key_block_end_lineno": 414, "new_func_code": "def forward(\n        self,\n        x: torch.Tensor,\n        attn_mask: Optional[torch.Tensor] = None,\n        head_mask: Optional[torch.Tensor] = None,\n        output_attentions: bool = False,\n    ) -> Tuple[torch.Tensor, ...]:\n        \"\"\"\n        Parameters:\n            x: torch.tensor(bs, seq_length, dim)\n            attn_mask: torch.tensor(bs, seq_length)\n\n        Returns:\n            sa_weights: torch.tensor(bs, n_heads, seq_length, seq_length) The attention weights ffn_output:\n            torch.tensor(bs, seq_length, dim) The output of the transformer block contextualization.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.distilbert.modeling_distilbert.MultiHeadSelfAttention::forward", "project": "transformers", "func": "MultiHeadSelfAttention::forward", "origin_file": "transformers/models/distilbert/modeling_distilbert.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 170, "func_end_lineno": 232, "key_block_start_lineno": 190, "key_block_end_lineno": 232, "new_func_code": "def forward(\n        self,\n        query: torch.Tensor,\n        key: torch.Tensor,\n        value: torch.Tensor,\n        mask: torch.Tensor,\n        head_mask: Optional[torch.Tensor] = None,\n        output_attentions: bool = False,\n    ) -> Tuple[torch.Tensor, ...]:\n        \"\"\"\n        Parameters:\n            query: torch.tensor(bs, seq_length, dim)\n            key: torch.tensor(bs, seq_length, dim)\n            value: torch.tensor(bs, seq_length, dim)\n            mask: torch.tensor(bs, seq_length)\n\n        Returns:\n            weights: torch.tensor(bs, n_heads, seq_length, seq_length) Attention weights context: torch.tensor(bs,\n            seq_length, dim) Contextualized layer. Optional: only if `output_attentions=True`\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.generation.beam_search.BeamHypotheses::add", "project": "transformers", "func": "BeamHypotheses::add", "origin_file": "transformers/generation/beam_search.py", "test_list": ["../tests/generation/test_beam_search.py"], "prob_info": {"func_start_lineno": 954, "func_end_lineno": 977, "key_block_start_lineno": 964, "key_block_end_lineno": 977, "new_func_code": "def add(\n        self,\n        hyp: torch.LongTensor,\n        sum_logprobs: float,\n        beam_indices: Optional[torch.LongTensor] = None,\n        generated_len: Optional[int] = None,\n    ):\n        \"\"\"\n        Add a new hypothesis to the list.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.generation.logits_process._get_ngrams", "project": "transformers", "func": "_get_ngrams", "origin_file": "transformers/generation/logits_process.py", "test_list": ["../tests/generation/test_logits_process.py"], "prob_info": {"func_start_lineno": 855, "func_end_lineno": 881, "key_block_start_lineno": 872, "key_block_end_lineno": 881, "new_func_code": "def _get_ngrams(ngram_size: int, prev_input_ids: torch.Tensor, num_hypos: int):\n    \"\"\"\n    Assume ngram_size=2 and prev_input_ids=tensor([[40, 2883, 2712, 4346]]). The output of generated ngrams look like\n    this {(40,): [2883], (2883,): [2712], (2712,): [4346]}.\n\n    Args:\n        ngram_size (`int`):\n            The number sequential tokens taken as a group which may only occur once before being banned.\n        prev_input_ids (`torch.Tensor`):\n           Generated token ids for the current hypothesis.\n        num_hypos (`int`):\n            The number of hypotheses for which n-grams need to be generated.\n\n    Returns:\n        generated_ngrams (`dict`):\n            Dictionary of generated ngrams.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.generation.logits_process._get_generated_ngrams", "project": "transformers", "func": "_get_generated_ngrams", "origin_file": "transformers/generation/logits_process.py", "test_list": ["../tests/generation/test_logits_process.py"], "prob_info": {"func_start_lineno": 884, "func_end_lineno": 904, "key_block_start_lineno": 901, "key_block_end_lineno": 904, "new_func_code": "def _get_generated_ngrams(banned_ngrams, prev_input_ids, ngram_size, cur_len):\n    \"\"\"\n    Determines the banned tokens for the current hypothesis based on previously generated n-grams.\n\n    Args:\n        banned_ngrams (`dict`):\n            A dictionary containing previously generated n-grams for each hypothesis.\n        prev_input_ids (`torch.Tensor`):\n            Generated token ids for the current hypothesis.\n        ngram_size (`int`):\n            The number sequential tokens taken as a group which may only occur once before being banned.\n        cur_len (`int`):\n            The current length of the token sequences for which the n-grams are being checked.\n\n    Returns:\n        List of tokens that are banned.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.generation.logits_process.HammingDiversityLogitsProcessor::__call__", "project": "transformers", "func": "HammingDiversityLogitsProcessor::__call__", "origin_file": "transformers/generation/logits_process.py", "test_list": ["../tests/generation/test_logits_process.py"], "prob_info": {"func_start_lineno": 1445, "func_end_lineno": 1491, "key_block_start_lineno": 1469, "key_block_end_lineno": 1491, "new_func_code": "def __call__(\n        self,\n        input_ids: torch.LongTensor,\n        scores: torch.FloatTensor,\n        current_tokens: torch.LongTensor,\n        beam_group_idx: int,\n    ) -> torch.FloatTensor:\n        r\"\"\"\n        Args:\n            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n                Indices of input sequence tokens in the vocabulary. [What are input IDs?](../glossary#input-ids)\n            scores (`torch.FloatTensor` of shape `(batch_size, config.vocab_size)`):\n                Prediction scores of a language modeling head. These can be logits for each vocabulary when not using\n                beam search or log softmax for each vocabulary token when using beam search\n            current_tokens (`torch.LongTensor` of shape `(batch_size)`):\n                Indices of input sequence tokens in the vocabulary, corresponding to the tokens selected by the other\n                beam groups in the current generation step.\n            beam_group_idx (`int`):\n                The index of the beam group currently being processed.\n\n        Return:\n            `torch.FloatTensor` of shape `(batch_size, config.vocab_size)`:\n                The processed prediction scores.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.pytorch_utils.isin_mps_friendly", "project": "transformers", "func": "isin_mps_friendly", "origin_file": "transformers/pytorch_utils.py", "test_list": ["../tests/generation/test_logits_process.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 328, "key_block_start_lineno": 323, "key_block_end_lineno": 328, "new_func_code": "def isin_mps_friendly(elements: torch.Tensor, test_elements: torch.Tensor | int) -> torch.Tensor:\n    \"\"\"\n    Same as `torch.isin` without flags, but MPS-friendly. We can remove this function when we stop supporting\n    torch <= 2.3. See https://github.com/pytorch/pytorch/issues/77764#issuecomment-2067838075\n\n    Args:\n        elements (`torch.Tensor`): Input elements\n        test_elements (`torch.Tensor`): The elements to check against.\n\n    Returns:\n        `torch.Tensor`: A boolean tensor of the same shape as `elements` that is True for `elements` in `test_elements`\n        and False otherwise\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.generation.logits_process.LogitsProcessorList::__call__", "project": "transformers", "func": "LogitsProcessorList::__call__", "origin_file": "transformers/generation/logits_process.py", "test_list": ["../tests/generation/test_logits_process.py"], "prob_info": {"func_start_lineno": 78, "func_end_lineno": 106, "key_block_start_lineno": 94, "key_block_end_lineno": 106, "new_func_code": "def __call__(self, input_ids: torch.LongTensor, scores: torch.FloatTensor, **kwargs) -> torch.FloatTensor:\n        r\"\"\"\n        Args:\n            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n                Indices of input sequence tokens in the vocabulary. [What are input IDs?](../glossary#input-ids)\n            scores (`torch.FloatTensor` of shape `(batch_size, config.vocab_size)`):\n                Prediction scores of a language modeling head. These can be logits for each vocabulary when not using\n                beam search or log softmax for each vocabulary token when using beam search\n            kwargs (`Dict[str, Any]`, *optional*):\n                Additional kwargs that are specific to a logits processor.\n\n        Return:\n            `torch.FloatTensor` of shape `(batch_size, config.vocab_size)`:\n                The processed prediction scores.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.feature_extraction_utils.BatchFeature::convert_to_tensors", "project": "transformers", "func": "BatchFeature::convert_to_tensors", "origin_file": "transformers/feature_extraction_utils.py", "test_list": ["../tests/models/audio_spectrogram_transformer/test_feature_extraction_audio_spectrogram_transformer.py"], "prob_info": {"func_start_lineno": 175, "func_end_lineno": 204, "key_block_start_lineno": 184, "key_block_end_lineno": 204, "new_func_code": "def convert_to_tensors(self, tensor_type: Optional[Union[str, TensorType]] = None):\n        \"\"\"\n        Convert the inner content to tensors.\n\n        Args:\n            tensor_type (`str` or [`~utils.TensorType`], *optional*):\n                The type of tensors to use. If `str`, should be one of the values of the enum [`~utils.TensorType`]. If\n                `None`, no modification is done.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.audio_spectrogram_transformer.feature_extraction_audio_spectrogram_transformer.ASTFeatureExtractor::__call__", "project": "transformers", "func": "ASTFeatureExtractor::__call__", "origin_file": "transformers/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.py", "test_list": ["../tests/models/audio_spectrogram_transformer/test_feature_extraction_audio_spectrogram_transformer.py"], "prob_info": {"func_start_lineno": 161, "func_end_lineno": 236, "key_block_start_lineno": 186, "key_block_end_lineno": 236, "new_func_code": "def __call__(\n        self,\n        raw_speech: Union[np.ndarray, List[float], List[np.ndarray], List[List[float]]],\n        sampling_rate: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        **kwargs,\n    ) -> BatchFeature:\n        \"\"\"\n        Main method to featurize and prepare for the model one or several sequence(s).\n\n        Args:\n            raw_speech (`np.ndarray`, `List[float]`, `List[np.ndarray]`, `List[List[float]]`):\n                The sequence or batch of sequences to be padded. Each sequence can be a numpy array, a list of float\n                values, a list of numpy arrays or a list of list of float values. Must be mono channel audio, not\n                stereo, i.e. single float per timestep.\n            sampling_rate (`int`, *optional*):\n                The sampling rate at which the `raw_speech` input was sampled. It is strongly recommended to pass\n                `sampling_rate` at the forward call to prevent silent errors.\n            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n                If set, will return tensors instead of list of python integers. Acceptable values are:\n\n                - `'tf'`: Return TensorFlow `tf.constant` objects.\n                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n                - `'np'`: Return Numpy `np.ndarray` objects.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.audio_utils.mel_filter_bank", "project": "transformers", "func": "mel_filter_bank", "origin_file": "transformers/audio_utils.py", "test_list": ["../tests/models/audio_spectrogram_transformer/test_feature_extraction_audio_spectrogram_transformer.py"], "prob_info": {"func_start_lineno": 218, "func_end_lineno": 303, "key_block_start_lineno": 271, "key_block_end_lineno": 303, "new_func_code": "def mel_filter_bank(\n    num_frequency_bins: int,\n    num_mel_filters: int,\n    min_frequency: float,\n    max_frequency: float,\n    sampling_rate: int,\n    norm: Optional[str] = None,\n    mel_scale: str = \"htk\",\n    triangularize_in_mel_space: bool = False,\n) -> np.ndarray:\n    \"\"\"\n    Creates a frequency bin conversion matrix used to obtain a mel spectrogram. This is called a *mel filter bank*, and\n    various implementation exist, which differ in the number of filters, the shape of the filters, the way the filters\n    are spaced, the bandwidth of the filters, and the manner in which the spectrum is warped. The goal of these\n    features is to approximate the non-linear human perception of the variation in pitch with respect to the frequency.\n\n    Different banks of mel filters were introduced in the literature. The following variations are supported:\n\n    - MFCC FB-20: introduced in 1980 by Davis and Mermelstein, it assumes a sampling frequency of 10 kHz and a speech\n      bandwidth of `[0, 4600]` Hz.\n    - MFCC FB-24 HTK: from the Cambridge HMM Toolkit (HTK) (1995) uses a filter bank of 24 filters for a speech\n      bandwidth of `[0, 8000]` Hz. This assumes sampling rate  16 kHz.\n    - MFCC FB-40: from the Auditory Toolbox for MATLAB written by Slaney in 1998, assumes a sampling rate of 16 kHz and\n      speech bandwidth of `[133, 6854]` Hz. This version also includes area normalization.\n    - HFCC-E FB-29 (Human Factor Cepstral Coefficients) of Skowronski and Harris (2004), assumes a sampling rate of\n      12.5 kHz and speech bandwidth of `[0, 6250]` Hz.\n\n    This code is adapted from *torchaudio* and *librosa*. Note that the default parameters of torchaudio's\n    `melscale_fbanks` implement the `\"htk\"` filters while librosa uses the `\"slaney\"` implementation.\n\n    Args:\n        num_frequency_bins (`int`):\n            Number of frequencies used to compute the spectrogram (should be the same as in `stft`).\n        num_mel_filters (`int`):\n            Number of mel filters to generate.\n        min_frequency (`float`):\n            Lowest frequency of interest in Hz.\n        max_frequency (`float`):\n            Highest frequency of interest in Hz. This should not exceed `sampling_rate / 2`.\n        sampling_rate (`int`):\n            Sample rate of the audio waveform.\n        norm (`str`, *optional*):\n            If `\"slaney\"`, divide the triangular mel weights by the width of the mel band (area normalization).\n        mel_scale (`str`, *optional*, defaults to `\"htk\"`):\n            The mel frequency scale to use, `\"htk\"`, `\"kaldi\"` or `\"slaney\"`.\n        triangularize_in_mel_space (`bool`, *optional*, defaults to `False`):\n            If this option is enabled, the triangular filter is applied in mel space rather than frequency space. This\n            should be set to `true` in order to get the same results as `torchaudio` when computing mel filters.\n\n    Returns:\n        `np.ndarray` of shape (`num_frequency_bins`, `num_mel_filters`): Triangular filter bank matrix. This is a\n        projection matrix to go from a spectrogram to a mel spectrogram.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.audio_utils.hertz_to_mel", "project": "transformers", "func": "hertz_to_mel", "origin_file": "transformers/audio_utils.py", "test_list": ["../tests/models/audio_spectrogram_transformer/test_feature_extraction_audio_spectrogram_transformer.py"], "prob_info": {"func_start_lineno": 26, "func_end_lineno": 59, "key_block_start_lineno": 39, "key_block_end_lineno": 59, "new_func_code": "def hertz_to_mel(freq: Union[float, np.ndarray], mel_scale: str = \"htk\") -> Union[float, np.ndarray]:\n    \"\"\"\n    Convert frequency from hertz to mels.\n\n    Args:\n        freq (`float` or `np.ndarray`):\n            The frequency, or multiple frequencies, in hertz (Hz).\n        mel_scale (`str`, *optional*, defaults to `\"htk\"`):\n            The mel frequency scale to use, `\"htk\"`, `\"kaldi\"` or `\"slaney\"`.\n\n    Returns:\n        `float` or `np.ndarray`: The frequencies on the mel scale.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.audio_utils.mel_to_hertz", "project": "transformers", "func": "mel_to_hertz", "origin_file": "transformers/audio_utils.py", "test_list": ["../tests/models/audio_spectrogram_transformer/test_feature_extraction_audio_spectrogram_transformer.py"], "prob_info": {"func_start_lineno": 62, "func_end_lineno": 95, "key_block_start_lineno": 75, "key_block_end_lineno": 95, "new_func_code": "def mel_to_hertz(mels: Union[float, np.ndarray], mel_scale: str = \"htk\") -> Union[float, np.ndarray]:\n    \"\"\"\n    Convert frequency from mels to hertz.\n\n    Args:\n        mels (`float` or `np.ndarray`):\n            The frequency, or multiple frequencies, in mels.\n        mel_scale (`str`, *optional*, `\"htk\"`):\n            The mel frequency scale to use, `\"htk\"`, `\"kaldi\"` or `\"slaney\"`.\n\n    Returns:\n        `float` or `np.ndarray`: The frequencies in hertz.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.audio_utils._create_triangular_filter_bank", "project": "transformers", "func": "_create_triangular_filter_bank", "origin_file": "transformers/audio_utils.py", "test_list": ["../tests/models/audio_spectrogram_transformer/test_feature_extraction_audio_spectrogram_transformer.py"], "prob_info": {"func_start_lineno": 121, "func_end_lineno": 140, "key_block_start_lineno": 136, "key_block_end_lineno": 140, "new_func_code": "def _create_triangular_filter_bank(fft_freqs: np.ndarray, filter_freqs: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Creates a triangular filter bank.\n\n    Adapted from *torchaudio* and *librosa*.\n\n    Args:\n        fft_freqs (`np.ndarray` of shape `(num_frequency_bins,)`):\n            Discrete frequencies of the FFT bins in Hz.\n        filter_freqs (`np.ndarray` of shape `(num_mel_filters,)`):\n            Center frequencies of the triangular filters to create, in Hz.\n\n    Returns:\n        `np.ndarray` of shape `(num_frequency_bins, num_mel_filters)`\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.audio_utils.window_function", "project": "transformers", "func": "window_function", "origin_file": "transformers/audio_utils.py", "test_list": ["../tests/models/audio_spectrogram_transformer/test_feature_extraction_audio_spectrogram_transformer.py"], "prob_info": {"func_start_lineno": 319, "func_end_lineno": 379, "key_block_start_lineno": 352, "key_block_end_lineno": 379, "new_func_code": "def window_function(\n    window_length: int,\n    name: str = \"hann\",\n    periodic: bool = True,\n    frame_length: Optional[int] = None,\n    center: bool = True,\n) -> np.ndarray:\n    \"\"\"\n    Returns an array containing the specified window. This window is intended to be used with `stft`.\n\n    The following window types are supported:\n\n        - `\"boxcar\"`: a rectangular window\n        - `\"hamming\"`: the Hamming window\n        - `\"hann\"`: the Hann window\n        - `\"povey\"`: the Povey window\n\n    Args:\n        window_length (`int`):\n            The length of the window in samples.\n        name (`str`, *optional*, defaults to `\"hann\"`):\n            The name of the window function.\n        periodic (`bool`, *optional*, defaults to `True`):\n            Whether the window is periodic or symmetric.\n        frame_length (`int`, *optional*):\n            The length of the analysis frames in samples. Provide a value for `frame_length` if the window is smaller\n            than the frame length, so that it will be zero-padded.\n        center (`bool`, *optional*, defaults to `True`):\n            Whether to center the window inside the FFT buffer. Only used when `frame_length` is provided.\n\n    Returns:\n        `np.ndarray` of shape `(window_length,)` or `(frame_length,)` containing the window.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.audio_utils.spectrogram", "project": "transformers", "func": "spectrogram", "origin_file": "transformers/audio_utils.py", "test_list": ["../tests/models/audio_spectrogram_transformer/test_feature_extraction_audio_spectrogram_transformer.py"], "prob_info": {"func_start_lineno": 383, "func_end_lineno": 581, "key_block_start_lineno": 494, "key_block_end_lineno": 581, "new_func_code": "def spectrogram(\n    waveform: np.ndarray,\n    window: np.ndarray,\n    frame_length: int,\n    hop_length: int,\n    fft_length: Optional[int] = None,\n    power: Optional[float] = 1.0,\n    center: bool = True,\n    pad_mode: str = \"reflect\",\n    onesided: bool = True,\n    preemphasis: Optional[float] = None,\n    mel_filters: Optional[np.ndarray] = None,\n    mel_floor: float = 1e-10,\n    log_mel: Optional[str] = None,\n    reference: float = 1.0,\n    min_value: float = 1e-10,\n    db_range: Optional[float] = None,\n    remove_dc_offset: Optional[bool] = None,\n    dtype: np.dtype = np.float32,\n) -> np.ndarray:\n    \"\"\"\n    Calculates a spectrogram over one waveform using the Short-Time Fourier Transform.\n\n    This function can create the following kinds of spectrograms:\n\n      - amplitude spectrogram (`power = 1.0`)\n      - power spectrogram (`power = 2.0`)\n      - complex-valued spectrogram (`power = None`)\n      - log spectrogram (use `log_mel` argument)\n      - mel spectrogram (provide `mel_filters`)\n      - log-mel spectrogram (provide `mel_filters` and `log_mel`)\n\n    How this works:\n\n      1. The input waveform is split into frames of size `frame_length` that are partially overlapping by `frame_length\n         - hop_length` samples.\n      2. Each frame is multiplied by the window and placed into a buffer of size `fft_length`.\n      3. The DFT is taken of each windowed frame.\n      4. The results are stacked into a spectrogram.\n\n    We make a distinction between the following \"blocks\" of sample data, each of which may have a different lengths:\n\n      - The analysis frame. This is the size of the time slices that the input waveform is split into.\n      - The window. Each analysis frame is multiplied by the window to avoid spectral leakage.\n      - The FFT input buffer. The length of this determines how many frequency bins are in the spectrogram.\n\n    In this implementation, the window is assumed to be zero-padded to have the same size as the analysis frame. A\n    padded window can be obtained from `window_function()`. The FFT input buffer may be larger than the analysis frame,\n    typically the next power of two.\n\n    Note: This function is not optimized for speed yet. It should be mostly compatible with `librosa.stft` and\n    `torchaudio.functional.transforms.Spectrogram`, although it is more flexible due to the different ways spectrograms\n    can be constructed.\n\n    Args:\n        waveform (`np.ndarray` of shape `(length,)`):\n            The input waveform. This must be a single real-valued, mono waveform.\n        window (`np.ndarray` of shape `(frame_length,)`):\n            The windowing function to apply, including zero-padding if necessary. The actual window length may be\n            shorter than `frame_length`, but we're assuming the array has already been zero-padded.\n        frame_length (`int`):\n            The length of the analysis frames in samples. With librosa this is always equal to `fft_length` but we also\n            allow smaller sizes.\n        hop_length (`int`):\n            The stride between successive analysis frames in samples.\n        fft_length (`int`, *optional*):\n            The size of the FFT buffer in samples. This determines how many frequency bins the spectrogram will have.\n            For optimal speed, this should be a power of two. If `None`, uses `frame_length`.\n        power (`float`, *optional*, defaults to 1.0):\n            If 1.0, returns the amplitude spectrogram. If 2.0, returns the power spectrogram. If `None`, returns\n            complex numbers.\n        center (`bool`, *optional*, defaults to `True`):\n            Whether to pad the waveform so that frame `t` is centered around time `t * hop_length`. If `False`, frame\n            `t` will start at time `t * hop_length`.\n        pad_mode (`str`, *optional*, defaults to `\"reflect\"`):\n            Padding mode used when `center` is `True`. Possible values are: `\"constant\"` (pad with zeros), `\"edge\"`\n            (pad with edge values), `\"reflect\"` (pads with mirrored values).\n        onesided (`bool`, *optional*, defaults to `True`):\n            If True, only computes the positive frequencies and returns a spectrogram containing `fft_length // 2 + 1`\n            frequency bins. If False, also computes the negative frequencies and returns `fft_length` frequency bins.\n        preemphasis (`float`, *optional*)\n            Coefficient for a low-pass filter that applies pre-emphasis before the DFT.\n        mel_filters (`np.ndarray` of shape `(num_freq_bins, num_mel_filters)`, *optional*):\n            The mel filter bank. If supplied, applies a this filter bank to create a mel spectrogram.\n        mel_floor (`float`, *optional*, defaults to 1e-10):\n            Minimum value of mel frequency banks.\n        log_mel (`str`, *optional*):\n            How to convert the spectrogram to log scale. Possible options are: `None` (don't convert), `\"log\"` (take\n            the natural logarithm) `\"log10\"` (take the base-10 logarithm), `\"dB\"` (convert to decibels). Can only be\n            used when `power` is not `None`.\n        reference (`float`, *optional*, defaults to 1.0):\n            Sets the input spectrogram value that corresponds to 0 dB. For example, use `np.max(spectrogram)` to set\n            the loudest part to 0 dB. Must be greater than zero.\n        min_value (`float`, *optional*, defaults to `1e-10`):\n            The spectrogram will be clipped to this minimum value before conversion to decibels, to avoid taking\n            `log(0)`. For a power spectrogram, the default of `1e-10` corresponds to a minimum of -100 dB. For an\n            amplitude spectrogram, the value `1e-5` corresponds to -100 dB. Must be greater than zero.\n        db_range (`float`, *optional*):\n            Sets the maximum dynamic range in decibels. For example, if `db_range = 80`, the difference between the\n            peak value and the smallest value will never be more than 80 dB. Must be greater than zero.\n        remove_dc_offset (`bool`, *optional*):\n            Subtract mean from waveform on each frame, applied before pre-emphasis. This should be set to `true` in\n            order to get the same results as `torchaudio.compliance.kaldi.fbank` when computing mel filters.\n        dtype (`np.dtype`, *optional*, defaults to `np.float32`):\n            Data type of the spectrogram tensor. If `power` is None, this argument is ignored and the dtype will be\n            `np.complex64`.\n\n    Returns:\n        `nd.array` containing a spectrogram of shape `(num_frequency_bins, length)` for a regular spectrogram or shape\n        `(num_mel_filters, length)` for a mel spectrogram.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.tokenization_utils.Trie::add", "project": "transformers", "func": "Trie::add", "origin_file": "transformers/tokenization_utils.py", "test_list": ["../tests/models/bartpho/test_tokenization_bartpho.py"], "prob_info": {"func_start_lineno": 75, "func_end_lineno": 104, "key_block_start_lineno": 95, "key_block_end_lineno": 104, "new_func_code": "def add(self, word: str):\n        \"\"\"\n        Passes over every char (utf-8 char) on word and recursively adds it to the internal `data` trie representation.\n        The special key `\"\"` in `self._termination_char` is used to represent termination.\n\n        This function is idempotent, adding twice the same word will leave the trie unchanged\n\n        Example:\n\n        ```python\n        >>> trie = Trie()\n        >>> trie.add(\"Hello \")\n        >>> trie.data\n        {\"H\": {\"e\": {\"l\": {\"l\": {\"o\": {\" \": {\"\": {\"\": {\"\": 1}}}}}}}}}\n\n        >>> trie.add(\"Hello\")\n        >>> trie.data\n        {\"H\": {\"e\": {\"l\": {\"l\": {\"o\": {\"\": 1, \" \": {\"\": {\"\": {\"\": 1}}}}}}}}}\n        ```\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.tokenization_utils.Trie::split", "project": "transformers", "func": "Trie::split", "origin_file": "transformers/tokenization_utils.py", "test_list": ["../tests/models/bartpho/test_tokenization_bartpho.py"], "prob_info": {"func_start_lineno": 106, "func_end_lineno": 257, "key_block_start_lineno": 127, "key_block_end_lineno": 257, "new_func_code": "def split(self, text: str) -> List[str]:\n        \"\"\"\n        Will look for the words added to the trie within `text`. Output is the original string splitted along the\n        boundaries of the words found.\n\n        This trie will match the longest possible word first !\n\n        Example:\n\n        ```python\n        >>> trie = Trie()\n        >>> trie.split(\"[CLS] This is a extra_id_100\")\n        [\"[CLS] This is a extra_id_100\"]\n\n        >>> trie.add(\"[CLS]\")\n        >>> trie.add(\"extra_id_1\")\n        >>> trie.add(\"extra_id_100\")\n        >>> trie.split(\"[CLS] This is a extra_id_100\")\n        [\"[CLS]\", \" This is a \", \"extra_id_100\"]\n        ```\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bartpho.tokenization_bartpho.BartphoTokenizer::build_inputs_with_special_tokens", "project": "transformers", "func": "BartphoTokenizer::build_inputs_with_special_tokens", "origin_file": "transformers/models/bartpho/tokenization_bartpho.py", "test_list": ["../tests/models/bartpho/test_tokenization_bartpho.py"], "prob_info": {"func_start_lineno": 177, "func_end_lineno": 201, "key_block_start_lineno": 196, "key_block_end_lineno": 201, "new_func_code": "def build_inputs_with_special_tokens(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n    ) -> List[int]:\n        \"\"\"\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and\n        adding special tokens. An BARTPho sequence has the following format:\n\n        - single sequence: `<s> X </s>`\n        - pair of sequences: `<s> A </s></s> B </s>`\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs to which the special tokens will be added.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n\n        Returns:\n            `List[int]`: List of [input IDs](../glossary#input-ids) with the appropriate special tokens.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bartpho.tokenization_bartpho.BartphoTokenizer::create_token_type_ids_from_sequences", "project": "transformers", "func": "BartphoTokenizer::create_token_type_ids_from_sequences", "origin_file": "transformers/models/bartpho/tokenization_bartpho.py", "test_list": ["../tests/models/bartpho/test_tokenization_bartpho.py"], "prob_info": {"func_start_lineno": 231, "func_end_lineno": 254, "key_block_start_lineno": 248, "key_block_end_lineno": 254, "new_func_code": "def create_token_type_ids_from_sequences(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n    ) -> List[int]:\n        \"\"\"\n        Create a mask from the two sequences passed to be used in a sequence-pair classification task. BARTPho does not\n        make use of token type ids, therefore a list of zeros is returned.\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n\n        Returns:\n            `List[int]`: List of zeros.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.tokenization_utils_base.BatchEncoding::convert_to_tensors", "project": "transformers", "func": "BatchEncoding::convert_to_tensors", "origin_file": "transformers/tokenization_utils_base.py", "test_list": ["../tests/models/bartpho/test_tokenization_bartpho.py"], "prob_info": {"func_start_lineno": 697, "func_end_lineno": 798, "key_block_start_lineno": 710, "key_block_end_lineno": 798, "new_func_code": "def convert_to_tensors(\n        self, tensor_type: Optional[Union[str, TensorType]] = None, prepend_batch_axis: bool = False\n    ):\n        \"\"\"\n        Convert the inner content to tensors.\n\n        Args:\n            tensor_type (`str` or [`~utils.TensorType`], *optional*):\n                The type of tensors to use. If `str`, should be one of the values of the enum [`~utils.TensorType`]. If\n                `None`, no modification is done.\n            prepend_batch_axis (`int`, *optional*, defaults to `False`):\n                Whether or not to add the batch dimension during the conversion.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bartpho.tokenization_bartpho.BartphoTokenizer::get_special_tokens_mask", "project": "transformers", "func": "BartphoTokenizer::get_special_tokens_mask", "origin_file": "transformers/models/bartpho/tokenization_bartpho.py", "test_list": ["../tests/models/bartpho/test_tokenization_bartpho.py"], "prob_info": {"func_start_lineno": 203, "func_end_lineno": 229, "key_block_start_lineno": 221, "key_block_end_lineno": 229, "new_func_code": "def get_special_tokens_mask(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None, already_has_special_tokens: bool = False\n    ) -> List[int]:\n        \"\"\"\n        Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer `prepare_for_model` method.\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n            already_has_special_tokens (`bool`, *optional*, defaults to `False`):\n                Whether or not the token list is already formatted with special tokens for the model.\n\n        Returns:\n            `List[int]`: A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.versions.require_version", "project": "transformers", "func": "require_version", "origin_file": "transformers/utils/versions.py", "test_list": ["../tests/models/bartpho/test_tokenization_bartpho.py"], "prob_info": {"func_start_lineno": 49, "func_end_lineno": 111, "key_block_start_lineno": 65, "key_block_end_lineno": 111, "new_func_code": "def require_version(requirement: str, hint: Optional[str] = None) -> None:\n    \"\"\"\n    Perform a runtime check of the dependency versions, using the exact same syntax used by pip.\n\n    The installed module version comes from the *site-packages* dir via *importlib.metadata*.\n\n    Args:\n        requirement (`str`): pip style definition, e.g.,  \"tokenizers==0.9.4\", \"tqdm>=4.27\", \"numpy\"\n        hint (`str`, *optional*): what suggestion to print in case of requirements not being met\n\n    Example:\n\n    ```python\n    require_version(\"pandas>1.1.2\")\n    require_version(\"numpy>1.18.5\", \"this is important to have for whatever reason\")\n    ```\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.testing_utils.run_test_in_subprocess", "project": "transformers", "func": "run_test_in_subprocess", "origin_file": "transformers/testing_utils.py", "test_list": ["../tests/models/bartpho/test_tokenization_bartpho.py"], "prob_info": {"func_start_lineno": 2265, "func_end_lineno": 2305, "key_block_start_lineno": 2280, "key_block_end_lineno": 2305, "new_func_code": "def run_test_in_subprocess(test_case, target_func, inputs=None, timeout=None):\n    \"\"\"\n    To run a test in a subprocess. In particular, this can avoid (GPU) memory issue.\n\n    Args:\n        test_case (`unittest.TestCase`):\n            The test that will run `target_func`.\n        target_func (`Callable`):\n            The function implementing the actual testing logic.\n        inputs (`dict`, *optional*, defaults to `None`):\n            The inputs that will be passed to `target_func` through an (input) queue.\n        timeout (`int`, *optional*, defaults to `None`):\n            The timeout (in seconds) that will be passed to the input and output queues. If not specified, the env.\n            variable `PYTEST_TIMEOUT` will be checked. If still `None`, its value will be set to `600`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bertweet.tokenization_bertweet.BertweetTokenizer::build_inputs_with_special_tokens", "project": "transformers", "func": "BertweetTokenizer::build_inputs_with_special_tokens", "origin_file": "transformers/models/bertweet/tokenization_bertweet.py", "test_list": ["../tests/models/bertweet/test_tokenization_bertweet.py"], "prob_info": {"func_start_lineno": 167, "func_end_lineno": 191, "key_block_start_lineno": 186, "key_block_end_lineno": 191, "new_func_code": "def build_inputs_with_special_tokens(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n    ) -> List[int]:\n        \"\"\"\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and\n        adding special tokens. A BERTweet sequence has the following format:\n\n        - single sequence: `<s> X </s>`\n        - pair of sequences: `<s> A </s></s> B </s>`\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs to which the special tokens will be added.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n\n        Returns:\n            `List[int]`: List of [input IDs](../glossary#input-ids) with the appropriate special tokens.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bertweet.tokenization_bertweet.BertweetTokenizer::create_token_type_ids_from_sequences", "project": "transformers", "func": "BertweetTokenizer::create_token_type_ids_from_sequences", "origin_file": "transformers/models/bertweet/tokenization_bertweet.py", "test_list": ["../tests/models/bertweet/test_tokenization_bertweet.py"], "prob_info": {"func_start_lineno": 221, "func_end_lineno": 243, "key_block_start_lineno": 237, "key_block_end_lineno": 243, "new_func_code": "def create_token_type_ids_from_sequences(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n    ) -> List[int]:\n        \"\"\"\n        Create a mask from the two sequences passed to be used in a sequence-pair classification task. BERTweet does\n        not make use of token type ids, therefore a list of zeros is returned.\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n\n        Returns:\n            `List[int]`: List of zeros.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.tokenization_utils_base.BatchEncoding::__getitem__", "project": "transformers", "func": "BatchEncoding::__getitem__", "origin_file": "transformers/tokenization_utils_base.py", "test_list": ["../tests/models/bertweet/test_tokenization_bertweet.py"], "prob_info": {"func_start_lineno": 259, "func_end_lineno": 279, "key_block_start_lineno": 269, "key_block_end_lineno": 279, "new_func_code": "def __getitem__(self, item: Union[int, str]) -> Union[Any, EncodingFast]:\n        \"\"\"\n        If the key is a string, returns the value of the dict associated to `key` ('input_ids', 'attention_mask',\n        etc.).\n\n        If the key is an integer, get the `tokenizers.Encoding` for batch item with index `key`.\n\n        If the key is a slice, returns the value of the dict associated to `key` ('input_ids', 'attention_mask', etc.)\n        with the constraint of slice.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bertweet.tokenization_bertweet.BertweetTokenizer::get_special_tokens_mask", "project": "transformers", "func": "BertweetTokenizer::get_special_tokens_mask", "origin_file": "transformers/models/bertweet/tokenization_bertweet.py", "test_list": ["../tests/models/bertweet/test_tokenization_bertweet.py"], "prob_info": {"func_start_lineno": 193, "func_end_lineno": 219, "key_block_start_lineno": 211, "key_block_end_lineno": 219, "new_func_code": "def get_special_tokens_mask(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None, already_has_special_tokens: bool = False\n    ) -> List[int]:\n        \"\"\"\n        Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer `prepare_for_model` method.\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n            already_has_special_tokens (`bool`, *optional*, defaults to `False`):\n                Whether or not the token list is already formatted with special tokens for the model.\n\n        Returns:\n            `List[int]`: A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_processing_utils.get_size_dict", "project": "transformers", "func": "get_size_dict", "origin_file": "transformers/image_processing_utils.py", "test_list": ["../tests/models/blip/test_image_processing_blip.py"], "prob_info": {"func_start_lineno": 208, "func_end_lineno": 249, "key_block_start_lineno": 236, "key_block_end_lineno": 249, "new_func_code": "def get_size_dict(\n    size: Union[int, Iterable[int], Dict[str, int]] = None,\n    max_size: Optional[int] = None,\n    height_width_order: bool = True,\n    default_to_square: bool = True,\n    param_name=\"size\",\n) -> dict:\n    \"\"\"\n    Converts the old size parameter in the config into the new dict expected in the config. This is to ensure backwards\n    compatibility with the old image processor configs and removes ambiguity over whether the tuple is in (height,\n    width) or (width, height) format.\n\n    - If `size` is tuple, it is converted to `{\"height\": size[0], \"width\": size[1]}` or `{\"height\": size[1], \"width\":\n    size[0]}` if `height_width_order` is `False`.\n    - If `size` is an int, and `default_to_square` is `True`, it is converted to `{\"height\": size, \"width\": size}`.\n    - If `size` is an int and `default_to_square` is False, it is converted to `{\"shortest_edge\": size}`. If `max_size`\n      is set, it is added to the dict as `{\"longest_edge\": max_size}`.\n\n    Args:\n        size (`Union[int, Iterable[int], Dict[str, int]]`, *optional*):\n            The `size` parameter to be cast into a size dictionary.\n        max_size (`Optional[int]`, *optional*):\n            The `max_size` parameter to be cast into a size dictionary.\n        height_width_order (`bool`, *optional*, defaults to `True`):\n            If `size` is a tuple, whether it's in (height, width) or (width, height) order.\n        default_to_square (`bool`, *optional*, defaults to `True`):\n            If `size` is an int, whether to default to a square image or not.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.blip.image_processing_blip.BlipImageProcessor::resize", "project": "transformers", "func": "BlipImageProcessor::resize", "origin_file": "transformers/models/blip/image_processing_blip.py", "test_list": ["../tests/models/blip/test_image_processing_blip.py"], "prob_info": {"func_start_lineno": 111, "func_end_lineno": 157, "key_block_start_lineno": 146, "key_block_end_lineno": 157, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image to `(size[\"height\"], size[\"width\"])`.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Dictionary in the format `{\"height\": int, \"width\": int}` specifying the size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                `PILImageResampling` filter to use when resizing the image e.g. `PILImageResampling.BICUBIC`.\n            data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the output image. If unset, the channel dimension format of the input\n                image is used. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n\n        Returns:\n            `np.ndarray`: The resized image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.resize", "project": "transformers", "func": "resize", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/models/blip/test_image_processing_blip.py"], "prob_info": {"func_start_lineno": 281, "func_end_lineno": 349, "key_block_start_lineno": 314, "key_block_end_lineno": 349, "new_func_code": "def resize(\n    image: np.ndarray,\n    size: Tuple[int, int],\n    resample: \"PILImageResampling\" = None,\n    reducing_gap: Optional[int] = None,\n    data_format: Optional[ChannelDimension] = None,\n    return_numpy: bool = True,\n    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Resizes `image` to `(height, width)` specified by `size` using the PIL library.\n\n    Args:\n        image (`np.ndarray`):\n            The image to resize.\n        size (`Tuple[int, int]`):\n            The size to use for resizing the image.\n        resample (`int`, *optional*, defaults to `PILImageResampling.BILINEAR`):\n            The filter to user for resampling.\n        reducing_gap (`int`, *optional*):\n            Apply optimization by resizing the image in two steps. The bigger `reducing_gap`, the closer the result to\n            the fair resampling. See corresponding Pillow documentation for more details.\n        data_format (`ChannelDimension`, *optional*):\n            The channel dimension format of the output image. If unset, will use the inferred format from the input.\n        return_numpy (`bool`, *optional*, defaults to `True`):\n            Whether or not to return the resized image as a numpy array. If False a `PIL.Image.Image` object is\n            returned.\n        input_data_format (`ChannelDimension`, *optional*):\n            The channel dimension format of the input image. If unset, will use the inferred format from the input.\n\n    Returns:\n        `np.ndarray`: The resized image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bridgetower.image_processing_bridgetower.BridgeTowerImageProcessor::resize", "project": "transformers", "func": "BridgeTowerImageProcessor::resize", "origin_file": "transformers/models/bridgetower/image_processing_bridgetower.py", "test_list": ["../tests/models/bridgetower/test_image_processing_bridgetower.py"], "prob_info": {"func_start_lineno": 209, "func_end_lineno": 255, "key_block_start_lineno": 240, "key_block_end_lineno": 255, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        size_divisor: int = 32,\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image.\n\n        Resizes the shorter side of the image to `size[\"shortest_edge\"]` while preserving the aspect ratio. If the\n        longer side is larger than the max size `(int(`size[\"shortest_edge\"]` * 1333 / 800))`, the longer side is then\n        resized to the max size while preserving the aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Controls the size of the output image. Should be of the form `{\"shortest_edge\": int}`.\n            size_divisor (`int`, *optional*, defaults to 32):\n                The image is resized to a size that is a multiple of this value.\n            resample (`PILImageResampling` filter, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.chameleon.image_processing_chameleon.ChameleonImageProcessor::resize", "project": "transformers", "func": "ChameleonImageProcessor::resize", "origin_file": "transformers/models/chameleon/image_processing_chameleon.py", "test_list": ["../tests/models/chameleon/test_image_processing_chameleon.py"], "prob_info": {"func_start_lineno": 145, "func_end_lineno": 192, "key_block_start_lineno": 170, "key_block_end_lineno": 192, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image. The shortest edge of the image is resized to size[\"shortest_edge\"], with the longest edge\n        resized to keep the input aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.get_resize_output_image_size", "project": "transformers", "func": "get_resize_output_image_size", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/models/chameleon/test_image_processing_chameleon.py"], "prob_info": {"func_start_lineno": 214, "func_end_lineno": 278, "key_block_start_lineno": 251, "key_block_end_lineno": 278, "new_func_code": "def get_resize_output_image_size(\n    input_image: np.ndarray,\n    size: Union[int, Tuple[int, int], List[int], Tuple[int]],\n    default_to_square: bool = True,\n    max_size: Optional[int] = None,\n    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n) -> tuple:\n    \"\"\"\n    Find the target (height, width) dimension of the output image after resizing given the input image and the desired\n    size.\n\n    Args:\n        input_image (`np.ndarray`):\n            The image to resize.\n        size (`int` or `Tuple[int, int]` or List[int] or `Tuple[int]`):\n            The size to use for resizing the image. If `size` is a sequence like (h, w), output size will be matched to\n            this.\n\n            If `size` is an int and `default_to_square` is `True`, then image will be resized to (size, size). If\n            `size` is an int and `default_to_square` is `False`, then smaller edge of the image will be matched to this\n            number. i.e, if height > width, then image will be rescaled to (size * height / width, size).\n        default_to_square (`bool`, *optional*, defaults to `True`):\n            How to convert `size` when it is a single int. If set to `True`, the `size` will be converted to a square\n            (`size`,`size`). If set to `False`, will replicate\n            [`torchvision.transforms.Resize`](https://pytorch.org/vision/stable/transforms.html#torchvision.transforms.Resize)\n            with support for resizing only the smallest edge and providing an optional `max_size`.\n        max_size (`int`, *optional*):\n            The maximum allowed for the longer edge of the resized image: if the longer edge of the image is greater\n            than `max_size` after being resized according to `size`, then the image is resized again so that the longer\n            edge is equal to `max_size`. As a result, `size` might be overruled, i.e the smaller edge may be shorter\n            than `size`. Only used if `default_to_square` is `False`.\n        input_data_format (`ChannelDimension`, *optional*):\n            The channel dimension format of the input image. If unset, will use the inferred format from the input.\n\n    Returns:\n        `tuple`: The target (height, width) dimension of the output image after resizing.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.clap.feature_extraction_clap.ClapFeatureExtractor::__call__", "project": "transformers", "func": "ClapFeatureExtractor::__call__", "origin_file": "transformers/models/clap/feature_extraction_clap.py", "test_list": ["../tests/models/clap/test_feature_extraction_clap.py"], "prob_info": {"func_start_lineno": 258, "func_end_lineno": 362, "key_block_start_lineno": 299, "key_block_end_lineno": 362, "new_func_code": "def __call__(\n        self,\n        raw_speech: Union[np.ndarray, List[float], List[np.ndarray], List[List[float]]],\n        truncation: str = None,\n        padding: Optional[str] = None,\n        max_length: Optional[int] = None,\n        sampling_rate: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        **kwargs,\n    ) -> BatchFeature:\n        \"\"\"\n        Main method to featurize and prepare for the model one or several sequence(s).\n\n        Args:\n            raw_speech (`np.ndarray`, `List[float]`, `List[np.ndarray]`, `List[List[float]]`):\n                The sequence or batch of sequences to be padded. Each sequence can be a numpy array, a list of float\n                values, a list of numpy arrays or a list of list of float values. Must be mono channel audio, not\n                stereo, i.e. single float per timestep.\n            truncation (`str`, *optional*):\n                Truncation pattern for long audio inputs. Two patterns are available:\n                    - `fusion` will use `_random_mel_fusion`, which stacks 3 random crops from the mel spectrogram and\n                      a downsampled version of the entire mel spectrogram.\n                If `config.fusion` is set to True, shorter audios also need to to return 4 mels, which will just be a\n                copy of the original mel obtained from the padded audio.\n                    - `rand_trunc` will select a random crop of the mel spectrogram.\n            padding (`str`, *optional*):\n               Padding pattern for shorter audio inputs. Three patterns were originally implemented:\n                    - `repeatpad`: the audio is repeated, and then padded to fit the `max_length`.\n                    - `repeat`: the audio is repeated and then cut to fit the `max_length`\n                    - `pad`: the audio is padded.\n            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n                If set, will return tensors instead of list of python integers. Acceptable values are:\n\n                - `'tf'`: Return TensorFlow `tf.constant` objects.\n                - `'pt'`: Return PyTorch `torch.np.array` objects.\n                - `'np'`: Return Numpy `np.ndarray` objects.\n            sampling_rate (`int`, *optional*):\n                The sampling rate at which the `raw_speech` input was sampled. It is strongly recommended to pass\n                `sampling_rate` at the forward call to prevent silent errors and allow automatic speech recognition\n                pipeline.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.audio_utils.power_to_db", "project": "transformers", "func": "power_to_db", "origin_file": "transformers/audio_utils.py", "test_list": ["../tests/models/clap/test_feature_extraction_clap.py"], "prob_info": {"func_start_lineno": 791, "func_end_lineno": 839, "key_block_start_lineno": 824, "key_block_end_lineno": 839, "new_func_code": "def power_to_db(\n    spectrogram: np.ndarray,\n    reference: float = 1.0,\n    min_value: float = 1e-10,\n    db_range: Optional[float] = None,\n) -> np.ndarray:\n    \"\"\"\n    Converts a power spectrogram to the decibel scale. This computes `10 * log10(spectrogram / reference)`, using basic\n    logarithm properties for numerical stability.\n\n    The motivation behind applying the log function on the (mel) spectrogram is that humans do not hear loudness on a\n    linear scale. Generally to double the perceived volume of a sound we need to put 8 times as much energy into it.\n    This means that large variations in energy may not sound all that different if the sound is loud to begin with.\n    This compression operation makes the (mel) spectrogram features match more closely what humans actually hear.\n\n    Based on the implementation of `librosa.power_to_db`.\n\n    Args:\n        spectrogram (`np.ndarray`):\n            The input power (mel) spectrogram. Note that a power spectrogram has the amplitudes squared!\n        reference (`float`, *optional*, defaults to 1.0):\n            Sets the input spectrogram value that corresponds to 0 dB. For example, use `np.max(spectrogram)` to set\n            the loudest part to 0 dB. Must be greater than zero.\n        min_value (`float`, *optional*, defaults to `1e-10`):\n            The spectrogram will be clipped to this minimum value before conversion to decibels, to avoid taking\n            `log(0)`. The default of `1e-10` corresponds to a minimum of -100 dB. Must be greater than zero.\n        db_range (`float`, *optional*):\n            Sets the maximum dynamic range in decibels. For example, if `db_range = 80`, the difference between the\n            peak value and the smallest value will never be more than 80 dB. Must be greater than zero.\n\n    Returns:\n        `np.ndarray`: the spectrogram in decibels\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.clap.feature_extraction_clap.ClapFeatureExtractor::to_dict", "project": "transformers", "func": "ClapFeatureExtractor::to_dict", "origin_file": "transformers/models/clap/feature_extraction_clap.py", "test_list": ["../tests/models/clap/test_feature_extraction_clap.py"], "prob_info": {"func_start_lineno": 137, "func_end_lineno": 151, "key_block_start_lineno": 145, "key_block_end_lineno": 151, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes this instance to a Python dictionary.\n\n        Returns:\n            `Dict[str, Any]`: Dictionary of all the attributes that make up this configuration instance, excpet for the\n            mel filter banks, which do not need to be saved or printed as they are too long.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.trainer_utils.set_seed", "project": "transformers", "func": "set_seed", "origin_file": "transformers/trainer_utils.py", "test_list": ["../tests/models/clap/test_feature_extraction_clap.py"], "prob_info": {"func_start_lineno": 92, "func_end_lineno": 123, "key_block_start_lineno": 102, "key_block_end_lineno": 123, "new_func_code": "def set_seed(seed: int, deterministic: bool = False):\n    \"\"\"\n    Helper function for reproducible behavior to set the seed in `random`, `numpy`, `torch` and/or `tf` (if installed).\n\n    Args:\n        seed (`int`):\n            The seed to set.\n        deterministic (`bool`, *optional*, defaults to `False`):\n            Whether to use deterministic algorithms where available. Can slow down training.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.clip.image_processing_clip.CLIPImageProcessor::preprocess", "project": "transformers", "func": "CLIPImageProcessor::preprocess", "origin_file": "transformers/models/clip/image_processing_clip.py", "test_list": ["../tests/models/clip/test_image_processing_clip.py"], "prob_info": {"func_start_lineno": 200, "func_end_lineno": 345, "key_block_start_lineno": 270, "key_block_end_lineno": 345, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: int = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_convert_rgb: bool = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n                the longest edge resized to keep the input aspect ratio.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_center_crop`):\n                Whether to center crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the center crop. Only has an effect if `do_center_crop` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                `True`.\n            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n                Whether to convert the image to RGB.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                - Unset: Return a list of `np.ndarray`.\n                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.dac.feature_extraction_dac.DacFeatureExtractor::__call__", "project": "transformers", "func": "DacFeatureExtractor::__call__", "origin_file": "transformers/models/dac/feature_extraction_dac.py", "test_list": ["../tests/models/dac/test_feature_extraction_dac.py"], "prob_info": {"func_start_lineno": 60, "func_end_lineno": 170, "key_block_start_lineno": 102, "key_block_end_lineno": 170, "new_func_code": "def __call__(\n        self,\n        raw_audio: Union[np.ndarray, List[float], List[np.ndarray], List[List[float]]],\n        padding: Optional[Union[bool, str, PaddingStrategy]] = None,\n        truncation: Optional[bool] = False,\n        max_length: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        sampling_rate: Optional[int] = None,\n    ) -> BatchFeature:\n        \"\"\"\n        Main method to featurize and prepare for the model one or several sequence(s).\n\n        Args:\n            raw_audio (`np.ndarray`, `List[float]`, `List[np.ndarray]`, `List[List[float]]`):\n                The sequence or batch of sequences to be processed. Each sequence can be a numpy array, a list of float\n                values, a list of numpy arrays or a list of list of float values. The numpy array must be of shape\n                `(num_samples,)` for mono audio (`feature_size = 1`), or `(2, num_samples)` for stereo audio\n                (`feature_size = 2`).\n            padding (`bool`, `str` or [`~utils.PaddingStrategy`], *optional*, defaults to `True`):\n                Select a strategy to pad the returned sequences (according to the model's padding side and padding\n                index) among:\n\n                - `True` or `'longest'`: Pad to the longest sequence in the batch (or no padding if only a single\n                  sequence if provided).\n                - `'max_length'`: Pad to a maximum length specified with the argument `max_length` or to the maximum\n                  acceptable input length for the model if that argument is not provided.\n                - `False` or `'do_not_pad'` (default): No padding (i.e., can output a batch with sequences of different\n                  lengths).\n            truncation (`bool`, *optional*, defaults to `False`):\n                Activates truncation to cut input sequences longer than `max_length` to `max_length`.\n            max_length (`int`, *optional*):\n                Maximum length of the returned list and optionally padding length (see above).\n            return_tensors (`str` or [`~utils.TensorType`], *optional*, default to 'pt'):\n                If set, will return tensors instead of list of python integers. Acceptable values are:\n\n                - `'tf'`: Return TensorFlow `tf.constant` objects.\n                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n                - `'np'`: Return Numpy `np.ndarray` objects.\n            sampling_rate (`int`, *optional*):\n                The sampling rate at which the `audio` input was sampled. It is strongly recommended to pass\n                `sampling_rate` at the forward call to prevent silent errors.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.generic._get_frameworks_and_test_func", "project": "transformers", "func": "_get_frameworks_and_test_func", "origin_file": "transformers/utils/generic.py", "test_list": ["../tests/models/deit/test_image_processing_deit.py"], "prob_info": {"func_start_lineno": 98, "func_end_lineno": 116, "key_block_start_lineno": 103, "key_block_end_lineno": 116, "new_func_code": "def _get_frameworks_and_test_func(x):\n    \"\"\"\n    Returns an (ordered since we are in Python 3.7+) dictionary framework to test function, which places the framework\n    we can guess from the repr first, then Numpy, then the others.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.deit.image_processing_deit.DeiTImageProcessor::resize", "project": "transformers", "func": "DeiTImageProcessor::resize", "origin_file": "transformers/models/deit/image_processing_deit.py", "test_list": ["../tests/models/deit/test_image_processing_deit.py"], "prob_info": {"func_start_lineno": 114, "func_end_lineno": 160, "key_block_start_lineno": 149, "key_block_end_lineno": 160, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image to `(size[\"height\"], size[\"width\"])`.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Dictionary in the format `{\"height\": int, \"width\": int}` specifying the size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                `PILImageResampling` filter to use when resizing the image e.g. `PILImageResampling.BICUBIC`.\n            data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the output image. If unset, the channel dimension format of the input\n                image is used. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n\n        Returns:\n            `np.ndarray`: The resized image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.to_pil_image", "project": "transformers", "func": "to_pil_image", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/models/dpt/test_image_processing_dpt.py"], "prob_info": {"func_start_lineno": 162, "func_end_lineno": 210, "key_block_start_lineno": 184, "key_block_end_lineno": 210, "new_func_code": "def to_pil_image(\n    image: Union[np.ndarray, \"PIL.Image.Image\", \"torch.Tensor\", \"tf.Tensor\", \"jnp.ndarray\"],\n    do_rescale: Optional[bool] = None,\n    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n) -> \"PIL.Image.Image\":\n    \"\"\"\n    Converts `image` to a PIL Image. Optionally rescales it and puts the channel dimension back as the last axis if\n    needed.\n\n    Args:\n        image (`PIL.Image.Image` or `numpy.ndarray` or `torch.Tensor` or `tf.Tensor`):\n            The image to convert to the `PIL.Image` format.\n        do_rescale (`bool`, *optional*):\n            Whether or not to apply the scaling factor (to make pixel values integers between 0 and 255). Will default\n            to `True` if the image type is a floating type and casting to `int` would result in a loss of precision,\n            and `False` otherwise.\n        input_data_format (`ChannelDimension`, *optional*):\n            The channel dimension format of the input image. If unset, will use the inferred format from the input.\n\n    Returns:\n        `PIL.Image.Image`: The converted image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.efficientnet.image_processing_efficientnet.EfficientNetImageProcessor::resize", "project": "transformers", "func": "EfficientNetImageProcessor::resize", "origin_file": "transformers/models/efficientnet/image_processing_efficientnet.py", "test_list": ["../tests/models/efficientnet/test_image_processing_efficientnet.py"], "prob_info": {"func_start_lineno": 123, "func_end_lineno": 169, "key_block_start_lineno": 158, "key_block_end_lineno": 169, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.NEAREST,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image to `(size[\"height\"], size[\"width\"])`.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Dictionary in the format `{\"height\": int, \"width\": int}` specifying the size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.NEAREST`):\n                `PILImageResampling` filter to use when resizing the image e.g. `PILImageResampling.NEAREST`.\n            data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the output image. If unset, the channel dimension format of the input\n                image is used. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n\n        Returns:\n            `np.ndarray`: The resized image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.rescale", "project": "transformers", "func": "rescale", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/models/flava/test_image_processing_flava.py"], "prob_info": {"func_start_lineno": 97, "func_end_lineno": 132, "key_block_start_lineno": 123, "key_block_end_lineno": 132, "new_func_code": "def rescale(\n    image: np.ndarray,\n    scale: float,\n    data_format: Optional[ChannelDimension] = None,\n    dtype: np.dtype = np.float32,\n    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Rescales `image` by `scale`.\n\n    Args:\n        image (`np.ndarray`):\n            The image to rescale.\n        scale (`float`):\n            The scale to use for rescaling the image.\n        data_format (`ChannelDimension`, *optional*):\n            The channel dimension format of the image. If not provided, it will be the same as the input image.\n        dtype (`np.dtype`, *optional*, defaults to `np.float32`):\n            The dtype of the output image. Defaults to `np.float32`. Used for backwards compatibility with feature\n            extractors.\n        input_data_format (`ChannelDimension`, *optional*):\n            The channel dimension format of the input image. If not provided, it will be inferred from the input image.\n\n    Returns:\n        `np.ndarray`: The rescaled image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.normalize", "project": "transformers", "func": "normalize", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/models/flava/test_image_processing_flava.py"], "prob_info": {"func_start_lineno": 352, "func_end_lineno": 410, "key_block_start_lineno": 376, "key_block_end_lineno": 410, "new_func_code": "def normalize(\n    image: np.ndarray,\n    mean: Union[float, Iterable[float]],\n    std: Union[float, Iterable[float]],\n    data_format: Optional[ChannelDimension] = None,\n    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Normalizes `image` using the mean and standard deviation specified by `mean` and `std`.\n\n    image = (image - mean) / std\n\n    Args:\n        image (`np.ndarray`):\n            The image to normalize.\n        mean (`float` or `Iterable[float]`):\n            The mean to use for normalization.\n        std (`float` or `Iterable[float]`):\n            The standard deviation to use for normalization.\n        data_format (`ChannelDimension`, *optional*):\n            The channel dimension format of the output image. If unset, will use the inferred format from the input.\n        input_data_format (`ChannelDimension`, *optional*):\n            The channel dimension format of the input image. If unset, will use the inferred format from the input.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_utils.get_channel_dimension_axis", "project": "transformers", "func": "get_channel_dimension_axis", "origin_file": "transformers/image_utils.py", "test_list": ["../tests/models/flava/test_image_processing_flava.py"], "prob_info": {"func_start_lineno": 257, "func_end_lineno": 278, "key_block_start_lineno": 272, "key_block_end_lineno": 278, "new_func_code": "def get_channel_dimension_axis(\n    image: np.ndarray, input_data_format: Optional[Union[ChannelDimension, str]] = None\n) -> int:\n    \"\"\"\n    Returns the channel dimension axis of the image.\n\n    Args:\n        image (`np.ndarray`):\n            The image to get the channel dimension axis of.\n        input_data_format (`ChannelDimension` or `str`, *optional*):\n            The channel dimension format of the image. If `None`, will infer the channel dimension from the image.\n\n    Returns:\n        The channel dimension axis of the image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.fuyu.image_processing_fuyu.FuyuImageProcessor::resize", "project": "transformers", "func": "FuyuImageProcessor::resize", "origin_file": "transformers/models/fuyu/image_processing_fuyu.py", "test_list": ["../tests/models/fuyu/test_image_processing_fuyu.py"], "prob_info": {"func_start_lineno": 266, "func_end_lineno": 322, "key_block_start_lineno": 301, "key_block_end_lineno": 322, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BILINEAR,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image to `(size[\"height\"], size[\"width\"])`.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Dictionary in the format `{\"height\": int, \"width\": int}` specifying the size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BILINEAR`):\n                `PILImageResampling` filter to use when resizing the image e.g. `PILImageResampling.BILINEAR`.\n            data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the output image. If unset, the channel dimension format of the input\n                image is used. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n\n        Returns:\n            `np.ndarray`: The resized image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.glpn.image_processing_glpn.GLPNImageProcessor::resize", "project": "transformers", "func": "GLPNImageProcessor::resize", "origin_file": "transformers/models/glpn/image_processing_glpn.py", "test_list": ["../tests/models/glpn/test_image_processing_glpn.py"], "prob_info": {"func_start_lineno": 75, "func_end_lineno": 123, "key_block_start_lineno": 111, "key_block_end_lineno": 123, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size_divisor: int,\n        resample: PILImageResampling = PILImageResampling.BILINEAR,\n        data_format: Optional[ChannelDimension] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize the image, rounding the (height, width) dimensions down to the closest multiple of size_divisor.\n\n        If the image is of dimension (3, 260, 170) and size_divisor is 32, the image will be resized to (3, 256, 160).\n\n        Args:\n            image (`np.ndarray`):\n                The image to resize.\n            size_divisor (`int`):\n                The image is resized so its height and width are rounded down to the closest multiple of\n                `size_divisor`.\n            resample:\n                `PIL.Image` resampling filter to use when resizing the image e.g. `PILImageResampling.BILINEAR`.\n            data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the output image. If `None`, the channel dimension format of the input\n                image is used. Can be one of:\n                - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not set, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n\n        Returns:\n            `np.ndarray`: The resized image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.idefics2.image_processing_idefics2.Idefics2ImageProcessor::preprocess", "project": "transformers", "func": "Idefics2ImageProcessor::preprocess", "origin_file": "transformers/models/idefics2/image_processing_idefics2.py", "test_list": ["../tests/models/idefics2/test_image_processing_idefics2.py"], "prob_info": {"func_start_lineno": 425, "func_end_lineno": 596, "key_block_start_lineno": 494, "key_block_end_lineno": 596, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        do_convert_rgb: Optional[bool] = None,\n        do_resize: Optional[bool] = None,\n        size: Optional[Dict[str, int]] = None,\n        resample: PILImageResampling = None,\n        do_rescale: Optional[bool] = None,\n        rescale_factor: Optional[float] = None,\n        do_normalize: Optional[bool] = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_pad: Optional[bool] = None,\n        do_image_splitting: Optional[bool] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        input_data_format: Optional[ChannelDimension] = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n    ):\n        \"\"\"\n        Preprocess a batch of images.\n\n        Args:\n            images (`ImageInput`):\n                A list of images to preprocess.\n            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n                Whether to convert the image to RGB.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n                the longest edge resized to keep the input aspect ratio.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n                has an effect if `do_resize` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                `True`.\n            do_pad (`bool`, *optional*, defaults to `self.do_pad`):\n                Whether or not to pad the images to the largest height and width in the batch.\n            do_image_splitting (`bool`, *optional*, defaults to `self.do_image_splitting`):\n                Whether to split the image into a sequence 4 equal sub-images concatenated with the original image. That\n                strategy was first introduced in https://arxiv.org/abs/2311.06607.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                - Unset: Return a list of `np.ndarray`.\n                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.idefics2.image_processing_idefics2.make_list_of_images", "project": "transformers", "func": "make_list_of_images", "origin_file": "transformers/models/idefics2/image_processing_idefics2.py", "test_list": ["../tests/models/idefics2/test_image_processing_idefics2.py"], "prob_info": {"func_start_lineno": 80, "func_end_lineno": 109, "key_block_start_lineno": 91, "key_block_end_lineno": 109, "new_func_code": "def make_list_of_images(images: ImageInput) -> List[List[np.ndarray]]:\n    \"\"\"\n    Convert a single image or a list of images to a list of numpy arrays.\n\n    Args:\n        images (`ImageInput`):\n            A single image or a list of images.\n\n    Returns:\n        A list of numpy arrays.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_utils.validate_preprocess_arguments", "project": "transformers", "func": "validate_preprocess_arguments", "origin_file": "transformers/image_utils.py", "test_list": ["../tests/models/idefics2/test_image_processing_idefics2.py"], "prob_info": {"func_start_lineno": 388, "func_end_lineno": 426, "key_block_start_lineno": 410, "key_block_end_lineno": 426, "new_func_code": "def validate_preprocess_arguments(\n    do_rescale: Optional[bool] = None,\n    rescale_factor: Optional[float] = None,\n    do_normalize: Optional[bool] = None,\n    image_mean: Optional[Union[float, List[float]]] = None,\n    image_std: Optional[Union[float, List[float]]] = None,\n    do_pad: Optional[bool] = None,\n    size_divisibility: Optional[int] = None,\n    do_center_crop: Optional[bool] = None,\n    crop_size: Optional[Dict[str, int]] = None,\n    do_resize: Optional[bool] = None,\n    size: Optional[Dict[str, int]] = None,\n    resample: Optional[\"PILImageResampling\"] = None,\n):\n    \"\"\"\n    Checks validity of typically used arguments in an `ImageProcessor` `preprocess` method.\n    Raises `ValueError` if arguments incompatibility is caught.\n    Many incompatibilities are model-specific. `do_pad` sometimes needs `size_divisor`,\n    sometimes `size_divisibility`, and sometimes `size`. New models and processors added should follow\n    existing arguments when possible.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.levit.image_processing_levit.LevitImageProcessor::resize", "project": "transformers", "func": "LevitImageProcessor::resize", "origin_file": "transformers/models/levit/image_processing_levit.py", "test_list": ["../tests/models/levit/test_image_processing_levit.py"], "prob_info": {"func_start_lineno": 119, "func_end_lineno": 172, "key_block_start_lineno": 153, "key_block_end_lineno": 172, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image.\n\n        If size is a dict with keys \"width\" and \"height\", the image will be resized to `(size[\"height\"],\n        size[\"width\"])`.\n\n        If size is a dict with key \"shortest_edge\", the shortest edge value `c` is rescaled to `int(c * (256/224))`.\n        The smaller edge of the image will be matched to this value i.e, if height > width, then image will be rescaled\n        to `(size[\"shortest_egde\"] * height / width, size[\"shortest_egde\"])`.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image after resizing. If size is a dict with keys \"width\" and \"height\", the image\n                will be resized to (height, width). If size is a dict with key \"shortest_edge\", the shortest edge value\n                `c` is rescaled to int(`c` * (256/224)). The smaller edge of the image will be matched to this value\n                i.e, if height > width, then image will be rescaled to (size * height / width, size).\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_next.image_processing_llava_next.make_batched_images", "project": "transformers", "func": "make_batched_images", "origin_file": "transformers/models/llava_next/image_processing_llava_next.py", "test_list": ["../tests/models/llava_next/test_image_processing_llava_next.py"], "prob_info": {"func_start_lineno": 56, "func_end_lineno": 76, "key_block_start_lineno": 67, "key_block_end_lineno": 76, "new_func_code": "def make_batched_images(images) -> List[List[ImageInput]]:\n    \"\"\"\n    Accepts images in list or nested list format, and makes a list of images for preprocessing.\n\n    Args:\n        images (`Union[List[List[ImageInput]], List[ImageInput], ImageInput]`):\n            The input image.\n\n    Returns:\n        list: A list of images.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_next_video.image_processing_llava_next_video.LlavaNextVideoImageProcessor::preprocess", "project": "transformers", "func": "LlavaNextVideoImageProcessor::preprocess", "origin_file": "transformers/models/llava_next_video/image_processing_llava_next_video.py", "test_list": ["../tests/models/llava_next_video/test_image_processing_llava_next_video.py"], "prob_info": {"func_start_lineno": 299, "func_end_lineno": 416, "key_block_start_lineno": 366, "key_block_end_lineno": 416, "new_func_code": "def preprocess(\n        self,\n        images: VideoInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: int = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_convert_rgb: bool = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ):\n        \"\"\"\n        Args:\n            images (`VideoInput`):\n                Videos to preprocess. Expects a single or batch of videos with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the video.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the video after resizing. Shortest edge of the video is resized to size[\"shortest_edge\"], with\n                the longest edge resized to keep the input aspect ratio.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the video. This can be one of the enum `PILImageResampling`. Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_center_crop`):\n                Whether to center crop the video.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the center crop. Only has an effect if `do_center_crop` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the video.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the video by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the video.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Frame mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Frame standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                `True`.\n            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n                Whether to convert the video to RGB.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                - Unset: Return a list of `np.ndarray`.\n                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_onevision.image_processing_llava_onevision.make_batched_images", "project": "transformers", "func": "make_batched_images", "origin_file": "transformers/models/llava_onevision/image_processing_llava_onevision.py", "test_list": ["../tests/models/llava_onevision/test_image_processing_llava_onevision.py"], "prob_info": {"func_start_lineno": 55, "func_end_lineno": 75, "key_block_start_lineno": 66, "key_block_end_lineno": 75, "new_func_code": "def make_batched_images(images) -> List[List[ImageInput]]:\n    \"\"\"\n    Accepts images in list or nested list format, and makes a list of images for preprocessing.\n\n    Args:\n        images (`Union[List[List[ImageInput]], List[ImageInput], ImageInput]`):\n            The input image.\n\n    Returns:\n        list: A list of images.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.mobilenet_v1.image_processing_mobilenet_v1.MobileNetV1ImageProcessor::resize", "project": "transformers", "func": "MobileNetV1ImageProcessor::resize", "origin_file": "transformers/models/mobilenet_v1/image_processing_mobilenet_v1.py", "test_list": ["../tests/models/mobilenet_v1/test_image_processing_mobilenet_v1.py"], "prob_info": {"func_start_lineno": 118, "func_end_lineno": 165, "key_block_start_lineno": 143, "key_block_end_lineno": 165, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image. The shortest edge of the image is resized to size[\"shortest_edge\"], with the longest edge\n        resized to keep the input aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.mobilenet_v2.image_processing_mobilenet_v2.MobileNetV2ImageProcessor::resize", "project": "transformers", "func": "MobileNetV2ImageProcessor::resize", "origin_file": "transformers/models/mobilenet_v2/image_processing_mobilenet_v2.py", "test_list": ["../tests/models/mobilenet_v2/test_image_processing_mobilenet_v2.py"], "prob_info": {"func_start_lineno": 122, "func_end_lineno": 169, "key_block_start_lineno": 147, "key_block_end_lineno": 169, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image. The shortest edge of the image is resized to size[\"shortest_edge\"], with the longest edge\n        resized to keep the input aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.audio_utils.chroma_filter_bank", "project": "transformers", "func": "chroma_filter_bank", "origin_file": "transformers/audio_utils.py", "test_list": ["../tests/models/musicgen_melody/test_feature_extraction_musicgen_melody.py"], "prob_info": {"func_start_lineno": 143, "func_end_lineno": 215, "key_block_start_lineno": 176, "key_block_end_lineno": 215, "new_func_code": "def chroma_filter_bank(\n    num_frequency_bins: int,\n    num_chroma: int,\n    sampling_rate: int,\n    tuning: float = 0.0,\n    power: Optional[float] = 2.0,\n    weighting_parameters: Optional[Tuple[float]] = (5.0, 2),\n    start_at_c_chroma: Optional[bool] = True,\n):\n    \"\"\"\n    Creates a chroma filter bank, i.e a linear transformation to project spectrogram bins onto chroma bins.\n\n    Adapted from *librosa*.\n\n    Args:\n        num_frequency_bins (`int`):\n            Number of frequencies used to compute the spectrogram (should be the same as in `stft`).\n        num_chroma (`int`):\n            Number of chroma bins (i.e pitch classes).\n        sampling_rate (`float`):\n            Sample rate of the audio waveform.\n        tuning (`float`):\n            Tuning deviation from A440 in fractions of a chroma bin.\n        power (`float`, *optional*, defaults to 2.0):\n            If 12.0, normalizes each column with their L2 norm. If 1.0, normalizes each column with their L1 norm.\n        weighting_parameters (`Tuple[float]`, *optional*, defaults to `(5., 2.)`):\n            If specified, apply a Gaussian weighting parameterized by the first element of the tuple being the center and\n            the second element being the Gaussian half-width.\n        start_at_c_chroma (`float`, *optional*, defaults to `True`):\n            If True, the filter bank will start at the 'C' pitch class. Otherwise, it will start at 'A'.\n    Returns:\n        `np.ndarray` of shape `(num_frequency_bins, num_chroma)`\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.audio_utils.hertz_to_octave", "project": "transformers", "func": "hertz_to_octave", "origin_file": "transformers/audio_utils.py", "test_list": ["../tests/models/musicgen_melody/test_feature_extraction_musicgen_melody.py"], "prob_info": {"func_start_lineno": 98, "func_end_lineno": 118, "key_block_start_lineno": 116, "key_block_end_lineno": 118, "new_func_code": "def hertz_to_octave(\n    freq: Union[float, np.ndarray], tuning: Optional[float] = 0.0, bins_per_octave: Optional[int] = 12\n):\n    \"\"\"\n    Convert frequency from hertz to fractional octave numbers.\n    Adapted from *librosa*.\n\n    Args:\n        freq (`float` or `np.ndarray`):\n            The frequency, or multiple frequencies, in hertz (Hz).\n        tuning (`float`, defaults to `0.`):\n            Tuning deviation from the Stuttgart pitch (A440) in (fractional) bins per octave.\n        bins_per_octave (`int`, defaults to `12`):\n            Number of bins per octave.\n\n    Returns:\n        `float` or `np.ndarray`: The frequencies on the octave scale.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.musicgen_melody.feature_extraction_musicgen_melody.MusicgenMelodyFeatureExtractor::__call__", "project": "transformers", "func": "MusicgenMelodyFeatureExtractor::__call__", "origin_file": "transformers/models/musicgen_melody/feature_extraction_musicgen_melody.py", "test_list": ["../tests/models/musicgen_melody/test_feature_extraction_musicgen_melody.py"], "prob_info": {"func_start_lineno": 181, "func_end_lineno": 314, "key_block_start_lineno": 242, "key_block_end_lineno": 314, "new_func_code": "def __call__(\n        self,\n        audio: Union[np.ndarray, List[float], List[np.ndarray], List[List[float]]],\n        truncation: bool = True,\n        pad_to_multiple_of: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        return_attention_mask: Optional[bool] = None,\n        padding: Optional[str] = True,\n        max_length: Optional[int] = None,\n        sampling_rate: Optional[int] = None,\n        **kwargs,\n    ) -> BatchFeature:\n        \"\"\"\n        Main method to featurize and prepare for the model one or several sequence(s).\n\n        Args:\n            audio (`torch.Tensor`, `np.ndarray`, `List[float]`, `List[np.ndarray]`, `List[torch.Tensor]`, `List[List[float]]`):\n                The sequence or batch of sequences to be padded. Each sequence can be a torch tensor, a numpy array, a list of float\n                values, a list of numpy arrays, a list of torch tensors, or a list of list of float values.\n                If `audio` is the output of Demucs, it has to be a torch tensor of shape `(batch_size, num_stems, channel_size, audio_length)`.\n                Otherwise, it must be mono or stereo channel audio.\n            truncation (`bool`, *optional*, default to `True`):\n                Activates truncation to cut input sequences longer than *max_length* to *max_length*.\n            pad_to_multiple_of (`int`, *optional*, defaults to None):\n                If set will pad the sequence to a multiple of the provided value.\n\n                This is especially useful to enable the use of Tensor Cores on NVIDIA hardware with compute capability\n                `>= 7.5` (Volta), or on TPUs which benefit from having sequence lengths be a multiple of 128.\n            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n                If set, will return tensors instead of list of python integers. Acceptable values are:\n\n                - `'tf'`: Return TensorFlow `tf.constant` objects.\n                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n                - `'np'`: Return Numpy `np.ndarray` objects.\n            return_attention_mask (`bool`, *optional*):\n                Whether to return the attention mask. If left to the default, will return the attention mask according\n                to the specific feature_extractor's default.\n\n                [What are attention masks?](../glossary#attention-mask)\n\n                <Tip>\n                For Musicgen Melody models, audio `attention_mask` is not necessary.\n                </Tip>\n\n            padding (`bool`, `str` or [`~utils.PaddingStrategy`], *optional*, defaults to `True`):\n                Select a strategy to pad the returned sequences (according to the model's padding side and padding\n                index) among:\n\n                - `True` or `'longest'`: Pad to the longest sequence in the batch (or no padding if only a single\n                  sequence if provided).\n                - `'max_length'`: Pad to a maximum length specified with the argument `max_length` or to the maximum\n                  acceptable input length for the model if that argument is not provided.\n                - `False` or `'do_not_pad'` (default): No padding (i.e., can output a batch with sequences of different\n                  lengths).\n            max_length (`int`, *optional*):\n                Maximum length of the returned list and optionally padding length (see above).\n            sampling_rate (`int`, *optional*):\n                The sampling rate at which the `audio` input was sampled. It is strongly recommended to pass\n                `sampling_rate` at the forward call to prevent silent errors.\n                Note that if `audio` is the output of Demucs, `sampling_rate` must be the sampling rate at which Demucs operates.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.musicgen_melody.feature_extraction_musicgen_melody.MusicgenMelodyFeatureExtractor::_extract_stem_indices", "project": "transformers", "func": "MusicgenMelodyFeatureExtractor::_extract_stem_indices", "origin_file": "transformers/models/musicgen_melody/feature_extraction_musicgen_melody.py", "test_list": ["../tests/models/musicgen_melody/test_feature_extraction_musicgen_melody.py"], "prob_info": {"func_start_lineno": 146, "func_end_lineno": 179, "key_block_start_lineno": 157, "key_block_end_lineno": 179, "new_func_code": "def _extract_stem_indices(self, audio, sampling_rate=None):\n        \"\"\"\n        Extracts stems from the output of the [Demucs](https://github.com/adefossez/demucs/tree/main) audio separation model,\n        then converts to mono-channel and resample to the feature extractor sampling rate.\n\n        Args:\n            audio (`torch.Tensor` of shape `(batch_size, num_stems, channel_size, audio_length)`):\n                The output of the Demucs model to be processed.\n            sampling_rate (`int`, *optional*):\n                Demucs sampling rate. If not specified, defaults to `44000`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.musicgen_melody.feature_extraction_musicgen_melody.MusicgenMelodyFeatureExtractor::to_dict", "project": "transformers", "func": "MusicgenMelodyFeatureExtractor::to_dict", "origin_file": "transformers/models/musicgen_melody/feature_extraction_musicgen_melody.py", "test_list": ["../tests/models/musicgen_melody/test_feature_extraction_musicgen_melody.py"], "prob_info": {"func_start_lineno": 316, "func_end_lineno": 331, "key_block_start_lineno": 321, "key_block_end_lineno": 331, "new_func_code": "def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Serializes this instance to a Python dictionary. Returns:\n            `Dict[str, Any]`: Dictionary of all the attributes that make up this configuration instance.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.owlvit.image_processing_owlvit.OwlViTImageProcessor::resize", "project": "transformers", "func": "OwlViTImageProcessor::resize", "origin_file": "transformers/models/owlvit/image_processing_owlvit.py", "test_list": ["../tests/models/owlvit/test_image_processing_owlvit.py"], "prob_info": {"func_start_lineno": 170, "func_end_lineno": 206, "key_block_start_lineno": 195, "key_block_end_lineno": 206, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image to a certain size.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                The size to resize the image to. Must contain height and width keys.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                The resampling filter to use when resizing the input.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format for the output image. If unset, the channel dimension format of the input\n                image is used.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.logging.get_logger", "project": "transformers", "func": "get_logger", "origin_file": "transformers/utils/logging.py", "test_list": ["../tests/models/phobert/test_tokenization_phobert.py"], "prob_info": {"func_start_lineno": 147, "func_end_lineno": 158, "key_block_start_lineno": 153, "key_block_end_lineno": 158, "new_func_code": "def get_logger(name: Optional[str] = None) -> logging.Logger:\n    \"\"\"\n    Return a logger with the specified name.\n\n    This function is not supposed to be directly accessed unless you are writing a custom transformers module.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.phobert.tokenization_phobert.PhobertTokenizer::build_inputs_with_special_tokens", "project": "transformers", "func": "PhobertTokenizer::build_inputs_with_special_tokens", "origin_file": "transformers/models/phobert/tokenization_phobert.py", "test_list": ["../tests/models/phobert/test_tokenization_phobert.py"], "prob_info": {"func_start_lineno": 146, "func_end_lineno": 170, "key_block_start_lineno": 165, "key_block_end_lineno": 170, "new_func_code": "def build_inputs_with_special_tokens(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n    ) -> List[int]:\n        \"\"\"\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and\n        adding special tokens. A PhoBERT sequence has the following format:\n\n        - single sequence: `<s> X </s>`\n        - pair of sequences: `<s> A </s></s> B </s>`\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs to which the special tokens will be added.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n\n        Returns:\n            `List[int]`: List of [input IDs](../glossary#input-ids) with the appropriate special tokens.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.phobert.tokenization_phobert.PhobertTokenizer::create_token_type_ids_from_sequences", "project": "transformers", "func": "PhobertTokenizer::create_token_type_ids_from_sequences", "origin_file": "transformers/models/phobert/tokenization_phobert.py", "test_list": ["../tests/models/phobert/test_tokenization_phobert.py"], "prob_info": {"func_start_lineno": 200, "func_end_lineno": 222, "key_block_start_lineno": 216, "key_block_end_lineno": 222, "new_func_code": "def create_token_type_ids_from_sequences(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n    ) -> List[int]:\n        \"\"\"\n        Create a mask from the two sequences passed to be used in a sequence-pair classification task. PhoBERT does not\n        make use of token type ids, therefore a list of zeros is returned.\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n\n        Returns:\n            `List[int]`: List of zeros.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.phobert.tokenization_phobert.PhobertTokenizer::get_special_tokens_mask", "project": "transformers", "func": "PhobertTokenizer::get_special_tokens_mask", "origin_file": "transformers/models/phobert/tokenization_phobert.py", "test_list": ["../tests/models/phobert/test_tokenization_phobert.py"], "prob_info": {"func_start_lineno": 172, "func_end_lineno": 198, "key_block_start_lineno": 190, "key_block_end_lineno": 198, "new_func_code": "def get_special_tokens_mask(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None, already_has_special_tokens: bool = False\n    ) -> List[int]:\n        \"\"\"\n        Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer `prepare_for_model` method.\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n            already_has_special_tokens (`bool`, *optional*, defaults to `False`):\n                Whether or not the token list is already formatted with special tokens for the model.\n\n        Returns:\n            `List[int]`: A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.poolformer.image_processing_poolformer.PoolFormerImageProcessor::resize", "project": "transformers", "func": "PoolFormerImageProcessor::resize", "origin_file": "transformers/models/poolformer/image_processing_poolformer.py", "test_list": ["../tests/models/poolformer/test_image_processing_poolformer.py"], "prob_info": {"func_start_lineno": 136, "func_end_lineno": 210, "key_block_start_lineno": 176, "key_block_end_lineno": 210, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        crop_pct: Optional[float] = None,\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image.\n\n        If crop_pct is unset:\n            - size is `{\"height\": h, \"width\": w}`: the image is resized to `(h, w)`.\n            - size is `{\"shortest_edge\": s}`: the shortest edge of the image is resized to s whilst maintaining the\n              aspect ratio.\n\n        if crop_pct is set:\n            - size is `{\"height\": h, \"width\": w}`: the image is resized to `(int(floor(h/crop_pct)),\n              int(floor(w/crop_pct)))`\n            - size is `{\"height\": c, \"width\": c}`: the shortest edge of the image is resized to `int(floor(c/crop_pct)`\n              whilst maintaining the aspect ratio.\n            - size is `{\"shortest_edge\": c}`: the shortest edge of the image is resized to `int(floor(c/crop_pct)`\n              whilst maintaining the aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image.\n            crop_pct (`float`, *optional*):\n                Percentage of the image that will be cropped from the center. If set, the image is resized\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.pvt.image_processing_pvt.PvtImageProcessor::resize", "project": "transformers", "func": "PvtImageProcessor::resize", "origin_file": "transformers/models/pvt/image_processing_pvt.py", "test_list": ["../tests/models/pvt/test_image_processing_pvt.py"], "prob_info": {"func_start_lineno": 100, "func_end_lineno": 146, "key_block_start_lineno": 135, "key_block_end_lineno": 146, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BILINEAR,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image to `(size[\"height\"], size[\"width\"])`.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Dictionary in the format `{\"height\": int, \"width\": int}` specifying the size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BILINEAR`):\n                `PILImageResampling` filter to use when resizing the image e.g. `PILImageResampling.BILINEAR`.\n            data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the output image. If unset, the channel dimension format of the input\n                image is used. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n\n        Returns:\n            `np.ndarray`: The resized image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.qwen2_vl.image_processing_qwen2_vl.Qwen2VLImageProcessor::preprocess", "project": "transformers", "func": "Qwen2VLImageProcessor::preprocess", "origin_file": "transformers/models/qwen2_vl/image_processing_qwen2_vl.py", "test_list": ["../tests/models/qwen2_vl/test_image_processing_qwen2_vl.py"], "prob_info": {"func_start_lineno": 317, "func_end_lineno": 458, "key_block_start_lineno": 383, "key_block_end_lineno": 458, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        videos: VideoInput = None,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_convert_rgb: bool = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ):\n        \"\"\"\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            videos (`VideoInput`):\n                Video to preprocess. Expects a single or batch of videos with pixel values ranging from 0 to 255. If\n                passing in videos with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n                the longest edge resized to keep the input aspect ratio.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n                has an effect if `do_resize` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                `True`.\n            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n                Whether to convert the image to RGB.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                - Unset: Return a list of `np.ndarray`.\n                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.qwen2_vl.image_processing_qwen2_vl.make_batched_images", "project": "transformers", "func": "make_batched_images", "origin_file": "transformers/models/qwen2_vl/image_processing_qwen2_vl.py", "test_list": ["../tests/models/qwen2_vl/test_image_processing_qwen2_vl.py"], "prob_info": {"func_start_lineno": 59, "func_end_lineno": 79, "key_block_start_lineno": 70, "key_block_end_lineno": 79, "new_func_code": "def make_batched_images(images) -> List[List[ImageInput]]:\n    \"\"\"\n    Accepts images in list or nested list format, and makes a list of images for preprocessing.\n\n    Args:\n        images (`Union[List[List[ImageInput]], List[ImageInput], ImageInput]`):\n            The input image.\n\n    Returns:\n        list: A list of images.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.qwen2_vl.image_processing_qwen2_vl.Qwen2VLImageProcessor::_preprocess", "project": "transformers", "func": "Qwen2VLImageProcessor::_preprocess", "origin_file": "transformers/models/qwen2_vl/image_processing_qwen2_vl.py", "test_list": ["../tests/models/qwen2_vl/test_image_processing_qwen2_vl.py"], "prob_info": {"func_start_lineno": 198, "func_end_lineno": 315, "key_block_start_lineno": 247, "key_block_end_lineno": 315, "new_func_code": "def _preprocess(\n        self,\n        images: Union[ImageInput, VideoInput],\n        do_resize: bool = None,\n        resample: PILImageResampling = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_convert_rgb: bool = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ):\n        \"\"\"\n        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n\n        Args:\n            images (`ImageInput`):\n                Image or batch of images to preprocess. Expects pixel values ranging from 0 to 255. If pixel values range from 0 to 1, set `do_rescale=False`.\n            vision_info (`List[Dict]`, *optional*):\n                Optional list of dictionaries containing additional information about vision inputs.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the `PILImageResampling` enums.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Scale factor to use if rescaling the image.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Mean to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Standard deviation to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n                Whether to convert the image to RGB.\n            data_format (`ChannelDimension`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.   - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.roc_bert.tokenization_roc_bert.RoCBertTokenizer::prepare_for_model", "project": "transformers", "func": "RoCBertTokenizer::prepare_for_model", "origin_file": "transformers/models/roc_bert/tokenization_roc_bert.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 297, "func_end_lineno": 475, "key_block_start_lineno": 349, "key_block_end_lineno": 475, "new_func_code": "def prepare_for_model(\n        self,\n        ids: List[int],\n        shape_ids: List[int],\n        pronunciation_ids: List[int],\n        pair_ids: Optional[List[int]] = None,\n        pair_shape_ids: Optional[List[int]] = None,\n        pair_pronunciation_ids: Optional[List[int]] = None,\n        add_special_tokens: bool = True,\n        padding: Union[bool, str, PaddingStrategy] = False,\n        truncation: Union[bool, str, TruncationStrategy] = None,\n        max_length: Optional[int] = None,\n        stride: int = 0,\n        pad_to_multiple_of: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        return_token_type_ids: Optional[bool] = None,\n        return_attention_mask: Optional[bool] = None,\n        return_overflowing_tokens: bool = False,\n        return_special_tokens_mask: bool = False,\n        return_offsets_mapping: bool = False,\n        return_length: bool = False,\n        verbose: bool = True,\n        prepend_batch_axis: bool = False,\n        **kwargs,\n    ) -> BatchEncoding:\n        \"\"\"\n        Prepares a sequence of input id, or a pair of sequences of inputs ids so that it can be used by the model. It\n        adds special tokens, truncates sequences if overflowing while taking into account the special tokens and\n        manages a moving window (with user defined stride) for overflowing tokens. Please Note, for *pair_ids*\n        different than `None` and *truncation_strategy = longest_first* or `True`, it is not possible to return\n        overflowing tokens. Such a combination of arguments will raise an error.\n\n        Args:\n            ids (`List[int]`):\n                Tokenized input ids of the first sequence. Can be obtained from a string by chaining the `tokenize` and\n                `convert_tokens_to_id` methods.\n            shape_ids (`List[int]`):\n                Tokenized input ids of the first sequence. Can be obtained from a string by chaining the `tokenize` and\n                `convert_token_to_shape_id` methods.\n            pronunciation_ids (`List[int]`):\n                Tokenized input ids of the first sequence. Can be obtained from a string by chaining the `tokenize` and\n                `convert_token_to_pronunciation_id` methods.\n            pair_ids (`List[int]`, *optional*):\n                Tokenized input ids of the second sequence. Can be obtained from a string by chaining the `tokenize`\n                and `convert_tokens_to_id` methods.\n            pair_shape_ids (`List[int]`, *optional*):\n                Tokenized input ids of the second sequence. Can be obtained from a string by chaining the `tokenize`\n                and `convert_token_to_shape_id` methods.\n            pair_pronunciation_ids (`List[int]`, *optional*):\n                Tokenized input ids of the second sequence. Can be obtained from a string by chaining the `tokenize`\n                and `convert_token_to_pronunciation_id` methods.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.roc_bert.tokenization_roc_bert.RoCBertTokenizer::build_inputs_with_special_tokens", "project": "transformers", "func": "RoCBertTokenizer::build_inputs_with_special_tokens", "origin_file": "transformers/models/roc_bert/tokenization_roc_bert.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 758, "func_end_lineno": 785, "key_block_start_lineno": 781, "key_block_end_lineno": 785, "new_func_code": "def build_inputs_with_special_tokens(\n        self,\n        token_ids_0: List[int],\n        token_ids_1: Optional[List[int]] = None,\n        cls_token_id: int = None,\n        sep_token_id: int = None,\n    ) -> List[int]:\n        \"\"\"\n        Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and\n        adding special tokens. A BERT sequence has the following format:\n\n        - single sequence: `[CLS] X [SEP]`\n        - pair of sequences: `[CLS] A [SEP] B [SEP]`\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs to which the special tokens will be added.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n\n        Returns:\n            `List[int]`: List of [input IDs](../glossary#input-ids) with the appropriate special tokens.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.roc_bert.tokenization_roc_bert.RoCBertTokenizer::create_token_type_ids_from_sequences", "project": "transformers", "func": "RoCBertTokenizer::create_token_type_ids_from_sequences", "origin_file": "transformers/models/roc_bert/tokenization_roc_bert.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 817, "func_end_lineno": 844, "key_block_start_lineno": 840, "key_block_end_lineno": 844, "new_func_code": "def create_token_type_ids_from_sequences(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n    ) -> List[int]:\n        \"\"\"\n        Create a mask from the two sequences passed to be used in a sequence-pair classification task. A BERT sequence\n        pair mask has the following format:\n\n        ```\n        0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1\n        | first sequence    | second sequence |\n        ```\n\n        If `token_ids_1` is `None`, this method only returns the first portion of the mask (0s).\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n\n        Returns:\n            `List[int]`: List of [token type IDs](../glossary#token-type-ids) according to the given sequence(s).\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.backbone_utils.get_aligned_output_features_output_indices", "project": "transformers", "func": "get_aligned_output_features_output_indices", "origin_file": "transformers/utils/backbone_utils.py", "test_list": ["../tests/models/rt_detr/test_modeling_rt_detr_resnet.py"], "prob_info": {"func_start_lineno": 108, "func_end_lineno": 137, "key_block_start_lineno": 129, "key_block_end_lineno": 137, "new_func_code": "def get_aligned_output_features_output_indices(\n    out_features: Optional[List[str]],\n    out_indices: Optional[Union[List[int], Tuple[int]]],\n    stage_names: List[str],\n) -> Tuple[List[str], List[int]]:\n    \"\"\"\n    Get the `out_features` and `out_indices` so that they are aligned.\n\n    The logic is as follows:\n        - `out_features` not set, `out_indices` set: `out_features` is set to the `out_features` corresponding to the\n        `out_indices`.\n        - `out_indices` not set, `out_features` set: `out_indices` is set to the `out_indices` corresponding to the\n        `out_features`.\n        - `out_indices` and `out_features` not set: `out_indices` and `out_features` are set to the last stage.\n        - `out_indices` and `out_features` set: they are verified to be aligned.\n\n    Args:\n        out_features (`List[str]`): The names of the features for the backbone to output.\n        out_indices (`List[int]` or `Tuple[int]`): The indices of the features for the backbone to output.\n        stage_names (`List[str]`): The names of the stages of the backbone.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.backbone_utils._align_output_features_output_indices", "project": "transformers", "func": "_align_output_features_output_indices", "origin_file": "transformers/utils/backbone_utils.py", "test_list": ["../tests/models/rt_detr/test_modeling_rt_detr_resnet.py"], "prob_info": {"func_start_lineno": 77, "func_end_lineno": 105, "key_block_start_lineno": 98, "key_block_end_lineno": 105, "new_func_code": "def _align_output_features_output_indices(\n    out_features: Optional[List[str]],\n    out_indices: Optional[Union[List[int], Tuple[int]]],\n    stage_names: List[str],\n):\n    \"\"\"\n    Finds the corresponding `out_features` and `out_indices` for the given `stage_names`.\n\n    The logic is as follows:\n        - `out_features` not set, `out_indices` set: `out_features` is set to the `out_features` corresponding to the\n        `out_indices`.\n        - `out_indices` not set, `out_features` set: `out_indices` is set to the `out_indices` corresponding to the\n        `out_features`.\n        - `out_indices` and `out_features` not set: `out_indices` and `out_features` are set to the last stage.\n        - `out_indices` and `out_features` set: input `out_indices` and `out_features` are returned.\n\n    Args:\n        out_features (`List[str]`): The names of the features for the backbone to output.\n        out_indices (`List[int]` or `Tuple[int]`): The indices of the features for the backbone to output.\n        stage_names (`List[str]`): The names of the stages of the backbone.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.rt_detr.modeling_rt_detr_resnet.RTDetrResNetBackbone::forward", "project": "transformers", "func": "RTDetrResNetBackbone::forward", "origin_file": "transformers/models/rt_detr/modeling_rt_detr_resnet.py", "test_list": ["../tests/models/rt_detr/test_modeling_rt_detr_resnet.py"], "prob_info": {"func_start_lineno": 384, "func_end_lineno": 434, "key_block_start_lineno": 408, "key_block_end_lineno": 434, "new_func_code": "def forward(\n        self, pixel_values: Tensor, output_hidden_states: Optional[bool] = None, return_dict: Optional[bool] = None\n    ) -> BackboneOutput:\n        \"\"\"\n        Returns:\n\n        Examples:\n\n        ```python\n        >>> from transformers import RTDetrResNetConfig, RTDetrResNetBackbone\n        >>> import torch\n\n        >>> config = RTDetrResNetConfig()\n        >>> model = RTDetrResNetBackbone(config)\n\n        >>> pixel_values = torch.randn(1, 3, 224, 224)\n\n        >>> with torch.no_grad():\n        ...     outputs = model(pixel_values)\n\n        >>> feature_maps = outputs.feature_maps\n        >>> list(feature_maps[-1].shape)\n        [1, 2048, 7, 7]\n        ```\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.siglip.image_processing_siglip.SiglipImageProcessor::preprocess", "project": "transformers", "func": "SiglipImageProcessor::preprocess", "origin_file": "transformers/models/siglip/image_processing_siglip.py", "test_list": ["../tests/models/siglip/test_image_processing_siglip.py"], "prob_info": {"func_start_lineno": 111, "func_end_lineno": 241, "key_block_start_lineno": 173, "key_block_end_lineno": 241, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        do_convert_rgb: bool = None,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after resizing.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n                has an effect if `do_resize` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                `True`.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                - Unset: Return a list of `np.ndarray`.\n                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n                Whether to convert the image to RGB.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.superpoint.image_processing_superpoint.SuperPointImageProcessor::preprocess", "project": "transformers", "func": "SuperPointImageProcessor::preprocess", "origin_file": "transformers/models/superpoint/image_processing_superpoint.py", "test_list": ["../tests/models/superpoint/test_image_processing_superpoint.py"], "prob_info": {"func_start_lineno": 164, "func_end_lineno": 272, "key_block_start_lineno": 213, "key_block_end_lineno": 272, "new_func_code": "def preprocess(\n        self,\n        images,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: ChannelDimension = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> BatchFeature:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the output image after `resize` has been applied. If `size[\"shortest_edge\"]` >= 384, the image\n                is resized to `(size[\"shortest_edge\"], size[\"shortest_edge\"])`. Otherwise, the smaller edge of the\n                image will be matched to `int(size[\"shortest_edge\"]/ crop_pct)`, after which the image is cropped to\n                `(size[\"shortest_edge\"], size[\"shortest_edge\"])`. Only has an effect if `do_resize` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between [0 - 1].\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                    - Unset: Return a list of `np.ndarray`.\n                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_utils.make_list_of_images", "project": "transformers", "func": "make_list_of_images", "origin_file": "transformers/image_utils.py", "test_list": ["../tests/models/superpoint/test_image_processing_superpoint.py"], "prob_info": {"func_start_lineno": 172, "func_end_lineno": 208, "key_block_start_lineno": 184, "key_block_end_lineno": 208, "new_func_code": "def make_list_of_images(images, expected_ndims: int = 3) -> List[ImageInput]:\n    \"\"\"\n    Ensure that the input is a list of images. If the input is a single image, it is converted to a list of length 1.\n    If the input is a batch of images, it is converted to a list of images.\n\n    Args:\n        images (`ImageInput`):\n            Image of images to turn into a list of images.\n        expected_ndims (`int`, *optional*, defaults to 3):\n            Expected number of dimensions for a single input image. If the input image has a different number of\n            dimensions, an error is raised.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.swin2sr.image_processing_swin2sr.Swin2SRImageProcessor::pad", "project": "transformers", "func": "Swin2SRImageProcessor::pad", "origin_file": "transformers/models/swin2sr/image_processing_swin2sr.py", "test_list": ["../tests/models/swin2sr/test_image_processing_swin2sr.py"], "prob_info": {"func_start_lineno": 69, "func_end_lineno": 108, "key_block_start_lineno": 98, "key_block_end_lineno": 108, "new_func_code": "def pad(\n        self,\n        image: np.ndarray,\n        size: int,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ):\n        \"\"\"\n        Pad an image to make the height and width divisible by `size`.\n\n        Args:\n            image (`np.ndarray`):\n                Image to pad.\n            size (`int`):\n                The size to make the height and width divisible by.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format for the output image. If unset, the channel dimension format of the input\n                image is used. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n\n        Returns:\n            `np.ndarray`: The padded image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.pad", "project": "transformers", "func": "pad", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/models/swin2sr/test_image_processing_swin2sr.py"], "prob_info": {"func_start_lineno": 667, "func_end_lineno": 750, "key_block_start_lineno": 710, "key_block_end_lineno": 750, "new_func_code": "def pad(\n    image: np.ndarray,\n    padding: Union[int, Tuple[int, int], Iterable[Tuple[int, int]]],\n    mode: PaddingMode = PaddingMode.CONSTANT,\n    constant_values: Union[float, Iterable[float]] = 0.0,\n    data_format: Optional[Union[str, ChannelDimension]] = None,\n    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Pads the `image` with the specified (height, width) `padding` and `mode`.\n\n    Args:\n        image (`np.ndarray`):\n            The image to pad.\n        padding (`int` or `Tuple[int, int]` or `Iterable[Tuple[int, int]]`):\n            Padding to apply to the edges of the height, width axes. Can be one of three formats:\n            - `((before_height, after_height), (before_width, after_width))` unique pad widths for each axis.\n            - `((before, after),)` yields same before and after pad for height and width.\n            - `(pad,)` or int is a shortcut for before = after = pad width for all axes.\n        mode (`PaddingMode`):\n            The padding mode to use. Can be one of:\n                - `\"constant\"`: pads with a constant value.\n                - `\"reflect\"`: pads with the reflection of the vector mirrored on the first and last values of the\n                  vector along each axis.\n                - `\"replicate\"`: pads with the replication of the last value on the edge of the array along each axis.\n                - `\"symmetric\"`: pads with the reflection of the vector mirrored along the edge of the array.\n        constant_values (`float` or `Iterable[float]`, *optional*):\n            The value to use for the padding if `mode` is `\"constant\"`.\n        data_format (`str` or `ChannelDimension`, *optional*):\n            The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            If unset, will use same as the input image.\n        input_data_format (`str` or `ChannelDimension`, *optional*):\n            The channel dimension format for the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            If unset, will use the inferred format of the input image.\n\n    Returns:\n        `np.ndarray`: The padded image.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::encode_plus", "project": "transformers", "func": "TapasTokenizer::encode_plus", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 898, "func_end_lineno": 979, "key_block_start_lineno": 941, "key_block_end_lineno": 979, "new_func_code": "def encode_plus(\n        self,\n        table: \"pd.DataFrame\",\n        query: Optional[\n            Union[\n                TextInput,\n                PreTokenizedInput,\n                EncodedInput,\n            ]\n        ] = None,\n        answer_coordinates: Optional[List[Tuple]] = None,\n        answer_text: Optional[List[TextInput]] = None,\n        add_special_tokens: bool = True,\n        padding: Union[bool, str, PaddingStrategy] = False,\n        truncation: Union[bool, str, TapasTruncationStrategy] = False,\n        max_length: Optional[int] = None,\n        pad_to_multiple_of: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        return_token_type_ids: Optional[bool] = None,\n        return_attention_mask: Optional[bool] = None,\n        return_special_tokens_mask: bool = False,\n        return_offsets_mapping: bool = False,\n        return_length: bool = False,\n        verbose: bool = True,\n        **kwargs,\n    ) -> BatchEncoding:\n        \"\"\"\n        Prepare a table and a string for the model.\n\n        Args:\n            table (`pd.DataFrame`):\n                Table containing tabular data. Note that all cell values must be text. Use *.astype(str)* on a Pandas\n                dataframe to convert it to string.\n            query (`str` or `List[str]`):\n                Question related to a table to be encoded.\n            answer_coordinates (`List[Tuple]` or `List[List[Tuple]]`, *optional*):\n                Answer coordinates of each table-question pair in the batch. The answer_coordinates must be a single\n                list of one or more tuples. Each tuple must be a (row_index, column_index) pair. The first data row\n                (not the column header row) has index 0. The first column has index 0.\n            answer_text (`List[str]` or `List[List[str]]`, *optional*):\n                Answer text of each table-question pair in the batch. The answer_text must be a single list of one or\n                more strings. Each string must be the answer text of a corresponding answer coordinate.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.WordpieceTokenizer::tokenize", "project": "transformers", "func": "WordpieceTokenizer::tokenize", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 2134, "func_end_lineno": 2180, "key_block_start_lineno": 2148, "key_block_end_lineno": 2180, "new_func_code": "def tokenize(self, text):\n        \"\"\"\n        Tokenizes a piece of text into its word pieces. This uses a greedy longest-match-first algorithm to perform\n        tokenization using the given vocabulary.\n\n        For example, `input = \"unaffable\"` wil return as output `[\"un\", \"##aff\", \"##able\"]`.\n\n        Args:\n            text: A single token or whitespace separated tokens. This should have\n                already been passed through *BasicTokenizer*.\n\n        Returns:\n            A list of wordpiece tokens.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::prepare_for_model", "project": "transformers", "func": "TapasTokenizer::prepare_for_model", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1037, "func_end_lineno": 1227, "key_block_start_lineno": 1085, "key_block_end_lineno": 1227, "new_func_code": "def prepare_for_model(\n        self,\n        raw_table: \"pd.DataFrame\",\n        raw_query: Union[\n            TextInput,\n            PreTokenizedInput,\n            EncodedInput,\n        ],\n        tokenized_table: Optional[TokenizedTable] = None,\n        query_tokens: Optional[TokenizedTable] = None,\n        answer_coordinates: Optional[List[Tuple]] = None,\n        answer_text: Optional[List[TextInput]] = None,\n        add_special_tokens: bool = True,\n        padding: Union[bool, str, PaddingStrategy] = False,\n        truncation: Union[bool, str, TapasTruncationStrategy] = False,\n        max_length: Optional[int] = None,\n        pad_to_multiple_of: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        return_token_type_ids: Optional[bool] = True,\n        return_attention_mask: Optional[bool] = True,\n        return_special_tokens_mask: bool = False,\n        return_offsets_mapping: bool = False,\n        return_length: bool = False,\n        verbose: bool = True,\n        prepend_batch_axis: bool = False,\n        **kwargs,\n    ) -> BatchEncoding:\n        \"\"\"\n        Prepares a sequence of input id so that it can be used by the model. It adds special tokens, truncates\n        sequences if overflowing while taking into account the special tokens.\n\n        Args:\n            raw_table (`pd.DataFrame`):\n                The original table before any transformation (like tokenization) was applied to it.\n            raw_query (`TextInput` or `PreTokenizedInput` or `EncodedInput`):\n                The original query before any transformation (like tokenization) was applied to it.\n            tokenized_table (`TokenizedTable`):\n                The table after tokenization.\n            query_tokens (`List[str]`):\n                The query after tokenization.\n            answer_coordinates (`List[Tuple]` or `List[List[Tuple]]`, *optional*):\n                Answer coordinates of each table-question pair in the batch. The answer_coordinates must be a single\n                list of one or more tuples. Each tuple must be a (row_index, column_index) pair. The first data row\n                (not the column header row) has index 0. The first column has index 0.\n            answer_text (`List[str]` or `List[List[str]]`, *optional*):\n                Answer text of each table-question pair in the batch. The answer_text must be a single list of one or\n                more strings. Each string must be the answer text of a corresponding answer coordinate.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::create_segment_token_type_ids_from_sequences", "project": "transformers", "func": "TapasTokenizer::create_segment_token_type_ids_from_sequences", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 401, "func_end_lineno": 416, "key_block_start_lineno": 415, "key_block_end_lineno": 416, "new_func_code": "def create_segment_token_type_ids_from_sequences(\n        self, query_ids: List[int], table_values: List[TableValue]\n    ) -> List[int]:\n        \"\"\"\n        Creates the segment token type IDs according to the query token IDs and a list of table values.\n\n        Args:\n            query_ids (`List[int]`): list of token IDs corresponding to the ID.\n            table_values (`List[TableValue]`): lift of table values, which are named tuples containing the\n                token value, the column ID and the row ID of said token.\n\n        Returns:\n            `List[int]`: List of ints containing the segment token type IDs values.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::create_column_token_type_ids_from_sequences", "project": "transformers", "func": "TapasTokenizer::create_column_token_type_ids_from_sequences", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 418, "func_end_lineno": 433, "key_block_start_lineno": 432, "key_block_end_lineno": 433, "new_func_code": "def create_column_token_type_ids_from_sequences(\n        self, query_ids: List[int], table_values: List[TableValue]\n    ) -> List[int]:\n        \"\"\"\n        Creates the column token type IDs according to the query token IDs and a list of table values.\n\n        Args:\n            query_ids (`List[int]`): list of token IDs corresponding to the ID.\n            table_values (`List[TableValue]`): lift of table values, which are named tuples containing the\n                token value, the column ID and the row ID of said token.\n\n        Returns:\n            `List[int]`: List of ints containing the column token type IDs values.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::create_row_token_type_ids_from_sequences", "project": "transformers", "func": "TapasTokenizer::create_row_token_type_ids_from_sequences", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 435, "func_end_lineno": 450, "key_block_start_lineno": 449, "key_block_end_lineno": 450, "new_func_code": "def create_row_token_type_ids_from_sequences(\n        self, query_ids: List[int], table_values: List[TableValue]\n    ) -> List[int]:\n        \"\"\"\n        Creates the row token type IDs according to the query token IDs and a list of table values.\n\n        Args:\n            query_ids (`List[int]`): list of token IDs corresponding to the ID.\n            table_values (`List[TableValue]`): lift of table values, which are named tuples containing the\n                token value, the column ID and the row ID of said token.\n\n        Returns:\n            `List[int]`: List of ints containing the row token type IDs values.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.add_numeric_table_values", "project": "transformers", "func": "add_numeric_table_values", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 2730, "func_end_lineno": 2763, "key_block_start_lineno": 2743, "key_block_end_lineno": 2763, "new_func_code": "def add_numeric_table_values(table, min_consolidation_fraction=0.7, debug_info=None):\n    \"\"\"\n    Parses text in table column-wise and adds the consolidated values. Consolidation refers to finding values with a\n    common types (date or number)\n\n    Args:\n        table:\n            Table to annotate.\n        min_consolidation_fraction:\n            Fraction of cells in a column that need to have consolidated value.\n        debug_info:\n            Additional information used for logging.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.filter_invalid_unicode_from_table", "project": "transformers", "func": "filter_invalid_unicode_from_table", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 2704, "func_end_lineno": 2727, "key_block_start_lineno": 2712, "key_block_end_lineno": 2727, "new_func_code": "def filter_invalid_unicode_from_table(table):\n    \"\"\"\n    Removes invalid unicode from table. Checks whether a table cell text contains an invalid unicode encoding. If yes,\n    reset the table cell text to an empty str and log a warning for each invalid cell\n\n    Args:\n        table: table to clean.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.parse_text", "project": "transformers", "func": "parse_text", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 2458, "func_end_lineno": 2512, "key_block_start_lineno": 2468, "key_block_end_lineno": 2512, "new_func_code": "def parse_text(text):\n    \"\"\"\n    Extracts longest number and date spans.\n\n    Args:\n      text: text to annotate\n\n    Returns:\n      List of longest numeric value spans.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.get_all_spans", "project": "transformers", "func": "get_all_spans", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 2419, "func_end_lineno": 2437, "key_block_start_lineno": 2429, "key_block_end_lineno": 2437, "new_func_code": "def get_all_spans(text, max_ngram_length):\n    \"\"\"\n    Split a text into all possible ngrams up to 'max_ngram_length'. Split points are white space and punctuation.\n\n    Args:\n      text: Text to split.\n      max_ngram_length: maximal ngram length.\n    Yields:\n      Spans, tuples of begin-end index.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::_get_numeric_column_ranks", "project": "transformers", "func": "TapasTokenizer::_get_numeric_column_ranks", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1482, "func_end_lineno": 1515, "key_block_start_lineno": 1484, "key_block_end_lineno": 1515, "new_func_code": "def _get_numeric_column_ranks(self, column_ids, row_ids, table):\n        \"\"\"Returns column ranks for all numeric columns.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::create_attention_mask_from_sequences", "project": "transformers", "func": "TapasTokenizer::create_attention_mask_from_sequences", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 387, "func_end_lineno": 399, "key_block_start_lineno": 399, "key_block_end_lineno": 399, "new_func_code": "def create_attention_mask_from_sequences(self, query_ids: List[int], table_values: List[TableValue]) -> List[int]:\n        \"\"\"\n        Creates the attention mask according to the query token IDs and a list of table values.\n\n        Args:\n            query_ids (`List[int]`): list of token IDs corresponding to the ID.\n            table_values (`List[TableValue]`): lift of table values, which are named tuples containing the\n                token value, the column ID and the row ID of said token.\n\n        Returns:\n            `List[int]`: List of ints containing the attention mask values.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::_pad", "project": "transformers", "func": "TapasTokenizer::_pad", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1751, "func_end_lineno": 1841, "key_block_start_lineno": 1782, "key_block_end_lineno": 1841, "new_func_code": "def _pad(\n        self,\n        encoded_inputs: Union[Dict[str, EncodedInput], BatchEncoding],\n        max_length: Optional[int] = None,\n        padding_strategy: PaddingStrategy = PaddingStrategy.DO_NOT_PAD,\n        pad_to_multiple_of: Optional[int] = None,\n        return_attention_mask: Optional[bool] = None,\n    ) -> dict:\n        \"\"\"\n        Pad encoded inputs (on left/right and up to predefined length or max length in the batch)\n\n        Args:\n            encoded_inputs:\n                Dictionary of tokenized inputs (`List[int]`) or batch of tokenized inputs (`List[List[int]]`).\n            max_length: maximum length of the returned list and optionally padding length (see below).\n                Will truncate by taking into account the special tokens.\n            padding_strategy: PaddingStrategy to use for padding.\n\n                - PaddingStrategy.LONGEST Pad to the longest sequence in the batch\n                - PaddingStrategy.MAX_LENGTH: Pad to the max length (default)\n                - PaddingStrategy.DO_NOT_PAD: Do not pad\n                The tokenizer padding sides are defined in self.padding_side:\n\n                    - 'left': pads on the left of the sequences\n                    - 'right': pads on the right of the sequences\n            pad_to_multiple_of: (optional) Integer if set will pad the sequence to a multiple of the provided value.\n                This is especially useful to enable the use of Tensor Core on NVIDIA hardware with compute capability\n                `>= 7.5` (Volta).\n            return_attention_mask:\n                (optional) Set to False to avoid returning attention mask (default: set to model specifics)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::_tokenize_table", "project": "transformers", "func": "TapasTokenizer::_tokenize_table", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1286, "func_end_lineno": 1329, "key_block_start_lineno": 1297, "key_block_end_lineno": 1329, "new_func_code": "def _tokenize_table(\n        self,\n        table=None,\n    ):\n        \"\"\"\n        Tokenizes column headers and cell texts of a table.\n\n        Args:\n            table (`pd.Dataframe`):\n                Table. Returns: `TokenizedTable`: TokenizedTable object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tvp.image_processing_tvp.TvpImageProcessor::resize", "project": "transformers", "func": "TvpImageProcessor::resize", "origin_file": "transformers/models/tvp/image_processing_tvp.py", "test_list": ["../tests/models/tvp/test_image_processing_tvp.py"], "prob_info": {"func_start_lineno": 176, "func_end_lineno": 217, "key_block_start_lineno": 202, "key_block_end_lineno": 217, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BILINEAR,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image. If `size` is of the form `{\"height\": h, \"width\": w}`, the output image will\n                have the size `(h, w)`. If `size` is of the form `{\"longest_edge\": s}`, the output image will have its\n                longest edge of length `s` while keeping the aspect ratio of the original image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BILINEAR`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.univnet.feature_extraction_univnet.UnivNetFeatureExtractor::batch_decode", "project": "transformers", "func": "UnivNetFeatureExtractor::batch_decode", "origin_file": "transformers/models/univnet/feature_extraction_univnet.py", "test_list": ["../tests/models/univnet/test_feature_extraction_univnet.py"], "prob_info": {"func_start_lineno": 263, "func_end_lineno": 284, "key_block_start_lineno": 278, "key_block_end_lineno": 284, "new_func_code": "def batch_decode(self, waveforms, waveform_lengths=None) -> List[np.ndarray]:\n        r\"\"\"\n        Removes padding from generated audio after running [`UnivNetModel.forward`]. This returns a ragged list of 1D\n        audio waveform arrays and not a single tensor/array because in general the waveforms will have different\n        lengths after removing padding.\n\n        Args:\n            waveforms (`torch.FloatTensor` of shape `(batch_size, sequence_length)`):\n                The batched output waveforms from the [`UnivNetModel`].\n            waveform_lengths (`torch.FloatTensor` of shape `(batch_size,)`, *optional*):\n                The batched lengths of each waveform before padding.\n\n        Returns:\n            `List[np.ndarray]`: A ragged list of 1D waveform arrays with padding removed.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.univnet.feature_extraction_univnet.UnivNetFeatureExtractor::__call__", "project": "transformers", "func": "UnivNetFeatureExtractor::__call__", "origin_file": "transformers/models/univnet/feature_extraction_univnet.py", "test_list": ["../tests/models/univnet/test_feature_extraction_univnet.py"], "prob_info": {"func_start_lineno": 286, "func_end_lineno": 445, "key_block_start_lineno": 362, "key_block_end_lineno": 445, "new_func_code": "def __call__(\n        self,\n        raw_speech: Union[np.ndarray, List[float], List[np.ndarray], List[List[float]]],\n        sampling_rate: Optional[int] = None,\n        padding: Union[bool, str, PaddingStrategy] = True,\n        max_length: Optional[int] = None,\n        truncation: bool = True,\n        pad_to_multiple_of: Optional[int] = None,\n        return_noise: bool = True,\n        generator: Optional[np.random.Generator] = None,\n        pad_end: bool = False,\n        pad_length: Optional[int] = None,\n        do_normalize: Optional[str] = None,\n        return_attention_mask: Optional[bool] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n    ) -> BatchFeature:\n        \"\"\"\n        Main method to featurize and prepare for the model one or several sequence(s).\n\n        Args:\n            raw_speech (`np.ndarray`, `List[float]`, `List[np.ndarray]`, `List[List[float]]`):\n                The sequence or batch of sequences to be padded. Each sequence can be a numpy array, a list of float\n                values, a list of numpy arrays or a list of list of float values. Must be mono channel audio, not\n                stereo, i.e. single float per timestep.\n            sampling_rate (`int`, *optional*):\n                The sampling rate at which the `raw_speech` input was sampled. It is strongly recommended to pass\n                `sampling_rate` at the forward call to prevent silent errors and allow automatic speech recognition\n                pipeline.\n            padding (`bool`, `str` or [`~utils.PaddingStrategy`], *optional*, defaults to `True`):\n                Select a strategy to pad the input `raw_speech` waveforms (according to the model's padding side and\n                padding index) among:\n\n                - `True` or `'longest'`: Pad to the longest sequence in the batch (or no padding if only a single\n                  sequence if provided).\n                - `'max_length'`: Pad to a maximum length specified with the argument `max_length` or to the maximum\n                  acceptable input length for the model if that argument is not provided.\n                - `False` or `'do_not_pad'` (default): No padding (i.e., can output a batch with sequences of different\n                  lengths).\n\n                If `pad_end = True`, that padding will occur before the `padding` strategy is applied.\n            max_length (`int`, *optional*):\n                Maximum length of the returned list and optionally padding length (see above).\n            truncation (`bool`, *optional*, defaults to `True`):\n                Activates truncation to cut input sequences longer than `max_length` to `max_length`.\n            pad_to_multiple_of (`int`, *optional*):\n                If set will pad the sequence to a multiple of the provided value.\n\n                This is especially useful to enable the use of Tensor Cores on NVIDIA hardware with compute capability\n                `>= 7.5` (Volta), or on TPUs which benefit from having sequence lengths be a multiple of 128.\n            return_noise (`bool`, *optional*, defaults to `True`):\n                Whether to generate and return a noise waveform for use in [`UnivNetModel.forward`].\n            generator (`numpy.random.Generator`, *optional*, defaults to `None`):\n                An optional `numpy.random.Generator` random number generator to use when generating noise.\n            pad_end (`bool`, *optional*, defaults to `False`):\n                Whether to pad the end of each waveform with silence. This can help reduce artifacts at the end of the\n                generated audio sample; see https://github.com/seungwonpark/melgan/issues/8 for more details. This\n                padding will be done before the padding strategy specified in `padding` is performed.\n            pad_length (`int`, *optional*, defaults to `None`):\n                If padding the end of each waveform, the length of the padding in spectrogram frames. If not set, this\n                will default to `self.config.pad_end_length`.\n            do_normalize (`bool`, *optional*):\n                Whether to perform Tacotron 2 normalization on the input. Normalizing can help to significantly improve\n                the performance for some models. If not set, this will default to `self.config.do_normalize`.\n            return_attention_mask (`bool`, *optional*):\n                Whether to return the attention mask. If left to the default, will return the attention mask according\n                to the specific feature_extractor's default.\n\n                [What are attention masks?](../glossary#attention-mask)\n\n            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n                If set, will return tensors instead of list of python integers. Acceptable values are:\n\n                - `'tf'`: Return TensorFlow `tf.constant` objects.\n                - `'pt'`: Return PyTorch `torch.np.array` objects.\n                - `'np'`: Return Numpy `np.ndarray` objects.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.univnet.feature_extraction_univnet.UnivNetFeatureExtractor::mel_spectrogram", "project": "transformers", "func": "UnivNetFeatureExtractor::mel_spectrogram", "origin_file": "transformers/models/univnet/feature_extraction_univnet.py", "test_list": ["../tests/models/univnet/test_feature_extraction_univnet.py"], "prob_info": {"func_start_lineno": 183, "func_end_lineno": 229, "key_block_start_lineno": 195, "key_block_end_lineno": 229, "new_func_code": "def mel_spectrogram(self, waveform: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Calculates log MEL spectrograms from a batch of waveforms. Note that the input waveform(s) will be padded by\n        `int(self.n_fft - self.hop_length) / 2` on both sides using the `reflect` padding mode.\n\n        Args:\n            waveform (`np.ndarray` of shape `(length,)`):\n                The input waveform. This must be a single real-valued, mono waveform.\n\n        Returns:\n            `numpy.ndarray`: Array containing a log-mel spectrogram of shape `(num_frames, num_mel_bins)`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.univnet.feature_extraction_univnet.UnivNetFeatureExtractor::generate_noise", "project": "transformers", "func": "UnivNetFeatureExtractor::generate_noise", "origin_file": "transformers/models/univnet/feature_extraction_univnet.py", "test_list": ["../tests/models/univnet/test_feature_extraction_univnet.py"], "prob_info": {"func_start_lineno": 231, "func_end_lineno": 261, "key_block_start_lineno": 255, "key_block_end_lineno": 261, "new_func_code": "def generate_noise(\n        self,\n        noise_length: int,\n        generator: Optional[np.random.Generator] = None,\n    ) -> np.ndarray:\n        \"\"\"\n        Generates a random noise sequence of standard Gaussian noise for use in the `noise_sequence` argument of\n        [`UnivNetModel.forward`].\n\n        Args:\n            spectrogram_length (`int`):\n                The length (dim 0) of the generated noise.\n            model_in_channels (`int`, *optional*, defaults to `None`):\n                The number of features (dim 1) of the generated noise. This should correspond to the\n                `model_in_channels` of the [`UnivNetGan`] model. If not set, this will default to\n                `self.config.model_in_channels`.\n            generator (`numpy.random.Generator`, *optional*, defaults to `None`)\n                An optional `numpy.random.Generator` random number generator to control noise generation. If not set, a\n                new generator with fresh entropy will be created.\n\n        Returns:\n            `numpy.ndarray`: Array containing random standard Gaussian noise of shape `(noise_length,\n            model_in_channels)`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.video_llava.image_processing_video_llava.VideoLlavaImageProcessor::resize", "project": "transformers", "func": "VideoLlavaImageProcessor::resize", "origin_file": "transformers/models/video_llava/image_processing_video_llava.py", "test_list": ["../tests/models/video_llava/test_image_processing_video_llava.py"], "prob_info": {"func_start_lineno": 143, "func_end_lineno": 190, "key_block_start_lineno": 168, "key_block_end_lineno": 190, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image. The shortest edge of the image is resized to size[\"shortest_edge\"], with the longest edge\n        resized to keep the input aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.videomae.image_processing_videomae.VideoMAEImageProcessor::resize", "project": "transformers", "func": "VideoMAEImageProcessor::resize", "origin_file": "transformers/models/videomae/image_processing_videomae.py", "test_list": ["../tests/models/videomae/test_image_processing_videomae.py"], "prob_info": {"func_start_lineno": 134, "func_end_lineno": 176, "key_block_start_lineno": 160, "key_block_end_lineno": 176, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BILINEAR,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image. If `size` is of the form `{\"height\": h, \"width\": w}`, the output image will\n                have the size `(h, w)`. If `size` is of the form `{\"shortest_edge\": s}`, the output image will have its\n                shortest edge of length `s` while keeping the aspect ratio of the original image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BILINEAR`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.vilt.image_processing_vilt.ViltImageProcessor::resize", "project": "transformers", "func": "ViltImageProcessor::resize", "origin_file": "transformers/models/vilt/image_processing_vilt.py", "test_list": ["../tests/models/vilt/test_image_processing_vilt.py"], "prob_info": {"func_start_lineno": 207, "func_end_lineno": 253, "key_block_start_lineno": 238, "key_block_end_lineno": 253, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        size_divisor: int = 32,\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image.\n\n        Resizes the shorter side of the image to `size[\"shortest_edge\"]` while preserving the aspect ratio. If the\n        longer side is larger than the max size `(int(`size[\"shortest_edge\"]` * 1333 / 800))`, the longer side is then\n        resized to the max size while preserving the aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Controls the size of the output image. Should be of the form `{\"shortest_edge\": int}`.\n            size_divisor (`int`, *optional*, defaults to 32):\n                The image is resized to a size that is a multiple of this value.\n            resample (`PILImageResampling` filter, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.vitmatte.image_processing_vitmatte.VitMatteImageProcessor::preprocess", "project": "transformers", "func": "VitMatteImageProcessor::preprocess", "origin_file": "transformers/models/vitmatte/image_processing_vitmatte.py", "test_list": ["../tests/models/vitmatte/test_image_processing_vitmatte.py"], "prob_info": {"func_start_lineno": 133, "func_end_lineno": 269, "key_block_start_lineno": 190, "key_block_end_lineno": 269, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        trimaps: ImageInput,\n        do_rescale: Optional[bool] = None,\n        rescale_factor: Optional[float] = None,\n        do_normalize: Optional[bool] = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_pad: Optional[bool] = None,\n        size_divisibility: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: Union[str, ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ):\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            trimaps (`ImageInput`):\n                Trimap to preprocess.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between [0 - 1].\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use if `do_normalize` is set to `True`.\n            do_pad (`bool`, *optional*, defaults to `self.do_pad`):\n                Whether to pad the image.\n            size_divisibility (`int`, *optional*, defaults to `self.size_divisibility`):\n                The size divisibility to pad the image to if `do_pad` is set to `True`.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                - Unset: Return a list of `np.ndarray`.\n                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.vits.tokenization_vits.VitsTokenizer::prepare_for_tokenization", "project": "transformers", "func": "VitsTokenizer::prepare_for_tokenization", "origin_file": "transformers/models/vits/tokenization_vits.py", "test_list": ["../tests/models/vits/test_tokenization_vits.py"], "prob_info": {"func_start_lineno": 142, "func_end_lineno": 205, "key_block_start_lineno": 168, "key_block_end_lineno": 205, "new_func_code": "def prepare_for_tokenization(\n        self, text: str, is_split_into_words: bool = False, normalize: Optional[bool] = None, **kwargs\n    ) -> Tuple[str, Dict[str, Any]]:\n        \"\"\"\n        Performs any necessary transformations before tokenization.\n\n        This method should pop the arguments from kwargs and return the remaining `kwargs` as well. We test the\n        `kwargs` at the end of the encoding process to be sure all the arguments have been used.\n\n        Args:\n            text (`str`):\n                The text to prepare.\n            is_split_into_words (`bool`, *optional*, defaults to `False`):\n                Whether or not the input is already pre-tokenized (e.g., split into words). If set to `True`, the\n                tokenizer assumes the input is already split into words (for instance, by splitting it on whitespace)\n                which it will tokenize.\n            normalize (`bool`, *optional*, defaults to `None`):\n                Whether or not to apply punctuation and casing normalization to the text inputs. Typically, VITS is\n                trained on lower-cased and un-punctuated text. Hence, normalization is used to ensure that the input\n                text consists only of lower-case characters.\n            kwargs (`Dict[str, Any]`, *optional*):\n                Keyword arguments to use for the tokenization.\n\n        Returns:\n            `Tuple[str, Dict[str, Any]]`: The prepared text and the unused kwargs.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.zoedepth.image_processing_zoedepth.ZoeDepthImageProcessor::resize", "project": "transformers", "func": "ZoeDepthImageProcessor::resize", "origin_file": "transformers/models/zoedepth/image_processing_zoedepth.py", "test_list": ["../tests/models/zoedepth/test_image_processing_zoedepth.py"], "prob_info": {"func_start_lineno": 174, "func_end_lineno": 241, "key_block_start_lineno": 206, "key_block_end_lineno": 241, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        keep_aspect_ratio: bool = False,\n        ensure_multiple_of: int = 1,\n        resample: PILImageResampling = PILImageResampling.BILINEAR,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image to target size `(size[\"height\"], size[\"width\"])`. If `keep_aspect_ratio` is `True`, the image\n        is resized to the largest possible size such that the aspect ratio is preserved. If `ensure_multiple_of` is\n        set, the image is resized to a size that is a multiple of this value.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Target size of the output image.\n            keep_aspect_ratio (`bool`, *optional*, defaults to `False`):\n                If `True`, the image is resized to the largest possible size such that the aspect ratio is preserved.\n            ensure_multiple_of (`int`, *optional*, defaults to 1):\n                The image is resized to a size that is a multiple of this value.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BILINEAR`):\n                Defines the resampling filter to use if resizing the image. Otherwise, the image is resized to size\n                specified in `size`.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.get_scheduler", "project": "transformers", "func": "get_scheduler", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 471, "func_end_lineno": 555, "key_block_start_lineno": 496, "key_block_end_lineno": 555, "new_func_code": "def get_scheduler(\n    name: Union[str, SchedulerType],\n    optimizer: Optimizer,\n    num_warmup_steps: Optional[int] = None,\n    num_training_steps: Optional[int] = None,\n    scheduler_specific_kwargs: Optional[dict] = None,\n):\n    \"\"\"\n    Unified API to get any scheduler from its name.\n\n    Args:\n        name (`str` or `SchedulerType`):\n            The name of the scheduler to use.\n        optimizer (`torch.optim.Optimizer`):\n            The optimizer that will be used during training.\n        num_warmup_steps (`int`, *optional*):\n            The number of warmup steps to do. This is not required by all schedulers (hence the argument being\n            optional), the function will raise an error if it's unset and the scheduler type requires it.\n        num_training_steps (`int``, *optional*):\n            The number of training steps to do. This is not required by all schedulers (hence the argument being\n            optional), the function will raise an error if it's unset and the scheduler type requires it.\n        scheduler_specific_kwargs (`dict`, *optional*):\n            Extra parameters for schedulers such as cosine with restarts. Mismatched scheduler types and scheduler\n            parameters will cause the scheduler function to raise a TypeError.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.get_wsd_schedule", "project": "transformers", "func": "get_wsd_schedule", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 410, "func_end_lineno": 454, "key_block_start_lineno": 446, "key_block_end_lineno": 454, "new_func_code": "def get_wsd_schedule(\n    optimizer: Optimizer,\n    num_warmup_steps: int,\n    num_stable_steps: int,\n    num_decay_steps: int,\n    min_lr_ratio: float = 0,\n    num_cycles: float = 0.5,\n    last_epoch: int = -1,\n):\n    \"\"\"\n    Create a schedule with a learning rate that has three stages:\n    1. linear increase from 0 to initial lr.\n    2. constant lr (equal to initial lr).\n    3. decrease following the values of the cosine function between the initial lr set in the optimizer to\n       a fraction of initial lr.\n\n    Args:\n        optimizer ([`~torch.optim.Optimizer`]):\n            The optimizer for which to schedule the learning rate.\n        num_warmup_steps (`int`):\n            The number of steps for the warmup phase.\n        num_stable_steps (`int`):\n            The number of steps for the stable phase.\n        num_decay_steps (`int`):\n            The number of steps for the cosine annealing phase.\n        min_lr_ratio (`float`, *optional*, defaults to 0):\n            The minimum learning rate as a ratio of the initial learning rate.\n        num_cycles (`float`, *optional*, defaults to 0.5):\n            The number of waves in the cosine schedule (the defaults is to just decrease from the max value to 0\n            following a half-cosine).\n        last_epoch (`int`, *optional*, defaults to -1):\n            The index of the last epoch when resuming training.\n\n    Return:\n        `torch.optim.lr_scheduler.LambdaLR` with the appropriate schedule.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.get_cosine_schedule_with_warmup", "project": "transformers", "func": "get_cosine_schedule_with_warmup", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 144, "func_end_lineno": 175, "key_block_start_lineno": 168, "key_block_end_lineno": 175, "new_func_code": "def get_cosine_schedule_with_warmup(\n    optimizer: Optimizer, num_warmup_steps: int, num_training_steps: int, num_cycles: float = 0.5, last_epoch: int = -1\n):\n    \"\"\"\n    Create a schedule with a learning rate that decreases following the values of the cosine function between the\n    initial lr set in the optimizer to 0, after a warmup period during which it increases linearly between 0 and the\n    initial lr set in the optimizer.\n\n    Args:\n        optimizer ([`~torch.optim.Optimizer`]):\n            The optimizer for which to schedule the learning rate.\n        num_warmup_steps (`int`):\n            The number of steps for the warmup phase.\n        num_training_steps (`int`):\n            The total number of training steps.\n        num_cycles (`float`, *optional*, defaults to 0.5):\n            The number of waves in the cosine schedule (the defaults is to just decrease from the max value to 0\n            following a half-cosine).\n        last_epoch (`int`, *optional*, defaults to -1):\n            The index of the last epoch when resuming training.\n\n    Return:\n        `torch.optim.lr_scheduler.LambdaLR` with the appropriate schedule.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.get_constant_schedule", "project": "transformers", "func": "get_constant_schedule", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 40, "func_end_lineno": 54, "key_block_start_lineno": 53, "key_block_end_lineno": 54, "new_func_code": "def get_constant_schedule(optimizer: Optimizer, last_epoch: int = -1):\n    \"\"\"\n    Create a schedule with a constant learning rate, using the learning rate set in optimizer.\n\n    Args:\n        optimizer ([`~torch.optim.Optimizer`]):\n            The optimizer for which to schedule the learning rate.\n        last_epoch (`int`, *optional*, defaults to -1):\n            The index of the last epoch when resuming training.\n\n    Return:\n        `torch.optim.lr_scheduler.LambdaLR` with the appropriate schedule.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.get_constant_schedule_with_warmup", "project": "transformers", "func": "get_constant_schedule_with_warmup", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 81, "func_end_lineno": 99, "key_block_start_lineno": 97, "key_block_end_lineno": 99, "new_func_code": "def get_constant_schedule_with_warmup(optimizer: Optimizer, num_warmup_steps: int, last_epoch: int = -1):\n    \"\"\"\n    Create a schedule with a constant learning rate preceded by a warmup period during which the learning rate\n    increases linearly between 0 and the initial lr set in the optimizer.\n\n    Args:\n        optimizer ([`~torch.optim.Optimizer`]):\n            The optimizer for which to schedule the learning rate.\n        num_warmup_steps (`int`):\n            The number of steps for the warmup phase.\n        last_epoch (`int`, *optional*, defaults to -1):\n            The index of the last epoch when resuming training.\n\n    Return:\n        `torch.optim.lr_scheduler.LambdaLR` with the appropriate schedule.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.get_linear_schedule_with_warmup", "project": "transformers", "func": "get_linear_schedule_with_warmup", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 108, "func_end_lineno": 132, "key_block_start_lineno": 126, "key_block_end_lineno": 132, "new_func_code": "def get_linear_schedule_with_warmup(optimizer, num_warmup_steps, num_training_steps, last_epoch=-1):\n    \"\"\"\n    Create a schedule with a learning rate that decreases linearly from the initial lr set in the optimizer to 0, after\n    a warmup period during which it increases linearly from 0 to the initial lr set in the optimizer.\n\n    Args:\n        optimizer ([`~torch.optim.Optimizer`]):\n            The optimizer for which to schedule the learning rate.\n        num_warmup_steps (`int`):\n            The number of steps for the warmup phase.\n        num_training_steps (`int`):\n            The total number of training steps.\n        last_epoch (`int`, *optional*, defaults to -1):\n            The index of the last epoch when resuming training.\n\n    Return:\n        `torch.optim.lr_scheduler.LambdaLR` with the appropriate schedule.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.get_cosine_with_hard_restarts_schedule_with_warmup", "project": "transformers", "func": "get_cosine_with_hard_restarts_schedule_with_warmup", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 189, "func_end_lineno": 219, "key_block_start_lineno": 212, "key_block_end_lineno": 219, "new_func_code": "def get_cosine_with_hard_restarts_schedule_with_warmup(\n    optimizer: Optimizer, num_warmup_steps: int, num_training_steps: int, num_cycles: int = 1, last_epoch: int = -1\n):\n    \"\"\"\n    Create a schedule with a learning rate that decreases following the values of the cosine function between the\n    initial lr set in the optimizer to 0, with several hard restarts, after a warmup period during which it increases\n    linearly between 0 and the initial lr set in the optimizer.\n\n    Args:\n        optimizer ([`~torch.optim.Optimizer`]):\n            The optimizer for which to schedule the learning rate.\n        num_warmup_steps (`int`):\n            The number of steps for the warmup phase.\n        num_training_steps (`int`):\n            The total number of training steps.\n        num_cycles (`int`, *optional*, defaults to 1):\n            The number of hard restarts to use.\n        last_epoch (`int`, *optional*, defaults to -1):\n            The index of the last epoch when resuming training.\n\n    Return:\n        `torch.optim.lr_scheduler.LambdaLR` with the appropriate schedule.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.get_polynomial_decay_schedule_with_warmup", "project": "transformers", "func": "get_polynomial_decay_schedule_with_warmup", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 286, "key_block_start_lineno": 273, "key_block_end_lineno": 286, "new_func_code": "def get_polynomial_decay_schedule_with_warmup(\n    optimizer, num_warmup_steps, num_training_steps, lr_end=1e-7, power=1.0, last_epoch=-1\n):\n    \"\"\"\n    Create a schedule with a learning rate that decreases as a polynomial decay from the initial lr set in the\n    optimizer to end lr defined by *lr_end*, after a warmup period during which it increases linearly from 0 to the\n    initial lr set in the optimizer.\n\n    Args:\n        optimizer ([`~torch.optim.Optimizer`]):\n            The optimizer for which to schedule the learning rate.\n        num_warmup_steps (`int`):\n            The number of steps for the warmup phase.\n        num_training_steps (`int`):\n            The total number of training steps.\n        lr_end (`float`, *optional*, defaults to 1e-7):\n            The end LR.\n        power (`float`, *optional*, defaults to 1.0):\n            Power factor.\n        last_epoch (`int`, *optional*, defaults to -1):\n            The index of the last epoch when resuming training.\n\n    Note: *power* defaults to 1.0 as in the fairseq implementation, which in turn is based on the original BERT\n    implementation at\n    https://github.com/google-research/bert/blob/f39e881b169b9d53bea03d2d341b31707a6c052b/optimization.py#L37\n\n    Return:\n        `torch.optim.lr_scheduler.LambdaLR` with the appropriate schedule.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.data.data_collator.DataCollatorForLanguageModeling::torch_mask_tokens", "project": "transformers", "func": "DataCollatorForLanguageModeling::torch_mask_tokens", "origin_file": "transformers/data/data_collator.py", "test_list": ["../tests/trainer/test_data_collator.py"], "prob_info": {"func_start_lineno": 827, "func_end_lineno": 858, "key_block_start_lineno": 831, "key_block_end_lineno": 858, "new_func_code": "def torch_mask_tokens(self, inputs: Any, special_tokens_mask: Optional[Any] = None) -> Tuple[Any, Any]:\n        \"\"\"\n        Prepare masked tokens inputs/labels for masked language modeling: 80% MASK, 10% random, 10% original.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bert.tokenization_bert.BertTokenizer::get_special_tokens_mask", "project": "transformers", "func": "BertTokenizer::get_special_tokens_mask", "origin_file": "transformers/models/bert/tokenization_bert.py", "test_list": ["../tests/trainer/test_data_collator.py"], "prob_info": {"func_start_lineno": 206, "func_end_lineno": 232, "key_block_start_lineno": 224, "key_block_end_lineno": 232, "new_func_code": "def get_special_tokens_mask(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None, already_has_special_tokens: bool = False\n    ) -> List[int]:\n        \"\"\"\n        Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer `prepare_for_model` method.\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n            already_has_special_tokens (`bool`, *optional*, defaults to `False`):\n                Whether or not the token list is already formatted with special tokens for the model.\n\n        Returns:\n            `List[int]`: A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.trainer_pt_utils.get_length_grouped_indices", "project": "transformers", "func": "get_length_grouped_indices", "origin_file": "transformers/trainer_pt_utils.py", "test_list": ["../tests/trainer/test_trainer_utils.py"], "prob_info": {"func_start_lineno": 587, "func_end_lineno": 619, "key_block_start_lineno": 599, "key_block_end_lineno": 619, "new_func_code": "def get_length_grouped_indices(lengths, batch_size, mega_batch_mult=None, generator=None):\n    \"\"\"\n    Return a list of indices so that each slice of `batch_size` consecutive indices correspond to elements of similar\n    lengths. To do this, the indices are:\n\n    - randomly permuted\n    - grouped in mega-batches of size `mega_batch_mult * batch_size`\n    - sorted by length in each mega-batch\n\n    The result is the concatenation of all mega-batches, with the batch of `batch_size` containing the element of\n    maximum length placed first, so that an OOM happens sooner rather than later.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.trainer_pt_utils.DistributedTensorGatherer::add_arrays", "project": "transformers", "func": "DistributedTensorGatherer::add_arrays", "origin_file": "transformers/trainer_pt_utils.py", "test_list": ["../tests/trainer/test_trainer_utils.py"], "prob_info": {"func_start_lineno": 496, "func_end_lineno": 509, "key_block_start_lineno": 501, "key_block_end_lineno": 509, "new_func_code": "def add_arrays(self, arrays):\n        \"\"\"\n        Add `arrays` to the internal storage, Will initialize the storage to the full size at the first arrays passed\n        so that if we're bound to get an OOM, it happens at the beginning.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.chat_template_utils.get_json_schema", "project": "transformers", "func": "get_json_schema", "origin_file": "transformers/utils/chat_template_utils.py", "test_list": ["../tests/utils/test_chat_template_utils.py"], "prob_info": {"func_start_lineno": 197, "func_end_lineno": 331, "key_block_start_lineno": 304, "key_block_end_lineno": 331, "new_func_code": "def get_json_schema(func: Callable) -> Dict:\n    \"\"\"\n    This function generates a JSON schema for a given function, based on its docstring and type hints. This is\n    mostly used for passing lists of tools to a chat template. The JSON schema contains the name and description of\n    the function, as well as the names, types and descriptions for each of its arguments. `get_json_schema()` requires\n    that the function has a docstring, and that each argument has a description in the docstring, in the standard\n    Google docstring format shown below. It also requires that all the function arguments have a valid Python type hint.\n\n    Although it is not required, a `Returns` block can also be added, which will be included in the schema. This is\n    optional because most chat templates ignore the return value of the function.\n\n    Args:\n        func: The function to generate a JSON schema for.\n\n    Returns:\n        A dictionary containing the JSON schema for the function.\n\n    Examples:\n    ```python\n    >>> def multiply(x: float, y: float):\n    >>>    '''\n    >>>    A function that multiplies two numbers\n    >>>\n    >>>    Args:\n    >>>        x: The first number to multiply\n    >>>        y: The second number to multiply\n    >>>    '''\n    >>>    return x * y\n    >>>\n    >>> print(get_json_schema(multiply))\n    {\n        \"name\": \"multiply\",\n        \"description\": \"A function that multiplies two numbers\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"x\": {\"type\": \"number\", \"description\": \"The first number to multiply\"},\n                \"y\": {\"type\": \"number\", \"description\": \"The second number to multiply\"}\n            },\n            \"required\": [\"x\", \"y\"]\n        }\n    }\n    ```\n\n    The general use for these schemas is that they are used to generate tool descriptions for chat templates that\n    support them, like so:\n\n    ```python\n    >>> from transformers import AutoTokenizer\n    >>> from transformers.utils import get_json_schema\n    >>>\n    >>> def multiply(x: float, y: float):\n    >>>    '''\n    >>>    A function that multiplies two numbers\n    >>>\n    >>>    Args:\n    >>>        x: The first number to multiply\n    >>>        y: The second number to multiply\n    >>>    return x * y\n    >>>    '''\n    >>>\n    >>> multiply_schema = get_json_schema(multiply)\n    >>> tokenizer = AutoTokenizer.from_pretrained(\"CohereForAI/c4ai-command-r-v01\")\n    >>> messages = [{\"role\": \"user\", \"content\": \"What is 179 x 4571?\"}]\n    >>> formatted_chat = tokenizer.apply_chat_template(\n    >>>     messages,\n    >>>     tools=[multiply_schema],\n    >>>     chat_template=\"tool_use\",\n    >>>     return_dict=True,\n    >>>     return_tensors=\"pt\",\n    >>>     add_generation_prompt=True\n    >>> )\n    >>> # The formatted chat can now be passed to model.generate()\n    ```\n\n    Each argument description can also have an optional `(choices: ...)` block at the end, such as\n    `(choices: [\"tea\", \"coffee\"])`, which will be parsed into an `enum` field in the schema. Note that this will\n    only be parsed correctly if it is at the end of the line:\n\n    ```python\n    >>> def drink_beverage(beverage: str):\n    >>>    '''\n    >>>    A function that drinks a beverage\n    >>>\n    >>>    Args:\n    >>>        beverage: The beverage to drink (choices: [\"tea\", \"coffee\"])\n    >>>    '''\n    >>>    pass\n    >>>\n    >>> print(get_json_schema(drink_beverage))\n    ```\n    {\n        'name': 'drink_beverage',\n        'description': 'A function that drinks a beverage',\n        'parameters': {\n            'type': 'object',\n            'properties': {\n                'beverage': {\n                    'type': 'string',\n                    'enum': ['tea', 'coffee'],\n                    'description': 'The beverage to drink'\n                    }\n                },\n            'required': ['beverage']\n        }\n    }\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.import_utils.define_import_structure", "project": "transformers", "func": "define_import_structure", "origin_file": "transformers/utils/import_utils.py", "test_list": ["../tests/utils/test_dynamic_module_utils.py"], "prob_info": {"func_start_lineno": 2136, "func_end_lineno": 2158, "key_block_start_lineno": 2157, "key_block_end_lineno": 2158, "new_func_code": "def define_import_structure(module_path: str) -> IMPORT_STRUCTURE_T:\n    \"\"\"\n    This method takes a module_path as input and creates an import structure digestible by a _LazyModule.\n\n    Here's an example of an output import structure at the src.transformers.models level:\n\n    {\n        frozenset({'tokenizers'}): {\n            'albert.tokenization_albert_fast': {'AlbertTokenizerFast'}\n        },\n        frozenset(): {\n            'albert.configuration_albert': {'AlbertConfig', 'AlbertOnnxConfig'},\n            'align.processing_align': {'AlignProcessor'},\n            'align.configuration_align': {'AlignConfig', 'AlignTextConfig', 'AlignVisionConfig'},\n            'altclip.configuration_altclip': {'AltCLIPConfig', 'AltCLIPTextConfig', 'AltCLIPVisionConfig'},\n            'altclip.processing_altclip': {'AltCLIPProcessor'}\n        }\n    }\n\n    The import structure is a dict defined with frozensets as keys, and dicts of strings to sets of objects.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.import_utils.create_import_structure_from_path", "project": "transformers", "func": "create_import_structure_from_path", "origin_file": "transformers/utils/import_utils.py", "test_list": ["../tests/utils/test_dynamic_module_utils.py"], "prob_info": {"func_start_lineno": 1846, "func_end_lineno": 2037, "key_block_start_lineno": 1899, "key_block_end_lineno": 2037, "new_func_code": "def create_import_structure_from_path(module_path):\n    \"\"\"\n    This method takes the path to a file/a folder and returns the import structure.\n    If a file is given, it will return the import structure of the parent folder.\n\n    Import structures are designed to be digestible by `_LazyModule` objects. They are\n    created from the __all__ definitions in each files as well as the `@export` decorators\n    above methods and objects.\n\n    The import structure allows explicit display of the required backends for a given object.\n    These backends are specified in two ways:\n\n    1. Through their `@export`, if they are exported with that decorator. This `@export` decorator\n       accepts a `backend` tuple kwarg mentioning which backends are required to run this object.\n\n    2. If an object is defined in a file with \"default\" backends, it will have, at a minimum, this\n       backend specified. The default backends are defined according to the filename:\n\n       - If a file is named like `modeling_*.py`, it will have a `torch` backend\n       - If a file is named like `modeling_tf_*.py`, it will have a `tf` backend\n       - If a file is named like `modeling_flax_*.py`, it will have a `flax` backend\n       - If a file is named like `tokenization_*_fast.py`, it will have a `tokenizers` backend\n\n    Backends serve the purpose of displaying a clear error message to the user in case the backends are not installed.\n    Should an object be imported without its required backends being in the environment, any attempt to use the\n    object will raise an error mentioning which backend(s) should be added to the environment in order to use\n    that object.\n\n    Here's an example of an input import structure at the src.transformers.models level:\n\n    {\n        'albert': {\n            frozenset(): {\n                'configuration_albert': {'AlbertConfig', 'AlbertOnnxConfig'}\n            },\n            frozenset({'tokenizers'}): {\n                'tokenization_albert_fast': {'AlbertTokenizerFast'}\n            },\n        },\n        'align': {\n            frozenset(): {\n                'configuration_align': {'AlignConfig', 'AlignTextConfig', 'AlignVisionConfig'},\n                'processing_align': {'AlignProcessor'}\n            },\n        },\n        'altclip': {\n            frozenset(): {\n                'configuration_altclip': {'AltCLIPConfig', 'AltCLIPTextConfig', 'AltCLIPVisionConfig'},\n                'processing_altclip': {'AltCLIPProcessor'},\n            }\n        }\n    }\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.import_utils.spread_import_structure", "project": "transformers", "func": "spread_import_structure", "origin_file": "transformers/utils/import_utils.py", "test_list": ["../tests/utils/test_dynamic_module_utils.py"], "prob_info": {"func_start_lineno": 2040, "func_end_lineno": 2133, "key_block_start_lineno": 2086, "key_block_end_lineno": 2133, "new_func_code": "def spread_import_structure(nested_import_structure):\n    \"\"\"\n    This method takes as input an unordered import structure and brings the required backends at the top-level,\n    aggregating modules and objects under their required backends.\n\n    Here's an example of an input import structure at the src.transformers.models level:\n\n    {\n        'albert': {\n            frozenset(): {\n                'configuration_albert': {'AlbertConfig', 'AlbertOnnxConfig'}\n            },\n            frozenset({'tokenizers'}): {\n                'tokenization_albert_fast': {'AlbertTokenizerFast'}\n            },\n        },\n        'align': {\n            frozenset(): {\n                'configuration_align': {'AlignConfig', 'AlignTextConfig', 'AlignVisionConfig'},\n                'processing_align': {'AlignProcessor'}\n            },\n        },\n        'altclip': {\n            frozenset(): {\n                'configuration_altclip': {'AltCLIPConfig', 'AltCLIPTextConfig', 'AltCLIPVisionConfig'},\n                'processing_altclip': {'AltCLIPProcessor'},\n            }\n        }\n    }\n\n    Here's an example of an output import structure at the src.transformers.models level:\n\n    {\n        frozenset({'tokenizers'}): {\n            'albert.tokenization_albert_fast': {'AlbertTokenizerFast'}\n        },\n        frozenset(): {\n            'albert.configuration_albert': {'AlbertConfig', 'AlbertOnnxConfig'},\n            'align.processing_align': {'AlignProcessor'},\n            'align.configuration_align': {'AlignConfig', 'AlignTextConfig', 'AlignVisionConfig'},\n            'altclip.configuration_altclip': {'AltCLIPConfig', 'AltCLIPTextConfig', 'AltCLIPVisionConfig'},\n            'altclip.processing_altclip': {'AltCLIPProcessor'}\n        }\n    }\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.generic.find_labels", "project": "transformers", "func": "find_labels", "origin_file": "transformers/utils/generic.py", "test_list": ["../tests/utils/test_file_utils.py"], "prob_info": {"func_start_lineno": 565, "func_end_lineno": 584, "key_block_start_lineno": 572, "key_block_end_lineno": 584, "new_func_code": "def find_labels(model_class):\n    \"\"\"\n    Find the labels used by a given model.\n\n    Args:\n        model_class (`type`): The class of the model.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.generic.filter_out_non_signature_kwargs", "project": "transformers", "func": "filter_out_non_signature_kwargs", "origin_file": "transformers/utils/generic.py", "test_list": ["../tests/utils/test_generic.py"], "prob_info": {"func_start_lineno": 780, "func_end_lineno": 856, "key_block_start_lineno": 807, "key_block_end_lineno": 856, "new_func_code": "def filter_out_non_signature_kwargs(extra: Optional[list] = None):\n    \"\"\"\n    Decorator to filter out named arguments that are not in the function signature.\n\n    This decorator ensures that only the keyword arguments that match the function's signature, or are specified in the\n    `extra` list, are passed to the function. Any additional keyword arguments are filtered out and a warning is issued.\n\n    Parameters:\n        extra (`Optional[list]`, *optional*):\n            A list of extra keyword argument names that are allowed even if they are not in the function's signature.\n\n    Returns:\n        Callable:\n            A decorator that wraps the function and filters out invalid keyword arguments.\n\n    Example usage:\n\n        ```python\n        @filter_out_non_signature_kwargs(extra=[\"allowed_extra_arg\"])\n        def my_function(arg1, arg2, **kwargs):\n            print(arg1, arg2, kwargs)\n\n        my_function(arg1=1, arg2=2, allowed_extra_arg=3, invalid_arg=4)\n        # This will print: 1 2 {\"allowed_extra_arg\": 3}\n        # And issue a warning: \"The following named arguments are not valid for `my_function` and were ignored: 'invalid_arg'\"\n        ```\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.hf_argparser.HfArgumentParser::parse_args_into_dataclasses", "project": "transformers", "func": "HfArgumentParser::parse_args_into_dataclasses", "origin_file": "transformers/hf_argparser.py", "test_list": ["../tests/utils/test_hf_argparser.py"], "prob_info": {"func_start_lineno": 266, "func_end_lineno": 350, "key_block_start_lineno": 302, "key_block_end_lineno": 350, "new_func_code": "def parse_args_into_dataclasses(\n        self,\n        args=None,\n        return_remaining_strings=False,\n        look_for_args_file=True,\n        args_filename=None,\n        args_file_flag=None,\n    ) -> Tuple[DataClass, ...]:\n        \"\"\"\n        Parse command-line args into instances of the specified dataclass types.\n\n        This relies on argparse's `ArgumentParser.parse_known_args`. See the doc at:\n        docs.python.org/3.7/library/argparse.html#argparse.ArgumentParser.parse_args\n\n        Args:\n            args:\n                List of strings to parse. The default is taken from sys.argv. (same as argparse.ArgumentParser)\n            return_remaining_strings:\n                If true, also return a list of remaining argument strings.\n            look_for_args_file:\n                If true, will look for a \".args\" file with the same base name as the entry point script for this\n                process, and will append its potential content to the command line args.\n            args_filename:\n                If not None, will uses this file instead of the \".args\" file specified in the previous argument.\n            args_file_flag:\n                If not None, will look for a file in the command-line args specified with this flag. The flag can be\n                specified multiple times and precedence is determined by the order (last one wins).\n\n        Returns:\n            Tuple consisting of:\n\n                - the dataclass instances in the same order as they were passed to the initializer.abspath\n                - if applicable, an additional namespace for more (non-dataclass backed) arguments added to the parser\n                  after initialization.\n                - The potential list of remaining argument strings. (same as argparse.ArgumentParser.parse_known_args)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.hf_argparser.make_choice_type_function", "project": "transformers", "func": "make_choice_type_function", "origin_file": "transformers/hf_argparser.py", "test_list": ["../tests/utils/test_hf_argparser.py"], "prob_info": {"func_start_lineno": 48, "func_end_lineno": 60, "key_block_start_lineno": 59, "key_block_end_lineno": 60, "new_func_code": "def make_choice_type_function(choices: list) -> Callable[[str], Any]:\n    \"\"\"\n    Creates a mapping function from each choices string representation to the actual value. Used to support multiple\n    value types for a single argument.\n\n    Args:\n        choices (list): List of choices.\n\n    Returns:\n        Callable[[str], Any]: Mapping function from string representation to actual value for each choice.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.hf_argparser.HfArgumentParser::parse_json_file", "project": "transformers", "func": "HfArgumentParser::parse_json_file", "origin_file": "transformers/hf_argparser.py", "test_list": ["../tests/utils/test_hf_argparser.py"], "prob_info": {"func_start_lineno": 380, "func_end_lineno": 402, "key_block_start_lineno": 399, "key_block_end_lineno": 402, "new_func_code": "def parse_json_file(\n        self, json_file: Union[str, os.PathLike], allow_extra_keys: bool = False\n    ) -> Tuple[DataClass, ...]:\n        \"\"\"\n        Alternative helper method that does not use `argparse` at all, instead loading a json file and populating the\n        dataclass types.\n\n        Args:\n            json_file (`str` or `os.PathLike`):\n                File name of the json file to parse\n            allow_extra_keys (`bool`, *optional*, defaults to `False`):\n                Defaults to False. If False, will raise an exception if the json file contains keys that are not\n                parsed.\n\n        Returns:\n            Tuple consisting of:\n\n                - the dataclass instances in the same order as they were passed to the initializer.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.hf_argparser.HfArgumentParser::parse_yaml_file", "project": "transformers", "func": "HfArgumentParser::parse_yaml_file", "origin_file": "transformers/hf_argparser.py", "test_list": ["../tests/utils/test_hf_argparser.py"], "prob_info": {"func_start_lineno": 404, "func_end_lineno": 424, "key_block_start_lineno": 423, "key_block_end_lineno": 424, "new_func_code": "def parse_yaml_file(\n        self, yaml_file: Union[str, os.PathLike], allow_extra_keys: bool = False\n    ) -> Tuple[DataClass, ...]:\n        \"\"\"\n        Alternative helper method that does not use `argparse` at all, instead loading a yaml file and populating the\n        dataclass types.\n\n        Args:\n            yaml_file (`str` or `os.PathLike`):\n                File name of the yaml file to parse\n            allow_extra_keys (`bool`, *optional*, defaults to `False`):\n                Defaults to False. If False, will raise an exception if the json file contains keys that are not\n                parsed.\n\n        Returns:\n            Tuple consisting of:\n\n                - the dataclass instances in the same order as they were passed to the initializer.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.testing_utils.mockenv_context", "project": "transformers", "func": "mockenv_context", "origin_file": "transformers/testing_utils.py", "test_list": ["../tests/utils/test_logging.py"], "prob_info": {"func_start_lineno": 1819, "func_end_lineno": 1846, "key_block_start_lineno": 1829, "key_block_end_lineno": 1846, "new_func_code": "def mockenv_context(*remove, **update):\n    \"\"\"\n    Temporarily updates the `os.environ` dictionary in-place. Similar to mockenv\n\n    The `os.environ` dictionary is updated in-place so that the modification is sure to work in all situations.\n\n    Args:\n      remove: Environment variables to remove.\n      update: Dictionary of environment variables and values to add/update.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.logging.get_verbosity", "project": "transformers", "func": "get_verbosity", "origin_file": "transformers/utils/logging.py", "test_list": ["../tests/utils/test_logging.py"], "prob_info": {"func_start_lineno": 161, "func_end_lineno": 181, "key_block_start_lineno": 179, "key_block_end_lineno": 181, "new_func_code": "def get_verbosity() -> int:\n    \"\"\"\n    Return the current level for the  Transformers's root logger as an int.\n\n    Returns:\n        `int`: The logging level.\n\n    <Tip>\n\n     Transformers has following logging levels:\n\n    - 50: `transformers.logging.CRITICAL` or `transformers.logging.FATAL`\n    - 40: `transformers.logging.ERROR`\n    - 30: `transformers.logging.WARNING` or `transformers.logging.WARN`\n    - 20: `transformers.logging.INFO`\n    - 10: `transformers.logging.DEBUG`\n\n    </Tip>\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.logging.set_verbosity", "project": "transformers", "func": "set_verbosity", "origin_file": "transformers/utils/logging.py", "test_list": ["../tests/utils/test_logging.py"], "prob_info": {"func_start_lineno": 184, "func_end_lineno": 200, "key_block_start_lineno": 198, "key_block_end_lineno": 200, "new_func_code": "def set_verbosity(verbosity: int) -> None:\n    \"\"\"\n    Set the verbosity level for the  Transformers's root logger.\n\n    Args:\n        verbosity (`int`):\n            Logging level, e.g., one of:\n\n            - `transformers.logging.CRITICAL` or `transformers.logging.FATAL`\n            - `transformers.logging.ERROR`\n            - `transformers.logging.WARNING` or `transformers.logging.WARN`\n            - `transformers.logging.INFO`\n            - `transformers.logging.DEBUG`\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.modeling_rope_utils._compute_default_rope_parameters", "project": "transformers", "func": "_compute_default_rope_parameters", "origin_file": "transformers/modeling_rope_utils.py", "test_list": ["../tests/utils/test_modeling_rope_utils.py"], "prob_info": {"func_start_lineno": 29, "func_end_lineno": 68, "key_block_start_lineno": 50, "key_block_end_lineno": 68, "new_func_code": "def _compute_default_rope_parameters(\n    config: Optional[PretrainedConfig] = None,\n    device: Optional[\"torch.device\"] = None,\n    seq_len: Optional[int] = None,\n    **rope_kwargs,\n) -> Tuple[\"torch.Tensor\", float]:\n    \"\"\"\n    Computes the inverse frequencies according to the original RoPE implementation\n    Args:\n        config ([`~transformers.PretrainedConfig`]):\n            The model configuration.\n        device (`torch.device`):\n            The device to use for initialization of the inverse frequencies.\n        seq_len (`int`, *optional*):\n            The current sequence length. Unused for this type of RoPE.\n        rope_kwargs (`Dict`, *optional*):\n            BC compatibility with the previous RoPE class instantiation, will be removed in v4.45.\n    Returns:\n        Tuple of (`torch.Tensor`, `float`), containing the inverse frequencies for the RoPE embeddings and the\n        post-processing scaling factor applied to the computed cos/sin (unused in this type of RoPE).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.modeling_rope_utils._compute_dynamic_ntk_parameters", "project": "transformers", "func": "_compute_dynamic_ntk_parameters", "origin_file": "transformers/modeling_rope_utils.py", "test_list": ["../tests/utils/test_modeling_rope_utils.py"], "prob_info": {"func_start_lineno": 112, "func_end_lineno": 160, "key_block_start_lineno": 133, "key_block_end_lineno": 160, "new_func_code": "def _compute_dynamic_ntk_parameters(\n    config: Optional[PretrainedConfig] = None,\n    device: Optional[\"torch.device\"] = None,\n    seq_len: Optional[int] = None,\n    **rope_kwargs,\n) -> Tuple[\"torch.Tensor\", float]:\n    \"\"\"\n    Computes the inverse frequencies with NTK scaling. Credits to the Reddit users /u/bloc97 and /u/emozilla\n    Args:\n        config ([`~transformers.PretrainedConfig`]):\n            The model configuration.\n        device (`torch.device`):\n            The device to use for initialization of the inverse frequencies.\n        seq_len (`int`, *optional*):\n            The current sequence length, used to update the dynamic RoPE at inference time.\n        rope_kwargs (`Dict`, *optional*):\n            BC compatibility with the previous RoPE class instantiation, will be removed in v4.45.\n    Returns:\n        Tuple of (`torch.Tensor`, `float`), containing the inverse frequencies for the RoPE embeddings and the\n        post-processing scaling factor applied to the computed cos/sin (unused in this type of RoPE).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.modeling_rope_utils._compute_linear_scaling_rope_parameters", "project": "transformers", "func": "_compute_linear_scaling_rope_parameters", "origin_file": "transformers/modeling_rope_utils.py", "test_list": ["../tests/utils/test_modeling_rope_utils.py"], "prob_info": {"func_start_lineno": 71, "func_end_lineno": 109, "key_block_start_lineno": 92, "key_block_end_lineno": 109, "new_func_code": "def _compute_linear_scaling_rope_parameters(\n    config: Optional[PretrainedConfig] = None,\n    device: Optional[\"torch.device\"] = None,\n    seq_len: Optional[int] = None,\n    **rope_kwargs,\n) -> Tuple[\"torch.Tensor\", float]:\n    \"\"\"\n    Computes the inverse frequencies with linear scaling. Credits to the Reddit user /u/kaiokendev\n    Args:\n        config ([`~transformers.PretrainedConfig`]):\n            The model configuration.\n        device (`torch.device`):\n            The device to use for initialization of the inverse frequencies.\n        seq_len (`int`, *optional*):\n            The current sequence length. Unused for this type of RoPE.\n        rope_kwargs (`Dict`, *optional*):\n            BC compatibility with the previous RoPE class instantiation, will be removed in v4.45.\n    Returns:\n        Tuple of (`torch.Tensor`, `float`), containing the inverse frequencies for the RoPE embeddings and the\n        post-processing scaling factor applied to the computed cos/sin (unused in this type of RoPE).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.modeling_rope_utils._compute_llama3_parameters", "project": "transformers", "func": "_compute_llama3_parameters", "origin_file": "transformers/modeling_rope_utils.py", "test_list": ["../tests/utils/test_modeling_rope_utils.py"], "prob_info": {"func_start_lineno": 307, "func_end_lineno": 347, "key_block_start_lineno": 326, "key_block_end_lineno": 347, "new_func_code": "def _compute_llama3_parameters(\n    config: PretrainedConfig, device: \"torch.device\", seq_len: Optional[int] = None, **rope_kwargs\n) -> Tuple[\"torch.Tensor\", float]:\n    \"\"\"\n    Computes the inverse frequencies for llama 3.1.\n\n    Args:\n        config ([`~transformers.PretrainedConfig`]):\n            The model configuration.\n        device (`torch.device`):\n            The device to use for initialization of the inverse frequencies.\n        seq_len (`int`, *optional*):\n            The current sequence length. Unused for this type of RoPE.\n        rope_kwargs (`Dict`, *optional*):\n            BC compatibility with the previous RoPE class instantiation, will be removed in v4.45.\n    Returns:\n        Tuple of (`torch.Tensor`, `float`), containing the inverse frequencies for the RoPE embeddings and the\n        post-processing scaling factor applied to the computed cos/sin.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.flip_channel_order", "project": "transformers", "func": "flip_channel_order", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/test_image_transforms.py"], "prob_info": {"func_start_lineno": 774, "func_end_lineno": 809, "key_block_start_lineno": 798, "key_block_end_lineno": 809, "new_func_code": "def flip_channel_order(\n    image: np.ndarray,\n    data_format: Optional[ChannelDimension] = None,\n    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n) -> np.ndarray:\n    \"\"\"\n    Flips the channel order of the image.\n\n    If the image is in RGB format, it will be converted to BGR and vice versa.\n\n    Args:\n        image (`np.ndarray`):\n            The image to flip.\n        data_format (`ChannelDimension`, *optional*):\n            The channel dimension format for the output image. Can be one of:\n                - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            If unset, will use same as the input image.\n        input_data_format (`ChannelDimension`, *optional*):\n            The channel dimension format for the input image. Can be one of:\n                - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            If unset, will use the inferred format of the input image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.generation.configuration_utils.GenerationConfig::validate", "project": "transformers", "func": "GenerationConfig::validate", "origin_file": "transformers/generation/configuration_utils.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 552, "func_end_lineno": 791, "key_block_start_lineno": 564, "key_block_end_lineno": 791, "new_func_code": "def validate(self, is_init=False):\n        \"\"\"\n        Validates the values of the attributes of the [`GenerationConfig`] instance. Raises exceptions in the presence\n        of parameterization that can be detected as incorrect from the configuration instance alone.\n\n        Note that some parameters not validated here are best validated at generate runtime, as they may depend on\n        other inputs and/or the model, such as parameters related to the generation length.\n\n        Arg:\n            is_init (`bool`, *optional*, defaults to `False`):\n                Whether the validation is performed during the initialization of the instance.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bart.modeling_bart.BartEncoderLayer::forward", "project": "transformers", "func": "BartEncoderLayer::forward", "origin_file": "transformers/models/bart/modeling_bart.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 548, "func_end_lineno": 596, "key_block_start_lineno": 566, "key_block_end_lineno": 596, "new_func_code": "def forward(\n        self,\n        hidden_states: torch.FloatTensor,\n        attention_mask: torch.FloatTensor,\n        layer_head_mask: torch.FloatTensor,\n        output_attentions: Optional[bool] = False,\n    ) -> Tuple[torch.FloatTensor, Optional[torch.FloatTensor]]:\n        \"\"\"\n        Args:\n            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n            attention_mask (`torch.FloatTensor`): attention mask of size\n                `(batch, 1, tgt_len, src_len)` where padding elements are indicated by very large negative values.\n            layer_head_mask (`torch.FloatTensor`): mask for attention heads in a given layer of size\n                `(encoder_attention_heads,)`.\n            output_attentions (`bool`, *optional*):\n                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n                returned tensors for more detail.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.modeling_attn_mask_utils._prepare_4d_causal_attention_mask_for_sdpa", "project": "transformers", "func": "_prepare_4d_causal_attention_mask_for_sdpa", "origin_file": "transformers/modeling_attn_mask_utils.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 351, "func_end_lineno": 406, "key_block_start_lineno": 365, "key_block_end_lineno": 406, "new_func_code": "def _prepare_4d_causal_attention_mask_for_sdpa(\n    attention_mask: Optional[torch.Tensor],\n    input_shape: Union[torch.Size, Tuple, List],\n    inputs_embeds: torch.Tensor,\n    past_key_values_length: int,\n    sliding_window: Optional[int] = None,\n):\n    \"\"\"\n    Prepares the correct `attn_mask` argument to be used by `torch.nn.functional.scaled_dot_product_attention`.\n\n    In case no token is masked in the `attention_mask` argument, we simply set it to `None` for the cases `query_length == 1` and\n    `key_value_length == query_length`, and rely instead on SDPA `is_causal` argument to use causal/non-causal masks,\n    allowing to dispatch to the flash attention kernel (that can otherwise not be used if a custom `attn_mask` is passed).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.pytorch_utils.apply_chunking_to_forward", "project": "transformers", "func": "apply_chunking_to_forward", "origin_file": "transformers/pytorch_utils.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 173, "func_end_lineno": 248, "key_block_start_lineno": 213, "key_block_end_lineno": 248, "new_func_code": "def apply_chunking_to_forward(\n    forward_fn: Callable[..., torch.Tensor],\n    chunk_size: int,\n    chunk_dim: int,\n    *input_tensors,\n) -> torch.Tensor:\n    \"\"\"\n    This function chunks the `input_tensors` into smaller input tensor parts of size `chunk_size` over the dimension\n    `chunk_dim`. It then applies a layer `forward_fn` to each chunk independently to save memory.\n\n    If the `forward_fn` is independent across the `chunk_dim` this function will yield the same result as directly\n    applying `forward_fn` to `input_tensors`.\n\n    Args:\n        forward_fn (`Callable[..., torch.Tensor]`):\n            The forward function of the model.\n        chunk_size (`int`):\n            The chunk size of a chunked tensor: `num_chunks = len(input_tensors[0]) / chunk_size`.\n        chunk_dim (`int`):\n            The dimension over which the `input_tensors` should be chunked.\n        input_tensors (`Tuple[torch.Tensor]`):\n            The input tensors of `forward_fn` which will be chunked\n\n    Returns:\n        `torch.Tensor`: A tensor with the same shape as the `forward_fn` would have given if applied`.\n\n\n    Examples:\n\n    ```python\n    # rename the usual forward() fn to forward_chunk()\n    def forward_chunk(self, hidden_states):\n        hidden_states = self.decoder(hidden_states)\n        return hidden_states\n\n\n    # implement a chunked forward function\n    def forward(self, hidden_states):\n        return apply_chunking_to_forward(self.forward_chunk, self.chunk_size_lm_head, self.seq_len_dim, hidden_states)\n    ```\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bertweet.tokenization_bertweet.get_pairs", "project": "transformers", "func": "get_pairs", "origin_file": "transformers/models/bertweet/tokenization_bertweet.py", "test_list": ["../tests/models/bertweet/test_tokenization_bertweet.py"], "prob_info": {"func_start_lineno": 38, "func_end_lineno": 51, "key_block_start_lineno": 44, "key_block_end_lineno": 51, "new_func_code": "def get_pairs(word):\n    \"\"\"\n    Return set of symbol pairs in a word.\n\n    Word is represented as tuple of symbols (symbols being variable-length strings).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas._process_date_pattern", "project": "transformers", "func": "_process_date_pattern", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/bertweet/test_tokenization_bertweet.py"], "prob_info": {"func_start_lineno": 2290, "func_end_lineno": 2301, "key_block_start_lineno": 2292, "key_block_end_lineno": 2301, "new_func_code": "def _process_date_pattern(dp):\n    \"\"\"Compute a regex for each date pattern to use as a prefilter.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bridgetower.image_processing_bridgetower.make_pixel_mask", "project": "transformers", "func": "make_pixel_mask", "origin_file": "transformers/models/bridgetower/image_processing_bridgetower.py", "test_list": ["../tests/models/bridgetower/test_image_processing_bridgetower.py"], "prob_info": {"func_start_lineno": 55, "func_end_lineno": 70, "key_block_start_lineno": 67, "key_block_end_lineno": 70, "new_func_code": "def make_pixel_mask(\n    image: np.ndarray, output_size: Tuple[int, int], input_data_format: Optional[Union[str, ChannelDimension]] = None\n) -> np.ndarray:\n    \"\"\"\n    Make a pixel mask for the image, where 1 indicates a valid pixel and 0 indicates padding.\n\n    Args:\n        image (`np.ndarray`):\n            Image to make the pixel mask for.\n        output_size (`Tuple[int, int]`):\n            Output size of the mask.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.chameleon.image_processing_chameleon.ChameleonImageProcessor::blend_rgba", "project": "transformers", "func": "ChameleonImageProcessor::blend_rgba", "origin_file": "transformers/models/chameleon/image_processing_chameleon.py", "test_list": ["../tests/models/chameleon/test_image_processing_chameleon.py"], "prob_info": {"func_start_lineno": 339, "func_end_lineno": 364, "key_block_start_lineno": 348, "key_block_end_lineno": 364, "new_func_code": "def blend_rgba(self, image: ImageInput) -> ImageInput:\n        \"\"\"\n        Convert image to RGB by blending the transparency layer if it's in RGBA format.\n        If image is not `PIL.Image`, it si simply returned without modifications.\n\n        Args:\n            image (`ImageInput`):\n                Image to convert.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.chameleon.image_processing_chameleon.make_batched_images", "project": "transformers", "func": "make_batched_images", "origin_file": "transformers/models/chameleon/image_processing_chameleon.py", "test_list": ["../tests/models/chameleon/test_image_processing_chameleon.py"], "prob_info": {"func_start_lineno": 47, "func_end_lineno": 67, "key_block_start_lineno": 58, "key_block_end_lineno": 67, "new_func_code": "def make_batched_images(images) -> List[List[ImageInput]]:\n    \"\"\"\n    Accepts images in list or nested list format, and makes a list of images for preprocessing.\n\n    Args:\n        images (`Union[List[List[ImageInput]], List[ImageInput], ImageInput]`):\n            The input image.\n\n    Returns:\n        list: A list of images.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.chinese_clip.image_processing_chinese_clip.ChineseCLIPImageProcessor::preprocess", "project": "transformers", "func": "ChineseCLIPImageProcessor::preprocess", "origin_file": "transformers/models/chinese_clip/image_processing_chinese_clip.py", "test_list": ["../tests/models/chinese_clip/test_image_processing_chinese_clip.py"], "prob_info": {"func_start_lineno": 165, "func_end_lineno": 306, "key_block_start_lineno": 234, "key_block_end_lineno": 306, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: int = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_convert_rgb: bool = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n                the longest edge resized to keep the input aspect ratio.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_center_crop`):\n                Whether to center crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the center crop. Only has an effect if `do_center_crop` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                `True`.\n            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n                Whether to convert the image to RGB.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                - Unset: Return a list of `np.ndarray`.\n                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.convert_to_rgb", "project": "transformers", "func": "convert_to_rgb", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/models/clip/test_image_processing_clip.py"], "prob_info": {"func_start_lineno": 754, "func_end_lineno": 771, "key_block_start_lineno": 762, "key_block_end_lineno": 771, "new_func_code": "def convert_to_rgb(image: ImageInput) -> ImageInput:\n    \"\"\"\n    Converts an image to RGB format. Only converts if the image is of type PIL.Image.Image, otherwise returns the image\n    as is.\n    Args:\n        image (Image):\n            The image to convert.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.convnext.image_processing_convnext.ConvNextImageProcessor::preprocess", "project": "transformers", "func": "ConvNextImageProcessor::preprocess", "origin_file": "transformers/models/convnext/image_processing_convnext.py", "test_list": ["../tests/models/convnext/test_image_processing_convnext.py"], "prob_info": {"func_start_lineno": 187, "func_end_lineno": 320, "key_block_start_lineno": 251, "key_block_end_lineno": 320, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        crop_pct: float = None,\n        resample: PILImageResampling = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: ChannelDimension = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the output image after `resize` has been applied. If `size[\"shortest_edge\"]` >= 384, the image\n                is resized to `(size[\"shortest_edge\"], size[\"shortest_edge\"])`. Otherwise, the smaller edge of the\n                image will be matched to `int(size[\"shortest_edge\"]/ crop_pct)`, after which the image is cropped to\n                `(size[\"shortest_edge\"], size[\"shortest_edge\"])`. Only has an effect if `do_resize` is set to `True`.\n            crop_pct (`float`, *optional*, defaults to `self.crop_pct`):\n                Percentage of the image to crop if size < 384.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of `PILImageResampling`, filters. Only\n                has an effect if `do_resize` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between [0 - 1].\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                    - Unset: Return a list of `np.ndarray`.\n                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.ctrl.tokenization_ctrl.get_pairs", "project": "transformers", "func": "get_pairs", "origin_file": "transformers/models/ctrl/tokenization_ctrl.py", "test_list": ["../tests/models/ctrl/test_tokenization_ctrl.py"], "prob_info": {"func_start_lineno": 94, "func_end_lineno": 107, "key_block_start_lineno": 100, "key_block_end_lineno": 107, "new_func_code": "def get_pairs(word):\n    \"\"\"\n    Return set of symbol pairs in a word.\n\n    Word is represented as tuple of symbols (symbols being variable-length strings).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.feature_extraction_utils.BatchFeature::to", "project": "transformers", "func": "BatchFeature::to", "origin_file": "transformers/feature_extraction_utils.py", "test_list": ["../tests/models/deit/test_image_processing_deit.py"], "prob_info": {"func_start_lineno": 206, "func_end_lineno": 248, "key_block_start_lineno": 220, "key_block_end_lineno": 248, "new_func_code": "def to(self, *args, **kwargs) -> \"BatchFeature\":\n        \"\"\"\n        Send all values to device by calling `v.to(*args, **kwargs)` (PyTorch only). This should support casting in\n        different `dtypes` and sending the `BatchFeature` to a different `device`.\n\n        Args:\n            args (`Tuple`):\n                Will be passed to the `to(...)` function of the tensors.\n            kwargs (`Dict`, *optional*):\n                Will be passed to the `to(...)` function of the tensors.\n\n        Returns:\n            [`BatchFeature`]: The same instance after modification.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.donut.image_processing_donut.DonutImageProcessor::thumbnail", "project": "transformers", "func": "DonutImageProcessor::thumbnail", "origin_file": "transformers/models/donut/image_processing_donut.py", "test_list": ["../tests/models/donut/test_image_processing_donut.py"], "prob_info": {"func_start_lineno": 209, "func_end_lineno": 257, "key_block_start_lineno": 234, "key_block_end_lineno": 257, "new_func_code": "def thumbnail(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize the image to make a thumbnail. The image is resized so that no dimension is larger than any\n        corresponding dimension of the specified size.\n\n        Args:\n            image (`np.ndarray`):\n                The image to be resized.\n            size (`Dict[str, int]`):\n                The size `{\"height\": h, \"width\": w}` to resize the image to.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                The resampling filter to use.\n            data_format (`Optional[Union[str, ChannelDimension]]`, *optional*):\n                The data format of the output image. If unset, the same format as the input image is used.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.donut.image_processing_donut.DonutImageProcessor::pad_image", "project": "transformers", "func": "DonutImageProcessor::pad_image", "origin_file": "transformers/models/donut/image_processing_donut.py", "test_list": ["../tests/models/donut/test_image_processing_donut.py"], "prob_info": {"func_start_lineno": 163, "func_end_lineno": 203, "key_block_start_lineno": 186, "key_block_end_lineno": 203, "new_func_code": "def pad_image(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        random_padding: bool = False,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> np.ndarray:\n        \"\"\"\n        Pad the image to the specified size.\n\n        Args:\n            image (`np.ndarray`):\n                The image to be padded.\n            size (`Dict[str, int]`):\n                The size `{\"height\": h, \"width\": w}` to pad the image to.\n            random_padding (`bool`, *optional*, defaults to `False`):\n                Whether to use random padding or not.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The data format of the output image. If unset, the same format as the input image is used.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.generic.to_numpy", "project": "transformers", "func": "to_numpy", "origin_file": "transformers/utils/generic.py", "test_list": ["../tests/models/donut/test_image_processing_donut.py"], "prob_info": {"func_start_lineno": 284, "func_end_lineno": 307, "key_block_start_lineno": 288, "key_block_end_lineno": 307, "new_func_code": "def to_numpy(obj):\n    \"\"\"\n    Convert a TensorFlow tensor, PyTorch tensor, Numpy array or python list to a Numpy array.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.dpt.image_processing_dpt.DPTImageProcessor::pad_image", "project": "transformers", "func": "DPTImageProcessor::pad_image", "origin_file": "transformers/models/dpt/image_processing_dpt.py", "test_list": ["../tests/models/dpt/test_image_processing_dpt.py"], "prob_info": {"func_start_lineno": 223, "func_end_lineno": 266, "key_block_start_lineno": 250, "key_block_end_lineno": 266, "new_func_code": "def pad_image(\n        self,\n        image: np.array,\n        size_divisor: int,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ):\n        \"\"\"\n        Center pad an image to be a multiple of `multiple`.\n\n        Args:\n            image (`np.ndarray`):\n                Image to pad.\n            size_divisor (`int`):\n                The width and height of the image will be padded to a multiple of this number.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.efficientnet.image_processing_efficientnet.EfficientNetImageProcessor::preprocess", "project": "transformers", "func": "EfficientNetImageProcessor::preprocess", "origin_file": "transformers/models/efficientnet/image_processing_efficientnet.py", "test_list": ["../tests/models/efficientnet/test_image_processing_efficientnet.py"], "prob_info": {"func_start_lineno": 212, "func_end_lineno": 366, "key_block_start_lineno": 282, "key_block_end_lineno": 366, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample=None,\n        do_center_crop: bool = None,\n        crop_size: Dict[str, int] = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        rescale_offset: bool = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        include_top: bool = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: ChannelDimension = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after `resize`.\n            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n                PILImageResampling filter to use if resizing the image Only has an effect if `do_resize` is set to\n                `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_center_crop`):\n                Whether to center crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the image after center crop. If one edge the image is smaller than `crop_size`, it will be\n                padded with zeros and then cropped\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between [0 - 1].\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            rescale_offset (`bool`, *optional*, defaults to `self.rescale_offset`):\n                Whether to rescale the image between [-scale_range, scale_range] instead of [0, scale_range].\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation.\n            include_top (`bool`, *optional*, defaults to `self.include_top`):\n                Rescales the image again for image classification if set to True.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                    - `None`: Return a list of `np.ndarray`.\n                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                    - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                    - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.flava.image_processing_flava.FlavaImageProcessor::preprocess", "project": "transformers", "func": "FlavaImageProcessor::preprocess", "origin_file": "transformers/models/flava/image_processing_flava.py", "test_list": ["../tests/models/flava/test_image_processing_flava.py"], "prob_info": {"func_start_lineno": 454, "func_end_lineno": 700, "key_block_start_lineno": 579, "key_block_end_lineno": 700, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        do_resize: Optional[bool] = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: Optional[bool] = None,\n        crop_size: Optional[Dict[str, int]] = None,\n        do_rescale: Optional[bool] = None,\n        rescale_factor: Optional[float] = None,\n        do_normalize: Optional[bool] = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        # Mask related params\n        return_image_mask: Optional[bool] = None,\n        input_size_patches: Optional[int] = None,\n        total_mask_patches: Optional[int] = None,\n        mask_group_min_patches: Optional[int] = None,\n        mask_group_max_patches: Optional[int] = None,\n        mask_group_min_aspect_ratio: Optional[float] = None,\n        mask_group_max_aspect_ratio: Optional[float] = None,\n        # Codebook related params\n        return_codebook_pixels: Optional[bool] = None,\n        codebook_do_resize: Optional[bool] = None,\n        codebook_size: Optional[Dict[str, int]] = None,\n        codebook_resample: Optional[int] = None,\n        codebook_do_center_crop: Optional[bool] = None,\n        codebook_crop_size: Optional[Dict[str, int]] = None,\n        codebook_do_rescale: Optional[bool] = None,\n        codebook_rescale_factor: Optional[float] = None,\n        codebook_do_map_pixels: Optional[bool] = None,\n        codebook_do_normalize: Optional[bool] = None,\n        codebook_image_mean: Optional[Iterable[float]] = None,\n        codebook_image_std: Optional[Iterable[float]] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: ChannelDimension = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`, Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_center_crop`):\n                Whether to center crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the center crop. Only has an effect if `do_center_crop` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between [0 - 1].\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation.\n            return_image_mask (`bool`, *optional*, defaults to `self.return_image_mask`):\n                Whether to return the image mask.\n            input_size_patches (`int`, *optional*, defaults to `self.input_size_patches`):\n                Size of the patches to extract from the image.\n            total_mask_patches (`int`, *optional*, defaults to `self.total_mask_patches`):\n                Total number of patches to extract from the image.\n            mask_group_min_patches (`int`, *optional*, defaults to `self.mask_group_min_patches`):\n                Minimum number of patches to extract from the image.\n            mask_group_max_patches (`int`, *optional*, defaults to `self.mask_group_max_patches`):\n                Maximum number of patches to extract from the image.\n            mask_group_min_aspect_ratio (`float`, *optional*, defaults to `self.mask_group_min_aspect_ratio`):\n                Minimum aspect ratio of the patches to extract from the image.\n            mask_group_max_aspect_ratio (`float`, *optional*, defaults to `self.mask_group_max_aspect_ratio`):\n                Maximum aspect ratio of the patches to extract from the image.\n            return_codebook_pixels (`bool`, *optional*, defaults to `self.return_codebook_pixels`):\n                Whether to return the codebook pixels.\n            codebook_do_resize (`bool`, *optional*, defaults to `self.codebook_do_resize`):\n                Whether to resize the codebook pixels.\n            codebook_size (`Dict[str, int]`, *optional*, defaults to `self.codebook_size`):\n                Size of the codebook pixels.\n            codebook_resample (`int`, *optional*, defaults to `self.codebook_resample`):\n                Resampling filter to use if resizing the codebook pixels. This can be one of the enum\n                `PILImageResampling`, Only has an effect if `codebook_do_resize` is set to `True`.\n            codebook_do_center_crop (`bool`, *optional*, defaults to `self.codebook_do_center_crop`):\n                Whether to center crop the codebook pixels.\n            codebook_crop_size (`Dict[str, int]`, *optional*, defaults to `self.codebook_crop_size`):\n                Size of the center crop of the codebook pixels. Only has an effect if `codebook_do_center_crop` is set\n                to `True`.\n            codebook_do_rescale (`bool`, *optional*, defaults to `self.codebook_do_rescale`):\n                Whether to rescale the codebook pixels values between [0 - 1].\n            codebook_rescale_factor (`float`, *optional*, defaults to `self.codebook_rescale_factor`):\n                Rescale factor to rescale the codebook pixels by if `codebook_do_rescale` is set to `True`.\n            codebook_do_map_pixels (`bool`, *optional*, defaults to `self.codebook_do_map_pixels`):\n                Whether to map the codebook pixels values.\n            codebook_do_normalize (`bool`, *optional*, defaults to `self.codebook_do_normalize`):\n                Whether to normalize the codebook pixels.\n            codebook_image_mean (`float` or `List[float]`, *optional*, defaults to `self.codebook_image_mean`):\n                Codebook pixels mean to normalize the codebook pixels by if `codebook_do_normalize` is set to `True`.\n            codebook_image_std (`float` or `List[float]`, *optional*, defaults to `self.codebook_image_std`):\n                Codebook pixels standard deviation to normalize the codebook pixels by if `codebook_do_normalize` is\n                set to `True`.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                    - Unset: Return a list of `np.ndarray`.\n                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                    - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                    - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.flava.image_processing_flava.FlavaImageProcessor::_preprocess_image", "project": "transformers", "func": "FlavaImageProcessor::_preprocess_image", "origin_file": "transformers/models/flava/image_processing_flava.py", "test_list": ["../tests/models/flava/test_image_processing_flava.py"], "prob_info": {"func_start_lineno": 389, "func_end_lineno": 451, "key_block_start_lineno": 407, "key_block_end_lineno": 451, "new_func_code": "def _preprocess_image(\n        self,\n        image: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: Dict[str, int] = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_map_pixels: bool = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[ChannelDimension] = None,\n    ) -> np.ndarray:\n        \"\"\"Preprocesses a single image.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.fuyu.image_processing_fuyu.FuyuImageProcessor::get_num_patches", "project": "transformers", "func": "FuyuImageProcessor::get_num_patches", "origin_file": "transformers/models/fuyu/image_processing_fuyu.py", "test_list": ["../tests/models/fuyu/test_image_processing_fuyu.py"], "prob_info": {"func_start_lineno": 539, "func_end_lineno": 562, "key_block_start_lineno": 551, "key_block_end_lineno": 562, "new_func_code": "def get_num_patches(self, image_height: int, image_width: int, patch_size: Dict[str, int] = None) -> int:\n        \"\"\"\n        Calculate number of patches required to encode an image.\n\n        Args:\n            image_height (`int`):\n                Height of the image.\n            image_width (`int`):\n                Width of the image.\n            patch_size (`Dict[str, int]`, *optional*, defaults to `self.patch_size`):\n                Dictionary in the format `{\"height\": int, \"width\": int}` specifying the size of the patches.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.fuyu.image_processing_fuyu.FuyuImageProcessor::patchify_image", "project": "transformers", "func": "FuyuImageProcessor::patchify_image", "origin_file": "transformers/models/fuyu/image_processing_fuyu.py", "test_list": ["../tests/models/fuyu/test_image_processing_fuyu.py"], "prob_info": {"func_start_lineno": 564, "func_end_lineno": 588, "key_block_start_lineno": 574, "key_block_end_lineno": 588, "new_func_code": "def patchify_image(self, image: \"torch.Tensor\", patch_size: Optional[Dict[str, int]] = None) -> \"torch.Tensor\":\n        \"\"\"\n        Convert an image into a tensor of patches.\n\n        Args:\n            image (`torch.Tensor`):\n                Image to convert. Shape: [batch, channels, height, width]\n            patch_size (`Dict[str, int]`, *optional*, defaults to `self.patch_size`):\n                Dictionary in the format `{\"height\": int, \"width\": int}` specifying the size of the patches.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.glpn.image_processing_glpn.GLPNImageProcessor::preprocess", "project": "transformers", "func": "GLPNImageProcessor::preprocess", "origin_file": "transformers/models/glpn/image_processing_glpn.py", "test_list": ["../tests/models/glpn/test_image_processing_glpn.py"], "prob_info": {"func_start_lineno": 126, "func_end_lineno": 220, "key_block_start_lineno": 172, "key_block_end_lineno": 220, "new_func_code": "def preprocess(\n        self,\n        images: Union[\"PIL.Image.Image\", TensorType, List[\"PIL.Image.Image\"], List[TensorType]],\n        do_resize: Optional[bool] = None,\n        size_divisor: Optional[int] = None,\n        resample=None,\n        do_rescale: Optional[bool] = None,\n        return_tensors: Optional[Union[TensorType, str]] = None,\n        data_format: ChannelDimension = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> BatchFeature:\n        \"\"\"\n        Preprocess the given images.\n\n        Args:\n            images (`PIL.Image.Image` or `TensorType` or `List[np.ndarray]` or `List[TensorType]`):\n                Images to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_normalize=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the input such that the (height, width) dimensions are a multiple of `size_divisor`.\n            size_divisor (`int`, *optional*, defaults to `self.size_divisor`):\n                When `do_resize` is `True`, images are resized so their height and width are rounded down to the\n                closest multiple of `size_divisor`.\n            resample (`PIL.Image` resampling filter, *optional*, defaults to `self.resample`):\n                `PIL.Image` resampling filter to use if resizing the image e.g. `PILImageResampling.BILINEAR`. Only has\n                an effect if `do_resize` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether or not to apply the scaling factor (to make pixel values floats between 0. and 1.).\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                    - `None`: Return a list of `np.ndarray`.\n                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                    - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                    - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.idefics2.image_processing_idefics2.Idefics2ImageProcessor::resize", "project": "transformers", "func": "Idefics2ImageProcessor::resize", "origin_file": "transformers/models/idefics2/image_processing_idefics2.py", "test_list": ["../tests/models/idefics2/test_image_processing_idefics2.py"], "prob_info": {"func_start_lineno": 249, "func_end_lineno": 284, "key_block_start_lineno": 274, "key_block_end_lineno": 284, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BILINEAR,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image. The shortest edge of the image is resized to size[\"shortest_edge\"], with the longest edge\n        resized to keep the input aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.idefics2.image_processing_idefics2.get_resize_output_image_size", "project": "transformers", "func": "get_resize_output_image_size", "origin_file": "transformers/models/idefics2/image_processing_idefics2.py", "test_list": ["../tests/models/idefics2/test_image_processing_idefics2.py"], "prob_info": {"func_start_lineno": 48, "func_end_lineno": 77, "key_block_start_lineno": 63, "key_block_end_lineno": 77, "new_func_code": "def get_resize_output_image_size(image, size, input_data_format) -> Tuple[int, int]:\n    \"\"\"\n    Get the output size of the image after resizing given a dictionary specifying the max and min sizes.\n\n    Args:\n        image (`np.ndarray`):\n            Image to resize.\n        size (`Dict[str, int]`):\n            Size of the output image containing the keys \"shortest_edge\" and \"longest_edge\".\n        input_data_format (`ChannelDimension` or `str`):\n            The channel dimension format of the input image.\n\n    Returns:\n        The output size of the image after resizing.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.idefics2.image_processing_idefics2.Idefics2ImageProcessor::pad", "project": "transformers", "func": "Idefics2ImageProcessor::pad", "origin_file": "transformers/models/idefics2/image_processing_idefics2.py", "test_list": ["../tests/models/idefics2/test_image_processing_idefics2.py"], "prob_info": {"func_start_lineno": 314, "func_end_lineno": 381, "key_block_start_lineno": 346, "key_block_end_lineno": 381, "new_func_code": "def pad(\n        self,\n        images: List[np.ndarray],\n        constant_values: Union[float, Iterable[float]] = 0,\n        return_pixel_mask: bool = True,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: Optional[ChannelDimension] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> BatchFeature:\n        \"\"\"\n        For a list of images, for each images, pads a batch of images to the bottom and right of the image with zeros to the size of largest height and width.\n        For each sample in the batch, pads the sample with empty images to the max_number of images per sample in the batch. Optionally returns a pixel mask.\n\n        Args:\n            images (`np.ndarray`):\n                List of list of images to pad. Pads to the largest height and width in the batch.\n            constant_values (`float` or `Iterable[float]`, *optional*):\n                The value to use for the padding if `mode` is `\"constant\"`.\n            return_pixel_mask (`bool`, *optional*, defaults to `True`):\n                Whether to return a pixel mask.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                    - Unset: Return a list of `np.ndarray`.\n                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_processing_utils.select_best_resolution", "project": "transformers", "func": "select_best_resolution", "origin_file": "transformers/image_processing_utils.py", "test_list": ["../tests/models/llava_next/test_image_processing_llava_next.py"], "prob_info": {"func_start_lineno": 252, "func_end_lineno": 287, "key_block_start_lineno": 269, "key_block_end_lineno": 287, "new_func_code": "def select_best_resolution(original_size: tuple, possible_resolutions: list) -> tuple:\n    \"\"\"\n    Selects the best resolution from a list of possible resolutions based on the original size.\n\n    This is done by calculating the effective and wasted resolution for each possible resolution.\n\n    The best fit resolution is the one that maximizes the effective resolution and minimizes the wasted resolution.\n\n    Args:\n        original_size (tuple):\n            The original size of the image in the format (height, width).\n        possible_resolutions (list):\n            A list of possible resolutions in the format [(height1, width1), (height2, width2), ...].\n\n    Returns:\n        tuple: The best fit resolution in the format (height, width).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_next.image_processing_llava_next.LlavaNextImageProcessor::_resize_for_patching", "project": "transformers", "func": "LlavaNextImageProcessor::_resize_for_patching", "origin_file": "transformers/models/llava_next/image_processing_llava_next.py", "test_list": ["../tests/models/llava_next/test_image_processing_llava_next.py"], "prob_info": {"func_start_lineno": 436, "func_end_lineno": 460, "key_block_start_lineno": 455, "key_block_end_lineno": 460, "new_func_code": "def _resize_for_patching(\n        self, image: np.array, target_resolution: tuple, resample, input_data_format: ChannelDimension\n    ) -> np.array:\n        \"\"\"\n        Resizes an image to a target resolution while maintaining aspect ratio.\n\n        Args:\n            image (np.array):\n                The input image.\n            target_resolution (tuple):\n                The target resolution (height, width) of the image.\n            resample (`PILImageResampling`):\n                Resampling filter to use if resizing the image.\n            input_data_format (`ChannelDimension` or `str`):\n                The channel dimension format of the input image.\n\n        Returns:\n            np.array: The resized and padded image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms._rescale_for_pil_conversion", "project": "transformers", "func": "_rescale_for_pil_conversion", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/models/llava_next/test_image_processing_llava_next.py"], "prob_info": {"func_start_lineno": 135, "func_end_lineno": 159, "key_block_start_lineno": 142, "key_block_end_lineno": 159, "new_func_code": "def _rescale_for_pil_conversion(image):\n    \"\"\"\n    Detects whether or not the image needs to be rescaled before being converted to a PIL image.\n\n    The assumption is that if the image is of type `np.float` and all values are between 0 and 1, it needs to be\n    rescaled.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_next.image_processing_llava_next.LlavaNextImageProcessor::_preprocess", "project": "transformers", "func": "LlavaNextImageProcessor::_preprocess", "origin_file": "transformers/models/llava_next/image_processing_llava_next.py", "test_list": ["../tests/models/llava_next/test_image_processing_llava_next.py"], "prob_info": {"func_start_lineno": 352, "func_end_lineno": 434, "key_block_start_lineno": 410, "key_block_end_lineno": 434, "new_func_code": "def _preprocess(\n        self,\n        images: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: int = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n                the longest edge resized to keep the input aspect ratio.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_center_crop`):\n                Whether to center crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the center crop. Only has an effect if `do_center_crop` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                `True`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_next.image_processing_llava_next.LlavaNextImageProcessor::resize", "project": "transformers", "func": "LlavaNextImageProcessor::resize", "origin_file": "transformers/models/llava_next/image_processing_llava_next.py", "test_list": ["../tests/models/llava_next/test_image_processing_llava_next.py"], "prob_info": {"func_start_lineno": 234, "func_end_lineno": 282, "key_block_start_lineno": 259, "key_block_end_lineno": 282, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image. The shortest edge of the image is resized to size[\"shortest_edge\"], with the longest edge\n        resized to keep the input aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_next_video.image_processing_llava_next_video.LlavaNextVideoImageProcessor::resize", "project": "transformers", "func": "LlavaNextVideoImageProcessor::resize", "origin_file": "transformers/models/llava_next_video/image_processing_llava_next_video.py", "test_list": ["../tests/models/llava_next_video/test_image_processing_llava_next_video.py"], "prob_info": {"func_start_lineno": 149, "func_end_lineno": 197, "key_block_start_lineno": 174, "key_block_end_lineno": 197, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image. The shortest edge of the image is resized to size[\"shortest_edge\"], with the longest edge\n        resized to keep the input aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_onevision.image_processing_llava_onevision.LlavaOnevisionImageProcessor::_resize_for_patching", "project": "transformers", "func": "LlavaOnevisionImageProcessor::_resize_for_patching", "origin_file": "transformers/models/llava_onevision/image_processing_llava_onevision.py", "test_list": ["../tests/models/llava_onevision/test_image_processing_llava_onevision.py"], "prob_info": {"func_start_lineno": 329, "func_end_lineno": 353, "key_block_start_lineno": 348, "key_block_end_lineno": 353, "new_func_code": "def _resize_for_patching(\n        self, image: np.array, target_resolution: tuple, resample, input_data_format: ChannelDimension\n    ) -> np.array:\n        \"\"\"\n        Resizes an image to a target resolution while maintaining aspect ratio.\n\n        Args:\n            image (np.array):\n                The input image.\n            target_resolution (tuple):\n                The target resolution (height, width) of the image.\n            resample (`PILImageResampling`):\n                Resampling filter to use if resizing the image.\n            input_data_format (`ChannelDimension` or `str`):\n                The channel dimension format of the input image.\n\n        Returns:\n            np.array: The resized and padded image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_onevision.image_processing_llava_onevision.divide_to_patches", "project": "transformers", "func": "divide_to_patches", "origin_file": "transformers/models/llava_onevision/image_processing_llava_onevision.py", "test_list": ["../tests/models/llava_onevision/test_image_processing_llava_onevision.py"], "prob_info": {"func_start_lineno": 79, "func_end_lineno": 104, "key_block_start_lineno": 94, "key_block_end_lineno": 104, "new_func_code": "def divide_to_patches(image: np.array, patch_size: int, input_data_format) -> List[np.array]:\n    \"\"\"\n    Divides an image into patches of a specified size.\n\n    Args:\n        image (`np.array`):\n            The input image.\n        patch_size (`int`):\n            The size of each patch.\n        input_data_format (`ChannelDimension` or `str`):\n            The channel dimension format of the input image.\n\n    Returns:\n        list: A list of np.array representing the patches.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_onevision.image_processing_llava_onevision.LlavaOnevisionImageProcessor::_pad_for_batching", "project": "transformers", "func": "LlavaOnevisionImageProcessor::_pad_for_batching", "origin_file": "transformers/models/llava_onevision/image_processing_llava_onevision.py", "test_list": ["../tests/models/llava_onevision/test_image_processing_llava_onevision.py"], "prob_info": {"func_start_lineno": 438, "func_end_lineno": 475, "key_block_start_lineno": 464, "key_block_end_lineno": 475, "new_func_code": "def _pad_for_batching(\n        self,\n        pixel_values: List[np.ndarray],\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ):\n        \"\"\"\n        Pads images on the `num_of_patches` dimension with zeros to form a batch of same number of patches.\n\n        Args:\n            pixel_values (`List[np.ndarray]`):\n                An array of pixel values of each images of shape (`batch_size`, `num_patches`, `image_in_3D`)\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format for the output image. Can be one of:\n                    - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                    - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                If unset, will use same as the input image.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format for the input image. Can be one of:\n                    - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                    - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                If unset, will use the inferred format of the input image.\n\n        Returns:\n            List[`np.ndarray`]: The padded images.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_onevision.video_processing_llava_onevision.LlavaOnevisionVideoProcessor::_preprocess", "project": "transformers", "func": "LlavaOnevisionVideoProcessor::_preprocess", "origin_file": "transformers/models/llava_onevision/video_processing_llava_onevision.py", "test_list": ["../tests/models/llava_onevision/test_image_processing_llava_onevision.py"], "prob_info": {"func_start_lineno": 127, "func_end_lineno": 216, "key_block_start_lineno": 178, "key_block_end_lineno": 216, "new_func_code": "def _preprocess(\n        self,\n        images: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_convert_rgb: bool = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> Image.Image:\n        \"\"\"\n        Args:\n            images (`ImageInput`):\n                Batch of frames (one video) to preprocess. Expects a batch of frames with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n                the longest edge resized to keep the input aspect ratio.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n                has an effect if `do_resize` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                `True`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.owlvit.image_processing_owlvit.OwlViTImageProcessor::center_crop", "project": "transformers", "func": "OwlViTImageProcessor::center_crop", "origin_file": "transformers/models/owlvit/image_processing_owlvit.py", "test_list": ["../tests/models/owlvit/test_image_processing_owlvit.py"], "prob_info": {"func_start_lineno": 208, "func_end_lineno": 240, "key_block_start_lineno": 230, "key_block_end_lineno": 240, "new_func_code": "def center_crop(\n        self,\n        image: np.ndarray,\n        crop_size: Dict[str, int],\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Center crop an image to a certain size.\n\n        Args:\n            image (`np.ndarray`):\n                Image to center crop.\n            crop_size (`Dict[str, int]`):\n                The size to center crop the image to. Must contain height and width keys.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format for the output image. If unset, the channel dimension format of the input\n                image is used.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.owlvit.image_processing_owlvit.OwlViTImageProcessor::rescale", "project": "transformers", "func": "OwlViTImageProcessor::rescale", "origin_file": "transformers/models/owlvit/image_processing_owlvit.py", "test_list": ["../tests/models/owlvit/test_image_processing_owlvit.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 269, "key_block_start_lineno": 269, "key_block_end_lineno": 269, "new_func_code": "def rescale(\n        self,\n        image: np.ndarray,\n        rescale_factor: float,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> np.ndarray:\n        \"\"\"\n        Rescale the image by the given factor. image = image * rescale_factor.\n\n        Args:\n            image (`np.ndarray`):\n                Image to rescale.\n            rescale_factor (`float`):\n                The value to use for rescaling.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format for the output image. If unset, the channel dimension format of the input\n                image is used. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format for the input image. If unset, is inferred from the input image. Can be\n                one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.poolformer.image_processing_poolformer.PoolFormerImageProcessor::preprocess", "project": "transformers", "func": "PoolFormerImageProcessor::preprocess", "origin_file": "transformers/models/poolformer/image_processing_poolformer.py", "test_list": ["../tests/models/poolformer/test_image_processing_poolformer.py"], "prob_info": {"func_start_lineno": 213, "func_end_lineno": 357, "key_block_start_lineno": 279, "key_block_end_lineno": 357, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        crop_pct: int = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: Dict[str, int] = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: ChannelDimension = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after applying resize.\n            crop_pct (`float`, *optional*, defaults to `self.crop_pct`):\n                Percentage of the image to crop. Only has an effect if `do_resize` is set to `True`.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`, Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_center_crop`):\n                Whether to center crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the image after applying center crop.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between [0 - 1].\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                    - Unset: Return a list of `np.ndarray`.\n                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                    - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                    - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.pvt.image_processing_pvt.PvtImageProcessor::preprocess", "project": "transformers", "func": "PvtImageProcessor::preprocess", "origin_file": "transformers/models/pvt/image_processing_pvt.py", "test_list": ["../tests/models/pvt/test_image_processing_pvt.py"], "prob_info": {"func_start_lineno": 149, "func_end_lineno": 273, "key_block_start_lineno": 208, "key_block_end_lineno": 273, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        do_resize: Optional[bool] = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_rescale: Optional[bool] = None,\n        rescale_factor: Optional[float] = None,\n        do_normalize: Optional[bool] = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: Union[str, ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ):\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Dictionary in the format `{\"height\": h, \"width\": w}` specifying the size of the output image after\n                resizing.\n            resample (`PILImageResampling` filter, *optional*, defaults to `self.resample`):\n                `PILImageResampling` filter to use if resizing the image e.g. `PILImageResampling.BILINEAR`. Only has\n                an effect if `do_resize` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between [0 - 1].\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use if `do_normalize` is set to `True`.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                - Unset: Return a list of `np.ndarray`.\n                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.roc_bert.tokenization_roc_bert.RoCBertWordpieceTokenizer::tokenize", "project": "transformers", "func": "RoCBertWordpieceTokenizer::tokenize", "origin_file": "transformers/models/roc_bert/tokenization_roc_bert.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 1062, "func_end_lineno": 1108, "key_block_start_lineno": 1076, "key_block_end_lineno": 1108, "new_func_code": "def tokenize(self, text):\n        \"\"\"\n        Tokenizes a piece of text into its word pieces. This uses a greedy longest-match-first algorithm to perform\n        tokenization using the given vocabulary.\n\n        For example, `input = \"unaffable\"` wil return as output `[\"un\", \"##aff\", \"##able\"]`.\n\n        Args:\n            text: A single token or whitespace separated tokens. This should have\n                already been passed through *BasicTokenizer*.\n\n        Returns:\n            A list of wordpiece tokens.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.roc_bert.tokenization_roc_bert.RoCBertBasicTokenizer::_run_split_on_punc", "project": "transformers", "func": "RoCBertBasicTokenizer::_run_split_on_punc", "origin_file": "transformers/models/roc_bert/tokenization_roc_bert.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 980, "func_end_lineno": 1000, "key_block_start_lineno": 982, "key_block_end_lineno": 1000, "new_func_code": "def _run_split_on_punc(self, text, never_split=None):\n        \"\"\"Splits punctuation on a piece of text.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.roc_bert.tokenization_roc_bert.RoCBertTokenizer::_batch_prepare_for_model", "project": "transformers", "func": "RoCBertTokenizer::_batch_prepare_for_model", "origin_file": "transformers/models/roc_bert/tokenization_roc_bert.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 642, "func_end_lineno": 714, "key_block_start_lineno": 671, "key_block_end_lineno": 714, "new_func_code": "def _batch_prepare_for_model(\n        self,\n        batch_ids_pairs: List[Union[PreTokenizedInputPair, Tuple[List[int], None]]],\n        batch_shape_ids_pairs: List[Union[PreTokenizedInputPair, Tuple[List[int], None]]],\n        batch_pronunciation_ids_pairs: List[Union[PreTokenizedInputPair, Tuple[List[int], None]]],\n        add_special_tokens: bool = True,\n        padding_strategy: PaddingStrategy = PaddingStrategy.DO_NOT_PAD,\n        truncation_strategy: TruncationStrategy = TruncationStrategy.DO_NOT_TRUNCATE,\n        max_length: Optional[int] = None,\n        stride: int = 0,\n        pad_to_multiple_of: Optional[int] = None,\n        return_tensors: Optional[str] = None,\n        return_token_type_ids: Optional[bool] = None,\n        return_attention_mask: Optional[bool] = None,\n        return_overflowing_tokens: bool = False,\n        return_special_tokens_mask: bool = False,\n        return_length: bool = False,\n        verbose: bool = True,\n    ) -> BatchEncoding:\n        \"\"\"\n        Prepares a sequence of input id, or a pair of sequences of inputs ids so that it can be used by the model. It\n        adds special tokens, truncates sequences if overflowing while taking into account the special tokens and\n        manages a moving window (with user defined stride) for overflowing tokens\n\n        Args:\n            batch_ids_pairs: list of tokenized input ids or input ids pairs\n            batch_shape_ids_pairs: list of tokenized input shape ids or input shape ids pairs\n            batch_pronunciation_ids_pairs: list of tokenized input pronunciation ids or input pronunciation ids pairs\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.roc_bert.tokenization_roc_bert.RoCBertBasicTokenizer::tokenize", "project": "transformers", "func": "RoCBertBasicTokenizer::tokenize", "origin_file": "transformers/models/roc_bert/tokenization_roc_bert.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 931, "func_end_lineno": 967, "key_block_start_lineno": 940, "key_block_end_lineno": 967, "new_func_code": "def tokenize(self, text, never_split=None):\n        \"\"\"\n        Basic Tokenization of a piece of text. For sub-word tokenization, see WordPieceTokenizer.\n\n        Args:\n            never_split (`List[str]`, *optional*)\n                Kept for backward compatibility purposes. Now implemented directly at the base class level (see\n                [`PreTrainedTokenizer.tokenize`]) List of token not to split.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.roc_bert.tokenization_roc_bert.RoCBertTokenizer::get_special_tokens_mask", "project": "transformers", "func": "RoCBertTokenizer::get_special_tokens_mask", "origin_file": "transformers/models/roc_bert/tokenization_roc_bert.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 788, "func_end_lineno": 814, "key_block_start_lineno": 806, "key_block_end_lineno": 814, "new_func_code": "def get_special_tokens_mask(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None, already_has_special_tokens: bool = False\n    ) -> List[int]:\n        \"\"\"\n        Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer `prepare_for_model` method.\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of IDs.\n            token_ids_1 (`List[int]`, *optional*):\n                Optional second list of IDs for sequence pairs.\n            already_has_special_tokens (`bool`, *optional*, defaults to `False`):\n                Whether or not the token list is already formatted with special tokens for the model.\n\n        Returns:\n            `List[int]`: A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.tokenization_utils_base.BatchEncoding::to", "project": "transformers", "func": "BatchEncoding::to", "origin_file": "transformers/tokenization_utils_base.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 800, "func_end_lineno": 819, "key_block_start_lineno": 810, "key_block_end_lineno": 819, "new_func_code": "def to(self, device: Union[str, \"torch.device\"]) -> \"BatchEncoding\":\n        \"\"\"\n        Send all values to device by calling `v.to(device)` (PyTorch only).\n\n        Args:\n            device (`str` or `torch.device`): The device to put the tensors on.\n\n        Returns:\n            [`BatchEncoding`]: The same instance after modification.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.roc_bert.modeling_roc_bert.RoCBertModel::forward", "project": "transformers", "func": "RoCBertModel::forward", "origin_file": "transformers/models/roc_bert/modeling_roc_bert.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 939, "func_end_lineno": 1070, "key_block_start_lineno": 976, "key_block_end_lineno": 1070, "new_func_code": "def forward(\n        self,\n        input_ids: Optional[torch.Tensor] = None,\n        input_shape_ids: Optional[torch.Tensor] = None,\n        input_pronunciation_ids: Optional[torch.Tensor] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        token_type_ids: Optional[torch.Tensor] = None,\n        position_ids: Optional[torch.Tensor] = None,\n        head_mask: Optional[torch.Tensor] = None,\n        inputs_embeds: Optional[torch.Tensor] = None,\n        encoder_hidden_states: Optional[torch.Tensor] = None,\n        encoder_attention_mask: Optional[torch.Tensor] = None,\n        past_key_values: Optional[List[torch.FloatTensor]] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple[torch.Tensor], BaseModelOutputWithPoolingAndCrossAttentions]:\n        r\"\"\"\n        encoder_hidden_states  (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n            Sequence of hidden-states at the output of the last layer of the encoder. Used in the cross-attention if\n            the model is configured as a decoder.\n        encoder_attention_mask (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Mask to avoid performing attention on the padding token indices of the encoder input. This mask is used in\n            the cross-attention if the model is configured as a decoder. Mask values selected in `[0, 1]`:\n\n            - 1 for tokens that are **not masked**,\n            - 0 for tokens that are **masked**.\n        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n        use_cache (`bool`, *optional*):\n            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n            `past_key_values`).\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.generic.is_tensor", "project": "transformers", "func": "is_tensor", "origin_file": "transformers/utils/generic.py", "test_list": ["../tests/models/roc_bert/test_tokenization_roc_bert.py"], "prob_info": {"func_start_lineno": 119, "func_end_lineno": 140, "key_block_start_lineno": 124, "key_block_end_lineno": 140, "new_func_code": "def is_tensor(x):\n    \"\"\"\n    Tests if `x` is a `torch.Tensor`, `tf.Tensor`, `jaxlib.xla_extension.DeviceArray`, `np.ndarray` or `mlx.array`\n    in the order defined by `infer_framework_from_repr`\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.backbone_utils.verify_out_features_out_indices", "project": "transformers", "func": "verify_out_features_out_indices", "origin_file": "transformers/utils/backbone_utils.py", "test_list": ["../tests/models/rt_detr/test_modeling_rt_detr_resnet.py"], "prob_info": {"func_start_lineno": 32, "func_end_lineno": 74, "key_block_start_lineno": 38, "key_block_end_lineno": 74, "new_func_code": "def verify_out_features_out_indices(\n    out_features: Optional[Iterable[str]], out_indices: Optional[Iterable[int]], stage_names: Optional[Iterable[str]]\n):\n    \"\"\"\n    Verify that out_indices and out_features are valid for the given stage_names.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.superpoint.image_processing_superpoint.SuperPointImageProcessor::resize", "project": "transformers", "func": "SuperPointImageProcessor::resize", "origin_file": "transformers/models/superpoint/image_processing_superpoint.py", "test_list": ["../tests/models/superpoint/test_image_processing_superpoint.py"], "prob_info": {"func_start_lineno": 125, "func_end_lineno": 162, "key_block_start_lineno": 154, "key_block_end_lineno": 162, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Resize an image.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Dictionary of the form `{\"height\": int, \"width\": int}`, specifying the size of the output image.\n            data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the output image. If not provided, it will be inferred from the input\n                image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.swin2sr.image_processing_swin2sr.Swin2SRImageProcessor::preprocess", "project": "transformers", "func": "Swin2SRImageProcessor::preprocess", "origin_file": "transformers/models/swin2sr/image_processing_swin2sr.py", "test_list": ["../tests/models/swin2sr/test_image_processing_swin2sr.py"], "prob_info": {"func_start_lineno": 111, "func_end_lineno": 203, "key_block_start_lineno": 157, "key_block_end_lineno": 203, "new_func_code": "def preprocess(\n        self,\n        images: ImageInput,\n        do_rescale: Optional[bool] = None,\n        rescale_factor: Optional[float] = None,\n        do_pad: Optional[bool] = None,\n        pad_size: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: Union[str, ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ):\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between [0 - 1].\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_pad (`bool`, *optional*, defaults to `True`):\n                Whether to pad the image to make the height and width divisible by `window_size`.\n            pad_size (`int`, *optional*, defaults to 32):\n                The size of the sliding window for the local attention.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                - Unset: Return a list of `np.ndarray`.\n                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of typ, input_data_format=input_data_formate\n                  `tf.Tensor`.\n                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::encode", "project": "transformers", "func": "TapasTokenizer::encode", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 855, "func_end_lineno": 895, "key_block_start_lineno": 884, "key_block_end_lineno": 895, "new_func_code": "def encode(\n        self,\n        table: \"pd.DataFrame\",\n        query: Optional[\n            Union[\n                TextInput,\n                PreTokenizedInput,\n                EncodedInput,\n            ]\n        ] = None,\n        add_special_tokens: bool = True,\n        padding: Union[bool, str, PaddingStrategy] = False,\n        truncation: Union[bool, str, TapasTruncationStrategy] = False,\n        max_length: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        **kwargs,\n    ) -> List[int]:\n        \"\"\"\n        Prepare a table and a string for the model. This method does not return token type IDs, attention masks, etc.\n        which are necessary for the model to work correctly. Use that method if you want to build your processing on\n        your own, otherwise refer to `__call__`.\n\n        Args:\n            table (`pd.DataFrame`):\n                Table containing tabular data. Note that all cell values must be text. Use *.astype(str)* on a Pandas\n                dataframe to convert it to string.\n            query (`str` or `List[str]`):\n                Question related to a table to be encoded.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.BasicTokenizer::tokenize", "project": "transformers", "func": "BasicTokenizer::tokenize", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 2003, "func_end_lineno": 2039, "key_block_start_lineno": 2012, "key_block_end_lineno": 2039, "new_func_code": "def tokenize(self, text, never_split=None):\n        \"\"\"\n        Basic Tokenization of a piece of text. For sub-word tokenization, see WordPieceTokenizer.\n\n        Args:\n            never_split (`List[str]`, *optional*)\n                Kept for backward compatibility purposes. Now implemented directly at the base class level (see\n                [`PreTrainedTokenizer.tokenize`]) List of token not to split.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.BasicTokenizer::_run_split_on_punc", "project": "transformers", "func": "BasicTokenizer::_run_split_on_punc", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 2052, "func_end_lineno": 2072, "key_block_start_lineno": 2054, "key_block_end_lineno": 2072, "new_func_code": "def _run_split_on_punc(self, text, never_split=None):\n        \"\"\"Splits punctuation on a piece of text.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::build_inputs_with_special_tokens", "project": "transformers", "func": "TapasTokenizer::build_inputs_with_special_tokens", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 452, "func_end_lineno": 469, "key_block_start_lineno": 466, "key_block_end_lineno": 469, "new_func_code": "def build_inputs_with_special_tokens(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n    ) -> List[int]:\n        \"\"\"\n        Build model inputs from a question and flattened table for question answering or sequence classification tasks\n        by concatenating and adding special tokens.\n\n        Args:\n            token_ids_0 (`List[int]`): The ids of the question.\n            token_ids_1 (`List[int]`, *optional*): The ids of the flattened table.\n\n        Returns:\n            `List[int]`: The model input with special tokens.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::batch_encode_plus", "project": "transformers", "func": "TapasTokenizer::batch_encode_plus", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 617, "func_end_lineno": 711, "key_block_start_lineno": 670, "key_block_end_lineno": 711, "new_func_code": "def batch_encode_plus(\n        self,\n        table: \"pd.DataFrame\",\n        queries: Optional[\n            Union[\n                List[TextInput],\n                List[PreTokenizedInput],\n                List[EncodedInput],\n            ]\n        ] = None,\n        answer_coordinates: Optional[List[List[Tuple]]] = None,\n        answer_text: Optional[List[List[TextInput]]] = None,\n        add_special_tokens: bool = True,\n        padding: Union[bool, str, PaddingStrategy] = False,\n        truncation: Union[bool, str, TapasTruncationStrategy] = False,\n        max_length: Optional[int] = None,\n        pad_to_multiple_of: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        return_token_type_ids: Optional[bool] = None,\n        return_attention_mask: Optional[bool] = None,\n        return_overflowing_tokens: bool = False,\n        return_special_tokens_mask: bool = False,\n        return_offsets_mapping: bool = False,\n        return_length: bool = False,\n        verbose: bool = True,\n        **kwargs,\n    ) -> BatchEncoding:\n        \"\"\"\n        Prepare a table and a list of strings for the model.\n\n        <Tip warning={true}>\n\n        This method is deprecated, `__call__` should be used instead.\n\n        </Tip>\n\n        Args:\n            table (`pd.DataFrame`):\n                Table containing tabular data. Note that all cell values must be text. Use *.astype(str)* on a Pandas\n                dataframe to convert it to string.\n            queries (`List[str]`):\n                Batch of questions related to a table to be encoded. Note that all questions must refer to the **same**\n                table.\n            answer_coordinates (`List[Tuple]` or `List[List[Tuple]]`, *optional*):\n                Answer coordinates of each table-question pair in the batch. Each tuple must be a (row_index,\n                column_index) pair. The first data row (not the column header row) has index 0. The first column has\n                index 0. The answer_coordinates must be a list of lists of tuples (each list corresponding to a single\n                table-question pair).\n            answer_text (`List[str]` or `List[List[str]]`, *optional*):\n                Answer text of each table-question pair in the batch. In case a batch of table-question pairs is\n                provided, then the answer_coordinates must be a list of lists of strings (each list corresponding to a\n                single table-question pair). Each string must be the answer text of a corresponding answer coordinate.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::__call__", "project": "transformers", "func": "TapasTokenizer::__call__", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 500, "func_end_lineno": 614, "key_block_start_lineno": 554, "key_block_end_lineno": 614, "new_func_code": "def __call__(\n        self,\n        table: \"pd.DataFrame\",\n        queries: Optional[\n            Union[\n                TextInput,\n                PreTokenizedInput,\n                EncodedInput,\n                List[TextInput],\n                List[PreTokenizedInput],\n                List[EncodedInput],\n            ]\n        ] = None,\n        answer_coordinates: Optional[Union[List[Tuple], List[List[Tuple]]]] = None,\n        answer_text: Optional[Union[List[TextInput], List[List[TextInput]]]] = None,\n        add_special_tokens: bool = True,\n        padding: Union[bool, str, PaddingStrategy] = False,\n        truncation: Union[bool, str, TapasTruncationStrategy] = False,\n        max_length: Optional[int] = None,\n        pad_to_multiple_of: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        return_token_type_ids: Optional[bool] = None,\n        return_attention_mask: Optional[bool] = None,\n        return_overflowing_tokens: bool = False,\n        return_special_tokens_mask: bool = False,\n        return_offsets_mapping: bool = False,\n        return_length: bool = False,\n        verbose: bool = True,\n        **kwargs,\n    ) -> BatchEncoding:\n        \"\"\"\n        Main method to tokenize and prepare for the model one or several sequence(s) related to a table.\n\n        Args:\n            table (`pd.DataFrame`):\n                Table containing tabular data. Note that all cell values must be text. Use *.astype(str)* on a Pandas\n                dataframe to convert it to string.\n            queries (`str` or `List[str]`):\n                Question or batch of questions related to a table to be encoded. Note that in case of a batch, all\n                questions must refer to the **same** table.\n            answer_coordinates (`List[Tuple]` or `List[List[Tuple]]`, *optional*):\n                Answer coordinates of each table-question pair in the batch. In case only a single table-question pair\n                is provided, then the answer_coordinates must be a single list of one or more tuples. Each tuple must\n                be a (row_index, column_index) pair. The first data row (not the column header row) has index 0. The\n                first column has index 0. In case a batch of table-question pairs is provided, then the\n                answer_coordinates must be a list of lists of tuples (each list corresponding to a single\n                table-question pair).\n            answer_text (`List[str]` or `List[List[str]]`, *optional*):\n                Answer text of each table-question pair in the batch. In case only a single table-question pair is\n                provided, then the answer_text must be a single list of one or more strings. Each string must be the\n                answer text of a corresponding answer coordinate. In case a batch of table-question pairs is provided,\n                then the answer_coordinates must be a list of lists of strings (each list corresponding to a single\n                table-question pair).\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas._consolidate_numeric_values", "project": "transformers", "func": "_consolidate_numeric_values", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 2609, "func_end_lineno": 2653, "key_block_start_lineno": 2625, "key_block_end_lineno": 2653, "new_func_code": "def _consolidate_numeric_values(row_index_to_values, min_consolidation_fraction, debug_info):\n    \"\"\"\n    Finds the most common numeric values in a column and returns them\n\n    Args:\n        row_index_to_values:\n            For each row index all the values in that cell.\n        min_consolidation_fraction:\n            Fraction of cells that need to have consolidated value.\n        debug_info:\n            Additional information only used for logging\n\n    Returns:\n        For each row index the first value that matches the most common value. Rows that don't have a matching value\n        are dropped. Empty list if values can't be consolidated.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::get_special_tokens_mask", "project": "transformers", "func": "TapasTokenizer::get_special_tokens_mask", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 471, "func_end_lineno": 497, "key_block_start_lineno": 489, "key_block_end_lineno": 497, "new_func_code": "def get_special_tokens_mask(\n        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None, already_has_special_tokens: bool = False\n    ) -> List[int]:\n        \"\"\"\n        Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding\n        special tokens using the tokenizer `prepare_for_model` method.\n\n        Args:\n            token_ids_0 (`List[int]`):\n                List of question IDs.\n            token_ids_1 (`List[int]`, *optional*):\n                List of flattened table IDs.\n            already_has_special_tokens (`bool`, *optional*, defaults to `False`):\n                Whether or not the token list is already formatted with special tokens for the model.\n\n        Returns:\n            `List[int]`: A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.get_numeric_sort_key_fn", "project": "transformers", "func": "get_numeric_sort_key_fn", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 2562, "func_end_lineno": 2606, "key_block_start_lineno": 2579, "key_block_end_lineno": 2606, "new_func_code": "def get_numeric_sort_key_fn(numeric_values):\n    \"\"\"\n    Creates a function that can be used as a sort key or to compare the values. Maps to primitive types and finds the\n    biggest common subset. Consider the values \"05/05/2010\" and \"August 2007\". With the corresponding primitive values\n    (2010.,5.,5.) and (2007.,8., None). These values can be compared by year and date so we map to the sequence (2010.,\n    5.), (2007., 8.). If we added a third value \"2006\" with primitive value (2006., None, None), we could only compare\n    by the year so we would map to (2010.,), (2007.,) and (2006.,).\n\n    Args:\n     numeric_values: Values to compare\n\n    Returns:\n     A function that can be used as a sort key function (mapping numeric values to a comparable tuple)\n\n    Raises:\n      ValueError if values don't have a common type or are not comparable.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::_get_truncated_table_rows", "project": "transformers", "func": "TapasTokenizer::_get_truncated_table_rows", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1229, "func_end_lineno": 1284, "key_block_start_lineno": 1260, "key_block_end_lineno": 1284, "new_func_code": "def _get_truncated_table_rows(\n        self,\n        query_tokens: List[str],\n        tokenized_table: TokenizedTable,\n        num_rows: int,\n        num_columns: int,\n        max_length: int,\n        truncation_strategy: Union[str, TapasTruncationStrategy],\n    ) -> Tuple[int, int]:\n        \"\"\"\n        Truncates a sequence pair in-place following the strategy.\n\n        Args:\n            query_tokens (`List[str]`):\n                List of strings corresponding to the tokenized query.\n            tokenized_table (`TokenizedTable`):\n                Tokenized table\n            num_rows (`int`):\n                Total number of table rows\n            num_columns (`int`):\n                Total number of table columns\n            max_length (`int`):\n                Total maximum length.\n            truncation_strategy (`str` or [`TapasTruncationStrategy]`):\n                Truncation strategy to use. Seeing as this method should only be called when truncating, the only\n                available strategy is the `\"drop_rows_to_fit\"` strategy.\n\n        Returns:\n            `Tuple(int, int)`: tuple containing the number of rows after truncation, and the number of tokens available\n            for each table element.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::_get_token_budget", "project": "transformers", "func": "TapasTokenizer::_get_token_budget", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1335, "func_end_lineno": 1347, "key_block_start_lineno": 1345, "key_block_end_lineno": 1347, "new_func_code": "def _get_token_budget(self, question_tokens, max_length=None):\n        \"\"\"\n        Computes the number of tokens left for the table after tokenizing a question, taking into account the max\n        sequence length of the model.\n\n        Args:\n            question_tokens (`List[String]`):\n                List of question tokens. Returns: `int`: the number of tokens left for the table, given the model max\n                length.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.tokenization_tapas.TapasTokenizer::_get_table_values", "project": "transformers", "func": "TapasTokenizer::_get_table_values", "origin_file": "transformers/models/tapas/tokenization_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1349, "func_end_lineno": 1366, "key_block_start_lineno": 1351, "key_block_end_lineno": 1366, "new_func_code": "def _get_table_values(self, table, num_columns, num_rows, num_tokens) -> Generator[TableValue, None, None]:\n        \"\"\"Iterates over partial table and returns token, column and row indexes.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.modeling_tapas.reduce_min", "project": "transformers", "func": "reduce_min", "origin_file": "transformers/models/tapas/modeling_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1858, "func_end_lineno": 1882, "key_block_start_lineno": 1882, "key_block_end_lineno": 1882, "new_func_code": "def reduce_min(values, index, name=\"segmented_reduce_min\"):\n    \"\"\"\n    Computes the minimum over segments.\n\n    This operations computes the minimum over segments, with support for:\n\n        - Batching using the first dimensions [B1, B2, ..., Bn]. Each element in a batch can have different indices.\n        - Vectorization using the last dimension [V1, V2, ...]. If they are present, the output will be an element-wise\n          minimum of vectors rather than scalars.\n\n    Only the middle dimensions [I1, ..., Ik] are reduced by the operation.\n\n    Args:\n        values (`torch.Tensor` of shape [B1, B2, ..., Bn, I1, .., Ik, V1, V2, ..]):\n            Tensor containing the values of which the min must be taken segment-wise.\n        index (`IndexMap`, indices are of shape [B1, B2, ..., Bn, I1, .., Ik].):\n            Index defining the segments.\n        name (`str`, *optional*, defaults to 'segmented_reduce_sum'):\n            Name for the operation. Currently not used\n\n    Returns:\n        output_values (`torch.Tensor`of shape [B1, B2, ..., Bn, num_segments, V1, V2, ..]): Tensor containing the\n        output values. output_index (`IndexMap`): IndexMap with shape [B1, B2, ..., Bn, num_segments].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.modeling_tapas._segment_reduce", "project": "transformers", "func": "_segment_reduce", "origin_file": "transformers/models/tapas/modeling_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1727, "func_end_lineno": 1772, "key_block_start_lineno": 1744, "key_block_end_lineno": 1772, "new_func_code": "def _segment_reduce(values, index, segment_reduce_fn, name):\n    \"\"\"\n    Applies a segment reduction segment-wise.\n\n    Args:\n        values (`torch.Tensor`):\n            Tensor with segment values.\n        index (`IndexMap`):\n            IndexMap.\n        segment_reduce_fn (`str`):\n            Name for the reduce operation. One of \"sum\", \"mean\", \"max\" or \"min\".\n        name (`str`):\n            Name for the operation. Currently not used\n\n    Returns:\n        (`IndexMap`): IndexMap of shape batch_shape with elements equal to range(num_segments).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.modeling_tapas.flatten", "project": "transformers", "func": "flatten", "origin_file": "transformers/models/tapas/modeling_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1657, "func_end_lineno": 1683, "key_block_start_lineno": 1673, "key_block_end_lineno": 1683, "new_func_code": "def flatten(index, name=\"segmented_flatten\"):\n    \"\"\"\n    Flattens a batched index map (which is typically of shape batch_size, seq_length) to a 1d index map. This operation\n    relabels the segments to keep batch elements distinct. The k-th batch element will have indices shifted by\n    *num_segments* * (k - 1). The result is a tensor with *num_segments* multiplied by the number of elements in the\n    batch.\n\n    Args:\n        index (`IndexMap`):\n            IndexMap to flatten.\n        name (`str`, *optional*, defaults to 'segmented_flatten'):\n            Name for the operation. Currently not used\n\n    Returns:\n        (`IndexMap`): The flattened IndexMap.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.modeling_tapas.range_index_map", "project": "transformers", "func": "range_index_map", "origin_file": "transformers/models/tapas/modeling_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1686, "func_end_lineno": 1724, "key_block_start_lineno": 1701, "key_block_end_lineno": 1724, "new_func_code": "def range_index_map(batch_shape, num_segments, name=\"range_index_map\"):\n    \"\"\"\n    Constructs an index map equal to range(num_segments).\n\n    Args:\n        batch_shape (`torch.Size`):\n            Batch shape\n        num_segments (`int`):\n            Number of segments\n        name (`str`, *optional*, defaults to 'range_index_map'):\n            Name for the operation. Currently not used\n\n    Returns:\n        (`IndexMap`): IndexMap of shape batch_shape with elements equal to range(num_segments).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.modeling_tapas.gather", "project": "transformers", "func": "gather", "origin_file": "transformers/models/tapas/modeling_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 1624, "func_end_lineno": 1654, "key_block_start_lineno": 1640, "key_block_end_lineno": 1654, "new_func_code": "def gather(values, index, name=\"segmented_gather\"):\n    \"\"\"\n    Gathers from *values* using the index map. For each element in the domain of the index map this operation looks up\n    a value for that index in *values*. Two elements from the same segment always get assigned the same value.\n\n    Args:\n        values (`torch.Tensor` of shape (B1, ..., Bn, num_segments, V1, ...)):\n            Tensor with segment values.\n        index (`IndexMap` of shape (B1, ..., Bn, I1, ..., Ik)):\n            IndexMap.\n        name (`str`, *optional*, defaults to 'segmented_gather'):\n            Name for the operation. Currently not used\n\n    Returns:\n        `tuple(torch.Tensor)`: Tensor of shape (B1, ..., Bn, I1, ..., Ik, V1, ...) with the gathered values.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tvp.image_processing_tvp.TvpImageProcessor::pad_image", "project": "transformers", "func": "TvpImageProcessor::pad_image", "origin_file": "transformers/models/tvp/image_processing_tvp.py", "test_list": ["../tests/models/tvp/test_image_processing_tvp.py"], "prob_info": {"func_start_lineno": 219, "func_end_lineno": 264, "key_block_start_lineno": 246, "key_block_end_lineno": 264, "new_func_code": "def pad_image(\n        self,\n        image: np.ndarray,\n        pad_size: Dict[str, int] = None,\n        constant_values: Union[float, Iterable[float]] = 0,\n        pad_mode: PaddingMode = PaddingMode.CONSTANT,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Pad an image with zeros to the given size.\n\n        Args:\n            image (`np.ndarray`):\n                Image to pad.\n            pad_size (`Dict[str, int]`)\n                Size of the output image with pad.\n            constant_values (`Union[float, Iterable[float]]`)\n                The fill value to use when padding the image.\n            pad_mode (`PaddingMode`)\n                The pad mode, default to PaddingMode.CONSTANT\n            data_format (`ChannelDimension` or `str`, *optional*)\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tvp.image_processing_tvp.TvpImageProcessor::preprocess", "project": "transformers", "func": "TvpImageProcessor::preprocess", "origin_file": "transformers/models/tvp/image_processing_tvp.py", "test_list": ["../tests/models/tvp/test_image_processing_tvp.py"], "prob_info": {"func_start_lineno": 340, "func_end_lineno": 478, "key_block_start_lineno": 419, "key_block_end_lineno": 478, "new_func_code": "def preprocess(\n        self,\n        videos: Union[ImageInput, List[ImageInput], List[List[ImageInput]]],\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: Dict[str, int] = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_pad: bool = None,\n        pad_size: Dict[str, int] = None,\n        constant_values: Union[float, Iterable[float]] = None,\n        pad_mode: PaddingMode = None,\n        do_normalize: bool = None,\n        do_flip_channel_order: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: ChannelDimension = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            videos (`ImageInput` or `List[ImageInput]` or `List[List[ImageInput]]`):\n                Frames to preprocess.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after applying resize.\n            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`, Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_centre_crop`):\n                Whether to centre crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the image after applying the centre crop.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between [0 - 1].\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_pad (`bool`, *optional*, defaults to `True`):\n                Whether to pad the image. Can be overridden by the `do_pad` parameter in the `preprocess` method.\n            pad_size (`Dict[str, int]`, *optional*, defaults to `{\"height\": 448, \"width\": 448}`):\n                Size of the image after applying the padding. Can be overridden by the `pad_size` parameter in the\n                `preprocess` method.\n            constant_values (`Union[float, Iterable[float]]`, *optional*, defaults to 0):\n                The fill value to use when padding the image.\n            pad_mode (`PaddingMode`, *optional*, defaults to \"PaddingMode.CONSTANT\"):\n                Use what kind of mode in padding.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            do_flip_channel_order (`bool`, *optional*, defaults to `self.do_flip_channel_order`):\n                Whether to flip the channel order of the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                    - Unset: Return a list of `np.ndarray`.\n                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                    - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                    - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                    - Unset: Use the inferred channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.video_llava.image_processing_video_llava.VideoLlavaImageProcessor::preprocess", "project": "transformers", "func": "VideoLlavaImageProcessor::preprocess", "origin_file": "transformers/models/video_llava/image_processing_video_llava.py", "test_list": ["../tests/models/video_llava/test_image_processing_video_llava.py"], "prob_info": {"func_start_lineno": 193, "func_end_lineno": 341, "key_block_start_lineno": 266, "key_block_end_lineno": 341, "new_func_code": "def preprocess(\n        self,\n        images: List[ImageInput] = None,\n        videos: List[VideoInput] = None,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: int = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_convert_rgb: bool = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`, *optional*):\n                List of images to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            videos (`VideoInput`, *optional*):\n                List of videos to preprocess. Expects a single or batch of videos with pixel values ranging from 0 to 255. If\n                passing in videos with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n                the longest edge resized to keep the input aspect ratio.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_center_crop`):\n                Whether to center crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the center crop. Only has an effect if `do_center_crop` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                `True`.\n            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n                Whether to convert the image to RGB.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                - Unset: Return a list of `np.ndarray`.\n                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.videomae.image_processing_videomae.VideoMAEImageProcessor::preprocess", "project": "transformers", "func": "VideoMAEImageProcessor::preprocess", "origin_file": "transformers/models/videomae/image_processing_videomae.py", "test_list": ["../tests/models/videomae/test_image_processing_videomae.py"], "prob_info": {"func_start_lineno": 236, "func_end_lineno": 345, "key_block_start_lineno": 300, "key_block_end_lineno": 345, "new_func_code": "def preprocess(\n        self,\n        videos: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: Dict[str, int] = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: ChannelDimension = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            images (`ImageInput`):\n                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after applying resize.\n            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`, Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_centre_crop`):\n                Whether to centre crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the image after applying the centre crop.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between [0 - 1].\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                    - Unset: Return a list of `np.ndarray`.\n                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                    - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                    - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                    - Unset: Use the inferred channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.vilt.image_processing_vilt.make_pixel_mask", "project": "transformers", "func": "make_pixel_mask", "origin_file": "transformers/models/vilt/image_processing_vilt.py", "test_list": ["../tests/models/vilt/test_image_processing_vilt.py"], "prob_info": {"func_start_lineno": 54, "func_end_lineno": 69, "key_block_start_lineno": 66, "key_block_end_lineno": 69, "new_func_code": "def make_pixel_mask(\n    image: np.ndarray, output_size: Tuple[int, int], input_data_format: Optional[Union[str, ChannelDimension]] = None\n) -> np.ndarray:\n    \"\"\"\n    Make a pixel mask for the image, where 1 indicates a valid pixel and 0 indicates padding.\n\n    Args:\n        image (`np.ndarray`):\n            Image to make the pixel mask for.\n        output_size (`Tuple[int, int]`):\n            Output size of the mask.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.vitmatte.image_processing_vitmatte.VitMatteImageProcessor::pad_image", "project": "transformers", "func": "VitMatteImageProcessor::pad_image", "origin_file": "transformers/models/vitmatte/image_processing_vitmatte.py", "test_list": ["../tests/models/vitmatte/test_image_processing_vitmatte.py"], "prob_info": {"func_start_lineno": 91, "func_end_lineno": 130, "key_block_start_lineno": 116, "key_block_end_lineno": 130, "new_func_code": "def pad_image(\n        self,\n        image: np.ndarray,\n        size_divisibility: int = 32,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> np.ndarray:\n        \"\"\"\n        Args:\n            image (`np.ndarray`):\n                Image to pad.\n            size_divisibility (`int`, *optional*, defaults to 32):\n                The width and height of the image will be padded to be divisible by this number.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.vivit.image_processing_vivit.VivitImageProcessor::preprocess", "project": "transformers", "func": "VivitImageProcessor::preprocess", "origin_file": "transformers/models/vivit/image_processing_vivit.py", "test_list": ["../tests/models/vivit/test_image_processing_vivit.py"], "prob_info": {"func_start_lineno": 290, "func_end_lineno": 404, "key_block_start_lineno": 357, "key_block_end_lineno": 404, "new_func_code": "def preprocess(\n        self,\n        videos: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: Dict[str, int] = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        offset: bool = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        data_format: ChannelDimension = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> PIL.Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images.\n\n        Args:\n            videos (`ImageInput`):\n                Video frames to preprocess. Expects a single or batch of video frames with pixel values ranging from 0\n                to 255. If passing in frames with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after applying resize.\n            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`, Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_centre_crop`):\n                Whether to centre crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the image after applying the centre crop.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image values between `[-1 - 1]` if `offset` is `True`, `[0, 1]` otherwise.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            offset (`bool`, *optional*, defaults to `self.offset`):\n                Whether to scale the image in both negative and positive directions.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation.\n            return_tensors (`str` or `TensorType`, *optional*):\n                The type of tensors to return. Can be one of:\n                    - Unset: Return a list of `np.ndarray`.\n                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                    - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                    - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                    - Unset: Use the inferred channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.wav2vec2.tokenization_wav2vec2.Wav2Vec2CTCTokenizer::batch_decode", "project": "transformers", "func": "Wav2Vec2CTCTokenizer::batch_decode", "origin_file": "transformers/models/wav2vec2/tokenization_wav2vec2.py", "test_list": ["../tests/models/wav2vec2/test_tokenization_wav2vec2.py"], "prob_info": {"func_start_lineno": 458, "func_end_lineno": 524, "key_block_start_lineno": 509, "key_block_end_lineno": 524, "new_func_code": "def batch_decode(\n        self,\n        sequences: Union[List[int], List[List[int]], \"np.ndarray\", \"torch.Tensor\", \"tf.Tensor\"],\n        skip_special_tokens: bool = False,\n        clean_up_tokenization_spaces: bool = None,\n        output_char_offsets: bool = False,\n        output_word_offsets: bool = False,\n        **kwargs,\n    ) -> List[str]:\n        \"\"\"\n        Convert a list of lists of token ids into a list of strings by calling decode.\n\n        Args:\n            sequences (`Union[List[int], List[List[int]], np.ndarray, torch.Tensor, tf.Tensor]`):\n                List of tokenized input ids. Can be obtained using the `__call__` method.\n            skip_special_tokens (`bool`, *optional*, defaults to `False`):\n                Whether or not to remove special tokens in the decoding.\n            clean_up_tokenization_spaces (`bool`, *optional*):\n                Whether or not to clean up the tokenization spaces.\n            output_char_offsets (`bool`, *optional*, defaults to `False`):\n                Whether or not to output character offsets. Character offsets can be used in combination with the\n                sampling rate and model downsampling rate to compute the time-stamps of transcribed characters.\n\n                <Tip>\n\n                Please take a look at the Example of [`~Wav2Vec2CTCTokenizer.decode`] to better understand how to make\n                use of `output_char_offsets`. [`~Wav2Vec2CTCTokenizer.batch_decode`] works the same way with batched\n                output.\n\n                </Tip>\n\n            output_word_offsets (`bool`, *optional*, defaults to `False`):\n                Whether or not to output word offsets. Word offsets can be used in combination with the sampling rate\n                and model downsampling rate to compute the time-stamps of transcribed words.\n\n                <Tip>\n\n                Please take a look at the Example of [`~Wav2Vec2CTCTokenizer.decode`] to better understand how to make\n                use of `output_word_offsets`. [`~Wav2Vec2CTCTokenizer.batch_decode`] works the same way with batched\n                output.\n\n                </Tip>\n\n            kwargs (additional keyword arguments, *optional*):\n                Will be passed to the underlying model specific decode method.\n\n        Returns:\n            `List[str]` or [`~models.wav2vec2.tokenization_wav2vec2.Wav2Vec2CTCTokenizerOutput`]: The list of decoded\n            sentences. Will be a [`~models.wav2vec2.tokenization_wav2vec2.Wav2Vec2CTCTokenizerOutput`] when\n            `output_char_offsets == True` or `output_word_offsets == True`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.zoedepth.image_processing_zoedepth.ZoeDepthImageProcessor::pad_image", "project": "transformers", "func": "ZoeDepthImageProcessor::pad_image", "origin_file": "transformers/models/zoedepth/image_processing_zoedepth.py", "test_list": ["../tests/models/zoedepth/test_image_processing_zoedepth.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 291, "key_block_start_lineno": 280, "key_block_end_lineno": 291, "new_func_code": "def pad_image(\n        self,\n        image: np.array,\n        mode: PaddingMode = PaddingMode.REFLECT,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ):\n        \"\"\"\n        Pad an image as done in the original ZoeDepth implementation.\n\n        Padding fixes the boundary artifacts in the output depth map.\n        Boundary artifacts are sometimes caused by the fact that the model is trained on NYU raw dataset\n        which has a black or white border around the image. This function pads the input image and crops\n        the prediction back to the original size / view.\n\n        Args:\n            image (`np.ndarray`):\n                Image to pad.\n            mode (`PaddingMode`):\n                The padding mode to use. Can be one of:\n                    - `\"constant\"`: pads with a constant value.\n                    - `\"reflect\"`: pads with the reflection of the vector mirrored on the first and last values of the\n                    vector along each axis.\n                    - `\"replicate\"`: pads with the replication of the last value on the edge of the array along each axis.\n                    - `\"symmetric\"`: pads with the reflection of the vector mirrored along the edge of the array.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.data.data_collator.DataCollatorForWholeWordMask::_whole_word_mask", "project": "transformers", "func": "DataCollatorForWholeWordMask::_whole_word_mask", "origin_file": "transformers/data/data_collator.py", "test_list": ["../tests/trainer/test_data_collator.py"], "prob_info": {"func_start_lineno": 1024, "func_end_lineno": 1069, "key_block_start_lineno": 1028, "key_block_end_lineno": 1069, "new_func_code": "def _whole_word_mask(self, input_tokens: List[str], max_predictions=512):\n        \"\"\"\n        Get 0/1 labels for masked tokens with whole word mask proxy\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.data.data_collator.DataCollatorForPermutationLanguageModeling::numpy_mask_tokens", "project": "transformers", "func": "DataCollatorForPermutationLanguageModeling::numpy_mask_tokens", "origin_file": "transformers/data/data_collator.py", "test_list": ["../tests/trainer/test_data_collator.py"], "prob_info": {"func_start_lineno": 1518, "func_end_lineno": 1613, "key_block_start_lineno": 1531, "key_block_end_lineno": 1613, "new_func_code": "def numpy_mask_tokens(self, inputs: Any) -> Tuple[Any, Any, Any, Any]:\n        \"\"\"\n        The masked tokens to be predicted for a particular sequence are determined by the following algorithm:\n\n            0. Start from the beginning of the sequence by setting `cur_len = 0` (number of tokens processed so far).\n            1. Sample a `span_length` from the interval `[1, max_span_length]` (length of span of tokens to be masked)\n            2. Reserve a context of length `context_length = span_length / plm_probability` to surround span to be\n               masked\n            3. Sample a starting point `start_index` from the interval `[cur_len, cur_len + context_length -\n               span_length]` and mask tokens `start_index:start_index + span_length`\n            4. Set `cur_len = cur_len + context_length`. If `cur_len < max_len` (i.e. there are tokens remaining in the\n               sequence to be processed), repeat from Step 1.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.trainer_pt_utils.EvalLoopContainer::to_cpu_and_numpy", "project": "transformers", "func": "EvalLoopContainer::to_cpu_and_numpy", "origin_file": "transformers/trainer_pt_utils.py", "test_list": ["../tests/trainer/test_trainer_utils.py"], "prob_info": {"func_start_lineno": 326, "func_end_lineno": 342, "key_block_start_lineno": 328, "key_block_end_lineno": 342, "new_func_code": "def to_cpu_and_numpy(self) -> None:\n        \"\"\"Move tensors in stored objects to CPU and convert them to numpy arrays.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.testing_utils.pytest_addoption_shared", "project": "transformers", "func": "pytest_addoption_shared", "origin_file": "transformers/testing_utils.py", "test_list": ["../tests/utils/test_dynamic_module_utils.py"], "prob_info": {"func_start_lineno": 1855, "func_end_lineno": 1871, "key_block_start_lineno": 1863, "key_block_end_lineno": 1871, "new_func_code": "def pytest_addoption_shared(parser):\n    \"\"\"\n    This function is to be called from `conftest.py` via `pytest_addoption` wrapper that has to be defined there.\n\n    It allows loading both `conftest.py` files at once without causing a failure due to adding the same `pytest`\n    option.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.modeling_rope_utils._check_received_keys", "project": "transformers", "func": "_check_received_keys", "origin_file": "transformers/modeling_rope_utils.py", "test_list": ["../tests/utils/test_modeling_rope_utils.py"], "prob_info": {"func_start_lineno": 363, "func_end_lineno": 379, "key_block_start_lineno": 365, "key_block_end_lineno": 379, "new_func_code": "def _check_received_keys(rope_type: str, received_keys: set, required_keys: set, optional_keys: Optional[set] = None):\n    \"\"\"Compare the received keys in `config.rope_scaling` against the expected and optional keys\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.modeling_rope_utils._compute_longrope_parameters", "project": "transformers", "func": "_compute_longrope_parameters", "origin_file": "transformers/modeling_rope_utils.py", "test_list": ["../tests/utils/test_modeling_rope_utils.py"], "prob_info": {"func_start_lineno": 242, "func_end_lineno": 304, "key_block_start_lineno": 261, "key_block_end_lineno": 304, "new_func_code": "def _compute_longrope_parameters(\n    config: PretrainedConfig, device: \"torch.device\", seq_len: Optional[int] = None, **rope_kwargs\n) -> Tuple[\"torch.Tensor\", float]:\n    \"\"\"\n    Computes the inverse frequencies with LongRoPE scaling. Please refer to the\n    [original implementation](https://github.com/microsoft/LongRoPE)\n    Args:\n        config ([`~transformers.PretrainedConfig`]):\n            The model configuration.\n        device (`torch.device`):\n            The device to use for initialization of the inverse frequencies.\n        seq_len (`int`, *optional*):\n            The current sequence length. Unused for this type of RoPE.\n        rope_kwargs (`Dict`, *optional*):\n            BC compatibility with the previous RoPE class instantiation, will be removed in v4.45.\n    Returns:\n        Tuple of (`torch.Tensor`, `float`), containing the inverse frequencies for the RoPE embeddings and the\n        post-processing scaling factor applied to the computed cos/sin.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.modeling_rope_utils._compute_yarn_parameters", "project": "transformers", "func": "_compute_yarn_parameters", "origin_file": "transformers/modeling_rope_utils.py", "test_list": ["../tests/utils/test_modeling_rope_utils.py"], "prob_info": {"func_start_lineno": 163, "func_end_lineno": 239, "key_block_start_lineno": 182, "key_block_end_lineno": 239, "new_func_code": "def _compute_yarn_parameters(\n    config: PretrainedConfig, device: \"torch.device\", seq_len: Optional[int] = None, **rope_kwargs\n) -> Tuple[\"torch.Tensor\", float]:\n    \"\"\"\n    Computes the inverse frequencies with NTK scaling. Please refer to the\n    [original paper](https://arxiv.org/abs/2309.00071)\n    Args:\n        config ([`~transformers.PretrainedConfig`]):\n            The model configuration.\n        device (`torch.device`):\n            The device to use for initialization of the inverse frequencies.\n        seq_len (`int`, *optional*):\n            The current sequence length. Unused for this type of RoPE.\n        rope_kwargs (`Dict`, *optional*):\n            BC compatibility with the previous RoPE class instantiation, will be removed in v4.45.\n    Returns:\n        Tuple of (`torch.Tensor`, `float`), containing the inverse frequencies for the RoPE embeddings and the\n        post-processing scaling factor applied to the computed cos/sin.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.image_transforms.center_to_corners_format", "project": "transformers", "func": "center_to_corners_format", "origin_file": "transformers/image_transforms.py", "test_list": ["../tests/test_image_transforms.py"], "prob_info": {"func_start_lineno": 543, "func_end_lineno": 561, "key_block_start_lineno": 552, "key_block_end_lineno": 561, "new_func_code": "def center_to_corners_format(bboxes_center: TensorType) -> TensorType:\n    \"\"\"\n    Converts bounding boxes from center format to corners format.\n\n    center format: contains the coordinate for the center of the box and its width, height dimensions\n        (center_x, center_y, width, height)\n    corners format: contains the coodinates for the top-left and bottom-right corners of the box\n        (top_left_x, top_left_y, bottom_right_x, bottom_right_y)\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bart.modeling_bart.BartSdpaAttention::forward", "project": "transformers", "func": "BartSdpaAttention::forward", "origin_file": "transformers/models/bart/modeling_bart.py", "test_list": ["../tests/benchmark/test_benchmark.py"], "prob_info": {"func_start_lineno": 417, "func_end_lineno": 519, "key_block_start_lineno": 427, "key_block_end_lineno": 519, "new_func_code": "def forward(\n        self,\n        hidden_states: torch.Tensor,\n        key_value_states: Optional[torch.Tensor] = None,\n        past_key_value: Optional[Tuple[torch.Tensor]] = None,\n        attention_mask: Optional[torch.Tensor] = None,\n        layer_head_mask: Optional[torch.Tensor] = None,\n        output_attentions: bool = False,\n    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n        \"\"\"Input shape: Batch x Time x Channel\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.generation.beam_search.ConstrainedBeamSearchScorer::process", "project": "transformers", "func": "ConstrainedBeamSearchScorer::process", "origin_file": "transformers/generation/beam_search.py", "test_list": ["../tests/generation/test_beam_search.py"], "prob_info": {"func_start_lineno": 513, "func_end_lineno": 670, "key_block_start_lineno": 563, "key_block_end_lineno": 670, "new_func_code": "def process(\n        self,\n        input_ids: torch.LongTensor,\n        next_scores: torch.FloatTensor,\n        next_tokens: torch.LongTensor,\n        next_indices: torch.LongTensor,\n        scores_for_all_vocab: torch.FloatTensor,\n        pad_token_id: Optional[Union[int, torch.Tensor]] = None,\n        eos_token_id: Optional[Union[int, List[int], torch.Tensor]] = None,\n        beam_indices: Optional[torch.LongTensor] = None,\n        decoder_prompt_len: Optional[int] = 0,\n    ) -> Tuple[torch.Tensor]:\n        r\"\"\"\n        Args:\n            input_ids (`torch.LongTensor` of shape `(batch_size * num_beams, sequence_length)`):\n                Indices of input sequence tokens in the vocabulary.\n\n                Indices can be obtained using any class inheriting from [`PreTrainedTokenizer`]. See\n                [`PreTrainedTokenizer.encode`] and [`PreTrainedTokenizer.__call__`] for details.\n\n                [What are input IDs?](../glossary#input-ids)\n            next_scores (`torch.FloatTensor` of shape `(batch_size, 2 * num_beams)`):\n                Current scores of the top `2 * num_beams` non-finished beam hypotheses.\n            next_tokens (`torch.LongTensor` of shape `(batch_size, 2 * num_beams)`):\n                `input_ids` of the tokens corresponding to the top `2 * num_beams` non-finished beam hypotheses.\n            next_indices (`torch.LongTensor` of shape `(batch_size, 2 * num_beams)`):\n                Beam indices indicating to which beam hypothesis the `next_tokens` correspond.\n            scores_for_all_vocab (`torch.FloatTensor` of shape `(batch_size * num_beams, sequence_length)`):\n                The scores of all tokens in the vocabulary for each of the beam hypotheses.\n            pad_token_id (`int`, *optional*):\n                The id of the *padding* token.\n            eos_token_id (`Union[int, List[int]]`, *optional*):\n                The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.\n            beam_indices (`torch.LongTensor`, *optional*):\n                Beam indices indicating to which beam hypothesis each token correspond.\n            decoder_prompt_len (`int`, *optional*):\n                The length of prompt that is included in the input to decoder.\n        Return:\n            `UserDict`: A dictionary composed of the fields as defined above:\n\n                - **next_beam_scores** (`torch.FloatTensor` of shape `(batch_size * num_beams)`) -- Updated scores of\n                  all\n                non-finished beams.\n\n                - **next_beam_tokens** (`torch.FloatTensor` of shape `(batch_size * num_beams)`) -- Next tokens to be\n                  added\n                to the non-finished beam_hypotheses.\n                - **next_beam_indices** (`torch.FloatTensor` of shape `(batch_size * num_beams)`) -- Beam indices\n                indicating to which beam the next tokens shall be added.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.clap.feature_extraction_clap.ClapFeatureExtractor::_np_extract_fbank_features", "project": "transformers", "func": "ClapFeatureExtractor::_np_extract_fbank_features", "origin_file": "transformers/models/clap/feature_extraction_clap.py", "test_list": ["../tests/models/clap/test_feature_extraction_clap.py"], "prob_info": {"func_start_lineno": 153, "func_end_lineno": 173, "key_block_start_lineno": 164, "key_block_end_lineno": 173, "new_func_code": "def _np_extract_fbank_features(self, waveform: np.array, mel_filters: Optional[np.array] = None) -> np.ndarray:\n        \"\"\"\n        Compute the log-mel spectrogram of the provided `waveform` using the Hann window. In CLAP, two different filter\n        banks are used depending on the truncation pattern:\n            - `self.mel_filters`: they correspond to the default parameters of `torchaudio` which can be obtained from\n              calling `torchaudio.transforms.MelSpectrogram().mel_scale.fb`. These filters are used when `truncation`\n              is set to `\"fusion\"`.\n            - `self.mel_filteres_slaney` : they correspond to the default parameters of `librosa` which used\n              `librosa.filters.mel` when computing the mel spectrogram. These filters were only used in the original\n              implementation when the truncation mode is not `\"fusion\"`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.hub.extract_commit_hash", "project": "transformers", "func": "extract_commit_hash", "origin_file": "transformers/utils/hub.py", "test_list": ["../tests/models/esm/test_tokenization_esm.py"], "prob_info": {"func_start_lineno": 256, "func_end_lineno": 267, "key_block_start_lineno": 260, "key_block_end_lineno": 267, "new_func_code": "def extract_commit_hash(resolved_file: Optional[str], commit_hash: Optional[str]) -> Optional[str]:\n    \"\"\"\n    Extracts the commit hash from a resolved filename toward a cache file.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.idefics2.image_processing_idefics2.convert_to_rgb", "project": "transformers", "func": "convert_to_rgb", "origin_file": "transformers/models/idefics2/image_processing_idefics2.py", "test_list": ["../tests/models/idefics2/test_image_processing_idefics2.py"], "prob_info": {"func_start_lineno": 158, "func_end_lineno": 178, "key_block_start_lineno": 166, "key_block_end_lineno": 178, "new_func_code": "def convert_to_rgb(image: ImageInput) -> ImageInput:\n    \"\"\"\n    Converts an image to RGB format. Only converts if the image is of type PIL.Image.Image, otherwise returns the image\n    as is.\n    Args:\n        image (Image):\n            The image to convert.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.idefics2.image_processing_idefics2.make_pixel_mask", "project": "transformers", "func": "make_pixel_mask", "origin_file": "transformers/models/idefics2/image_processing_idefics2.py", "test_list": ["../tests/models/idefics2/test_image_processing_idefics2.py"], "prob_info": {"func_start_lineno": 139, "func_end_lineno": 154, "key_block_start_lineno": 151, "key_block_end_lineno": 154, "new_func_code": "def make_pixel_mask(\n    image: np.ndarray, output_size: Tuple[int, int], input_data_format: Optional[Union[str, ChannelDimension]] = None\n) -> np.ndarray:\n    \"\"\"\n    Make a pixel mask for the image, where 1 indicates a valid pixel and 0 indicates padding.\n\n    Args:\n        image (`np.ndarray`):\n            Image to make the pixel mask for.\n        output_size (`Tuple[int, int]`):\n            Output size of the mask.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.generic.infer_framework_from_repr", "project": "transformers", "func": "infer_framework_from_repr", "origin_file": "transformers/utils/generic.py", "test_list": ["../tests/models/mobilenet_v1/test_image_processing_mobilenet_v1.py"], "prob_info": {"func_start_lineno": 80, "func_end_lineno": 95, "key_block_start_lineno": 85, "key_block_end_lineno": 95, "new_func_code": "def infer_framework_from_repr(x):\n    \"\"\"\n    Tries to guess the framework of an object `x` from its repr (brittle but will help in `is_tensor` to try the\n    frameworks in a smart order, without the need to import the frameworks).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.phobert.tokenization_phobert.get_pairs", "project": "transformers", "func": "get_pairs", "origin_file": "transformers/models/phobert/tokenization_phobert.py", "test_list": ["../tests/models/phobert/test_tokenization_phobert.py"], "prob_info": {"func_start_lineno": 35, "func_end_lineno": 48, "key_block_start_lineno": 41, "key_block_end_lineno": 48, "new_func_code": "def get_pairs(word):\n    \"\"\"\n    Return set of symbol pairs in a word.\n\n    Word is represented as tuple of symbols (symbols being variable-length strings).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.superpoint.image_processing_superpoint.convert_to_grayscale", "project": "transformers", "func": "convert_to_grayscale", "origin_file": "transformers/models/superpoint/image_processing_superpoint.py", "test_list": ["../tests/models/superpoint/test_image_processing_superpoint.py"], "prob_info": {"func_start_lineno": 51, "func_end_lineno": 84, "key_block_start_lineno": 69, "key_block_end_lineno": 84, "new_func_code": "def convert_to_grayscale(\n    image: ImageInput,\n    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n) -> ImageInput:\n    \"\"\"\n    Converts an image to grayscale format using the NTSC formula. Only support numpy and PIL Image. TODO support torch\n    and tensorflow grayscale conversion\n\n    This function is supposed to return a 1-channel image, but it returns a 3-channel image with the same value in each\n    channel, because of an issue that is discussed in :\n    https://github.com/huggingface/transformers/pull/25786#issuecomment-1730176446\n\n    Args:\n        image (Image):\n            The image to convert.\n        input_data_format (`ChannelDimension` or `str`, *optional*):\n            The channel dimension format for the input image.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.tapas.modeling_tapas.TapasModel::forward", "project": "transformers", "func": "TapasModel::forward", "origin_file": "transformers/models/tapas/modeling_tapas.py", "test_list": ["../tests/models/tapas/test_tokenization_tapas.py"], "prob_info": {"func_start_lineno": 848, "func_end_lineno": 958, "key_block_start_lineno": 887, "key_block_end_lineno": 958, "new_func_code": "def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        attention_mask: Optional[torch.FloatTensor] = None,\n        token_type_ids: Optional[torch.LongTensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        head_mask: Optional[torch.FloatTensor] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        encoder_hidden_states: Optional[torch.FloatTensor] = None,\n        encoder_attention_mask: Optional[torch.FloatTensor] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n    ) -> Union[Tuple, BaseModelOutputWithPooling]:\n        r\"\"\"\n        Returns:\n\n        Examples:\n\n        ```python\n        >>> from transformers import AutoTokenizer, TapasModel\n        >>> import pandas as pd\n\n        >>> tokenizer = AutoTokenizer.from_pretrained(\"google/tapas-base\")\n        >>> model = TapasModel.from_pretrained(\"google/tapas-base\")\n\n        >>> data = {\n        ...     \"Actors\": [\"Brad Pitt\", \"Leonardo Di Caprio\", \"George Clooney\"],\n        ...     \"Age\": [\"56\", \"45\", \"59\"],\n        ...     \"Number of movies\": [\"87\", \"53\", \"69\"],\n        ... }\n        >>> table = pd.DataFrame.from_dict(data)\n        >>> queries = [\"How many movies has George Clooney played in?\", \"How old is Brad Pitt?\"]\n\n        >>> inputs = tokenizer(table=table, queries=queries, padding=\"max_length\", return_tensors=\"pt\")\n        >>> outputs = model(**inputs)\n\n        >>> last_hidden_states = outputs.last_hidden_state\n        ```\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.generic.to_py_obj", "project": "transformers", "func": "to_py_obj", "origin_file": "transformers/utils/generic.py", "test_list": ["../tests/models/wav2vec2/test_tokenization_wav2vec2.py"], "prob_info": {"func_start_lineno": 254, "func_end_lineno": 281, "key_block_start_lineno": 258, "key_block_end_lineno": 281, "new_func_code": "def to_py_obj(obj):\n    \"\"\"\n    Convert a TensorFlow tensor, PyTorch tensor, Numpy array or python list to a python list.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.data.data_collator.DataCollatorForWholeWordMask::torch_mask_tokens", "project": "transformers", "func": "DataCollatorForWholeWordMask::torch_mask_tokens", "origin_file": "transformers/data/data_collator.py", "test_list": ["../tests/trainer/test_data_collator.py"], "prob_info": {"func_start_lineno": 1071, "func_end_lineno": 1109, "key_block_start_lineno": 1076, "key_block_end_lineno": 1109, "new_func_code": "def torch_mask_tokens(self, inputs: Any, mask_labels: Any) -> Tuple[Any, Any]:\n        \"\"\"\n        Prepare masked tokens inputs/labels for masked language modeling: 80% MASK, 10% random, 10% original. Set\n        'mask_labels' means we use whole word mask (wwm), we directly mask idxs according to it's ref.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.data.data_collator._numpy_collate_batch", "project": "transformers", "func": "_numpy_collate_batch", "origin_file": "transformers/data/data_collator.py", "test_list": ["../tests/trainer/test_data_collator.py"], "prob_info": {"func_start_lineno": 502, "func_end_lineno": 531, "key_block_start_lineno": 504, "key_block_end_lineno": 531, "new_func_code": "def _numpy_collate_batch(examples, tokenizer, pad_to_multiple_of: Optional[int] = None):\n    \"\"\"Collate `examples` into a batch, using the information in `tokenizer` for padding if necessary.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.data.data_collator.DataCollatorForWholeWordMask::numpy_mask_tokens", "project": "transformers", "func": "DataCollatorForWholeWordMask::numpy_mask_tokens", "origin_file": "transformers/data/data_collator.py", "test_list": ["../tests/trainer/test_data_collator.py"], "prob_info": {"func_start_lineno": 1153, "func_end_lineno": 1191, "key_block_start_lineno": 1158, "key_block_end_lineno": 1191, "new_func_code": "def numpy_mask_tokens(self, inputs: Any, mask_labels: Any) -> Tuple[Any, Any]:\n        \"\"\"\n        Prepare masked tokens inputs/labels for masked language modeling: 80% MASK, 10% random, 10% original. Set\n        'mask_labels' means we use whole word mask (wwm), we directly mask idxs according to it's ref.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.bertweet.tokenization_bertweet.BertweetTokenizer::add_from_file", "project": "transformers", "func": "BertweetTokenizer::add_from_file", "origin_file": "transformers/models/bertweet/tokenization_bertweet.py", "test_list": ["../tests/models/bertweet/test_tokenization_bertweet.py"], "prob_info": {"func_start_lineno": 402, "func_end_lineno": 423, "key_block_start_lineno": 406, "key_block_end_lineno": 423, "new_func_code": "def add_from_file(self, f):\n        \"\"\"\n        Loads a pre-existing dictionary from a text file and adds its symbols to this instance.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.chinese_clip.image_processing_chinese_clip.ChineseCLIPImageProcessor::resize", "project": "transformers", "func": "ChineseCLIPImageProcessor::resize", "origin_file": "transformers/models/chinese_clip/image_processing_chinese_clip.py", "test_list": ["../tests/models/chinese_clip/test_image_processing_chinese_clip.py"], "prob_info": {"func_start_lineno": 125, "func_end_lineno": 162, "key_block_start_lineno": 151, "key_block_end_lineno": 162, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image. The shortest edge of the image is resized to size[\"shortest_edge\"], with the longest edge\n        resized to keep the input aspect ratio.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred from the input\n                image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.dpt.image_processing_dpt.DPTImageProcessor::resize", "project": "transformers", "func": "DPTImageProcessor::resize", "origin_file": "transformers/models/dpt/image_processing_dpt.py", "test_list": ["../tests/models/dpt/test_image_processing_dpt.py"], "prob_info": {"func_start_lineno": 168, "func_end_lineno": 221, "key_block_start_lineno": 203, "key_block_end_lineno": 221, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        keep_aspect_ratio: bool = False,\n        ensure_multiple_of: int = 1,\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image to target size `(size[\"height\"], size[\"width\"])`. If `keep_aspect_ratio` is `True`, the image\n        is resized to the largest possible size such that the aspect ratio is preserved. If `ensure_multiple_of` is\n        set, the image is resized to a size that is a multiple of this value.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Target size of the output image.\n            keep_aspect_ratio (`bool`, *optional*, defaults to `False`):\n                If `True`, the image is resized to the largest possible size such that the aspect ratio is preserved.\n            ensure_multiple_of (`int`, *optional*, defaults to 1):\n                The image is resized to a size that is a multiple of this value.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Defines the resampling filter to use if resizing the image. Otherwise, the image is resized to size\n                specified in `size`.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.encodec.feature_extraction_encodec.EncodecFeatureExtractor::__call__", "project": "transformers", "func": "EncodecFeatureExtractor::__call__", "origin_file": "transformers/models/encodec/feature_extraction_encodec.py", "test_list": ["../tests/models/encodec/test_feature_extraction_encodec.py"], "prob_info": {"func_start_lineno": 84, "func_end_lineno": 206, "key_block_start_lineno": 126, "key_block_end_lineno": 206, "new_func_code": "def __call__(\n        self,\n        raw_audio: Union[np.ndarray, List[float], List[np.ndarray], List[List[float]]],\n        padding: Optional[Union[bool, str, PaddingStrategy]] = None,\n        truncation: Optional[bool] = False,\n        max_length: Optional[int] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        sampling_rate: Optional[int] = None,\n    ) -> BatchFeature:\n        \"\"\"\n        Main method to featurize and prepare for the model one or several sequence(s).\n\n        Args:\n            raw_audio (`np.ndarray`, `List[float]`, `List[np.ndarray]`, `List[List[float]]`):\n                The sequence or batch of sequences to be processed. Each sequence can be a numpy array, a list of float\n                values, a list of numpy arrays or a list of list of float values. The numpy array must be of shape\n                `(num_samples,)` for mono audio (`feature_size = 1`), or `(2, num_samples)` for stereo audio\n                (`feature_size = 2`).\n            padding (`bool`, `str` or [`~utils.PaddingStrategy`], *optional*, defaults to `True`):\n                Select a strategy to pad the returned sequences (according to the model's padding side and padding\n                index) among:\n\n                - `True` or `'longest'`: Pad to the longest sequence in the batch (or no padding if only a single\n                  sequence if provided).\n                - `'max_length'`: Pad to a maximum length specified with the argument `max_length` or to the maximum\n                  acceptable input length for the model if that argument is not provided.\n                - `False` or `'do_not_pad'` (default): No padding (i.e., can output a batch with sequences of different\n                  lengths).\n            truncation (`bool`, *optional*, defaults to `False`):\n                Activates truncation to cut input sequences longer than `max_length` to `max_length`.\n            max_length (`int`, *optional*):\n                Maximum length of the returned list and optionally padding length (see above).\n            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n                If set, will return tensors instead of list of python integers. Acceptable values are:\n\n                - `'tf'`: Return TensorFlow `tf.constant` objects.\n                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n                - `'np'`: Return Numpy `np.ndarray` objects.\n            sampling_rate (`int`, *optional*):\n                The sampling rate at which the `audio` input was sampled. It is strongly recommended to pass\n                `sampling_rate` at the forward call to prevent silent errors.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.flava.image_processing_flava.FlavaImageProcessor::resize", "project": "transformers", "func": "FlavaImageProcessor::resize", "origin_file": "transformers/models/flava/image_processing_flava.py", "test_list": ["../tests/models/flava/test_image_processing_flava.py"], "prob_info": {"func_start_lineno": 338, "func_end_lineno": 384, "key_block_start_lineno": 373, "key_block_end_lineno": 384, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BICUBIC,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image to `(size[\"height\"], size[\"width\"])`.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Dictionary in the format `{\"height\": int, \"width\": int}` specifying the size of the output image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n                `PILImageResampling` filter to use when resizing the image e.g. `PILImageResampling.BICUBIC`.\n            data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the output image. If unset, the channel dimension format of the input\n                image is used. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n\n        Returns:\n            `np.ndarray`: The resized image.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.llava_next_video.image_processing_llava_next_video.LlavaNextVideoImageProcessor::_preprocess", "project": "transformers", "func": "LlavaNextVideoImageProcessor::_preprocess", "origin_file": "transformers/models/llava_next_video/image_processing_llava_next_video.py", "test_list": ["../tests/models/llava_next_video/test_image_processing_llava_next_video.py"], "prob_info": {"func_start_lineno": 199, "func_end_lineno": 297, "key_block_start_lineno": 258, "key_block_end_lineno": 297, "new_func_code": "def _preprocess(\n        self,\n        images: ImageInput,\n        do_resize: bool = None,\n        size: Dict[str, int] = None,\n        resample: PILImageResampling = None,\n        do_center_crop: bool = None,\n        crop_size: int = None,\n        do_rescale: bool = None,\n        rescale_factor: float = None,\n        do_normalize: bool = None,\n        image_mean: Optional[Union[float, List[float]]] = None,\n        image_std: Optional[Union[float, List[float]]] = None,\n        do_convert_rgb: bool = None,\n        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n    ) -> Image.Image:\n        \"\"\"\n        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n\n        Args:\n            images (`ImageInput`):\n                Batch of frames (one video) to preprocess. Expects a batch of frames with pixel values ranging from 0 to 255. If\n                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n                Whether to resize the image.\n            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n                the longest edge resized to keep the input aspect ratio.\n            resample (`int`, *optional*, defaults to `self.resample`):\n                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n                has an effect if `do_resize` is set to `True`.\n            do_center_crop (`bool`, *optional*, defaults to `self.do_center_crop`):\n                Whether to center crop the image.\n            crop_size (`Dict[str, int]`, *optional*, defaults to `self.crop_size`):\n                Size of the center crop. Only has an effect if `do_center_crop` is set to `True`.\n            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n                Whether to rescale the image.\n            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n                Whether to normalize the image.\n            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                `True`.\n            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n                The channel dimension format for the output image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - Unset: Use the channel dimension format of the input image.\n            input_data_format (`ChannelDimension` or `str`, *optional*):\n                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n                from the input image. Can be one of:\n                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.vivit.image_processing_vivit.VivitImageProcessor::resize", "project": "transformers", "func": "VivitImageProcessor::resize", "origin_file": "transformers/models/vivit/image_processing_vivit.py", "test_list": ["../tests/models/vivit/test_image_processing_vivit.py"], "prob_info": {"func_start_lineno": 142, "func_end_lineno": 184, "key_block_start_lineno": 168, "key_block_end_lineno": 184, "new_func_code": "def resize(\n        self,\n        image: np.ndarray,\n        size: Dict[str, int],\n        resample: PILImageResampling = PILImageResampling.BILINEAR,\n        data_format: Optional[Union[str, ChannelDimension]] = None,\n        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n        **kwargs,\n    ) -> np.ndarray:\n        \"\"\"\n        Resize an image.\n\n        Args:\n            image (`np.ndarray`):\n                Image to resize.\n            size (`Dict[str, int]`):\n                Size of the output image. If `size` is of the form `{\"height\": h, \"width\": w}`, the output image will\n                have the size `(h, w)`. If `size` is of the form `{\"shortest_edge\": s}`, the output image will have its\n                shortest edge of length `s` while keeping the aspect ratio of the original image.\n            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BILINEAR`):\n                Resampling filter to use when resiizing the image.\n            data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the image. If not provided, it will be the same as the input image.\n            input_data_format (`str` or `ChannelDimension`, *optional*):\n                The channel dimension format of the input image. If not provided, it will be inferred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.models.wav2vec2.feature_extraction_wav2vec2.Wav2Vec2FeatureExtractor::__call__", "project": "transformers", "func": "Wav2Vec2FeatureExtractor::__call__", "origin_file": "transformers/models/wav2vec2/feature_extraction_wav2vec2.py", "test_list": ["../tests/models/wav2vec2/test_feature_extraction_wav2vec2.py"], "prob_info": {"func_start_lineno": 102, "func_end_lineno": 240, "key_block_start_lineno": 171, "key_block_end_lineno": 240, "new_func_code": "def __call__(\n        self,\n        raw_speech: Union[np.ndarray, List[float], List[np.ndarray], List[List[float]]],\n        padding: Union[bool, str, PaddingStrategy] = False,\n        max_length: Optional[int] = None,\n        truncation: bool = False,\n        pad_to_multiple_of: Optional[int] = None,\n        return_attention_mask: Optional[bool] = None,\n        return_tensors: Optional[Union[str, TensorType]] = None,\n        sampling_rate: Optional[int] = None,\n        **kwargs,\n    ) -> BatchFeature:\n        \"\"\"\n        Main method to featurize and prepare for the model one or several sequence(s).\n\n        Args:\n            raw_speech (`np.ndarray`, `List[float]`, `List[np.ndarray]`, `List[List[float]]`):\n                The sequence or batch of sequences to be padded. Each sequence can be a numpy array, a list of float\n                values, a list of numpy arrays or a list of list of float values. Must be mono channel audio, not\n                stereo, i.e. single float per timestep.\n            padding (`bool`, `str` or [`~utils.PaddingStrategy`], *optional*, defaults to `False`):\n                Select a strategy to pad the returned sequences (according to the model's padding side and padding\n                index) among:\n\n                - `True` or `'longest'`: Pad to the longest sequence in the batch (or no padding if only a single\n                  sequence if provided).\n                - `'max_length'`: Pad to a maximum length specified with the argument `max_length` or to the maximum\n                  acceptable input length for the model if that argument is not provided.\n                - `False` or `'do_not_pad'` (default): No padding (i.e., can output a batch with sequences of different\n                  lengths).\n            max_length (`int`, *optional*):\n                Maximum length of the returned list and optionally padding length (see above).\n            truncation (`bool`):\n                Activates truncation to cut input sequences longer than *max_length* to *max_length*.\n            pad_to_multiple_of (`int`, *optional*):\n                If set will pad the sequence to a multiple of the provided value.\n\n                This is especially useful to enable the use of Tensor Cores on NVIDIA hardware with compute capability\n                `>= 7.5` (Volta), or on TPUs which benefit from having sequence lengths be a multiple of 128.\n            return_attention_mask (`bool`, *optional*):\n                Whether to return the attention mask. If left to the default, will return the attention mask according\n                to the specific feature_extractor's default.\n\n                [What are attention masks?](../glossary#attention-mask)\n\n                <Tip>\n\n                Wav2Vec2 models that have set `config.feat_extract_norm == \"group\"`, such as\n                [wav2vec2-base](https://huggingface.co/facebook/wav2vec2-base-960h), have **not** been trained using\n                `attention_mask`. For such models, `input_values` should simply be padded with 0 and no\n                `attention_mask` should be passed.\n\n                For Wav2Vec2 models that have set `config.feat_extract_norm == \"layer\"`, such as\n                [wav2vec2-lv60](https://huggingface.co/facebook/wav2vec2-large-960h-lv60-self), `attention_mask` should\n                be passed for batched inference.\n\n                </Tip>\n\n            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n                If set, will return tensors instead of list of python integers. Acceptable values are:\n\n                - `'tf'`: Return TensorFlow `tf.constant` objects.\n                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n                - `'np'`: Return Numpy `np.ndarray` objects.\n            sampling_rate (`int`, *optional*):\n                The sampling rate at which the `raw_speech` input was sampled. It is strongly recommended to pass\n                `sampling_rate` at the forward call to prevent silent errors.\n            padding_value (`float`, *optional*, defaults to 0.0):\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.Adafactor::step", "project": "transformers", "func": "Adafactor::step", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 819, "func_end_lineno": 910, "key_block_start_lineno": 827, "key_block_end_lineno": 910, "new_func_code": "def step(self, closure=None):\n        \"\"\"\n        Performs a single optimization step\n\n        Arguments:\n            closure (callable, optional): A closure that reevaluates the model\n                and returns the loss.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.AdamW::step", "project": "transformers", "func": "AdamW::step", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 610, "func_end_lineno": 669, "key_block_start_lineno": 617, "key_block_end_lineno": 669, "new_func_code": "def step(self, closure: Callable = None):\n        \"\"\"\n        Performs a single optimization step.\n\n        Arguments:\n            closure (`Callable`, *optional*): A closure that reevaluates the model and returns the loss.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.optimization.get_inverse_sqrt_schedule", "project": "transformers", "func": "get_inverse_sqrt_schedule", "origin_file": "transformers/optimization.py", "test_list": ["../tests/optimization/test_optimization.py"], "prob_info": {"func_start_lineno": 297, "func_end_lineno": 324, "key_block_start_lineno": 317, "key_block_end_lineno": 324, "new_func_code": "def get_inverse_sqrt_schedule(\n    optimizer: Optimizer, num_warmup_steps: int, timescale: int = None, last_epoch: int = -1\n):\n    \"\"\"\n    Create a schedule with an inverse square-root learning rate, from the initial lr set in the optimizer, after a\n    warmup period which increases lr linearly from 0 to the initial lr set in the optimizer.\n\n    Args:\n        optimizer ([`~torch.optim.Optimizer`]):\n            The optimizer for which to schedule the learning rate.\n        num_warmup_steps (`int`):\n            The number of steps for the warmup phase.\n        timescale (`int`, *optional*, defaults to `num_warmup_steps`):\n            Time scale.\n        last_epoch (`int`, *optional*, defaults to -1):\n            The index of the last epoch when resuming training.\n\n    Return:\n        `torch.optim.lr_scheduler.LambdaLR` with the appropriate schedule.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.trainer_utils.find_executable_batch_size", "project": "transformers", "func": "find_executable_batch_size", "origin_file": "transformers/trainer_utils.py", "test_list": ["../tests/trainer/test_trainer_utils.py"], "prob_info": {"func_start_lineno": 766, "func_end_lineno": 794, "key_block_start_lineno": 781, "key_block_end_lineno": 794, "new_func_code": "def find_executable_batch_size(\n    function: callable = None, starting_batch_size: int = 128, auto_find_batch_size: bool = False\n):\n    \"\"\"\n    Args:\n    A basic decorator that will try to execute `function`. If it fails from exceptions related to out-of-memory or\n    CUDNN, the batch size is cut in half and passed to `function`. `function` must take in a `batch_size` parameter as\n    its first argument.\n        function (`callable`, *optional*)\n            A function to wrap\n        starting_batch_size (`int`, *optional*)\n            The batch size to try and fit into memory\n        auto_find_batch_size (`bool`, *optional*)\n            If False, will just execute `function`\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.chat_template_utils.parse_google_format_docstring", "project": "transformers", "func": "parse_google_format_docstring", "origin_file": "transformers/utils/chat_template_utils.py", "test_list": ["../tests/utils/test_chat_template_utils.py"], "prob_info": {"func_start_lineno": 164, "func_end_lineno": 194, "key_block_start_lineno": 175, "key_block_end_lineno": 194, "new_func_code": "def parse_google_format_docstring(docstring: str) -> Tuple[Optional[str], Optional[Dict], Optional[str]]:\n    \"\"\"\n    Parses a Google-style docstring to extract the function description,\n    argument descriptions, and return description.\n\n    Args:\n        docstring (str): The docstring to parse.\n\n    Returns:\n        The function description, arguments, and return description.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.utils.deprecation.deprecate_kwarg", "project": "transformers", "func": "deprecate_kwarg", "origin_file": "transformers/utils/deprecation.py", "test_list": ["../tests/utils/test_deprecation.py"], "prob_info": {"func_start_lineno": 32, "func_end_lineno": 169, "key_block_start_lineno": 97, "key_block_end_lineno": 169, "new_func_code": "def deprecate_kwarg(\n    old_name: str,\n    version: str,\n    new_name: Optional[str] = None,\n    warn_if_greater_or_equal_version: bool = False,\n    raise_if_greater_or_equal_version: bool = False,\n    raise_if_both_names: bool = False,\n    additional_message: Optional[str] = None,\n):\n    \"\"\"\n    Function or method decorator to notify users about deprecated keyword arguments, replacing them with a new name if specified.\n\n    This decorator allows you to:\n    - Notify users when a keyword argument is deprecated.\n    - Automatically replace deprecated keyword arguments with new ones.\n    - Raise an error if deprecated arguments are used, depending on the specified conditions.\n\n    By default, the decorator notifies the user about the deprecated argument while the `transformers.__version__` < specified `version`\n    in the decorator. To keep notifications with any version `warn_if_greater_or_equal_version=True` can be set.\n\n    Parameters:\n        old_name (`str`):\n            Name of the deprecated keyword argument.\n        version (`str`):\n            The version in which the keyword argument was (or will be) deprecated.\n        new_name (`Optional[str]`, *optional*):\n            The new name for the deprecated keyword argument. If specified, the deprecated keyword argument will be replaced with this new name.\n        warn_if_greater_or_equal_version (`bool`, *optional*, defaults to `False`):\n            Whether to show warning if current `transformers` version is greater or equal to the deprecated version.\n        raise_if_greater_or_equal_version (`bool`, *optional*, defaults to `False`):\n            Whether to raise `ValueError` if current `transformers` version is greater or equal to the deprecated version.\n        raise_if_both_names (`bool`, *optional*, defaults to `False`):\n            Whether to raise `ValueError` if both deprecated and new keyword arguments are set.\n        additional_message (`Optional[str]`, *optional*):\n            An additional message to append to the default deprecation message.\n\n    Raises:\n        ValueError:\n            If raise_if_greater_or_equal_version is True and the current version is greater than or equal to the deprecated version, or if raise_if_both_names is True and both old and new keyword arguments are provided.\n\n    Returns:\n        Callable:\n            A wrapped function that handles the deprecated keyword arguments according to the specified parameters.\n\n    Example usage with renaming argument:\n\n        ```python\n        @deprecate_kwarg(\"reduce_labels\", new_name=\"do_reduce_labels\", version=\"6.0.0\")\n        def my_function(do_reduce_labels):\n            print(do_reduce_labels)\n\n        my_function(reduce_labels=True)  # Will show a deprecation warning and use do_reduce_labels=True\n        ```\n\n    Example usage without renaming argument:\n\n        ```python\n        @deprecate_kwarg(\"max_size\", version=\"6.0.0\")\n        def my_function(max_size):\n            print(max_size)\n\n        my_function(max_size=1333)  # Will show a deprecation warning\n        ```\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "transformers.src.transformers.hf_argparser.HfArgumentParser::parse_dict", "project": "transformers", "func": "HfArgumentParser::parse_dict", "origin_file": "transformers/hf_argparser.py", "test_list": ["../tests/utils/test_hf_argparser.py"], "prob_info": {"func_start_lineno": 352, "func_end_lineno": 378, "key_block_start_lineno": 368, "key_block_end_lineno": 378, "new_func_code": "def parse_dict(self, args: Dict[str, Any], allow_extra_keys: bool = False) -> Tuple[DataClass, ...]:\n        \"\"\"\n        Alternative helper method that does not use `argparse` at all, instead uses a dict and populating the dataclass\n        types.\n\n        Args:\n            args (`dict`):\n                dict containing config values\n            allow_extra_keys (`bool`, *optional*, defaults to `False`):\n                Defaults to False. If False, will raise an exception if the dict contains keys that are not parsed.\n\n        Returns:\n            Tuple consisting of:\n\n                - the dataclass instances in the same order as they were passed to the initializer.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.instances.Instances::set", "project": "UniRef", "func": "Instances::set", "origin_file": "./Source_Copy/UniRef/detectron2/structures/instances.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 68, "func_end_lineno": 79, "key_block_start_lineno": 74, "key_block_end_lineno": 79, "new_func_code": "def set(self, name: str, value: Any) -> None:\n        \"\"\"\n        Set the field named `name` to `value`.\n        The length of `value` must be the number of instances,\n        and must agree with other existing fields in this object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.instances.Instances::__getitem__", "project": "UniRef", "func": "Instances::__getitem__", "origin_file": "./Source_Copy/UniRef/detectron2/structures/instances.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 122, "func_end_lineno": 140, "key_block_start_lineno": 131, "key_block_end_lineno": 140, "new_func_code": "def __getitem__(self, item: Union[int, slice, torch.BoolTensor]) -> \"Instances\":\n        \"\"\"\n        Args:\n            item: an index-like object and will be used to index all the fields.\n\n        Returns:\n            If `item` is a string, return the data in the corresponding field.\n            Otherwise, returns an `Instances` where all fields are indexed by `item`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.Boxes::__getitem__", "project": "UniRef", "func": "Boxes::__getitem__", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 213, "func_end_lineno": 235, "key_block_start_lineno": 231, "key_block_end_lineno": 235, "new_func_code": "def __getitem__(self, item) -> \"Boxes\":\n        \"\"\"\n        Args:\n            item: int, slice, or a BoolTensor\n\n        Returns:\n            Boxes: Create a new :class:`Boxes` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_boxes = boxes[3]`: return a `Boxes` which contains only one box.\n        2. `new_boxes = boxes[2:10]`: return a slice of boxes.\n        3. `new_boxes = boxes[vector]`, where vector is a torch.BoolTensor\n           with `length = len(boxes)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned Boxes might share storage with this Boxes,\n        subject to Pytorch's indexing semantics.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.config.config._called_with_cfg", "project": "UniRef", "func": "_called_with_cfg", "origin_file": "./Source_Copy/UniRef/detectron2/config/config.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 251, "func_end_lineno": 265, "key_block_start_lineno": 257, "key_block_end_lineno": 265, "new_func_code": "def _called_with_cfg(*args, **kwargs):\n    \"\"\"\n    Returns:\n        bool: whether the arguments contain CfgNode and should be considered\n            forwarded to from_config.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::forward", "project": "UniRef", "func": "FastRCNNOutputLayers::forward", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 259, "func_end_lineno": 276, "key_block_start_lineno": 272, "key_block_end_lineno": 276, "new_func_code": "def forward(self, x):\n        \"\"\"\n        Args:\n            x: per-region features of shape (N, ...) for N bounding boxes to predict.\n\n        Returns:\n            (Tensor, Tensor):\n            First tensor: shape (N,K+1), scores for each of the N box. Each row contains the\n            scores for K object categories and 1 background class.\n\n            Second tensor: bounding box regression deltas for each box. Shape is shape (N,Kx4),\n            or (N,4) for class-agnostic regression.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::losses", "project": "UniRef", "func": "FastRCNNOutputLayers::losses", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 278, "func_end_lineno": 318, "key_block_start_lineno": 289, "key_block_end_lineno": 318, "new_func_code": "def losses(self, predictions, proposals):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were used\n                to compute predictions. The fields ``proposal_boxes``, ``gt_boxes``,\n                ``gt_classes`` are expected.\n\n        Returns:\n            Dict[str, Tensor]: dict of losses\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn._log_classification_stats", "project": "UniRef", "func": "_log_classification_stats", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 87, "func_end_lineno": 114, "key_block_start_lineno": 95, "key_block_end_lineno": 114, "new_func_code": "def _log_classification_stats(pred_logits, gt_classes, prefix=\"fast_rcnn\"):\n    \"\"\"\n    Log the classification metrics to EventStorage.\n\n    Args:\n        pred_logits: Rx(K+1) logits. The last column is for background class.\n        gt_classes: R labels\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression._dense_box_regression_loss", "project": "UniRef", "func": "_dense_box_regression_loss", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 369, "key_block_start_lineno": 333, "key_block_end_lineno": 369, "new_func_code": "def _dense_box_regression_loss(\n    anchors: List[Union[Boxes, torch.Tensor]],\n    box2box_transform: Box2BoxTransform,\n    pred_anchor_deltas: List[torch.Tensor],\n    gt_boxes: List[torch.Tensor],\n    fg_mask: torch.Tensor,\n    box_reg_loss_type=\"smooth_l1\",\n    smooth_l1_beta=0.0,\n):\n    \"\"\"\n    Compute loss for dense multi-level box regression.\n    Loss is accumulated over ``fg_mask``.\n\n    Args:\n        anchors: #lvl anchor boxes, each is (HixWixA, 4)\n        pred_anchor_deltas: #lvl predictions, each is (N, HixWixA, 4)\n        gt_boxes: N ground truth boxes, each has shape (R, 4) (R = sum(Hi * Wi * A))\n        fg_mask: the foreground boolean mask of shape (N, R) to compute loss on\n        box_reg_loss_type (str): Loss type to use. Supported losses: \"smooth_l1\", \"giou\",\n            \"diou\", \"ciou\".\n        smooth_l1_beta (float): beta parameter for the smooth L1 regression loss. Default to\n            use L1 loss. Only used when `box_reg_loss_type` is \"smooth_l1\"\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransform::get_deltas", "project": "UniRef", "func": "Box2BoxTransform::get_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 43, "func_end_lineno": 76, "key_block_start_lineno": 55, "key_block_end_lineno": 76, "new_func_code": "def get_deltas(self, src_boxes, target_boxes):\n        \"\"\"\n        Get box regression transformation deltas (dx, dy, dw, dh) that can be used\n        to transform the `src_boxes` into the `target_boxes`. That is, the relation\n        ``target_boxes == self.apply_deltas(deltas, src_boxes)`` is true (unless\n        any delta is too large and is clamped).\n\n        Args:\n            src_boxes (Tensor): source boxes, e.g., object proposals\n            target_boxes (Tensor): target of the transformation, e.g., ground-truth\n                boxes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransformRotated::get_deltas", "project": "UniRef", "func": "Box2BoxTransformRotated::get_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 145, "func_end_lineno": 181, "key_block_start_lineno": 157, "key_block_end_lineno": 181, "new_func_code": "def get_deltas(self, src_boxes, target_boxes):\n        \"\"\"\n        Get box regression transformation deltas (dx, dy, dw, dh, da) that can be used\n        to transform the `src_boxes` into the `target_boxes`. That is, the relation\n        ``target_boxes == self.apply_deltas(deltas, src_boxes)`` is true (unless\n        any delta is too large and is clamped).\n\n        Args:\n            src_boxes (Tensor): Nx5 source boxes, e.g., object proposals\n            target_boxes (Tensor): Nx5 target of the transformation, e.g., ground-truth\n                boxes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.config.instantiate.instantiate", "project": "UniRef", "func": "instantiate", "origin_file": "./Source_Copy/UniRef/detectron2/config/instantiate.py", "test_list": ["tests/config/test_instantiate_config.py"], "prob_info": {"func_start_lineno": 36, "func_end_lineno": 82, "key_block_start_lineno": 48, "key_block_end_lineno": 82, "new_func_code": "def instantiate(cfg):\n    \"\"\"\n    Recursively instantiate objects defined in dictionaries by\n    \"_target_\" and arguments.\n\n    Args:\n        cfg: a dict-like object with \"_target_\" that defines the caller, and\n            other keys that define the arguments\n\n    Returns:\n        object instantiated by cfg\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.transform_instance_annotations", "project": "UniRef", "func": "transform_instance_annotations", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 257, "func_end_lineno": 318, "key_block_start_lineno": 281, "key_block_end_lineno": 318, "new_func_code": "def transform_instance_annotations(\n    annotation, transforms, image_size, *, keypoint_hflip_indices=None\n):\n    \"\"\"\n    Apply transforms to box, segmentation and keypoints annotations of a single instance.\n\n    It will use `transforms.apply_box` for the box, and\n    `transforms.apply_coords` for segmentation polygons & keypoints.\n    If you need anything more specially designed for each data structure,\n    you'll need to implement your own version of this function or the transforms.\n\n    Args:\n        annotation (dict): dict of instance annotations for a single instance.\n            It will be modified in-place.\n        transforms (TransformList or list[Transform]):\n        image_size (tuple): the height, width of the transformed image\n        keypoint_hflip_indices (ndarray[int]): see `create_keypoint_hflip_indices`.\n\n    Returns:\n        dict:\n            the same input dict with fields \"bbox\", \"segmentation\", \"keypoints\"\n            transformed according to `transforms`.\n            The \"bbox_mode\" field will be set to XYXY_ABS.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.create_keypoint_hflip_indices", "project": "UniRef", "func": "create_keypoint_hflip_indices", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 509, "func_end_lineno": 531, "key_block_start_lineno": 518, "key_block_end_lineno": 531, "new_func_code": "def create_keypoint_hflip_indices(dataset_names: Union[str, List[str]]) -> List[int]:\n    \"\"\"\n    Args:\n        dataset_names: list of dataset names\n\n    Returns:\n        list[int]: a list of size=#keypoints, storing the\n        horizontally-flipped keypoint indices.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.check_metadata_consistency", "project": "UniRef", "func": "check_metadata_consistency", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 564, "func_end_lineno": 590, "key_block_start_lineno": 576, "key_block_end_lineno": 590, "new_func_code": "def check_metadata_consistency(key, dataset_names):\n    \"\"\"\n    Check that the datasets have consistent metadata.\n\n    Args:\n        key (str): a metadata key\n        dataset_names (list[str]): a list of dataset names\n\n    Raises:\n        AttributeError: if the key does not exist in the metadata\n        ValueError: if the given datasets do not have the same metadata values defined by key\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.catalog._MetadataCatalog::get", "project": "UniRef", "func": "_MetadataCatalog::get", "origin_file": "./Source_Copy/UniRef/detectron2/data/catalog.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 194, "func_end_lineno": 207, "key_block_start_lineno": 203, "key_block_end_lineno": 207, "new_func_code": "def get(self, name):\n        \"\"\"\n        Args:\n            name (str): name of a dataset (e.g. coco_2014_train).\n\n        Returns:\n            Metadata: The :class:`Metadata` instance associated with this name,\n            or create an empty one if none is available.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.read_image", "project": "UniRef", "func": "read_image", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 166, "func_end_lineno": 185, "key_block_start_lineno": 180, "key_block_end_lineno": 185, "new_func_code": "def read_image(file_name, format=None):\n    \"\"\"\n    Read an image into the given format.\n    Will apply rotation and flipping if the image has such exif information.\n\n    Args:\n        file_name (str): image file path\n        format (str): one of the supported image modes in PIL, or \"BGR\" or \"YUV-BT.601\".\n\n    Returns:\n        image (np.ndarray):\n            an HWC image in the given format, which is 0-255, uint8 for\n            supported image modes in PIL or \"BGR\"; float (0-1 for Y) for YUV-BT.601.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils._apply_exif_orientation", "project": "UniRef", "func": "_apply_exif_orientation", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 119, "func_end_lineno": 163, "key_block_start_lineno": 138, "key_block_end_lineno": 163, "new_func_code": "def _apply_exif_orientation(image):\n    \"\"\"\n    Applies the exif orientation correctly.\n\n    This code exists per the bug:\n      https://github.com/python-pillow/Pillow/issues/3973\n    with the function `ImageOps.exif_transpose`. The Pillow source raises errors with\n    various methods, especially `tobytes`\n\n    Function based on:\n      https://github.com/wkentaro/labelme/blob/v4.5.4/labelme/utils/image.py#L59\n      https://github.com/python-pillow/Pillow/blob/7.1.2/src/PIL/ImageOps.py#L527\n\n    Args:\n        image (PIL.Image): a PIL image\n\n    Returns:\n        (PIL.Image): the PIL image with exif orientation applied, if applicable\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.convert_PIL_to_numpy", "project": "UniRef", "func": "convert_PIL_to_numpy", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 60, "func_end_lineno": 90, "key_block_start_lineno": 71, "key_block_end_lineno": 90, "new_func_code": "def convert_PIL_to_numpy(image, format):\n    \"\"\"\n    Convert PIL image to numpy array of target format.\n\n    Args:\n        image (PIL.Image): a PIL image\n        format (str): the format of output image\n\n    Returns:\n        (np.ndarray): also see `read_image`\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.annotations_to_instances", "project": "UniRef", "func": "annotations_to_instances", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 369, "func_end_lineno": 441, "key_block_start_lineno": 385, "key_block_end_lineno": 441, "new_func_code": "def annotations_to_instances(annos, image_size, mask_format=\"polygon\"):\n    \"\"\"\n    Create an :class:`Instances` object used by the models,\n    from instance annotations in the dataset dict.\n\n    Args:\n        annos (list[dict]): a list of instance annotations in one image, each\n            element for one instance.\n        image_size (tuple): height, width\n\n    Returns:\n        Instances:\n            It will contain fields \"gt_boxes\", \"gt_classes\",\n            \"gt_masks\", \"gt_keypoints\", if they can be obtained from `annos`.\n            This is the format that builtin models expect.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.hungarian_tracker.BaseHungarianTracker::_initialize_extra_fields", "project": "UniRef", "func": "BaseHungarianTracker::_initialize_extra_fields", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/hungarian_tracker.py", "test_list": ["tests/tracking/test_hungarian_tracker.py"], "prob_info": {"func_start_lineno": 74, "func_end_lineno": 95, "key_block_start_lineno": 84, "key_block_end_lineno": 95, "new_func_code": "def _initialize_extra_fields(self, instances: Instances) -> Instances:\n        \"\"\"\n        If input instances don't have ID, ID_period, lost_frame_count fields,\n        this method is used to initialize these fields.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances with extra fields added\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.catalog._DatasetCatalog::get", "project": "UniRef", "func": "_DatasetCatalog::get", "origin_file": "./Source_Copy/UniRef/detectron2/data/catalog.py", "test_list": ["tests/data/test_coco.py"], "prob_info": {"func_start_lineno": 40, "func_end_lineno": 58, "key_block_start_lineno": 50, "key_block_end_lineno": 58, "new_func_code": "def get(self, name):\n        \"\"\"\n        Call the registered function and return its results.\n\n        Args:\n            name (str): the name that identifies a dataset, e.g. \"coco_2014_train\".\n\n        Returns:\n            list[dict]: dataset annotations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.datasets.coco.load_coco_json", "project": "UniRef", "func": "load_coco_json", "origin_file": "./Source_Copy/UniRef/detectron2/data/datasets/coco.py", "test_list": ["tests/data/test_coco.py"], "prob_info": {"func_start_lineno": 30, "func_end_lineno": 229, "key_block_start_lineno": 64, "key_block_end_lineno": 229, "new_func_code": "def load_coco_json(json_file, image_root, dataset_name=None, extra_annotation_keys=None, dataset_name_in_dict=\"coco\"):\n    \"\"\"\n    Load a json file with COCO's instances annotation format.\n    Currently supports instance detection, instance segmentation,\n    and person keypoints annotations.\n\n    Args:\n        json_file (str): full path to the json file in COCO instances annotation format.\n        image_root (str or path-like): the directory where the images in this json file exists.\n        dataset_name (str or None): the name of the dataset (e.g., coco_2017_train).\n            When provided, this function will also do the following:\n\n            * Put \"thing_classes\" into the metadata associated with this dataset.\n            * Map the category ids into a contiguous range (needed by standard dataset format),\n              and add \"thing_dataset_id_to_contiguous_id\" to the metadata associated\n              with this dataset.\n\n            This option should usually be provided, unless users need to load\n            the original json content and apply more processing manually.\n        extra_annotation_keys (list[str]): list of per-annotation keys that should also be\n            loaded into the dataset dict (besides \"iscrowd\", \"bbox\", \"keypoints\",\n            \"category_id\", \"segmentation\"). The values for these keys will be returned as-is.\n            For example, the densepose annotations are loaded in this way.\n\n    Returns:\n        list[dict]: a list of dicts in Detectron2 standard dataset dicts format (See\n        `Using Custom Datasets </tutorials/datasets.html>`_ ) when `dataset_name` is not None.\n        If `dataset_name` is None, the returned `category_ids` may be\n        incontiguous and may not conform to the Detectron2 standard format.\n\n    Notes:\n        1. This function does not read the image files.\n           The results do not have the \"image\" field.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.VisImage::_setup_figure", "project": "UniRef", "func": "VisImage::_setup_figure", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 276, "func_end_lineno": 299, "key_block_start_lineno": 285, "key_block_end_lineno": 299, "new_func_code": "def _setup_figure(self, img):\n        \"\"\"\n        Args:\n            Same as in :meth:`__init__()`.\n\n        Returns:\n            fig (matplotlib.pyplot.figure): top level container for all the image plot elements.\n            ax (matplotlib.pyplot.Axes): contains figure elements and sets the coordinate system.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer._create_text_labels", "project": "UniRef", "func": "_create_text_labels", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 237, "func_end_lineno": 261, "key_block_start_lineno": 248, "key_block_end_lineno": 261, "new_func_code": "def _create_text_labels(classes, scores, class_names, is_crowd=None):\n    \"\"\"\n    Args:\n        classes (list[int] or None):\n        scores (list[float] or None):\n        class_names (list[str] or None):\n        is_crowd (list[bool] or None):\n\n    Returns:\n        list[str] or None\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::overlay_instances", "project": "UniRef", "func": "Visualizer::overlay_instances", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 614, "func_end_lineno": 754, "key_block_start_lineno": 652, "key_block_end_lineno": 754, "new_func_code": "def overlay_instances(\n        self,\n        *,\n        boxes=None,\n        labels=None,\n        masks=None,\n        keypoints=None,\n        assigned_colors=None,\n        alpha=0.5,\n    ):\n        \"\"\"\n        Args:\n            boxes (Boxes, RotatedBoxes or ndarray): either a :class:`Boxes`,\n                or an Nx4 numpy array of XYXY_ABS format for the N objects in a single image,\n                or a :class:`RotatedBoxes`,\n                or an Nx5 numpy array of (x_center, y_center, width, height, angle_degrees) format\n                for the N objects in a single image,\n            labels (list[str]): the text to be displayed for each instance.\n            masks (masks-like object): Supported types are:\n\n                * :class:`detectron2.structures.PolygonMasks`,\n                  :class:`detectron2.structures.BitMasks`.\n                * list[list[ndarray]]: contains the segmentation masks for all objects in one image.\n                  The first level of the list corresponds to individual instances. The second\n                  level to all the polygon that compose the instance, and the third level\n                  to the polygon coordinates. The third level should have the format of\n                  [x0, y0, x1, y1, ..., xn, yn] (n >= 3).\n                * list[ndarray]: each ndarray is a binary mask of shape (H, W).\n                * list[dict]: each dict is a COCO-style RLE.\n            keypoints (Keypoint or array like): an array-like object of shape (N, K, 3),\n                where the N is the number of instances and K is the number of keypoints.\n                The last dimension corresponds to (x, y, visibility or score).\n            assigned_colors (list[matplotlib.colors]): a list of colors, where each color\n                corresponds to each mask or box in the image. Refer to 'matplotlib.colors'\n                for full list of formats that the colors are accepted in.\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::_convert_masks", "project": "UniRef", "func": "Visualizer::_convert_masks", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1221, "func_end_lineno": 1242, "key_block_start_lineno": 1228, "key_block_end_lineno": 1242, "new_func_code": "def _convert_masks(self, masks_or_polygons):\n        \"\"\"\n        Convert different format of masks or polygons to a tuple of masks and polygons.\n\n        Returns:\n            list[GenericMask]:\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.colormap.random_color", "project": "UniRef", "func": "random_color", "origin_file": "./Source_Copy/UniRef/detectron2/utils/colormap.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 112, "func_end_lineno": 125, "key_block_start_lineno": 121, "key_block_end_lineno": 125, "new_func_code": "def random_color(rgb=False, maximum=255):\n    \"\"\"\n    Args:\n        rgb (bool): whether to return RGB colors or BGR colors.\n        maximum (int): either 255 or 1\n\n    Returns:\n        ndarray: a vector of 3 numbers\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.matcher.Matcher::__call__", "project": "UniRef", "func": "Matcher::__call__", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/matcher.py", "test_list": ["tests/modeling/test_matcher.py"], "prob_info": {"func_start_lineno": 62, "func_end_lineno": 104, "key_block_start_lineno": 76, "key_block_end_lineno": 104, "new_func_code": "def __call__(self, match_quality_matrix):\n        \"\"\"\n        Args:\n            match_quality_matrix (Tensor[float]): an MxN tensor, containing the\n                pairwise quality between M ground-truth elements and N predicted\n                elements. All elements must be >= 0 (due to the us of `torch.nonzero`\n                for selecting indices in :meth:`set_low_quality_matches_`).\n\n        Returns:\n            matches (Tensor[int64]): a vector of length N, where matches[i] is a matched\n                ground-truth index in [0, M)\n            match_labels (Tensor[int8]): a vector of length N, where pred_labels[i] indicates\n                whether a prediction is a true or false positive or ignored\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.vanilla_hungarian_bbox_iou_tracker.VanillaHungarianBBoxIOUTracker::assign_cost_matrix_values", "project": "UniRef", "func": "VanillaHungarianBBoxIOUTracker::assign_cost_matrix_values", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/vanilla_hungarian_bbox_iou_tracker.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 118, "func_end_lineno": 131, "key_block_start_lineno": 128, "key_block_end_lineno": 131, "new_func_code": "def assign_cost_matrix_values(self, cost_matrix: np.ndarray, bbox_pairs: List) -> np.ndarray:\n        \"\"\"\n        Based on IoU for each pair of bbox, assign the associated value in cost matrix\n\n        Args:\n            cost_matrix: np.ndarray, initialized 2D array with target dimensions\n            bbox_pairs: list of bbox pair, in each pair, iou value is stored\n        Return:\n            np.ndarray, cost_matrix with assigned values\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.base_tracker.build_tracker_head", "project": "UniRef", "func": "build_tracker_head", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/base_tracker.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 53, "func_end_lineno": 64, "key_block_start_lineno": 62, "key_block_end_lineno": 64, "new_func_code": "def build_tracker_head(cfg: CfgNode_) -> BaseTracker:\n    \"\"\"\n    Build a tracker head from `cfg.TRACKER_HEADS.TRACKER_NAME`.\n\n    Args:\n        cfg: D2 CfgNode, config file with tracker information\n    Return:\n        tracker object\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.pairwise_iou", "project": "UniRef", "func": "pairwise_iou", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 334, "func_end_lineno": 356, "key_block_start_lineno": 346, "key_block_end_lineno": 356, "new_func_code": "def pairwise_iou(boxes1: Boxes, boxes2: Boxes) -> torch.Tensor:\n    \"\"\"\n    Given two lists of boxes of size N and M, compute the IoU\n    (intersection over union) between **all** N x M pairs of boxes.\n    The box order must be (xmin, ymin, xmax, ymax).\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: IoU, sized [N,M].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.utils.create_prediction_pairs", "project": "UniRef", "func": "create_prediction_pairs", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/utils.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 36, "key_block_start_lineno": 22, "key_block_end_lineno": 36, "new_func_code": "def create_prediction_pairs(\n    instances: Instances,\n    prev_instances: Instances,\n    iou_all: np.ndarray,\n    threshold: float = 0.5,\n) -> List:\n    \"\"\"\n    Args:\n        instances: predictions from current frame\n        prev_instances: predictions from previous frame\n        iou_all: 2D numpy array containing iou for each bbox pair\n        threshold: below the threshold, doesn't consider the pair of bbox is valid\n    Return:\n        List of bbox pairs\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_initialize_extra_fields", "project": "UniRef", "func": "BBoxIOUTracker::_initialize_extra_fields", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 152, "func_end_lineno": 173, "key_block_start_lineno": 162, "key_block_end_lineno": 173, "new_func_code": "def _initialize_extra_fields(self, instances: Instances) -> Instances:\n        \"\"\"\n        If input instances don't have ID, ID_period, lost_frame_count fields,\n        this method is used to initialize these fields.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances with extra fields added\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_assign_new_id", "project": "UniRef", "func": "BBoxIOUTracker::_assign_new_id", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 183, "func_end_lineno": 198, "key_block_start_lineno": 192, "key_block_end_lineno": 198, "new_func_code": "def _assign_new_id(self, instances: Instances) -> Instances:\n        \"\"\"\n        For each untracked instance, assign a new id\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances with new ID assigned\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.config.config._get_args_from_config", "project": "UniRef", "func": "_get_args_from_config", "origin_file": "./Source_Copy/UniRef/detectron2/config/config.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 218, "func_end_lineno": 248, "key_block_start_lineno": 225, "key_block_end_lineno": 248, "new_func_code": "def _get_args_from_config(from_config_func, *args, **kwargs):\n    \"\"\"\n    Use `from_config` to obtain explicit arguments.\n\n    Returns:\n        dict: arguments to be used for cls.__init__\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.pairwise_intersection", "project": "UniRef", "func": "pairwise_intersection", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 329, "key_block_start_lineno": 322, "key_block_end_lineno": 329, "new_func_code": "def pairwise_intersection(boxes1: Boxes, boxes2: Boxes) -> torch.Tensor:\n    \"\"\"\n    Given two lists of boxes of size N and M,\n    compute the intersection area between __all__ N x M pairs of boxes.\n    The box order must be (xmin, ymin, xmax, ymax)\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: intersection, sized [N,M].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.layers.batch_norm.get_norm", "project": "UniRef", "func": "get_norm", "origin_file": "./Source_Copy/UniRef/detectron2/layers/batch_norm.py", "test_list": ["tests/layers/test_blocks.py"], "prob_info": {"func_start_lineno": 121, "func_end_lineno": 149, "key_block_start_lineno": 131, "key_block_end_lineno": 149, "new_func_code": "def get_norm(norm, out_channels):\n    \"\"\"\n    Args:\n        norm (str or callable): either one of BN, SyncBN, FrozenBN, GN;\n            or a callable that takes a channel number and returns\n            the normalization layer as a nn.Module.\n\n    Returns:\n        nn.Module or None: the normalization layer\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.backbone.resnet.ResNet::freeze", "project": "UniRef", "func": "ResNet::freeze", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/backbone/resnet.py", "test_list": ["tests/layers/test_blocks.py"], "prob_info": {"func_start_lineno": 468, "func_end_lineno": 490, "key_block_start_lineno": 484, "key_block_end_lineno": 490, "new_func_code": "def freeze(self, freeze_at=0):\n        \"\"\"\n        Freeze the first several stages of the ResNet. Commonly used in\n        fine-tuning.\n\n        Layers that produce the same feature map spatial size are defined as one\n        \"stage\" by :paper:`FPN`.\n\n        Args:\n            freeze_at (int): number of stages to freeze.\n                `1` means freezing the stem. `2` means freezing the stem and\n                one residual stage, etc.\n\n        Returns:\n            nn.Module: this ResNet itself\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.pairwise_ioa", "project": "UniRef", "func": "pairwise_ioa", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/structures/test_boxes.py"], "prob_info": {"func_start_lineno": 359, "func_end_lineno": 376, "key_block_start_lineno": 369, "key_block_end_lineno": 376, "new_func_code": "def pairwise_ioa(boxes1: Boxes, boxes2: Boxes) -> torch.Tensor:\n    \"\"\"\n    Similar to :func:`pariwise_iou` but compute the IoA (intersection over boxes2 area).\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: IoA, sized [N,M].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.iou_weighted_hungarian_bbox_iou_tracker.IOUWeightedHungarianBBoxIOUTracker::assign_cost_matrix_values", "project": "UniRef", "func": "IOUWeightedHungarianBBoxIOUTracker::assign_cost_matrix_values", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/iou_weighted_hungarian_bbox_iou_tracker.py", "test_list": ["tests/tracking/test_iou_weighted_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 88, "func_end_lineno": 101, "key_block_start_lineno": 98, "key_block_end_lineno": 101, "new_func_code": "def assign_cost_matrix_values(self, cost_matrix: np.ndarray, bbox_pairs: List) -> np.ndarray:\n        \"\"\"\n        Based on IoU for each pair of bbox, assign the associated value in cost matrix\n\n        Args:\n            cost_matrix: np.ndarray, initialized 2D array with target dimensions\n            bbox_pairs: list of bbox pair, in each pair, iou value is stored\n        Return:\n            np.ndarray, cost_matrix with assigned values\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.layers.losses.ciou_loss", "project": "UniRef", "func": "ciou_loss", "origin_file": "./Source_Copy/UniRef/detectron2/layers/losses.py", "test_list": ["tests/layers/test_losses.py"], "prob_info": {"func_start_lineno": 66, "func_end_lineno": 133, "key_block_start_lineno": 83, "key_block_end_lineno": 133, "new_func_code": "def ciou_loss(\n    boxes1: torch.Tensor,\n    boxes2: torch.Tensor,\n    reduction: str = \"none\",\n    eps: float = 1e-7,\n) -> torch.Tensor:\n    \"\"\"\n    Complete Intersection over Union Loss (Zhaohui Zheng et. al)\n    https://arxiv.org/abs/1911.08287\n    Args:\n        boxes1, boxes2 (Tensor): box locations in XYXY format, shape (N, 4) or (4,).\n        reduction: 'none' | 'mean' | 'sum'\n                 'none': No reduction will be applied to the output.\n                 'mean': The output will be averaged.\n                 'sum': The output will be summed.\n        eps (float): small number to prevent division by zero\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.layers.losses.diou_loss", "project": "UniRef", "func": "diou_loss", "origin_file": "./Source_Copy/UniRef/detectron2/layers/losses.py", "test_list": ["tests/layers/test_losses.py"], "prob_info": {"func_start_lineno": 5, "func_end_lineno": 63, "key_block_start_lineno": 22, "key_block_end_lineno": 63, "new_func_code": "def diou_loss(\n    boxes1: torch.Tensor,\n    boxes2: torch.Tensor,\n    reduction: str = \"none\",\n    eps: float = 1e-7,\n) -> torch.Tensor:\n    \"\"\"\n    Distance Intersection over Union Loss (Zhaohui Zheng et. al)\n    https://arxiv.org/abs/1911.08287\n    Args:\n        boxes1, boxes2 (Tensor): box locations in XYXY format, shape (N, 4) or (4,).\n        reduction: 'none' | 'mean' | 'sum'\n                 'none': No reduction will be applied to the output.\n                 'mean': The output will be averaged.\n                 'sum': The output will be summed.\n        eps (float): small number to prevent division by zero\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.masks.PolygonMasks::get_bounding_boxes", "project": "UniRef", "func": "PolygonMasks::get_bounding_boxes", "origin_file": "./Source_Copy/UniRef/detectron2/structures/masks.py", "test_list": ["tests/structures/test_masks.py"], "prob_info": {"func_start_lineno": 318, "func_end_lineno": 333, "key_block_start_lineno": 323, "key_block_end_lineno": 333, "new_func_code": "def get_bounding_boxes(self) -> Boxes:\n        \"\"\"\n        Returns:\n            Boxes: tight bounding boxes around polygon masks.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.masks.BitMasks::__getitem__", "project": "UniRef", "func": "BitMasks::__getitem__", "origin_file": "./Source_Copy/UniRef/detectron2/structures/masks.py", "test_list": ["tests/structures/test_masks.py"], "prob_info": {"func_start_lineno": 117, "func_end_lineno": 138, "key_block_start_lineno": 132, "key_block_end_lineno": 138, "new_func_code": "def __getitem__(self, item: Union[int, slice, torch.BoolTensor]) -> \"BitMasks\":\n        \"\"\"\n        Returns:\n            BitMasks: Create a new :class:`BitMasks` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_masks = masks[3]`: return a `BitMasks` which contains only one mask.\n        2. `new_masks = masks[2:10]`: return a slice of masks.\n        3. `new_masks = masks[vector]`, where vector is a torch.BoolTensor\n           with `length = len(masks)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned object might share storage with this object,\n        subject to Pytorch's indexing semantics.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.testing.random_boxes", "project": "UniRef", "func": "random_boxes", "origin_file": "./Source_Copy/UniRef/detectron2/utils/testing.py", "test_list": ["tests/modeling/test_box2box_transform.py"], "prob_info": {"func_start_lineno": 33, "func_end_lineno": 44, "key_block_start_lineno": 37, "key_block_end_lineno": 44, "new_func_code": "def random_boxes(num_boxes, max_coord=100, device=\"cpu\"):\n    \"\"\"\n    Create a random Nx4 boxes tensor, with coordinates < max_coord.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransformLinear::get_deltas", "project": "UniRef", "func": "Box2BoxTransformLinear::get_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_box2box_transform.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 273, "key_block_start_lineno": 255, "key_block_end_lineno": 273, "new_func_code": "def get_deltas(self, src_boxes, target_boxes):\n        \"\"\"\n        Get box regression transformation deltas (dx1, dy1, dx2, dy2) that can be used\n        to transform the `src_boxes` into the `target_boxes`. That is, the relation\n        ``target_boxes == self.apply_deltas(deltas, src_boxes)`` is true.\n        The center of src must be inside target boxes.\n\n        Args:\n            src_boxes (Tensor): square source boxes, e.g., anchors\n            target_boxes (Tensor): target of the transformation, e.g., ground-truth\n                boxes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransformLinear::apply_deltas", "project": "UniRef", "func": "Box2BoxTransformLinear::apply_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_box2box_transform.py"], "prob_info": {"func_start_lineno": 275, "func_end_lineno": 307, "key_block_start_lineno": 285, "key_block_end_lineno": 307, "new_func_code": "def apply_deltas(self, deltas, boxes):\n        \"\"\"\n        Apply transformation `deltas` (dx1, dy1, dx2, dy2) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*4), where k >= 1.\n                deltas[i] represents k potentially different class-specific\n                box transformations for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 4)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransformRotated::apply_deltas", "project": "UniRef", "func": "Box2BoxTransformRotated::apply_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_box2box_transform.py"], "prob_info": {"func_start_lineno": 183, "func_end_lineno": 227, "key_block_start_lineno": 192, "key_block_end_lineno": 227, "new_func_code": "def apply_deltas(self, deltas, boxes):\n        \"\"\"\n        Apply transformation `deltas` (dx, dy, dw, dh, da) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*5).\n                deltas[i] represents box transformation for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 5)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator._broadcast_params", "project": "UniRef", "func": "_broadcast_params", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 54, "func_end_lineno": 78, "key_block_start_lineno": 66, "key_block_end_lineno": 78, "new_func_code": "def _broadcast_params(params, num_features, name):\n    \"\"\"\n    If one size (or aspect ratio) is specified and there are multiple feature\n    maps, we \"broadcast\" anchors of that single size (or aspect ratio)\n    over all feature maps.\n\n    If params is list[float], or list[list[float]] with len(params) == 1, repeat\n    it num_features time.\n\n    Returns:\n        list[list[float]]: param for each feature\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.DefaultAnchorGenerator::generate_cell_anchors", "project": "UniRef", "func": "DefaultAnchorGenerator::generate_cell_anchors", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 177, "func_end_lineno": 212, "key_block_start_lineno": 192, "key_block_end_lineno": 212, "new_func_code": "def generate_cell_anchors(self, sizes=(32, 64, 128, 256, 512), aspect_ratios=(0.5, 1, 2)):\n        \"\"\"\n        Generate a tensor storing canonical anchor boxes, which are all anchor\n        boxes of different sizes and aspect_ratios centered at (0, 0).\n        We can later build the set of anchors for a full feature map by\n        shifting and tiling these tensors (see `meth:_grid_anchors`).\n\n        Args:\n            sizes (tuple[float]):\n            aspect_ratios (tuple[float]]):\n\n        Returns:\n            Tensor of shape (len(sizes) * len(aspect_ratios), 4) storing anchor boxes\n                in XYXY format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.DefaultAnchorGenerator::forward", "project": "UniRef", "func": "DefaultAnchorGenerator::forward", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 214, "func_end_lineno": 227, "key_block_start_lineno": 225, "key_block_end_lineno": 227, "new_func_code": "def forward(self, features: List[torch.Tensor]):\n        \"\"\"\n        Args:\n            features (list[Tensor]): list of backbone feature maps on which to generate anchors.\n\n        Returns:\n            list[Boxes]: a list of Boxes containing all the anchors for each feature map\n                (i.e. the cell anchors repeated over all locations in the feature map).\n                The number of anchors of each feature map is Hi x Wi x num_cell_anchors,\n                where Hi, Wi are resolution of the feature map divided by anchor stride.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.DefaultAnchorGenerator::num_anchors", "project": "UniRef", "func": "DefaultAnchorGenerator::num_anchors", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 148, "func_end_lineno": 159, "key_block_start_lineno": 159, "key_block_end_lineno": 159, "new_func_code": "def num_anchors(self):\n        \"\"\"\n        Returns:\n            list[int]: Each int is the number of anchors at every pixel\n                location, on that feature map.\n                For example, if at every pixel we use anchors of 3 aspect\n                ratios and 5 sizes, the number of anchors is 15.\n                (See also ANCHOR_GENERATOR.SIZES and ANCHOR_GENERATOR.ASPECT_RATIOS in config)\n\n                In standard RPN models, `num_anchors` on every feature map is the same.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.RotatedAnchorGenerator::forward", "project": "UniRef", "func": "RotatedAnchorGenerator::forward", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 361, "func_end_lineno": 374, "key_block_start_lineno": 372, "key_block_end_lineno": 374, "new_func_code": "def forward(self, features):\n        \"\"\"\n        Args:\n            features (list[Tensor]): list of backbone feature maps on which to generate anchors.\n\n        Returns:\n            list[RotatedBoxes]: a list of Boxes containing all the anchors for each feature map\n                (i.e. the cell anchors repeated over all locations in the feature map).\n                The number of anchors of each feature map is Hi x Wi x num_cell_anchors,\n                where Hi, Wi are resolution of the feature map divided by anchor stride.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.events.EventStorage::put_scalar", "project": "UniRef", "func": "EventStorage::put_scalar", "origin_file": "./Source_Copy/UniRef/detectron2/utils/events.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 309, "func_end_lineno": 334, "key_block_start_lineno": 322, "key_block_end_lineno": 334, "new_func_code": "def put_scalar(self, name, value, smoothing_hint=True):\n        \"\"\"\n        Add a scalar `value` to the `HistoryBuffer` associated with `name`.\n\n        Args:\n            smoothing_hint (bool): a 'hint' on whether this scalar is noisy and should be\n                smoothed when logged. The hint will be accessible through\n                :meth:`EventStorage.smoothing_hints`.  A writer may ignore the hint\n                and apply custom smoothing rule.\n\n                It defaults to True because most scalars we save need to be smoothed to\n                provide any useful signal.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::box_reg_loss", "project": "UniRef", "func": "FastRCNNOutputLayers::box_reg_loss", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 320, "func_end_lineno": 359, "key_block_start_lineno": 328, "key_block_end_lineno": 359, "new_func_code": "def box_reg_loss(self, proposal_boxes, gt_boxes, pred_deltas, gt_classes):\n        \"\"\"\n        Args:\n            proposal_boxes/gt_boxes are tensors with the same shape (R, 4 or 5).\n            pred_deltas has shape (R, 4 or 5), or (R, num_classes * (4 or 5)).\n            gt_classes is a long tensor of shape R, the gt class label of each proposal.\n            R shall be the number of proposals.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::inference", "project": "UniRef", "func": "FastRCNNOutputLayers::inference", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 361, "func_end_lineno": 382, "key_block_start_lineno": 372, "key_block_end_lineno": 382, "new_func_code": "def inference(self, predictions: Tuple[torch.Tensor, torch.Tensor], proposals: List[Instances]):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions. The ``proposal_boxes`` field is expected.\n\n        Returns:\n            list[Instances]: same as `fast_rcnn_inference`.\n            list[Tensor]: same as `fast_rcnn_inference`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::predict_boxes", "project": "UniRef", "func": "FastRCNNOutputLayers::predict_boxes", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 419, "func_end_lineno": 443, "key_block_start_lineno": 434, "key_block_end_lineno": 443, "new_func_code": "def predict_boxes(\n        self, predictions: Tuple[torch.Tensor, torch.Tensor], proposals: List[Instances]\n    ):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions. The ``proposal_boxes`` field is expected.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted class-specific or class-agnostic boxes\n                for each image. Element i has shape (Ri, K * B) or (Ri, B), where Ri is\n                the number of proposals for image i and B is the box dimension (4 or 5)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::predict_probs", "project": "UniRef", "func": "FastRCNNOutputLayers::predict_probs", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 445, "func_end_lineno": 462, "key_block_start_lineno": 459, "key_block_end_lineno": 462, "new_func_code": "def predict_probs(\n        self, predictions: Tuple[torch.Tensor, torch.Tensor], proposals: List[Instances]\n    ):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted class probabilities for each image.\n                Element i has shape (Ri, K + 1), where Ri is the number of proposals for image i.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.fast_rcnn_inference", "project": "UniRef", "func": "fast_rcnn_inference", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 45, "func_end_lineno": 84, "key_block_start_lineno": 78, "key_block_end_lineno": 84, "new_func_code": "def fast_rcnn_inference(\n    boxes: List[torch.Tensor],\n    scores: List[torch.Tensor],\n    image_shapes: List[Tuple[int, int]],\n    score_thresh: float,\n    nms_thresh: float,\n    topk_per_image: int,\n):\n    \"\"\"\n    Call `fast_rcnn_inference_single_image` for all images.\n\n    Args:\n        boxes (list[Tensor]): A list of Tensors of predicted class-specific or class-agnostic\n            boxes for each image. Element i has shape (Ri, K * 4) if doing\n            class-specific regression, or (Ri, 4) if doing class-agnostic\n            regression, where Ri is the number of predicted objects for image i.\n            This is compatible with the output of :meth:`FastRCNNOutputLayers.predict_boxes`.\n        scores (list[Tensor]): A list of Tensors of predicted class scores for each image.\n            Element i has shape (Ri, K + 1), where Ri is the number of predicted objects\n            for image i. Compatible with the output of :meth:`FastRCNNOutputLayers.predict_probs`.\n        image_shapes (list[tuple]): A list of (width, height) tuples for each image in the batch.\n        score_thresh (float): Only return detections with a confidence score exceeding this\n            threshold.\n        nms_thresh (float):  The threshold to use for box non-maximum suppression. Value in [0, 1].\n        topk_per_image (int): The number of top scoring detections to return. Set < 0 to return\n            all detections.\n\n    Returns:\n        instances: (list[Instances]): A list of N instances, one for each image in the batch,\n            that stores the topk most confidence detections.\n        kept_indices: (list[Tensor]): A list of 1D tensor of length of N, each element indicates\n            the corresponding boxes/scores index in [0, Ri) from the input, for image i.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.export.torchscript_patch.patch_builtin_len", "project": "UniRef", "func": "patch_builtin_len", "origin_file": "./Source_Copy/UniRef/detectron2/export/torchscript_patch.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 316, "func_end_lineno": 339, "key_block_start_lineno": 326, "key_block_end_lineno": 339, "new_func_code": "def patch_builtin_len(modules=()):\n    \"\"\"\n    Patch the builtin len() function of a few detectron2 modules\n    to use __len__ instead, because __len__ does not convert values to\n    integers and therefore is friendly to tracing.\n\n    Args:\n        modules (list[stsr]): names of extra modules to patch len(), in\n            addition to those in detectron2.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.gen_crop_transform_with_instance", "project": "UniRef", "func": "gen_crop_transform_with_instance", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 534, "func_end_lineno": 561, "key_block_start_lineno": 545, "key_block_end_lineno": 561, "new_func_code": "def gen_crop_transform_with_instance(crop_size, image_size, instance):\n    \"\"\"\n    Generate a CropTransform so that the cropping region contains\n    the center of the given instance.\n\n    Args:\n        crop_size (tuple): h, w in pixels\n        image_size (tuple): h, w\n        instance (dict): an annotation dict of one instance, in Detectron2's\n            dataset format.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_box", "project": "UniRef", "func": "Visualizer::draw_box", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 904, "func_end_lineno": 936, "key_block_start_lineno": 918, "key_block_end_lineno": 936, "new_func_code": "def draw_box(self, box_coord, alpha=0.5, edge_color=\"g\", line_style=\"-\"):\n        \"\"\"\n        Args:\n            box_coord (tuple): a tuple containing x0, y0, x1, y1 coordinates, where x0 and y0\n                are the coordinates of the image's top left corner. x1 and y1 are the\n                coordinates of the image's bottom right corner.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            edge_color: color of the outline of the box. Refer to `matplotlib.colors`\n                for full list of formats that are accepted.\n            line_style (string): the string to use to create the outline of the boxes.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::_change_color_brightness", "project": "UniRef", "func": "Visualizer::_change_color_brightness", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1187, "func_end_lineno": 1210, "key_block_start_lineno": 1203, "key_block_end_lineno": 1210, "new_func_code": "def _change_color_brightness(self, color, brightness_factor):\n        \"\"\"\n        Depending on the brightness_factor, gives a lighter or darker color i.e. a color with\n        less or more saturation than the original color.\n\n        Args:\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            brightness_factor (float): a value in [-1.0, 1.0] range. A lightness factor of\n                0 will correspond to no change, a factor in [-1.0, 0) range will result in\n                a darker color and a factor in (0, 1.0] range will result in a lighter color.\n\n        Returns:\n            modified_color (tuple[double]): a tuple containing the RGB values of the\n                modified color. Each value in the tuple is in the [0.0, 1.0] range.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_text", "project": "UniRef", "func": "Visualizer::draw_text", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 857, "func_end_lineno": 902, "key_block_start_lineno": 881, "key_block_end_lineno": 902, "new_func_code": "def draw_text(\n        self,\n        text,\n        position,\n        *,\n        font_size=None,\n        color=\"g\",\n        horizontal_alignment=\"center\",\n        rotation=0,\n    ):\n        \"\"\"\n        Args:\n            text (str): class label\n            position (tuple): a tuple of the x and y coordinates to place text on image.\n            font_size (int, optional): font of the text. If not provided, a font size\n                proportional to the image width is calculated and used.\n            color: color of the text. Refer to `matplotlib.colors` for full list\n                of formats that are accepted.\n            horizontal_alignment (str): see `matplotlib.text.Text`\n            rotation: rotation angle in degrees CCW\n\n        Returns:\n            output (VisImage): image object with text drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_polygon", "project": "UniRef", "func": "Visualizer::draw_polygon", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1121, "func_end_lineno": 1151, "key_block_start_lineno": 1135, "key_block_end_lineno": 1151, "new_func_code": "def draw_polygon(self, segment, color, edge_color=None, alpha=0.5):\n        \"\"\"\n        Args:\n            segment: numpy array of shape Nx2, containing all the points in the polygon.\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            edge_color: color of the polygon edges. Refer to `matplotlib.colors` for a\n                full list of formats that are accepted. If not provided, a darker shade\n                of the polygon color will be used instead.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n\n        Returns:\n            output (VisImage): image object with polygon drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_dataset_dict", "project": "UniRef", "func": "Visualizer::draw_dataset_dict", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 545, "func_end_lineno": 612, "key_block_start_lineno": 555, "key_block_end_lineno": 612, "new_func_code": "def draw_dataset_dict(self, dic):\n        \"\"\"\n        Draw annotations/segmentaions in Detectron2 Dataset format.\n\n        Args:\n            dic (dict): annotation/segmentation data of one image, in Detectron2 Dataset format.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::overlay_rotated_instances", "project": "UniRef", "func": "Visualizer::overlay_rotated_instances", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 756, "func_end_lineno": 792, "key_block_start_lineno": 770, "key_block_end_lineno": 792, "new_func_code": "def overlay_rotated_instances(self, boxes=None, labels=None, assigned_colors=None):\n        \"\"\"\n        Args:\n            boxes (ndarray): an Nx5 numpy array of\n                (x_center, y_center, width, height, angle_degrees) format\n                for the N objects in a single image.\n            labels (list[str]): the text to be displayed for each instance.\n            assigned_colors (list[matplotlib.colors]): a list of colors, where each color\n                corresponds to each mask or box in the image. Refer to 'matplotlib.colors'\n                for full list of formats that the colors are accepted in.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_rotated_box_with_label", "project": "UniRef", "func": "Visualizer::draw_rotated_box_with_label", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 938, "func_end_lineno": 991, "key_block_start_lineno": 958, "key_block_end_lineno": 991, "new_func_code": "def draw_rotated_box_with_label(\n        self, rotated_box, alpha=0.5, edge_color=\"g\", line_style=\"-\", label=None\n    ):\n        \"\"\"\n        Draw a rotated box with label on its top-left corner.\n\n        Args:\n            rotated_box (tuple): a tuple containing (cnt_x, cnt_y, w, h, angle),\n                where cnt_x and cnt_y are the center coordinates of the box.\n                w and h are the width and height of the box. angle represents how\n                many degrees the box is rotated CCW with regard to the 0-degree box.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            edge_color: color of the outline of the box. Refer to `matplotlib.colors`\n                for full list of formats that are accepted.\n            line_style (string): the string to use to create the outline of the boxes.\n            label (string): label for rotated box. It will not be rendered when set to None.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_line", "project": "UniRef", "func": "Visualizer::draw_line", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1011, "func_end_lineno": 1040, "key_block_start_lineno": 1028, "key_block_end_lineno": 1040, "new_func_code": "def draw_line(self, x_data, y_data, color, linestyle=\"-\", linewidth=None):\n        \"\"\"\n        Args:\n            x_data (list[int]): a list containing x values of all the points being drawn.\n                Length of list should match the length of y_data.\n            y_data (list[int]): a list containing y values of all the points being drawn.\n                Length of list should match the length of x_data.\n            color: color of the line. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            linestyle: style of the line. Refer to `matplotlib.lines.Line2D`\n                for a full list of formats that are accepted.\n            linewidth (float or None): width of the line. When it's None,\n                a default value will be computed and used.\n\n        Returns:\n            output (VisImage): image object with line drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_soft_mask", "project": "UniRef", "func": "Visualizer::draw_soft_mask", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1093, "func_end_lineno": 1119, "key_block_start_lineno": 1105, "key_block_end_lineno": 1119, "new_func_code": "def draw_soft_mask(self, soft_mask, color=None, *, text=None, alpha=0.5):\n        \"\"\"\n        Args:\n            soft_mask (ndarray): float array of shape (H, W), each value in [0, 1].\n            color: color of the mask. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted. If None, will pick a random color.\n            text (str): if None, will be drawn on the object\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n\n        Returns:\n            output (VisImage): image object with mask drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_create_prediction_pairs", "project": "UniRef", "func": "BBoxIOUTracker::_create_prediction_pairs", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 123, "func_end_lineno": 150, "key_block_start_lineno": 138, "key_block_end_lineno": 150, "new_func_code": "def _create_prediction_pairs(\n        self, instances: Instances, iou_all: np.ndarray\n    ) -> List:\n        \"\"\"\n        For all instances in previous and current frames, create pairs. For each\n        pair, store index of the instance in current frame predcitions, index in\n        previous predictions, ID in previous predictions, IoU of the bboxes in this\n        pair, period in previous predictions.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n            iou_all: IoU for all bboxes pairs\n        Return:\n            A list of IoU for all pairs\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_merge_untracked_instances", "project": "UniRef", "func": "BBoxIOUTracker::_merge_untracked_instances", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 200, "func_end_lineno": 260, "key_block_start_lineno": 211, "key_block_end_lineno": 260, "new_func_code": "def _merge_untracked_instances(self, instances: Instances) -> Instances:\n        \"\"\"\n        For untracked previous instances, under certain condition, still keep them\n        in tracking and merge with the current instances.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances merging current instances and instances from previous\n            frame decided to keep tracking\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.instances.Instances::set", "project": "UniRef", "func": "Instances::set", "origin_file": "./Source_Copy/UniRef/detectron2/structures/instances.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 68, "func_end_lineno": 79, "key_block_start_lineno": 74, "key_block_end_lineno": 79, "new_func_code": "def set(self, name: str, value: Any) -> None:\n        \"\"\"\n        Set the field named `name` to `value`.\n        The length of `value` must be the number of instances,\n        and must agree with other existing fields in this object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.export.torchscript_patch.patch_instances", "project": "UniRef", "func": "patch_instances", "origin_file": "./Source_Copy/UniRef/detectron2/export/torchscript_patch.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 51, "func_end_lineno": 87, "key_block_start_lineno": 57, "key_block_end_lineno": 87, "new_func_code": "def patch_instances(fields):\n    \"\"\"\n    A contextmanager, under which the Instances class in detectron2 is replaced\n    by a statically-typed scriptable class, defined by `fields`.\n    See more in `scripting_with_instances`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.export.torchscript_patch._gen_instance_class", "project": "UniRef", "func": "_gen_instance_class", "origin_file": "./Source_Copy/UniRef/detectron2/export/torchscript_patch.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 90, "func_end_lineno": 287, "key_block_start_lineno": 95, "key_block_end_lineno": 287, "new_func_code": "def _gen_instance_class(fields):\n    \"\"\"\n    Args:\n        fields (dict[name: type])\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.instances.Instances::__getitem__", "project": "UniRef", "func": "Instances::__getitem__", "origin_file": "./Source_Copy/UniRef/detectron2/structures/instances.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 122, "func_end_lineno": 140, "key_block_start_lineno": 131, "key_block_end_lineno": 140, "new_func_code": "def __getitem__(self, item: Union[int, slice, torch.BoolTensor]) -> \"Instances\":\n        \"\"\"\n        Args:\n            item: an index-like object and will be used to index all the fields.\n\n        Returns:\n            If `item` is a string, return the data in the corresponding field.\n            Otherwise, returns an `Instances` where all fields are indexed by `item`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.Boxes::__getitem__", "project": "UniRef", "func": "Boxes::__getitem__", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 213, "func_end_lineno": 235, "key_block_start_lineno": 231, "key_block_end_lineno": 235, "new_func_code": "def __getitem__(self, item) -> \"Boxes\":\n        \"\"\"\n        Args:\n            item: int, slice, or a BoolTensor\n\n        Returns:\n            Boxes: Create a new :class:`Boxes` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_boxes = boxes[3]`: return a `Boxes` which contains only one box.\n        2. `new_boxes = boxes[2:10]`: return a slice of boxes.\n        3. `new_boxes = boxes[vector]`, where vector is a torch.BoolTensor\n           with `length = len(boxes)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned Boxes might share storage with this Boxes,\n        subject to Pytorch's indexing semantics.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.config.config._called_with_cfg", "project": "UniRef", "func": "_called_with_cfg", "origin_file": "./Source_Copy/UniRef/detectron2/config/config.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 251, "func_end_lineno": 265, "key_block_start_lineno": 257, "key_block_end_lineno": 265, "new_func_code": "def _called_with_cfg(*args, **kwargs):\n    \"\"\"\n    Returns:\n        bool: whether the arguments contain CfgNode and should be considered\n            forwarded to from_config.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::forward", "project": "UniRef", "func": "FastRCNNOutputLayers::forward", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 259, "func_end_lineno": 276, "key_block_start_lineno": 272, "key_block_end_lineno": 276, "new_func_code": "def forward(self, x):\n        \"\"\"\n        Args:\n            x: per-region features of shape (N, ...) for N bounding boxes to predict.\n\n        Returns:\n            (Tensor, Tensor):\n            First tensor: shape (N,K+1), scores for each of the N box. Each row contains the\n            scores for K object categories and 1 background class.\n\n            Second tensor: bounding box regression deltas for each box. Shape is shape (N,Kx4),\n            or (N,4) for class-agnostic regression.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::losses", "project": "UniRef", "func": "FastRCNNOutputLayers::losses", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 278, "func_end_lineno": 318, "key_block_start_lineno": 289, "key_block_end_lineno": 318, "new_func_code": "def losses(self, predictions, proposals):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were used\n                to compute predictions. The fields ``proposal_boxes``, ``gt_boxes``,\n                ``gt_classes`` are expected.\n\n        Returns:\n            Dict[str, Tensor]: dict of losses\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn._log_classification_stats", "project": "UniRef", "func": "_log_classification_stats", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 87, "func_end_lineno": 114, "key_block_start_lineno": 95, "key_block_end_lineno": 114, "new_func_code": "def _log_classification_stats(pred_logits, gt_classes, prefix=\"fast_rcnn\"):\n    \"\"\"\n    Log the classification metrics to EventStorage.\n\n    Args:\n        pred_logits: Rx(K+1) logits. The last column is for background class.\n        gt_classes: R labels\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression._dense_box_regression_loss", "project": "UniRef", "func": "_dense_box_regression_loss", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 369, "key_block_start_lineno": 333, "key_block_end_lineno": 369, "new_func_code": "def _dense_box_regression_loss(\n    anchors: List[Union[Boxes, torch.Tensor]],\n    box2box_transform: Box2BoxTransform,\n    pred_anchor_deltas: List[torch.Tensor],\n    gt_boxes: List[torch.Tensor],\n    fg_mask: torch.Tensor,\n    box_reg_loss_type=\"smooth_l1\",\n    smooth_l1_beta=0.0,\n):\n    \"\"\"\n    Compute loss for dense multi-level box regression.\n    Loss is accumulated over ``fg_mask``.\n\n    Args:\n        anchors: #lvl anchor boxes, each is (HixWixA, 4)\n        pred_anchor_deltas: #lvl predictions, each is (N, HixWixA, 4)\n        gt_boxes: N ground truth boxes, each has shape (R, 4) (R = sum(Hi * Wi * A))\n        fg_mask: the foreground boolean mask of shape (N, R) to compute loss on\n        box_reg_loss_type (str): Loss type to use. Supported losses: \"smooth_l1\", \"giou\",\n            \"diou\", \"ciou\".\n        smooth_l1_beta (float): beta parameter for the smooth L1 regression loss. Default to\n            use L1 loss. Only used when `box_reg_loss_type` is \"smooth_l1\"\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.events.EventStorage::put_scalar", "project": "UniRef", "func": "EventStorage::put_scalar", "origin_file": "./Source_Copy/UniRef/detectron2/utils/events.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 309, "func_end_lineno": 334, "key_block_start_lineno": 322, "key_block_end_lineno": 334, "new_func_code": "def put_scalar(self, name, value, smoothing_hint=True):\n        \"\"\"\n        Add a scalar `value` to the `HistoryBuffer` associated with `name`.\n\n        Args:\n            smoothing_hint (bool): a 'hint' on whether this scalar is noisy and should be\n                smoothed when logged. The hint will be accessible through\n                :meth:`EventStorage.smoothing_hints`.  A writer may ignore the hint\n                and apply custom smoothing rule.\n\n                It defaults to True because most scalars we save need to be smoothed to\n                provide any useful signal.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::inference", "project": "UniRef", "func": "FastRCNNOutputLayers::inference", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 361, "func_end_lineno": 382, "key_block_start_lineno": 372, "key_block_end_lineno": 382, "new_func_code": "def inference(self, predictions: Tuple[torch.Tensor, torch.Tensor], proposals: List[Instances]):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions. The ``proposal_boxes`` field is expected.\n\n        Returns:\n            list[Instances]: same as `fast_rcnn_inference`.\n            list[Tensor]: same as `fast_rcnn_inference`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::predict_boxes", "project": "UniRef", "func": "FastRCNNOutputLayers::predict_boxes", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 419, "func_end_lineno": 443, "key_block_start_lineno": 434, "key_block_end_lineno": 443, "new_func_code": "def predict_boxes(\n        self, predictions: Tuple[torch.Tensor, torch.Tensor], proposals: List[Instances]\n    ):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions. The ``proposal_boxes`` field is expected.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted class-specific or class-agnostic boxes\n                for each image. Element i has shape (Ri, K * B) or (Ri, B), where Ri is\n                the number of proposals for image i and B is the box dimension (4 or 5)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::predict_probs", "project": "UniRef", "func": "FastRCNNOutputLayers::predict_probs", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 445, "func_end_lineno": 462, "key_block_start_lineno": 459, "key_block_end_lineno": 462, "new_func_code": "def predict_probs(\n        self, predictions: Tuple[torch.Tensor, torch.Tensor], proposals: List[Instances]\n    ):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted class probabilities for each image.\n                Element i has shape (Ri, K + 1), where Ri is the number of proposals for image i.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.fast_rcnn_inference", "project": "UniRef", "func": "fast_rcnn_inference", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 45, "func_end_lineno": 84, "key_block_start_lineno": 78, "key_block_end_lineno": 84, "new_func_code": "def fast_rcnn_inference(\n    boxes: List[torch.Tensor],\n    scores: List[torch.Tensor],\n    image_shapes: List[Tuple[int, int]],\n    score_thresh: float,\n    nms_thresh: float,\n    topk_per_image: int,\n):\n    \"\"\"\n    Call `fast_rcnn_inference_single_image` for all images.\n\n    Args:\n        boxes (list[Tensor]): A list of Tensors of predicted class-specific or class-agnostic\n            boxes for each image. Element i has shape (Ri, K * 4) if doing\n            class-specific regression, or (Ri, 4) if doing class-agnostic\n            regression, where Ri is the number of predicted objects for image i.\n            This is compatible with the output of :meth:`FastRCNNOutputLayers.predict_boxes`.\n        scores (list[Tensor]): A list of Tensors of predicted class scores for each image.\n            Element i has shape (Ri, K + 1), where Ri is the number of predicted objects\n            for image i. Compatible with the output of :meth:`FastRCNNOutputLayers.predict_probs`.\n        image_shapes (list[tuple]): A list of (width, height) tuples for each image in the batch.\n        score_thresh (float): Only return detections with a confidence score exceeding this\n            threshold.\n        nms_thresh (float):  The threshold to use for box non-maximum suppression. Value in [0, 1].\n        topk_per_image (int): The number of top scoring detections to return. Set < 0 to return\n            all detections.\n\n    Returns:\n        instances: (list[Instances]): A list of N instances, one for each image in the batch,\n            that stores the topk most confidence detections.\n        kept_indices: (list[Tensor]): A list of 1D tensor of length of N, each element indicates\n            the corresponding boxes/scores index in [0, Ri) from the input, for image i.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.export.torchscript_patch.patch_builtin_len", "project": "UniRef", "func": "patch_builtin_len", "origin_file": "./Source_Copy/UniRef/detectron2/export/torchscript_patch.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 316, "func_end_lineno": 339, "key_block_start_lineno": 326, "key_block_end_lineno": 339, "new_func_code": "def patch_builtin_len(modules=()):\n    \"\"\"\n    Patch the builtin len() function of a few detectron2 modules\n    to use __len__ instead, because __len__ does not convert values to\n    integers and therefore is friendly to tracing.\n\n    Args:\n        modules (list[stsr]): names of extra modules to patch len(), in\n            addition to those in detectron2.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.config.instantiate.instantiate", "project": "UniRef", "func": "instantiate", "origin_file": "./Source_Copy/UniRef/detectron2/config/instantiate.py", "test_list": ["tests/config/test_instantiate_config.py"], "prob_info": {"func_start_lineno": 36, "func_end_lineno": 82, "key_block_start_lineno": 48, "key_block_end_lineno": 82, "new_func_code": "def instantiate(cfg):\n    \"\"\"\n    Recursively instantiate objects defined in dictionaries by\n    \"_target_\" and arguments.\n\n    Args:\n        cfg: a dict-like object with \"_target_\" that defines the caller, and\n            other keys that define the arguments\n\n    Returns:\n        object instantiated by cfg\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.transform_instance_annotations", "project": "UniRef", "func": "transform_instance_annotations", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 257, "func_end_lineno": 318, "key_block_start_lineno": 281, "key_block_end_lineno": 318, "new_func_code": "def transform_instance_annotations(\n    annotation, transforms, image_size, *, keypoint_hflip_indices=None\n):\n    \"\"\"\n    Apply transforms to box, segmentation and keypoints annotations of a single instance.\n\n    It will use `transforms.apply_box` for the box, and\n    `transforms.apply_coords` for segmentation polygons & keypoints.\n    If you need anything more specially designed for each data structure,\n    you'll need to implement your own version of this function or the transforms.\n\n    Args:\n        annotation (dict): dict of instance annotations for a single instance.\n            It will be modified in-place.\n        transforms (TransformList or list[Transform]):\n        image_size (tuple): the height, width of the transformed image\n        keypoint_hflip_indices (ndarray[int]): see `create_keypoint_hflip_indices`.\n\n    Returns:\n        dict:\n            the same input dict with fields \"bbox\", \"segmentation\", \"keypoints\"\n            transformed according to `transforms`.\n            The \"bbox_mode\" field will be set to XYXY_ABS.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.transform_keypoint_annotations", "project": "UniRef", "func": "transform_keypoint_annotations", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 321, "func_end_lineno": 366, "key_block_start_lineno": 335, "key_block_end_lineno": 366, "new_func_code": "def transform_keypoint_annotations(keypoints, transforms, image_size, keypoint_hflip_indices=None):\n    \"\"\"\n    Transform keypoint annotations of an image.\n    If a keypoint is transformed out of image boundary, it will be marked \"unlabeled\" (visibility=0)\n\n    Args:\n        keypoints (list[float]): Nx3 float in Detectron2's Dataset format.\n            Each point is represented by (x, y, visibility).\n        transforms (TransformList):\n        image_size (tuple): the height, width of the transformed image\n        keypoint_hflip_indices (ndarray[int]): see `create_keypoint_hflip_indices`.\n            When `transforms` includes horizontal flip, will use the index\n            mapping to flip keypoints.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.create_keypoint_hflip_indices", "project": "UniRef", "func": "create_keypoint_hflip_indices", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 509, "func_end_lineno": 531, "key_block_start_lineno": 518, "key_block_end_lineno": 531, "new_func_code": "def create_keypoint_hflip_indices(dataset_names: Union[str, List[str]]) -> List[int]:\n    \"\"\"\n    Args:\n        dataset_names: list of dataset names\n\n    Returns:\n        list[int]: a list of size=#keypoints, storing the\n        horizontally-flipped keypoint indices.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.check_metadata_consistency", "project": "UniRef", "func": "check_metadata_consistency", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 564, "func_end_lineno": 590, "key_block_start_lineno": 576, "key_block_end_lineno": 590, "new_func_code": "def check_metadata_consistency(key, dataset_names):\n    \"\"\"\n    Check that the datasets have consistent metadata.\n\n    Args:\n        key (str): a metadata key\n        dataset_names (list[str]): a list of dataset names\n\n    Raises:\n        AttributeError: if the key does not exist in the metadata\n        ValueError: if the given datasets do not have the same metadata values defined by key\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.catalog._MetadataCatalog::get", "project": "UniRef", "func": "_MetadataCatalog::get", "origin_file": "./Source_Copy/UniRef/detectron2/data/catalog.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 194, "func_end_lineno": 207, "key_block_start_lineno": 203, "key_block_end_lineno": 207, "new_func_code": "def get(self, name):\n        \"\"\"\n        Args:\n            name (str): name of a dataset (e.g. coco_2014_train).\n\n        Returns:\n            Metadata: The :class:`Metadata` instance associated with this name,\n            or create an empty one if none is available.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.gen_crop_transform_with_instance", "project": "UniRef", "func": "gen_crop_transform_with_instance", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 534, "func_end_lineno": 561, "key_block_start_lineno": 545, "key_block_end_lineno": 561, "new_func_code": "def gen_crop_transform_with_instance(crop_size, image_size, instance):\n    \"\"\"\n    Generate a CropTransform so that the cropping region contains\n    the center of the given instance.\n\n    Args:\n        crop_size (tuple): h, w in pixels\n        image_size (tuple): h, w\n        instance (dict): an annotation dict of one instance, in Detectron2's\n            dataset format.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.read_image", "project": "UniRef", "func": "read_image", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 166, "func_end_lineno": 185, "key_block_start_lineno": 180, "key_block_end_lineno": 185, "new_func_code": "def read_image(file_name, format=None):\n    \"\"\"\n    Read an image into the given format.\n    Will apply rotation and flipping if the image has such exif information.\n\n    Args:\n        file_name (str): image file path\n        format (str): one of the supported image modes in PIL, or \"BGR\" or \"YUV-BT.601\".\n\n    Returns:\n        image (np.ndarray):\n            an HWC image in the given format, which is 0-255, uint8 for\n            supported image modes in PIL or \"BGR\"; float (0-1 for Y) for YUV-BT.601.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils._apply_exif_orientation", "project": "UniRef", "func": "_apply_exif_orientation", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 119, "func_end_lineno": 163, "key_block_start_lineno": 138, "key_block_end_lineno": 163, "new_func_code": "def _apply_exif_orientation(image):\n    \"\"\"\n    Applies the exif orientation correctly.\n\n    This code exists per the bug:\n      https://github.com/python-pillow/Pillow/issues/3973\n    with the function `ImageOps.exif_transpose`. The Pillow source raises errors with\n    various methods, especially `tobytes`\n\n    Function based on:\n      https://github.com/wkentaro/labelme/blob/v4.5.4/labelme/utils/image.py#L59\n      https://github.com/python-pillow/Pillow/blob/7.1.2/src/PIL/ImageOps.py#L527\n\n    Args:\n        image (PIL.Image): a PIL image\n\n    Returns:\n        (PIL.Image): the PIL image with exif orientation applied, if applicable\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.convert_PIL_to_numpy", "project": "UniRef", "func": "convert_PIL_to_numpy", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 60, "func_end_lineno": 90, "key_block_start_lineno": 71, "key_block_end_lineno": 90, "new_func_code": "def convert_PIL_to_numpy(image, format):\n    \"\"\"\n    Convert PIL image to numpy array of target format.\n\n    Args:\n        image (PIL.Image): a PIL image\n        format (str): the format of output image\n\n    Returns:\n        (np.ndarray): also see `read_image`\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.annotations_to_instances", "project": "UniRef", "func": "annotations_to_instances", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 369, "func_end_lineno": 441, "key_block_start_lineno": 385, "key_block_end_lineno": 441, "new_func_code": "def annotations_to_instances(annos, image_size, mask_format=\"polygon\"):\n    \"\"\"\n    Create an :class:`Instances` object used by the models,\n    from instance annotations in the dataset dict.\n\n    Args:\n        annos (list[dict]): a list of instance annotations in one image, each\n            element for one instance.\n        image_size (tuple): height, width\n\n    Returns:\n        Instances:\n            It will contain fields \"gt_boxes\", \"gt_classes\",\n            \"gt_masks\", \"gt_keypoints\", if they can be obtained from `annos`.\n            This is the format that builtin models expect.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.hungarian_tracker.BaseHungarianTracker::_initialize_extra_fields", "project": "UniRef", "func": "BaseHungarianTracker::_initialize_extra_fields", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/hungarian_tracker.py", "test_list": ["tests/tracking/test_hungarian_tracker.py"], "prob_info": {"func_start_lineno": 74, "func_end_lineno": 95, "key_block_start_lineno": 84, "key_block_end_lineno": 95, "new_func_code": "def _initialize_extra_fields(self, instances: Instances) -> Instances:\n        \"\"\"\n        If input instances don't have ID, ID_period, lost_frame_count fields,\n        this method is used to initialize these fields.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances with extra fields added\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.catalog._DatasetCatalog::get", "project": "UniRef", "func": "_DatasetCatalog::get", "origin_file": "./Source_Copy/UniRef/detectron2/data/catalog.py", "test_list": ["tests/data/test_coco.py"], "prob_info": {"func_start_lineno": 40, "func_end_lineno": 58, "key_block_start_lineno": 50, "key_block_end_lineno": 58, "new_func_code": "def get(self, name):\n        \"\"\"\n        Call the registered function and return its results.\n\n        Args:\n            name (str): the name that identifies a dataset, e.g. \"coco_2014_train\".\n\n        Returns:\n            list[dict]: dataset annotations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.datasets.coco.load_coco_json", "project": "UniRef", "func": "load_coco_json", "origin_file": "./Source_Copy/UniRef/detectron2/data/datasets/coco.py", "test_list": ["tests/data/test_coco.py"], "prob_info": {"func_start_lineno": 30, "func_end_lineno": 229, "key_block_start_lineno": 64, "key_block_end_lineno": 229, "new_func_code": "def load_coco_json(json_file, image_root, dataset_name=None, extra_annotation_keys=None, dataset_name_in_dict=\"coco\"):\n    \"\"\"\n    Load a json file with COCO's instances annotation format.\n    Currently supports instance detection, instance segmentation,\n    and person keypoints annotations.\n\n    Args:\n        json_file (str): full path to the json file in COCO instances annotation format.\n        image_root (str or path-like): the directory where the images in this json file exists.\n        dataset_name (str or None): the name of the dataset (e.g., coco_2017_train).\n            When provided, this function will also do the following:\n\n            * Put \"thing_classes\" into the metadata associated with this dataset.\n            * Map the category ids into a contiguous range (needed by standard dataset format),\n              and add \"thing_dataset_id_to_contiguous_id\" to the metadata associated\n              with this dataset.\n\n            This option should usually be provided, unless users need to load\n            the original json content and apply more processing manually.\n        extra_annotation_keys (list[str]): list of per-annotation keys that should also be\n            loaded into the dataset dict (besides \"iscrowd\", \"bbox\", \"keypoints\",\n            \"category_id\", \"segmentation\"). The values for these keys will be returned as-is.\n            For example, the densepose annotations are loaded in this way.\n\n    Returns:\n        list[dict]: a list of dicts in Detectron2 standard dataset dicts format (See\n        `Using Custom Datasets </tutorials/datasets.html>`_ ) when `dataset_name` is not None.\n        If `dataset_name` is None, the returned `category_ids` may be\n        incontiguous and may not conform to the Detectron2 standard format.\n\n    Notes:\n        1. This function does not read the image files.\n           The results do not have the \"image\" field.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.VisImage::_setup_figure", "project": "UniRef", "func": "VisImage::_setup_figure", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 276, "func_end_lineno": 299, "key_block_start_lineno": 285, "key_block_end_lineno": 299, "new_func_code": "def _setup_figure(self, img):\n        \"\"\"\n        Args:\n            Same as in :meth:`__init__()`.\n\n        Returns:\n            fig (matplotlib.pyplot.figure): top level container for all the image plot elements.\n            ax (matplotlib.pyplot.Axes): contains figure elements and sets the coordinate system.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer._create_text_labels", "project": "UniRef", "func": "_create_text_labels", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 237, "func_end_lineno": 261, "key_block_start_lineno": 248, "key_block_end_lineno": 261, "new_func_code": "def _create_text_labels(classes, scores, class_names, is_crowd=None):\n    \"\"\"\n    Args:\n        classes (list[int] or None):\n        scores (list[float] or None):\n        class_names (list[str] or None):\n        is_crowd (list[bool] or None):\n\n    Returns:\n        list[str] or None\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::overlay_instances", "project": "UniRef", "func": "Visualizer::overlay_instances", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 614, "func_end_lineno": 754, "key_block_start_lineno": 652, "key_block_end_lineno": 754, "new_func_code": "def overlay_instances(\n        self,\n        *,\n        boxes=None,\n        labels=None,\n        masks=None,\n        keypoints=None,\n        assigned_colors=None,\n        alpha=0.5,\n    ):\n        \"\"\"\n        Args:\n            boxes (Boxes, RotatedBoxes or ndarray): either a :class:`Boxes`,\n                or an Nx4 numpy array of XYXY_ABS format for the N objects in a single image,\n                or a :class:`RotatedBoxes`,\n                or an Nx5 numpy array of (x_center, y_center, width, height, angle_degrees) format\n                for the N objects in a single image,\n            labels (list[str]): the text to be displayed for each instance.\n            masks (masks-like object): Supported types are:\n\n                * :class:`detectron2.structures.PolygonMasks`,\n                  :class:`detectron2.structures.BitMasks`.\n                * list[list[ndarray]]: contains the segmentation masks for all objects in one image.\n                  The first level of the list corresponds to individual instances. The second\n                  level to all the polygon that compose the instance, and the third level\n                  to the polygon coordinates. The third level should have the format of\n                  [x0, y0, x1, y1, ..., xn, yn] (n >= 3).\n                * list[ndarray]: each ndarray is a binary mask of shape (H, W).\n                * list[dict]: each dict is a COCO-style RLE.\n            keypoints (Keypoint or array like): an array-like object of shape (N, K, 3),\n                where the N is the number of instances and K is the number of keypoints.\n                The last dimension corresponds to (x, y, visibility or score).\n            assigned_colors (list[matplotlib.colors]): a list of colors, where each color\n                corresponds to each mask or box in the image. Refer to 'matplotlib.colors'\n                for full list of formats that the colors are accepted in.\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::_convert_masks", "project": "UniRef", "func": "Visualizer::_convert_masks", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1221, "func_end_lineno": 1242, "key_block_start_lineno": 1228, "key_block_end_lineno": 1242, "new_func_code": "def _convert_masks(self, masks_or_polygons):\n        \"\"\"\n        Convert different format of masks or polygons to a tuple of masks and polygons.\n\n        Returns:\n            list[GenericMask]:\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.colormap.random_color", "project": "UniRef", "func": "random_color", "origin_file": "./Source_Copy/UniRef/detectron2/utils/colormap.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 112, "func_end_lineno": 125, "key_block_start_lineno": 121, "key_block_end_lineno": 125, "new_func_code": "def random_color(rgb=False, maximum=255):\n    \"\"\"\n    Args:\n        rgb (bool): whether to return RGB colors or BGR colors.\n        maximum (int): either 255 or 1\n\n    Returns:\n        ndarray: a vector of 3 numbers\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_box", "project": "UniRef", "func": "Visualizer::draw_box", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 904, "func_end_lineno": 936, "key_block_start_lineno": 918, "key_block_end_lineno": 936, "new_func_code": "def draw_box(self, box_coord, alpha=0.5, edge_color=\"g\", line_style=\"-\"):\n        \"\"\"\n        Args:\n            box_coord (tuple): a tuple containing x0, y0, x1, y1 coordinates, where x0 and y0\n                are the coordinates of the image's top left corner. x1 and y1 are the\n                coordinates of the image's bottom right corner.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            edge_color: color of the outline of the box. Refer to `matplotlib.colors`\n                for full list of formats that are accepted.\n            line_style (string): the string to use to create the outline of the boxes.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::_change_color_brightness", "project": "UniRef", "func": "Visualizer::_change_color_brightness", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1187, "func_end_lineno": 1210, "key_block_start_lineno": 1203, "key_block_end_lineno": 1210, "new_func_code": "def _change_color_brightness(self, color, brightness_factor):\n        \"\"\"\n        Depending on the brightness_factor, gives a lighter or darker color i.e. a color with\n        less or more saturation than the original color.\n\n        Args:\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            brightness_factor (float): a value in [-1.0, 1.0] range. A lightness factor of\n                0 will correspond to no change, a factor in [-1.0, 0) range will result in\n                a darker color and a factor in (0, 1.0] range will result in a lighter color.\n\n        Returns:\n            modified_color (tuple[double]): a tuple containing the RGB values of the\n                modified color. Each value in the tuple is in the [0.0, 1.0] range.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_text", "project": "UniRef", "func": "Visualizer::draw_text", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 857, "func_end_lineno": 902, "key_block_start_lineno": 881, "key_block_end_lineno": 902, "new_func_code": "def draw_text(\n        self,\n        text,\n        position,\n        *,\n        font_size=None,\n        color=\"g\",\n        horizontal_alignment=\"center\",\n        rotation=0,\n    ):\n        \"\"\"\n        Args:\n            text (str): class label\n            position (tuple): a tuple of the x and y coordinates to place text on image.\n            font_size (int, optional): font of the text. If not provided, a font size\n                proportional to the image width is calculated and used.\n            color: color of the text. Refer to `matplotlib.colors` for full list\n                of formats that are accepted.\n            horizontal_alignment (str): see `matplotlib.text.Text`\n            rotation: rotation angle in degrees CCW\n\n        Returns:\n            output (VisImage): image object with text drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_polygon", "project": "UniRef", "func": "Visualizer::draw_polygon", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1121, "func_end_lineno": 1151, "key_block_start_lineno": 1135, "key_block_end_lineno": 1151, "new_func_code": "def draw_polygon(self, segment, color, edge_color=None, alpha=0.5):\n        \"\"\"\n        Args:\n            segment: numpy array of shape Nx2, containing all the points in the polygon.\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            edge_color: color of the polygon edges. Refer to `matplotlib.colors` for a\n                full list of formats that are accepted. If not provided, a darker shade\n                of the polygon color will be used instead.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n\n        Returns:\n            output (VisImage): image object with polygon drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_dataset_dict", "project": "UniRef", "func": "Visualizer::draw_dataset_dict", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 545, "func_end_lineno": 612, "key_block_start_lineno": 555, "key_block_end_lineno": 612, "new_func_code": "def draw_dataset_dict(self, dic):\n        \"\"\"\n        Draw annotations/segmentaions in Detectron2 Dataset format.\n\n        Args:\n            dic (dict): annotation/segmentation data of one image, in Detectron2 Dataset format.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::overlay_rotated_instances", "project": "UniRef", "func": "Visualizer::overlay_rotated_instances", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 756, "func_end_lineno": 792, "key_block_start_lineno": 770, "key_block_end_lineno": 792, "new_func_code": "def overlay_rotated_instances(self, boxes=None, labels=None, assigned_colors=None):\n        \"\"\"\n        Args:\n            boxes (ndarray): an Nx5 numpy array of\n                (x_center, y_center, width, height, angle_degrees) format\n                for the N objects in a single image.\n            labels (list[str]): the text to be displayed for each instance.\n            assigned_colors (list[matplotlib.colors]): a list of colors, where each color\n                corresponds to each mask or box in the image. Refer to 'matplotlib.colors'\n                for full list of formats that the colors are accepted in.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_rotated_box_with_label", "project": "UniRef", "func": "Visualizer::draw_rotated_box_with_label", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 938, "func_end_lineno": 991, "key_block_start_lineno": 958, "key_block_end_lineno": 991, "new_func_code": "def draw_rotated_box_with_label(\n        self, rotated_box, alpha=0.5, edge_color=\"g\", line_style=\"-\", label=None\n    ):\n        \"\"\"\n        Draw a rotated box with label on its top-left corner.\n\n        Args:\n            rotated_box (tuple): a tuple containing (cnt_x, cnt_y, w, h, angle),\n                where cnt_x and cnt_y are the center coordinates of the box.\n                w and h are the width and height of the box. angle represents how\n                many degrees the box is rotated CCW with regard to the 0-degree box.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            edge_color: color of the outline of the box. Refer to `matplotlib.colors`\n                for full list of formats that are accepted.\n            line_style (string): the string to use to create the outline of the boxes.\n            label (string): label for rotated box. It will not be rendered when set to None.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_line", "project": "UniRef", "func": "Visualizer::draw_line", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1011, "func_end_lineno": 1040, "key_block_start_lineno": 1028, "key_block_end_lineno": 1040, "new_func_code": "def draw_line(self, x_data, y_data, color, linestyle=\"-\", linewidth=None):\n        \"\"\"\n        Args:\n            x_data (list[int]): a list containing x values of all the points being drawn.\n                Length of list should match the length of y_data.\n            y_data (list[int]): a list containing y values of all the points being drawn.\n                Length of list should match the length of x_data.\n            color: color of the line. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            linestyle: style of the line. Refer to `matplotlib.lines.Line2D`\n                for a full list of formats that are accepted.\n            linewidth (float or None): width of the line. When it's None,\n                a default value will be computed and used.\n\n        Returns:\n            output (VisImage): image object with line drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_soft_mask", "project": "UniRef", "func": "Visualizer::draw_soft_mask", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1093, "func_end_lineno": 1119, "key_block_start_lineno": 1105, "key_block_end_lineno": 1119, "new_func_code": "def draw_soft_mask(self, soft_mask, color=None, *, text=None, alpha=0.5):\n        \"\"\"\n        Args:\n            soft_mask (ndarray): float array of shape (H, W), each value in [0, 1].\n            color: color of the mask. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted. If None, will pick a random color.\n            text (str): if None, will be drawn on the object\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n\n        Returns:\n            output (VisImage): image object with mask drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.matcher.Matcher::__call__", "project": "UniRef", "func": "Matcher::__call__", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/matcher.py", "test_list": ["tests/modeling/test_matcher.py"], "prob_info": {"func_start_lineno": 62, "func_end_lineno": 104, "key_block_start_lineno": 76, "key_block_end_lineno": 104, "new_func_code": "def __call__(self, match_quality_matrix):\n        \"\"\"\n        Args:\n            match_quality_matrix (Tensor[float]): an MxN tensor, containing the\n                pairwise quality between M ground-truth elements and N predicted\n                elements. All elements must be >= 0 (due to the us of `torch.nonzero`\n                for selecting indices in :meth:`set_low_quality_matches_`).\n\n        Returns:\n            matches (Tensor[int64]): a vector of length N, where matches[i] is a matched\n                ground-truth index in [0, M)\n            match_labels (Tensor[int8]): a vector of length N, where pred_labels[i] indicates\n                whether a prediction is a true or false positive or ignored\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.vanilla_hungarian_bbox_iou_tracker.VanillaHungarianBBoxIOUTracker::assign_cost_matrix_values", "project": "UniRef", "func": "VanillaHungarianBBoxIOUTracker::assign_cost_matrix_values", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/vanilla_hungarian_bbox_iou_tracker.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 118, "func_end_lineno": 131, "key_block_start_lineno": 128, "key_block_end_lineno": 131, "new_func_code": "def assign_cost_matrix_values(self, cost_matrix: np.ndarray, bbox_pairs: List) -> np.ndarray:\n        \"\"\"\n        Based on IoU for each pair of bbox, assign the associated value in cost matrix\n\n        Args:\n            cost_matrix: np.ndarray, initialized 2D array with target dimensions\n            bbox_pairs: list of bbox pair, in each pair, iou value is stored\n        Return:\n            np.ndarray, cost_matrix with assigned values\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.base_tracker.build_tracker_head", "project": "UniRef", "func": "build_tracker_head", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/base_tracker.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 53, "func_end_lineno": 64, "key_block_start_lineno": 62, "key_block_end_lineno": 64, "new_func_code": "def build_tracker_head(cfg: CfgNode_) -> BaseTracker:\n    \"\"\"\n    Build a tracker head from `cfg.TRACKER_HEADS.TRACKER_NAME`.\n\n    Args:\n        cfg: D2 CfgNode, config file with tracker information\n    Return:\n        tracker object\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.config.config._get_args_from_config", "project": "UniRef", "func": "_get_args_from_config", "origin_file": "./Source_Copy/UniRef/detectron2/config/config.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 218, "func_end_lineno": 248, "key_block_start_lineno": 225, "key_block_end_lineno": 248, "new_func_code": "def _get_args_from_config(from_config_func, *args, **kwargs):\n    \"\"\"\n    Use `from_config` to obtain explicit arguments.\n\n    Returns:\n        dict: arguments to be used for cls.__init__\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.pairwise_iou", "project": "UniRef", "func": "pairwise_iou", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 334, "func_end_lineno": 356, "key_block_start_lineno": 346, "key_block_end_lineno": 356, "new_func_code": "def pairwise_iou(boxes1: Boxes, boxes2: Boxes) -> torch.Tensor:\n    \"\"\"\n    Given two lists of boxes of size N and M, compute the IoU\n    (intersection over union) between **all** N x M pairs of boxes.\n    The box order must be (xmin, ymin, xmax, ymax).\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: IoU, sized [N,M].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.pairwise_intersection", "project": "UniRef", "func": "pairwise_intersection", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 329, "key_block_start_lineno": 322, "key_block_end_lineno": 329, "new_func_code": "def pairwise_intersection(boxes1: Boxes, boxes2: Boxes) -> torch.Tensor:\n    \"\"\"\n    Given two lists of boxes of size N and M,\n    compute the intersection area between __all__ N x M pairs of boxes.\n    The box order must be (xmin, ymin, xmax, ymax)\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: intersection, sized [N,M].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.utils.create_prediction_pairs", "project": "UniRef", "func": "create_prediction_pairs", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/utils.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 36, "key_block_start_lineno": 22, "key_block_end_lineno": 36, "new_func_code": "def create_prediction_pairs(\n    instances: Instances,\n    prev_instances: Instances,\n    iou_all: np.ndarray,\n    threshold: float = 0.5,\n) -> List:\n    \"\"\"\n    Args:\n        instances: predictions from current frame\n        prev_instances: predictions from previous frame\n        iou_all: 2D numpy array containing iou for each bbox pair\n        threshold: below the threshold, doesn't consider the pair of bbox is valid\n    Return:\n        List of bbox pairs\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_initialize_extra_fields", "project": "UniRef", "func": "BBoxIOUTracker::_initialize_extra_fields", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 152, "func_end_lineno": 173, "key_block_start_lineno": 162, "key_block_end_lineno": 173, "new_func_code": "def _initialize_extra_fields(self, instances: Instances) -> Instances:\n        \"\"\"\n        If input instances don't have ID, ID_period, lost_frame_count fields,\n        this method is used to initialize these fields.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances with extra fields added\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_assign_new_id", "project": "UniRef", "func": "BBoxIOUTracker::_assign_new_id", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 183, "func_end_lineno": 198, "key_block_start_lineno": 192, "key_block_end_lineno": 198, "new_func_code": "def _assign_new_id(self, instances: Instances) -> Instances:\n        \"\"\"\n        For each untracked instance, assign a new id\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances with new ID assigned\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_create_prediction_pairs", "project": "UniRef", "func": "BBoxIOUTracker::_create_prediction_pairs", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 123, "func_end_lineno": 150, "key_block_start_lineno": 138, "key_block_end_lineno": 150, "new_func_code": "def _create_prediction_pairs(\n        self, instances: Instances, iou_all: np.ndarray\n    ) -> List:\n        \"\"\"\n        For all instances in previous and current frames, create pairs. For each\n        pair, store index of the instance in current frame predcitions, index in\n        previous predictions, ID in previous predictions, IoU of the bboxes in this\n        pair, period in previous predictions.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n            iou_all: IoU for all bboxes pairs\n        Return:\n            A list of IoU for all pairs\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_merge_untracked_instances", "project": "UniRef", "func": "BBoxIOUTracker::_merge_untracked_instances", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 200, "func_end_lineno": 260, "key_block_start_lineno": 211, "key_block_end_lineno": 260, "new_func_code": "def _merge_untracked_instances(self, instances: Instances) -> Instances:\n        \"\"\"\n        For untracked previous instances, under certain condition, still keep them\n        in tracking and merge with the current instances.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances merging current instances and instances from previous\n            frame decided to keep tracking\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.layers.batch_norm.get_norm", "project": "UniRef", "func": "get_norm", "origin_file": "./Source_Copy/UniRef/detectron2/layers/batch_norm.py", "test_list": ["tests/layers/test_blocks.py"], "prob_info": {"func_start_lineno": 121, "func_end_lineno": 149, "key_block_start_lineno": 131, "key_block_end_lineno": 149, "new_func_code": "def get_norm(norm, out_channels):\n    \"\"\"\n    Args:\n        norm (str or callable): either one of BN, SyncBN, FrozenBN, GN;\n            or a callable that takes a channel number and returns\n            the normalization layer as a nn.Module.\n\n    Returns:\n        nn.Module or None: the normalization layer\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.backbone.resnet.ResNet::freeze", "project": "UniRef", "func": "ResNet::freeze", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/backbone/resnet.py", "test_list": ["tests/layers/test_blocks.py"], "prob_info": {"func_start_lineno": 468, "func_end_lineno": 490, "key_block_start_lineno": 484, "key_block_end_lineno": 490, "new_func_code": "def freeze(self, freeze_at=0):\n        \"\"\"\n        Freeze the first several stages of the ResNet. Commonly used in\n        fine-tuning.\n\n        Layers that produce the same feature map spatial size are defined as one\n        \"stage\" by :paper:`FPN`.\n\n        Args:\n            freeze_at (int): number of stages to freeze.\n                `1` means freezing the stem. `2` means freezing the stem and\n                one residual stage, etc.\n\n        Returns:\n            nn.Module: this ResNet itself\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.pairwise_ioa", "project": "UniRef", "func": "pairwise_ioa", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/structures/test_boxes.py"], "prob_info": {"func_start_lineno": 359, "func_end_lineno": 376, "key_block_start_lineno": 369, "key_block_end_lineno": 376, "new_func_code": "def pairwise_ioa(boxes1: Boxes, boxes2: Boxes) -> torch.Tensor:\n    \"\"\"\n    Similar to :func:`pariwise_iou` but compute the IoA (intersection over boxes2 area).\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: IoA, sized [N,M].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.iou_weighted_hungarian_bbox_iou_tracker.IOUWeightedHungarianBBoxIOUTracker::assign_cost_matrix_values", "project": "UniRef", "func": "IOUWeightedHungarianBBoxIOUTracker::assign_cost_matrix_values", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/iou_weighted_hungarian_bbox_iou_tracker.py", "test_list": ["tests/tracking/test_iou_weighted_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 88, "func_end_lineno": 101, "key_block_start_lineno": 98, "key_block_end_lineno": 101, "new_func_code": "def assign_cost_matrix_values(self, cost_matrix: np.ndarray, bbox_pairs: List) -> np.ndarray:\n        \"\"\"\n        Based on IoU for each pair of bbox, assign the associated value in cost matrix\n\n        Args:\n            cost_matrix: np.ndarray, initialized 2D array with target dimensions\n            bbox_pairs: list of bbox pair, in each pair, iou value is stored\n        Return:\n            np.ndarray, cost_matrix with assigned values\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.layers.losses.ciou_loss", "project": "UniRef", "func": "ciou_loss", "origin_file": "./Source_Copy/UniRef/detectron2/layers/losses.py", "test_list": ["tests/layers/test_losses.py"], "prob_info": {"func_start_lineno": 66, "func_end_lineno": 133, "key_block_start_lineno": 83, "key_block_end_lineno": 133, "new_func_code": "def ciou_loss(\n    boxes1: torch.Tensor,\n    boxes2: torch.Tensor,\n    reduction: str = \"none\",\n    eps: float = 1e-7,\n) -> torch.Tensor:\n    \"\"\"\n    Complete Intersection over Union Loss (Zhaohui Zheng et. al)\n    https://arxiv.org/abs/1911.08287\n    Args:\n        boxes1, boxes2 (Tensor): box locations in XYXY format, shape (N, 4) or (4,).\n        reduction: 'none' | 'mean' | 'sum'\n                 'none': No reduction will be applied to the output.\n                 'mean': The output will be averaged.\n                 'sum': The output will be summed.\n        eps (float): small number to prevent division by zero\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.layers.losses.diou_loss", "project": "UniRef", "func": "diou_loss", "origin_file": "./Source_Copy/UniRef/detectron2/layers/losses.py", "test_list": ["tests/layers/test_losses.py"], "prob_info": {"func_start_lineno": 5, "func_end_lineno": 63, "key_block_start_lineno": 22, "key_block_end_lineno": 63, "new_func_code": "def diou_loss(\n    boxes1: torch.Tensor,\n    boxes2: torch.Tensor,\n    reduction: str = \"none\",\n    eps: float = 1e-7,\n) -> torch.Tensor:\n    \"\"\"\n    Distance Intersection over Union Loss (Zhaohui Zheng et. al)\n    https://arxiv.org/abs/1911.08287\n    Args:\n        boxes1, boxes2 (Tensor): box locations in XYXY format, shape (N, 4) or (4,).\n        reduction: 'none' | 'mean' | 'sum'\n                 'none': No reduction will be applied to the output.\n                 'mean': The output will be averaged.\n                 'sum': The output will be summed.\n        eps (float): small number to prevent division by zero\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.masks.BitMasks::__getitem__", "project": "UniRef", "func": "BitMasks::__getitem__", "origin_file": "./Source_Copy/UniRef/detectron2/structures/masks.py", "test_list": ["tests/structures/test_masks.py"], "prob_info": {"func_start_lineno": 117, "func_end_lineno": 138, "key_block_start_lineno": 132, "key_block_end_lineno": 138, "new_func_code": "def __getitem__(self, item: Union[int, slice, torch.BoolTensor]) -> \"BitMasks\":\n        \"\"\"\n        Returns:\n            BitMasks: Create a new :class:`BitMasks` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_masks = masks[3]`: return a `BitMasks` which contains only one mask.\n        2. `new_masks = masks[2:10]`: return a slice of masks.\n        3. `new_masks = masks[vector]`, where vector is a torch.BoolTensor\n           with `length = len(masks)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned object might share storage with this object,\n        subject to Pytorch's indexing semantics.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransform::get_deltas", "project": "UniRef", "func": "Box2BoxTransform::get_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_box2box_transform.py"], "prob_info": {"func_start_lineno": 43, "func_end_lineno": 76, "key_block_start_lineno": 55, "key_block_end_lineno": 76, "new_func_code": "def get_deltas(self, src_boxes, target_boxes):\n        \"\"\"\n        Get box regression transformation deltas (dx, dy, dw, dh) that can be used\n        to transform the `src_boxes` into the `target_boxes`. That is, the relation\n        ``target_boxes == self.apply_deltas(deltas, src_boxes)`` is true (unless\n        any delta is too large and is clamped).\n\n        Args:\n            src_boxes (Tensor): source boxes, e.g., object proposals\n            target_boxes (Tensor): target of the transformation, e.g., ground-truth\n                boxes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransformLinear::apply_deltas", "project": "UniRef", "func": "Box2BoxTransformLinear::apply_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_box2box_transform.py"], "prob_info": {"func_start_lineno": 275, "func_end_lineno": 307, "key_block_start_lineno": 285, "key_block_end_lineno": 307, "new_func_code": "def apply_deltas(self, deltas, boxes):\n        \"\"\"\n        Apply transformation `deltas` (dx1, dy1, dx2, dy2) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*4), where k >= 1.\n                deltas[i] represents k potentially different class-specific\n                box transformations for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 4)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransformRotated::apply_deltas", "project": "UniRef", "func": "Box2BoxTransformRotated::apply_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_box2box_transform.py"], "prob_info": {"func_start_lineno": 183, "func_end_lineno": 227, "key_block_start_lineno": 192, "key_block_end_lineno": 227, "new_func_code": "def apply_deltas(self, deltas, boxes):\n        \"\"\"\n        Apply transformation `deltas` (dx, dy, dw, dh, da) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*5).\n                deltas[i] represents box transformation for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 5)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator._broadcast_params", "project": "UniRef", "func": "_broadcast_params", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 54, "func_end_lineno": 78, "key_block_start_lineno": 66, "key_block_end_lineno": 78, "new_func_code": "def _broadcast_params(params, num_features, name):\n    \"\"\"\n    If one size (or aspect ratio) is specified and there are multiple feature\n    maps, we \"broadcast\" anchors of that single size (or aspect ratio)\n    over all feature maps.\n\n    If params is list[float], or list[list[float]] with len(params) == 1, repeat\n    it num_features time.\n\n    Returns:\n        list[list[float]]: param for each feature\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.DefaultAnchorGenerator::generate_cell_anchors", "project": "UniRef", "func": "DefaultAnchorGenerator::generate_cell_anchors", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 177, "func_end_lineno": 212, "key_block_start_lineno": 192, "key_block_end_lineno": 212, "new_func_code": "def generate_cell_anchors(self, sizes=(32, 64, 128, 256, 512), aspect_ratios=(0.5, 1, 2)):\n        \"\"\"\n        Generate a tensor storing canonical anchor boxes, which are all anchor\n        boxes of different sizes and aspect_ratios centered at (0, 0).\n        We can later build the set of anchors for a full feature map by\n        shifting and tiling these tensors (see `meth:_grid_anchors`).\n\n        Args:\n            sizes (tuple[float]):\n            aspect_ratios (tuple[float]]):\n\n        Returns:\n            Tensor of shape (len(sizes) * len(aspect_ratios), 4) storing anchor boxes\n                in XYXY format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.DefaultAnchorGenerator::forward", "project": "UniRef", "func": "DefaultAnchorGenerator::forward", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 214, "func_end_lineno": 227, "key_block_start_lineno": 225, "key_block_end_lineno": 227, "new_func_code": "def forward(self, features: List[torch.Tensor]):\n        \"\"\"\n        Args:\n            features (list[Tensor]): list of backbone feature maps on which to generate anchors.\n\n        Returns:\n            list[Boxes]: a list of Boxes containing all the anchors for each feature map\n                (i.e. the cell anchors repeated over all locations in the feature map).\n                The number of anchors of each feature map is Hi x Wi x num_cell_anchors,\n                where Hi, Wi are resolution of the feature map divided by anchor stride.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.DefaultAnchorGenerator::num_anchors", "project": "UniRef", "func": "DefaultAnchorGenerator::num_anchors", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 148, "func_end_lineno": 159, "key_block_start_lineno": 159, "key_block_end_lineno": 159, "new_func_code": "def num_anchors(self):\n        \"\"\"\n        Returns:\n            list[int]: Each int is the number of anchors at every pixel\n                location, on that feature map.\n                For example, if at every pixel we use anchors of 3 aspect\n                ratios and 5 sizes, the number of anchors is 15.\n                (See also ANCHOR_GENERATOR.SIZES and ANCHOR_GENERATOR.ASPECT_RATIOS in config)\n\n                In standard RPN models, `num_anchors` on every feature map is the same.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.RotatedAnchorGenerator::forward", "project": "UniRef", "func": "RotatedAnchorGenerator::forward", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 361, "func_end_lineno": 374, "key_block_start_lineno": 372, "key_block_end_lineno": 374, "new_func_code": "def forward(self, features):\n        \"\"\"\n        Args:\n            features (list[Tensor]): list of backbone feature maps on which to generate anchors.\n\n        Returns:\n            list[RotatedBoxes]: a list of Boxes containing all the anchors for each feature map\n                (i.e. the cell anchors repeated over all locations in the feature map).\n                The number of anchors of each feature map is Hi x Wi x num_cell_anchors,\n                where Hi, Wi are resolution of the feature map divided by anchor stride.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.export.torchscript_patch.patch_instances", "project": "UniRef", "func": "patch_instances", "origin_file": "./Source_Copy/UniRef/detectron2/export/torchscript_patch.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 51, "func_end_lineno": 87, "key_block_start_lineno": 57, "key_block_end_lineno": 87, "new_func_code": "def patch_instances(fields):\n    \"\"\"\n    A contextmanager, under which the Instances class in detectron2 is replaced\n    by a statically-typed scriptable class, defined by `fields`.\n    See more in `scripting_with_instances`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.instances.Instances::set", "project": "UniRef", "func": "Instances::set", "origin_file": "./Source_Copy/UniRef/detectron2/structures/instances.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 68, "func_end_lineno": 79, "key_block_start_lineno": 74, "key_block_end_lineno": 79, "new_func_code": "def set(self, name: str, value: Any) -> None:\n        \"\"\"\n        Set the field named `name` to `value`.\n        The length of `value` must be the number of instances,\n        and must agree with other existing fields in this object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.instances.Instances::__getitem__", "project": "UniRef", "func": "Instances::__getitem__", "origin_file": "./Source_Copy/UniRef/detectron2/structures/instances.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 122, "func_end_lineno": 140, "key_block_start_lineno": 131, "key_block_end_lineno": 140, "new_func_code": "def __getitem__(self, item: Union[int, slice, torch.BoolTensor]) -> \"Instances\":\n        \"\"\"\n        Args:\n            item: an index-like object and will be used to index all the fields.\n\n        Returns:\n            If `item` is a string, return the data in the corresponding field.\n            Otherwise, returns an `Instances` where all fields are indexed by `item`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.Boxes::__getitem__", "project": "UniRef", "func": "Boxes::__getitem__", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 213, "func_end_lineno": 235, "key_block_start_lineno": 231, "key_block_end_lineno": 235, "new_func_code": "def __getitem__(self, item) -> \"Boxes\":\n        \"\"\"\n        Args:\n            item: int, slice, or a BoolTensor\n\n        Returns:\n            Boxes: Create a new :class:`Boxes` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_boxes = boxes[3]`: return a `Boxes` which contains only one box.\n        2. `new_boxes = boxes[2:10]`: return a slice of boxes.\n        3. `new_boxes = boxes[vector]`, where vector is a torch.BoolTensor\n           with `length = len(boxes)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned Boxes might share storage with this Boxes,\n        subject to Pytorch's indexing semantics.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.config.config._called_with_cfg", "project": "UniRef", "func": "_called_with_cfg", "origin_file": "./Source_Copy/UniRef/detectron2/config/config.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 251, "func_end_lineno": 265, "key_block_start_lineno": 257, "key_block_end_lineno": 265, "new_func_code": "def _called_with_cfg(*args, **kwargs):\n    \"\"\"\n    Returns:\n        bool: whether the arguments contain CfgNode and should be considered\n            forwarded to from_config.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::forward", "project": "UniRef", "func": "FastRCNNOutputLayers::forward", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 259, "func_end_lineno": 276, "key_block_start_lineno": 272, "key_block_end_lineno": 276, "new_func_code": "def forward(self, x):\n        \"\"\"\n        Args:\n            x: per-region features of shape (N, ...) for N bounding boxes to predict.\n\n        Returns:\n            (Tensor, Tensor):\n            First tensor: shape (N,K+1), scores for each of the N box. Each row contains the\n            scores for K object categories and 1 background class.\n\n            Second tensor: bounding box regression deltas for each box. Shape is shape (N,Kx4),\n            or (N,4) for class-agnostic regression.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::losses", "project": "UniRef", "func": "FastRCNNOutputLayers::losses", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 278, "func_end_lineno": 318, "key_block_start_lineno": 289, "key_block_end_lineno": 318, "new_func_code": "def losses(self, predictions, proposals):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were used\n                to compute predictions. The fields ``proposal_boxes``, ``gt_boxes``,\n                ``gt_classes`` are expected.\n\n        Returns:\n            Dict[str, Tensor]: dict of losses\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.events.EventStorage::put_scalar", "project": "UniRef", "func": "EventStorage::put_scalar", "origin_file": "./Source_Copy/UniRef/detectron2/utils/events.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 309, "func_end_lineno": 334, "key_block_start_lineno": 322, "key_block_end_lineno": 334, "new_func_code": "def put_scalar(self, name, value, smoothing_hint=True):\n        \"\"\"\n        Add a scalar `value` to the `HistoryBuffer` associated with `name`.\n\n        Args:\n            smoothing_hint (bool): a 'hint' on whether this scalar is noisy and should be\n                smoothed when logged. The hint will be accessible through\n                :meth:`EventStorage.smoothing_hints`.  A writer may ignore the hint\n                and apply custom smoothing rule.\n\n                It defaults to True because most scalars we save need to be smoothed to\n                provide any useful signal.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression._dense_box_regression_loss", "project": "UniRef", "func": "_dense_box_regression_loss", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 369, "key_block_start_lineno": 333, "key_block_end_lineno": 369, "new_func_code": "def _dense_box_regression_loss(\n    anchors: List[Union[Boxes, torch.Tensor]],\n    box2box_transform: Box2BoxTransform,\n    pred_anchor_deltas: List[torch.Tensor],\n    gt_boxes: List[torch.Tensor],\n    fg_mask: torch.Tensor,\n    box_reg_loss_type=\"smooth_l1\",\n    smooth_l1_beta=0.0,\n):\n    \"\"\"\n    Compute loss for dense multi-level box regression.\n    Loss is accumulated over ``fg_mask``.\n\n    Args:\n        anchors: #lvl anchor boxes, each is (HixWixA, 4)\n        pred_anchor_deltas: #lvl predictions, each is (N, HixWixA, 4)\n        gt_boxes: N ground truth boxes, each has shape (R, 4) (R = sum(Hi * Wi * A))\n        fg_mask: the foreground boolean mask of shape (N, R) to compute loss on\n        box_reg_loss_type (str): Loss type to use. Supported losses: \"smooth_l1\", \"giou\",\n            \"diou\", \"ciou\".\n        smooth_l1_beta (float): beta parameter for the smooth L1 regression loss. Default to\n            use L1 loss. Only used when `box_reg_loss_type` is \"smooth_l1\"\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransform::get_deltas", "project": "UniRef", "func": "Box2BoxTransform::get_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 43, "func_end_lineno": 76, "key_block_start_lineno": 55, "key_block_end_lineno": 76, "new_func_code": "def get_deltas(self, src_boxes, target_boxes):\n        \"\"\"\n        Get box regression transformation deltas (dx, dy, dw, dh) that can be used\n        to transform the `src_boxes` into the `target_boxes`. That is, the relation\n        ``target_boxes == self.apply_deltas(deltas, src_boxes)`` is true (unless\n        any delta is too large and is clamped).\n\n        Args:\n            src_boxes (Tensor): source boxes, e.g., object proposals\n            target_boxes (Tensor): target of the transformation, e.g., ground-truth\n                boxes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::inference", "project": "UniRef", "func": "FastRCNNOutputLayers::inference", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 361, "func_end_lineno": 382, "key_block_start_lineno": 372, "key_block_end_lineno": 382, "new_func_code": "def inference(self, predictions: Tuple[torch.Tensor, torch.Tensor], proposals: List[Instances]):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions. The ``proposal_boxes`` field is expected.\n\n        Returns:\n            list[Instances]: same as `fast_rcnn_inference`.\n            list[Tensor]: same as `fast_rcnn_inference`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::predict_boxes", "project": "UniRef", "func": "FastRCNNOutputLayers::predict_boxes", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 419, "func_end_lineno": 443, "key_block_start_lineno": 434, "key_block_end_lineno": 443, "new_func_code": "def predict_boxes(\n        self, predictions: Tuple[torch.Tensor, torch.Tensor], proposals: List[Instances]\n    ):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions. The ``proposal_boxes`` field is expected.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted class-specific or class-agnostic boxes\n                for each image. Element i has shape (Ri, K * B) or (Ri, B), where Ri is\n                the number of proposals for image i and B is the box dimension (4 or 5)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers::predict_probs", "project": "UniRef", "func": "FastRCNNOutputLayers::predict_probs", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 445, "func_end_lineno": 462, "key_block_start_lineno": 459, "key_block_end_lineno": 462, "new_func_code": "def predict_probs(\n        self, predictions: Tuple[torch.Tensor, torch.Tensor], proposals: List[Instances]\n    ):\n        \"\"\"\n        Args:\n            predictions: return values of :meth:`forward()`.\n            proposals (list[Instances]): proposals that match the features that were\n                used to compute predictions.\n\n        Returns:\n            list[Tensor]:\n                A list of Tensors of predicted class probabilities for each image.\n                Element i has shape (Ri, K + 1), where Ri is the number of proposals for image i.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.roi_heads.fast_rcnn.fast_rcnn_inference", "project": "UniRef", "func": "fast_rcnn_inference", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/roi_heads/fast_rcnn.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 45, "func_end_lineno": 84, "key_block_start_lineno": 78, "key_block_end_lineno": 84, "new_func_code": "def fast_rcnn_inference(\n    boxes: List[torch.Tensor],\n    scores: List[torch.Tensor],\n    image_shapes: List[Tuple[int, int]],\n    score_thresh: float,\n    nms_thresh: float,\n    topk_per_image: int,\n):\n    \"\"\"\n    Call `fast_rcnn_inference_single_image` for all images.\n\n    Args:\n        boxes (list[Tensor]): A list of Tensors of predicted class-specific or class-agnostic\n            boxes for each image. Element i has shape (Ri, K * 4) if doing\n            class-specific regression, or (Ri, 4) if doing class-agnostic\n            regression, where Ri is the number of predicted objects for image i.\n            This is compatible with the output of :meth:`FastRCNNOutputLayers.predict_boxes`.\n        scores (list[Tensor]): A list of Tensors of predicted class scores for each image.\n            Element i has shape (Ri, K + 1), where Ri is the number of predicted objects\n            for image i. Compatible with the output of :meth:`FastRCNNOutputLayers.predict_probs`.\n        image_shapes (list[tuple]): A list of (width, height) tuples for each image in the batch.\n        score_thresh (float): Only return detections with a confidence score exceeding this\n            threshold.\n        nms_thresh (float):  The threshold to use for box non-maximum suppression. Value in [0, 1].\n        topk_per_image (int): The number of top scoring detections to return. Set < 0 to return\n            all detections.\n\n    Returns:\n        instances: (list[Instances]): A list of N instances, one for each image in the batch,\n            that stores the topk most confidence detections.\n        kept_indices: (list[Tensor]): A list of 1D tensor of length of N, each element indicates\n            the corresponding boxes/scores index in [0, Ri) from the input, for image i.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.export.torchscript_patch.patch_builtin_len", "project": "UniRef", "func": "patch_builtin_len", "origin_file": "./Source_Copy/UniRef/detectron2/export/torchscript_patch.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 316, "func_end_lineno": 339, "key_block_start_lineno": 326, "key_block_end_lineno": 339, "new_func_code": "def patch_builtin_len(modules=()):\n    \"\"\"\n    Patch the builtin len() function of a few detectron2 modules\n    to use __len__ instead, because __len__ does not convert values to\n    integers and therefore is friendly to tracing.\n\n    Args:\n        modules (list[stsr]): names of extra modules to patch len(), in\n            addition to those in detectron2.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.config.instantiate.instantiate", "project": "UniRef", "func": "instantiate", "origin_file": "./Source_Copy/UniRef/detectron2/config/instantiate.py", "test_list": ["tests/config/test_instantiate_config.py"], "prob_info": {"func_start_lineno": 36, "func_end_lineno": 82, "key_block_start_lineno": 48, "key_block_end_lineno": 82, "new_func_code": "def instantiate(cfg):\n    \"\"\"\n    Recursively instantiate objects defined in dictionaries by\n    \"_target_\" and arguments.\n\n    Args:\n        cfg: a dict-like object with \"_target_\" that defines the caller, and\n            other keys that define the arguments\n\n    Returns:\n        object instantiated by cfg\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.transform_instance_annotations", "project": "UniRef", "func": "transform_instance_annotations", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 257, "func_end_lineno": 318, "key_block_start_lineno": 281, "key_block_end_lineno": 318, "new_func_code": "def transform_instance_annotations(\n    annotation, transforms, image_size, *, keypoint_hflip_indices=None\n):\n    \"\"\"\n    Apply transforms to box, segmentation and keypoints annotations of a single instance.\n\n    It will use `transforms.apply_box` for the box, and\n    `transforms.apply_coords` for segmentation polygons & keypoints.\n    If you need anything more specially designed for each data structure,\n    you'll need to implement your own version of this function or the transforms.\n\n    Args:\n        annotation (dict): dict of instance annotations for a single instance.\n            It will be modified in-place.\n        transforms (TransformList or list[Transform]):\n        image_size (tuple): the height, width of the transformed image\n        keypoint_hflip_indices (ndarray[int]): see `create_keypoint_hflip_indices`.\n\n    Returns:\n        dict:\n            the same input dict with fields \"bbox\", \"segmentation\", \"keypoints\"\n            transformed according to `transforms`.\n            The \"bbox_mode\" field will be set to XYXY_ABS.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.create_keypoint_hflip_indices", "project": "UniRef", "func": "create_keypoint_hflip_indices", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 509, "func_end_lineno": 531, "key_block_start_lineno": 518, "key_block_end_lineno": 531, "new_func_code": "def create_keypoint_hflip_indices(dataset_names: Union[str, List[str]]) -> List[int]:\n    \"\"\"\n    Args:\n        dataset_names: list of dataset names\n\n    Returns:\n        list[int]: a list of size=#keypoints, storing the\n        horizontally-flipped keypoint indices.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.check_metadata_consistency", "project": "UniRef", "func": "check_metadata_consistency", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 564, "func_end_lineno": 590, "key_block_start_lineno": 576, "key_block_end_lineno": 590, "new_func_code": "def check_metadata_consistency(key, dataset_names):\n    \"\"\"\n    Check that the datasets have consistent metadata.\n\n    Args:\n        key (str): a metadata key\n        dataset_names (list[str]): a list of dataset names\n\n    Raises:\n        AttributeError: if the key does not exist in the metadata\n        ValueError: if the given datasets do not have the same metadata values defined by key\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.catalog._MetadataCatalog::get", "project": "UniRef", "func": "_MetadataCatalog::get", "origin_file": "./Source_Copy/UniRef/detectron2/data/catalog.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 194, "func_end_lineno": 207, "key_block_start_lineno": 203, "key_block_end_lineno": 207, "new_func_code": "def get(self, name):\n        \"\"\"\n        Args:\n            name (str): name of a dataset (e.g. coco_2014_train).\n\n        Returns:\n            Metadata: The :class:`Metadata` instance associated with this name,\n            or create an empty one if none is available.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.read_image", "project": "UniRef", "func": "read_image", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 166, "func_end_lineno": 185, "key_block_start_lineno": 180, "key_block_end_lineno": 185, "new_func_code": "def read_image(file_name, format=None):\n    \"\"\"\n    Read an image into the given format.\n    Will apply rotation and flipping if the image has such exif information.\n\n    Args:\n        file_name (str): image file path\n        format (str): one of the supported image modes in PIL, or \"BGR\" or \"YUV-BT.601\".\n\n    Returns:\n        image (np.ndarray):\n            an HWC image in the given format, which is 0-255, uint8 for\n            supported image modes in PIL or \"BGR\"; float (0-1 for Y) for YUV-BT.601.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils._apply_exif_orientation", "project": "UniRef", "func": "_apply_exif_orientation", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 119, "func_end_lineno": 163, "key_block_start_lineno": 138, "key_block_end_lineno": 163, "new_func_code": "def _apply_exif_orientation(image):\n    \"\"\"\n    Applies the exif orientation correctly.\n\n    This code exists per the bug:\n      https://github.com/python-pillow/Pillow/issues/3973\n    with the function `ImageOps.exif_transpose`. The Pillow source raises errors with\n    various methods, especially `tobytes`\n\n    Function based on:\n      https://github.com/wkentaro/labelme/blob/v4.5.4/labelme/utils/image.py#L59\n      https://github.com/python-pillow/Pillow/blob/7.1.2/src/PIL/ImageOps.py#L527\n\n    Args:\n        image (PIL.Image): a PIL image\n\n    Returns:\n        (PIL.Image): the PIL image with exif orientation applied, if applicable\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.convert_PIL_to_numpy", "project": "UniRef", "func": "convert_PIL_to_numpy", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 60, "func_end_lineno": 90, "key_block_start_lineno": 71, "key_block_end_lineno": 90, "new_func_code": "def convert_PIL_to_numpy(image, format):\n    \"\"\"\n    Convert PIL image to numpy array of target format.\n\n    Args:\n        image (PIL.Image): a PIL image\n        format (str): the format of output image\n\n    Returns:\n        (np.ndarray): also see `read_image`\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.detection_utils.annotations_to_instances", "project": "UniRef", "func": "annotations_to_instances", "origin_file": "./Source_Copy/UniRef/detectron2/data/detection_utils.py", "test_list": ["tests/data/test_detection_utils.py"], "prob_info": {"func_start_lineno": 369, "func_end_lineno": 441, "key_block_start_lineno": 385, "key_block_end_lineno": 441, "new_func_code": "def annotations_to_instances(annos, image_size, mask_format=\"polygon\"):\n    \"\"\"\n    Create an :class:`Instances` object used by the models,\n    from instance annotations in the dataset dict.\n\n    Args:\n        annos (list[dict]): a list of instance annotations in one image, each\n            element for one instance.\n        image_size (tuple): height, width\n\n    Returns:\n        Instances:\n            It will contain fields \"gt_boxes\", \"gt_classes\",\n            \"gt_masks\", \"gt_keypoints\", if they can be obtained from `annos`.\n            This is the format that builtin models expect.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.hungarian_tracker.BaseHungarianTracker::_initialize_extra_fields", "project": "UniRef", "func": "BaseHungarianTracker::_initialize_extra_fields", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/hungarian_tracker.py", "test_list": ["tests/tracking/test_hungarian_tracker.py"], "prob_info": {"func_start_lineno": 74, "func_end_lineno": 95, "key_block_start_lineno": 84, "key_block_end_lineno": 95, "new_func_code": "def _initialize_extra_fields(self, instances: Instances) -> Instances:\n        \"\"\"\n        If input instances don't have ID, ID_period, lost_frame_count fields,\n        this method is used to initialize these fields.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances with extra fields added\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.catalog._DatasetCatalog::get", "project": "UniRef", "func": "_DatasetCatalog::get", "origin_file": "./Source_Copy/UniRef/detectron2/data/catalog.py", "test_list": ["tests/data/test_coco.py"], "prob_info": {"func_start_lineno": 40, "func_end_lineno": 58, "key_block_start_lineno": 50, "key_block_end_lineno": 58, "new_func_code": "def get(self, name):\n        \"\"\"\n        Call the registered function and return its results.\n\n        Args:\n            name (str): the name that identifies a dataset, e.g. \"coco_2014_train\".\n\n        Returns:\n            list[dict]: dataset annotations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.data.datasets.coco.load_coco_json", "project": "UniRef", "func": "load_coco_json", "origin_file": "./Source_Copy/UniRef/detectron2/data/datasets/coco.py", "test_list": ["tests/data/test_coco.py"], "prob_info": {"func_start_lineno": 30, "func_end_lineno": 229, "key_block_start_lineno": 64, "key_block_end_lineno": 229, "new_func_code": "def load_coco_json(json_file, image_root, dataset_name=None, extra_annotation_keys=None, dataset_name_in_dict=\"coco\"):\n    \"\"\"\n    Load a json file with COCO's instances annotation format.\n    Currently supports instance detection, instance segmentation,\n    and person keypoints annotations.\n\n    Args:\n        json_file (str): full path to the json file in COCO instances annotation format.\n        image_root (str or path-like): the directory where the images in this json file exists.\n        dataset_name (str or None): the name of the dataset (e.g., coco_2017_train).\n            When provided, this function will also do the following:\n\n            * Put \"thing_classes\" into the metadata associated with this dataset.\n            * Map the category ids into a contiguous range (needed by standard dataset format),\n              and add \"thing_dataset_id_to_contiguous_id\" to the metadata associated\n              with this dataset.\n\n            This option should usually be provided, unless users need to load\n            the original json content and apply more processing manually.\n        extra_annotation_keys (list[str]): list of per-annotation keys that should also be\n            loaded into the dataset dict (besides \"iscrowd\", \"bbox\", \"keypoints\",\n            \"category_id\", \"segmentation\"). The values for these keys will be returned as-is.\n            For example, the densepose annotations are loaded in this way.\n\n    Returns:\n        list[dict]: a list of dicts in Detectron2 standard dataset dicts format (See\n        `Using Custom Datasets </tutorials/datasets.html>`_ ) when `dataset_name` is not None.\n        If `dataset_name` is None, the returned `category_ids` may be\n        incontiguous and may not conform to the Detectron2 standard format.\n\n    Notes:\n        1. This function does not read the image files.\n           The results do not have the \"image\" field.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.VisImage::_setup_figure", "project": "UniRef", "func": "VisImage::_setup_figure", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 276, "func_end_lineno": 299, "key_block_start_lineno": 285, "key_block_end_lineno": 299, "new_func_code": "def _setup_figure(self, img):\n        \"\"\"\n        Args:\n            Same as in :meth:`__init__()`.\n\n        Returns:\n            fig (matplotlib.pyplot.figure): top level container for all the image plot elements.\n            ax (matplotlib.pyplot.Axes): contains figure elements and sets the coordinate system.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer._create_text_labels", "project": "UniRef", "func": "_create_text_labels", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 237, "func_end_lineno": 261, "key_block_start_lineno": 248, "key_block_end_lineno": 261, "new_func_code": "def _create_text_labels(classes, scores, class_names, is_crowd=None):\n    \"\"\"\n    Args:\n        classes (list[int] or None):\n        scores (list[float] or None):\n        class_names (list[str] or None):\n        is_crowd (list[bool] or None):\n\n    Returns:\n        list[str] or None\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::overlay_instances", "project": "UniRef", "func": "Visualizer::overlay_instances", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 614, "func_end_lineno": 754, "key_block_start_lineno": 652, "key_block_end_lineno": 754, "new_func_code": "def overlay_instances(\n        self,\n        *,\n        boxes=None,\n        labels=None,\n        masks=None,\n        keypoints=None,\n        assigned_colors=None,\n        alpha=0.5,\n    ):\n        \"\"\"\n        Args:\n            boxes (Boxes, RotatedBoxes or ndarray): either a :class:`Boxes`,\n                or an Nx4 numpy array of XYXY_ABS format for the N objects in a single image,\n                or a :class:`RotatedBoxes`,\n                or an Nx5 numpy array of (x_center, y_center, width, height, angle_degrees) format\n                for the N objects in a single image,\n            labels (list[str]): the text to be displayed for each instance.\n            masks (masks-like object): Supported types are:\n\n                * :class:`detectron2.structures.PolygonMasks`,\n                  :class:`detectron2.structures.BitMasks`.\n                * list[list[ndarray]]: contains the segmentation masks for all objects in one image.\n                  The first level of the list corresponds to individual instances. The second\n                  level to all the polygon that compose the instance, and the third level\n                  to the polygon coordinates. The third level should have the format of\n                  [x0, y0, x1, y1, ..., xn, yn] (n >= 3).\n                * list[ndarray]: each ndarray is a binary mask of shape (H, W).\n                * list[dict]: each dict is a COCO-style RLE.\n            keypoints (Keypoint or array like): an array-like object of shape (N, K, 3),\n                where the N is the number of instances and K is the number of keypoints.\n                The last dimension corresponds to (x, y, visibility or score).\n            assigned_colors (list[matplotlib.colors]): a list of colors, where each color\n                corresponds to each mask or box in the image. Refer to 'matplotlib.colors'\n                for full list of formats that the colors are accepted in.\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::_convert_masks", "project": "UniRef", "func": "Visualizer::_convert_masks", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1221, "func_end_lineno": 1242, "key_block_start_lineno": 1228, "key_block_end_lineno": 1242, "new_func_code": "def _convert_masks(self, masks_or_polygons):\n        \"\"\"\n        Convert different format of masks or polygons to a tuple of masks and polygons.\n\n        Returns:\n            list[GenericMask]:\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.colormap.random_color", "project": "UniRef", "func": "random_color", "origin_file": "./Source_Copy/UniRef/detectron2/utils/colormap.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 112, "func_end_lineno": 125, "key_block_start_lineno": 121, "key_block_end_lineno": 125, "new_func_code": "def random_color(rgb=False, maximum=255):\n    \"\"\"\n    Args:\n        rgb (bool): whether to return RGB colors or BGR colors.\n        maximum (int): either 255 or 1\n\n    Returns:\n        ndarray: a vector of 3 numbers\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_box", "project": "UniRef", "func": "Visualizer::draw_box", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 904, "func_end_lineno": 936, "key_block_start_lineno": 918, "key_block_end_lineno": 936, "new_func_code": "def draw_box(self, box_coord, alpha=0.5, edge_color=\"g\", line_style=\"-\"):\n        \"\"\"\n        Args:\n            box_coord (tuple): a tuple containing x0, y0, x1, y1 coordinates, where x0 and y0\n                are the coordinates of the image's top left corner. x1 and y1 are the\n                coordinates of the image's bottom right corner.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            edge_color: color of the outline of the box. Refer to `matplotlib.colors`\n                for full list of formats that are accepted.\n            line_style (string): the string to use to create the outline of the boxes.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::_change_color_brightness", "project": "UniRef", "func": "Visualizer::_change_color_brightness", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1187, "func_end_lineno": 1210, "key_block_start_lineno": 1203, "key_block_end_lineno": 1210, "new_func_code": "def _change_color_brightness(self, color, brightness_factor):\n        \"\"\"\n        Depending on the brightness_factor, gives a lighter or darker color i.e. a color with\n        less or more saturation than the original color.\n\n        Args:\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            brightness_factor (float): a value in [-1.0, 1.0] range. A lightness factor of\n                0 will correspond to no change, a factor in [-1.0, 0) range will result in\n                a darker color and a factor in (0, 1.0] range will result in a lighter color.\n\n        Returns:\n            modified_color (tuple[double]): a tuple containing the RGB values of the\n                modified color. Each value in the tuple is in the [0.0, 1.0] range.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_text", "project": "UniRef", "func": "Visualizer::draw_text", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 857, "func_end_lineno": 902, "key_block_start_lineno": 881, "key_block_end_lineno": 902, "new_func_code": "def draw_text(\n        self,\n        text,\n        position,\n        *,\n        font_size=None,\n        color=\"g\",\n        horizontal_alignment=\"center\",\n        rotation=0,\n    ):\n        \"\"\"\n        Args:\n            text (str): class label\n            position (tuple): a tuple of the x and y coordinates to place text on image.\n            font_size (int, optional): font of the text. If not provided, a font size\n                proportional to the image width is calculated and used.\n            color: color of the text. Refer to `matplotlib.colors` for full list\n                of formats that are accepted.\n            horizontal_alignment (str): see `matplotlib.text.Text`\n            rotation: rotation angle in degrees CCW\n\n        Returns:\n            output (VisImage): image object with text drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_polygon", "project": "UniRef", "func": "Visualizer::draw_polygon", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1121, "func_end_lineno": 1151, "key_block_start_lineno": 1135, "key_block_end_lineno": 1151, "new_func_code": "def draw_polygon(self, segment, color, edge_color=None, alpha=0.5):\n        \"\"\"\n        Args:\n            segment: numpy array of shape Nx2, containing all the points in the polygon.\n            color: color of the polygon. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            edge_color: color of the polygon edges. Refer to `matplotlib.colors` for a\n                full list of formats that are accepted. If not provided, a darker shade\n                of the polygon color will be used instead.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n\n        Returns:\n            output (VisImage): image object with polygon drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_dataset_dict", "project": "UniRef", "func": "Visualizer::draw_dataset_dict", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 545, "func_end_lineno": 612, "key_block_start_lineno": 555, "key_block_end_lineno": 612, "new_func_code": "def draw_dataset_dict(self, dic):\n        \"\"\"\n        Draw annotations/segmentaions in Detectron2 Dataset format.\n\n        Args:\n            dic (dict): annotation/segmentation data of one image, in Detectron2 Dataset format.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::overlay_rotated_instances", "project": "UniRef", "func": "Visualizer::overlay_rotated_instances", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 756, "func_end_lineno": 792, "key_block_start_lineno": 770, "key_block_end_lineno": 792, "new_func_code": "def overlay_rotated_instances(self, boxes=None, labels=None, assigned_colors=None):\n        \"\"\"\n        Args:\n            boxes (ndarray): an Nx5 numpy array of\n                (x_center, y_center, width, height, angle_degrees) format\n                for the N objects in a single image.\n            labels (list[str]): the text to be displayed for each instance.\n            assigned_colors (list[matplotlib.colors]): a list of colors, where each color\n                corresponds to each mask or box in the image. Refer to 'matplotlib.colors'\n                for full list of formats that the colors are accepted in.\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_rotated_box_with_label", "project": "UniRef", "func": "Visualizer::draw_rotated_box_with_label", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 938, "func_end_lineno": 991, "key_block_start_lineno": 958, "key_block_end_lineno": 991, "new_func_code": "def draw_rotated_box_with_label(\n        self, rotated_box, alpha=0.5, edge_color=\"g\", line_style=\"-\", label=None\n    ):\n        \"\"\"\n        Draw a rotated box with label on its top-left corner.\n\n        Args:\n            rotated_box (tuple): a tuple containing (cnt_x, cnt_y, w, h, angle),\n                where cnt_x and cnt_y are the center coordinates of the box.\n                w and h are the width and height of the box. angle represents how\n                many degrees the box is rotated CCW with regard to the 0-degree box.\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n            edge_color: color of the outline of the box. Refer to `matplotlib.colors`\n                for full list of formats that are accepted.\n            line_style (string): the string to use to create the outline of the boxes.\n            label (string): label for rotated box. It will not be rendered when set to None.\n\n        Returns:\n            output (VisImage): image object with box drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_line", "project": "UniRef", "func": "Visualizer::draw_line", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1011, "func_end_lineno": 1040, "key_block_start_lineno": 1028, "key_block_end_lineno": 1040, "new_func_code": "def draw_line(self, x_data, y_data, color, linestyle=\"-\", linewidth=None):\n        \"\"\"\n        Args:\n            x_data (list[int]): a list containing x values of all the points being drawn.\n                Length of list should match the length of y_data.\n            y_data (list[int]): a list containing y values of all the points being drawn.\n                Length of list should match the length of x_data.\n            color: color of the line. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted.\n            linestyle: style of the line. Refer to `matplotlib.lines.Line2D`\n                for a full list of formats that are accepted.\n            linewidth (float or None): width of the line. When it's None,\n                a default value will be computed and used.\n\n        Returns:\n            output (VisImage): image object with line drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.visualizer.Visualizer::draw_soft_mask", "project": "UniRef", "func": "Visualizer::draw_soft_mask", "origin_file": "./Source_Copy/UniRef/detectron2/utils/visualizer.py", "test_list": ["tests/test_visualizer.py"], "prob_info": {"func_start_lineno": 1093, "func_end_lineno": 1119, "key_block_start_lineno": 1105, "key_block_end_lineno": 1119, "new_func_code": "def draw_soft_mask(self, soft_mask, color=None, *, text=None, alpha=0.5):\n        \"\"\"\n        Args:\n            soft_mask (ndarray): float array of shape (H, W), each value in [0, 1].\n            color: color of the mask. Refer to `matplotlib.colors` for a full list of\n                formats that are accepted. If None, will pick a random color.\n            text (str): if None, will be drawn on the object\n            alpha (float): blending efficient. Smaller values lead to more transparent masks.\n\n        Returns:\n            output (VisImage): image object with mask drawn.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.matcher.Matcher::__call__", "project": "UniRef", "func": "Matcher::__call__", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/matcher.py", "test_list": ["tests/modeling/test_matcher.py"], "prob_info": {"func_start_lineno": 62, "func_end_lineno": 104, "key_block_start_lineno": 76, "key_block_end_lineno": 104, "new_func_code": "def __call__(self, match_quality_matrix):\n        \"\"\"\n        Args:\n            match_quality_matrix (Tensor[float]): an MxN tensor, containing the\n                pairwise quality between M ground-truth elements and N predicted\n                elements. All elements must be >= 0 (due to the us of `torch.nonzero`\n                for selecting indices in :meth:`set_low_quality_matches_`).\n\n        Returns:\n            matches (Tensor[int64]): a vector of length N, where matches[i] is a matched\n                ground-truth index in [0, M)\n            match_labels (Tensor[int8]): a vector of length N, where pred_labels[i] indicates\n                whether a prediction is a true or false positive or ignored\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.vanilla_hungarian_bbox_iou_tracker.VanillaHungarianBBoxIOUTracker::assign_cost_matrix_values", "project": "UniRef", "func": "VanillaHungarianBBoxIOUTracker::assign_cost_matrix_values", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/vanilla_hungarian_bbox_iou_tracker.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 118, "func_end_lineno": 131, "key_block_start_lineno": 128, "key_block_end_lineno": 131, "new_func_code": "def assign_cost_matrix_values(self, cost_matrix: np.ndarray, bbox_pairs: List) -> np.ndarray:\n        \"\"\"\n        Based on IoU for each pair of bbox, assign the associated value in cost matrix\n\n        Args:\n            cost_matrix: np.ndarray, initialized 2D array with target dimensions\n            bbox_pairs: list of bbox pair, in each pair, iou value is stored\n        Return:\n            np.ndarray, cost_matrix with assigned values\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.base_tracker.build_tracker_head", "project": "UniRef", "func": "build_tracker_head", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/base_tracker.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 53, "func_end_lineno": 64, "key_block_start_lineno": 62, "key_block_end_lineno": 64, "new_func_code": "def build_tracker_head(cfg: CfgNode_) -> BaseTracker:\n    \"\"\"\n    Build a tracker head from `cfg.TRACKER_HEADS.TRACKER_NAME`.\n\n    Args:\n        cfg: D2 CfgNode, config file with tracker information\n    Return:\n        tracker object\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.config.config._get_args_from_config", "project": "UniRef", "func": "_get_args_from_config", "origin_file": "./Source_Copy/UniRef/detectron2/config/config.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 218, "func_end_lineno": 248, "key_block_start_lineno": 225, "key_block_end_lineno": 248, "new_func_code": "def _get_args_from_config(from_config_func, *args, **kwargs):\n    \"\"\"\n    Use `from_config` to obtain explicit arguments.\n\n    Returns:\n        dict: arguments to be used for cls.__init__\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.pairwise_iou", "project": "UniRef", "func": "pairwise_iou", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 334, "func_end_lineno": 356, "key_block_start_lineno": 346, "key_block_end_lineno": 356, "new_func_code": "def pairwise_iou(boxes1: Boxes, boxes2: Boxes) -> torch.Tensor:\n    \"\"\"\n    Given two lists of boxes of size N and M, compute the IoU\n    (intersection over union) between **all** N x M pairs of boxes.\n    The box order must be (xmin, ymin, xmax, ymax).\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: IoU, sized [N,M].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.pairwise_intersection", "project": "UniRef", "func": "pairwise_intersection", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 329, "key_block_start_lineno": 322, "key_block_end_lineno": 329, "new_func_code": "def pairwise_intersection(boxes1: Boxes, boxes2: Boxes) -> torch.Tensor:\n    \"\"\"\n    Given two lists of boxes of size N and M,\n    compute the intersection area between __all__ N x M pairs of boxes.\n    The box order must be (xmin, ymin, xmax, ymax)\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: intersection, sized [N,M].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.utils.create_prediction_pairs", "project": "UniRef", "func": "create_prediction_pairs", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/utils.py", "test_list": ["tests/tracking/test_vanilla_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 36, "key_block_start_lineno": 22, "key_block_end_lineno": 36, "new_func_code": "def create_prediction_pairs(\n    instances: Instances,\n    prev_instances: Instances,\n    iou_all: np.ndarray,\n    threshold: float = 0.5,\n) -> List:\n    \"\"\"\n    Args:\n        instances: predictions from current frame\n        prev_instances: predictions from previous frame\n        iou_all: 2D numpy array containing iou for each bbox pair\n        threshold: below the threshold, doesn't consider the pair of bbox is valid\n    Return:\n        List of bbox pairs\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_initialize_extra_fields", "project": "UniRef", "func": "BBoxIOUTracker::_initialize_extra_fields", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 152, "func_end_lineno": 173, "key_block_start_lineno": 162, "key_block_end_lineno": 173, "new_func_code": "def _initialize_extra_fields(self, instances: Instances) -> Instances:\n        \"\"\"\n        If input instances don't have ID, ID_period, lost_frame_count fields,\n        this method is used to initialize these fields.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances with extra fields added\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_assign_new_id", "project": "UniRef", "func": "BBoxIOUTracker::_assign_new_id", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 183, "func_end_lineno": 198, "key_block_start_lineno": 192, "key_block_end_lineno": 198, "new_func_code": "def _assign_new_id(self, instances: Instances) -> Instances:\n        \"\"\"\n        For each untracked instance, assign a new id\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances with new ID assigned\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_create_prediction_pairs", "project": "UniRef", "func": "BBoxIOUTracker::_create_prediction_pairs", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 123, "func_end_lineno": 150, "key_block_start_lineno": 138, "key_block_end_lineno": 150, "new_func_code": "def _create_prediction_pairs(\n        self, instances: Instances, iou_all: np.ndarray\n    ) -> List:\n        \"\"\"\n        For all instances in previous and current frames, create pairs. For each\n        pair, store index of the instance in current frame predcitions, index in\n        previous predictions, ID in previous predictions, IoU of the bboxes in this\n        pair, period in previous predictions.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n            iou_all: IoU for all bboxes pairs\n        Return:\n            A list of IoU for all pairs\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.bbox_iou_tracker.BBoxIOUTracker::_merge_untracked_instances", "project": "UniRef", "func": "BBoxIOUTracker::_merge_untracked_instances", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/bbox_iou_tracker.py", "test_list": ["tests/tracking/test_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 200, "func_end_lineno": 260, "key_block_start_lineno": 211, "key_block_end_lineno": 260, "new_func_code": "def _merge_untracked_instances(self, instances: Instances) -> Instances:\n        \"\"\"\n        For untracked previous instances, under certain condition, still keep them\n        in tracking and merge with the current instances.\n\n        Args:\n            instances: D2 Instances, for predictions of the current frame\n        Return:\n            D2 Instances merging current instances and instances from previous\n            frame decided to keep tracking\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.layers.batch_norm.get_norm", "project": "UniRef", "func": "get_norm", "origin_file": "./Source_Copy/UniRef/detectron2/layers/batch_norm.py", "test_list": ["tests/layers/test_blocks.py"], "prob_info": {"func_start_lineno": 121, "func_end_lineno": 149, "key_block_start_lineno": 131, "key_block_end_lineno": 149, "new_func_code": "def get_norm(norm, out_channels):\n    \"\"\"\n    Args:\n        norm (str or callable): either one of BN, SyncBN, FrozenBN, GN;\n            or a callable that takes a channel number and returns\n            the normalization layer as a nn.Module.\n\n    Returns:\n        nn.Module or None: the normalization layer\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.backbone.resnet.ResNet::freeze", "project": "UniRef", "func": "ResNet::freeze", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/backbone/resnet.py", "test_list": ["tests/layers/test_blocks.py"], "prob_info": {"func_start_lineno": 468, "func_end_lineno": 490, "key_block_start_lineno": 484, "key_block_end_lineno": 490, "new_func_code": "def freeze(self, freeze_at=0):\n        \"\"\"\n        Freeze the first several stages of the ResNet. Commonly used in\n        fine-tuning.\n\n        Layers that produce the same feature map spatial size are defined as one\n        \"stage\" by :paper:`FPN`.\n\n        Args:\n            freeze_at (int): number of stages to freeze.\n                `1` means freezing the stem. `2` means freezing the stem and\n                one residual stage, etc.\n\n        Returns:\n            nn.Module: this ResNet itself\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.boxes.pairwise_ioa", "project": "UniRef", "func": "pairwise_ioa", "origin_file": "./Source_Copy/UniRef/detectron2/structures/boxes.py", "test_list": ["tests/structures/test_boxes.py"], "prob_info": {"func_start_lineno": 359, "func_end_lineno": 376, "key_block_start_lineno": 369, "key_block_end_lineno": 376, "new_func_code": "def pairwise_ioa(boxes1: Boxes, boxes2: Boxes) -> torch.Tensor:\n    \"\"\"\n    Similar to :func:`pariwise_iou` but compute the IoA (intersection over boxes2 area).\n\n    Args:\n        boxes1,boxes2 (Boxes): two `Boxes`. Contains N & M boxes, respectively.\n\n    Returns:\n        Tensor: IoA, sized [N,M].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.tracking.iou_weighted_hungarian_bbox_iou_tracker.IOUWeightedHungarianBBoxIOUTracker::assign_cost_matrix_values", "project": "UniRef", "func": "IOUWeightedHungarianBBoxIOUTracker::assign_cost_matrix_values", "origin_file": "./Source_Copy/UniRef/detectron2/tracking/iou_weighted_hungarian_bbox_iou_tracker.py", "test_list": ["tests/tracking/test_iou_weighted_hungarian_bbox_iou_tracker.py"], "prob_info": {"func_start_lineno": 88, "func_end_lineno": 101, "key_block_start_lineno": 98, "key_block_end_lineno": 101, "new_func_code": "def assign_cost_matrix_values(self, cost_matrix: np.ndarray, bbox_pairs: List) -> np.ndarray:\n        \"\"\"\n        Based on IoU for each pair of bbox, assign the associated value in cost matrix\n\n        Args:\n            cost_matrix: np.ndarray, initialized 2D array with target dimensions\n            bbox_pairs: list of bbox pair, in each pair, iou value is stored\n        Return:\n            np.ndarray, cost_matrix with assigned values\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.layers.losses.ciou_loss", "project": "UniRef", "func": "ciou_loss", "origin_file": "./Source_Copy/UniRef/detectron2/layers/losses.py", "test_list": ["tests/layers/test_losses.py"], "prob_info": {"func_start_lineno": 66, "func_end_lineno": 133, "key_block_start_lineno": 83, "key_block_end_lineno": 133, "new_func_code": "def ciou_loss(\n    boxes1: torch.Tensor,\n    boxes2: torch.Tensor,\n    reduction: str = \"none\",\n    eps: float = 1e-7,\n) -> torch.Tensor:\n    \"\"\"\n    Complete Intersection over Union Loss (Zhaohui Zheng et. al)\n    https://arxiv.org/abs/1911.08287\n    Args:\n        boxes1, boxes2 (Tensor): box locations in XYXY format, shape (N, 4) or (4,).\n        reduction: 'none' | 'mean' | 'sum'\n                 'none': No reduction will be applied to the output.\n                 'mean': The output will be averaged.\n                 'sum': The output will be summed.\n        eps (float): small number to prevent division by zero\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.layers.losses.diou_loss", "project": "UniRef", "func": "diou_loss", "origin_file": "./Source_Copy/UniRef/detectron2/layers/losses.py", "test_list": ["tests/layers/test_losses.py"], "prob_info": {"func_start_lineno": 5, "func_end_lineno": 63, "key_block_start_lineno": 22, "key_block_end_lineno": 63, "new_func_code": "def diou_loss(\n    boxes1: torch.Tensor,\n    boxes2: torch.Tensor,\n    reduction: str = \"none\",\n    eps: float = 1e-7,\n) -> torch.Tensor:\n    \"\"\"\n    Distance Intersection over Union Loss (Zhaohui Zheng et. al)\n    https://arxiv.org/abs/1911.08287\n    Args:\n        boxes1, boxes2 (Tensor): box locations in XYXY format, shape (N, 4) or (4,).\n        reduction: 'none' | 'mean' | 'sum'\n                 'none': No reduction will be applied to the output.\n                 'mean': The output will be averaged.\n                 'sum': The output will be summed.\n        eps (float): small number to prevent division by zero\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.masks.BitMasks::get_bounding_boxes", "project": "UniRef", "func": "BitMasks::get_bounding_boxes", "origin_file": "./Source_Copy/UniRef/detectron2/structures/masks.py", "test_list": ["tests/structures/test_masks.py"], "prob_info": {"func_start_lineno": 222, "func_end_lineno": 238, "key_block_start_lineno": 228, "key_block_end_lineno": 238, "new_func_code": "def get_bounding_boxes(self) -> Boxes:\n        \"\"\"\n        Returns:\n            Boxes: tight bounding boxes around bitmasks.\n            If a mask is empty, it's bounding box will be all zero.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.structures.masks.BitMasks::__getitem__", "project": "UniRef", "func": "BitMasks::__getitem__", "origin_file": "./Source_Copy/UniRef/detectron2/structures/masks.py", "test_list": ["tests/structures/test_masks.py"], "prob_info": {"func_start_lineno": 117, "func_end_lineno": 138, "key_block_start_lineno": 132, "key_block_end_lineno": 138, "new_func_code": "def __getitem__(self, item: Union[int, slice, torch.BoolTensor]) -> \"BitMasks\":\n        \"\"\"\n        Returns:\n            BitMasks: Create a new :class:`BitMasks` by indexing.\n\n        The following usage are allowed:\n\n        1. `new_masks = masks[3]`: return a `BitMasks` which contains only one mask.\n        2. `new_masks = masks[2:10]`: return a slice of masks.\n        3. `new_masks = masks[vector]`, where vector is a torch.BoolTensor\n           with `length = len(masks)`. Nonzero elements in the vector will be selected.\n\n        Note that the returned object might share storage with this object,\n        subject to Pytorch's indexing semantics.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransformLinear::get_deltas", "project": "UniRef", "func": "Box2BoxTransformLinear::get_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_box2box_transform.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 273, "key_block_start_lineno": 255, "key_block_end_lineno": 273, "new_func_code": "def get_deltas(self, src_boxes, target_boxes):\n        \"\"\"\n        Get box regression transformation deltas (dx1, dy1, dx2, dy2) that can be used\n        to transform the `src_boxes` into the `target_boxes`. That is, the relation\n        ``target_boxes == self.apply_deltas(deltas, src_boxes)`` is true.\n        The center of src must be inside target boxes.\n\n        Args:\n            src_boxes (Tensor): square source boxes, e.g., anchors\n            target_boxes (Tensor): target of the transformation, e.g., ground-truth\n                boxes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransformLinear::apply_deltas", "project": "UniRef", "func": "Box2BoxTransformLinear::apply_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_box2box_transform.py"], "prob_info": {"func_start_lineno": 275, "func_end_lineno": 307, "key_block_start_lineno": 285, "key_block_end_lineno": 307, "new_func_code": "def apply_deltas(self, deltas, boxes):\n        \"\"\"\n        Apply transformation `deltas` (dx1, dy1, dx2, dy2) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*4), where k >= 1.\n                deltas[i] represents k potentially different class-specific\n                box transformations for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 4)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransformRotated::apply_deltas", "project": "UniRef", "func": "Box2BoxTransformRotated::apply_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_box2box_transform.py"], "prob_info": {"func_start_lineno": 183, "func_end_lineno": 227, "key_block_start_lineno": 192, "key_block_end_lineno": 227, "new_func_code": "def apply_deltas(self, deltas, boxes):\n        \"\"\"\n        Apply transformation `deltas` (dx, dy, dw, dh, da) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*5).\n                deltas[i] represents box transformation for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 5)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator._broadcast_params", "project": "UniRef", "func": "_broadcast_params", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 54, "func_end_lineno": 78, "key_block_start_lineno": 66, "key_block_end_lineno": 78, "new_func_code": "def _broadcast_params(params, num_features, name):\n    \"\"\"\n    If one size (or aspect ratio) is specified and there are multiple feature\n    maps, we \"broadcast\" anchors of that single size (or aspect ratio)\n    over all feature maps.\n\n    If params is list[float], or list[list[float]] with len(params) == 1, repeat\n    it num_features time.\n\n    Returns:\n        list[list[float]]: param for each feature\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.DefaultAnchorGenerator::generate_cell_anchors", "project": "UniRef", "func": "DefaultAnchorGenerator::generate_cell_anchors", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 177, "func_end_lineno": 212, "key_block_start_lineno": 192, "key_block_end_lineno": 212, "new_func_code": "def generate_cell_anchors(self, sizes=(32, 64, 128, 256, 512), aspect_ratios=(0.5, 1, 2)):\n        \"\"\"\n        Generate a tensor storing canonical anchor boxes, which are all anchor\n        boxes of different sizes and aspect_ratios centered at (0, 0).\n        We can later build the set of anchors for a full feature map by\n        shifting and tiling these tensors (see `meth:_grid_anchors`).\n\n        Args:\n            sizes (tuple[float]):\n            aspect_ratios (tuple[float]]):\n\n        Returns:\n            Tensor of shape (len(sizes) * len(aspect_ratios), 4) storing anchor boxes\n                in XYXY format.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.DefaultAnchorGenerator::forward", "project": "UniRef", "func": "DefaultAnchorGenerator::forward", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 214, "func_end_lineno": 227, "key_block_start_lineno": 225, "key_block_end_lineno": 227, "new_func_code": "def forward(self, features: List[torch.Tensor]):\n        \"\"\"\n        Args:\n            features (list[Tensor]): list of backbone feature maps on which to generate anchors.\n\n        Returns:\n            list[Boxes]: a list of Boxes containing all the anchors for each feature map\n                (i.e. the cell anchors repeated over all locations in the feature map).\n                The number of anchors of each feature map is Hi x Wi x num_cell_anchors,\n                where Hi, Wi are resolution of the feature map divided by anchor stride.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.DefaultAnchorGenerator::num_anchors", "project": "UniRef", "func": "DefaultAnchorGenerator::num_anchors", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 148, "func_end_lineno": 159, "key_block_start_lineno": 159, "key_block_end_lineno": 159, "new_func_code": "def num_anchors(self):\n        \"\"\"\n        Returns:\n            list[int]: Each int is the number of anchors at every pixel\n                location, on that feature map.\n                For example, if at every pixel we use anchors of 3 aspect\n                ratios and 5 sizes, the number of anchors is 15.\n                (See also ANCHOR_GENERATOR.SIZES and ANCHOR_GENERATOR.ASPECT_RATIOS in config)\n\n                In standard RPN models, `num_anchors` on every feature map is the same.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.anchor_generator.RotatedAnchorGenerator::forward", "project": "UniRef", "func": "RotatedAnchorGenerator::forward", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/anchor_generator.py", "test_list": ["tests/modeling/test_anchor_generator.py"], "prob_info": {"func_start_lineno": 361, "func_end_lineno": 374, "key_block_start_lineno": 372, "key_block_end_lineno": 374, "new_func_code": "def forward(self, features):\n        \"\"\"\n        Args:\n            features (list[Tensor]): list of backbone feature maps on which to generate anchors.\n\n        Returns:\n            list[RotatedBoxes]: a list of Boxes containing all the anchors for each feature map\n                (i.e. the cell anchors repeated over all locations in the feature map).\n                The number of anchors of each feature map is Hi x Wi x num_cell_anchors,\n                where Hi, Wi are resolution of the feature map divided by anchor stride.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.box_regression.Box2BoxTransform::apply_deltas", "project": "UniRef", "func": "Box2BoxTransform::apply_deltas", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/box_regression.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 78, "func_end_lineno": 116, "key_block_start_lineno": 88, "key_block_end_lineno": 116, "new_func_code": "def apply_deltas(self, deltas, boxes):\n        \"\"\"\n        Apply transformation `deltas` (dx, dy, dw, dh) to `boxes`.\n\n        Args:\n            deltas (Tensor): transformation deltas of shape (N, k*4), where k >= 1.\n                deltas[i] represents k potentially different class-specific\n                box transformations for the single box boxes[i].\n            boxes (Tensor): boxes to transform, of shape (N, 4)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.modeling.matcher.Matcher::set_low_quality_matches_", "project": "UniRef", "func": "Matcher::set_low_quality_matches_", "origin_file": "./Source_Copy/UniRef/detectron2/modeling/matcher.py", "test_list": ["tests/modeling/test_matcher.py"], "prob_info": {"func_start_lineno": 106, "func_end_lineno": 127, "key_block_start_lineno": 116, "key_block_end_lineno": 127, "new_func_code": "def set_low_quality_matches_(self, match_labels, match_quality_matrix):\n        \"\"\"\n        Produce additional matches for predictions that have only low-quality matches.\n        Specifically, for each ground-truth G find the set of predictions that have\n        maximum overlap with it (including ties); for each prediction in that set, if\n        it is unmatched, then match it to the ground-truth G.\n\n        This function implements the RPN assignment case (i) in Sec. 3.1.2 of\n        :paper:`Faster R-CNN`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.layers.nms.batched_nms", "project": "UniRef", "func": "batched_nms", "origin_file": "./Source_Copy/UniRef/detectron2/layers/nms.py", "test_list": ["tests/layers/test_nms.py"], "prob_info": {"func_start_lineno": 9, "func_end_lineno": 20, "key_block_start_lineno": 15, "key_block_end_lineno": 20, "new_func_code": "def batched_nms(\n    boxes: torch.Tensor, scores: torch.Tensor, idxs: torch.Tensor, iou_threshold: float\n):\n    \"\"\"\n    Same as torchvision.ops.boxes.batched_nms, but with float().\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.utils.events.EventStorage::latest_with_smoothing_hint", "project": "UniRef", "func": "EventStorage::latest_with_smoothing_hint", "origin_file": "./Source_Copy/UniRef/detectron2/utils/events.py", "test_list": ["tests/test_events.py"], "prob_info": {"func_start_lineno": 402, "func_end_lineno": 417, "key_block_start_lineno": 411, "key_block_end_lineno": 417, "new_func_code": "def latest_with_smoothing_hint(self, window_size=20):\n        \"\"\"\n        Similar to :meth:`latest`, but the returned values\n        are either the un-smoothed original latest value,\n        or a median of the given window_size,\n        depend on whether the smoothing_hint is True.\n\n        This provides a default behavior that other writers can use.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.export.torchscript_patch._add_instances_conversion_methods", "project": "UniRef", "func": "_add_instances_conversion_methods", "origin_file": "./Source_Copy/UniRef/detectron2/export/torchscript_patch.py", "test_list": ["tests/structures/test_instances.py"], "prob_info": {"func_start_lineno": 28, "func_end_lineno": 47, "key_block_start_lineno": 32, "key_block_end_lineno": 47, "new_func_code": "def _add_instances_conversion_methods(newInstances):\n    \"\"\"\n    Add from_instances methods to the scripted Instances class.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "UniRef.detectron2.export.torchscript_patch.patch_nonscriptable_classes", "project": "UniRef", "func": "patch_nonscriptable_classes", "origin_file": "./Source_Copy/UniRef/detectron2/export/torchscript_patch.py", "test_list": ["tests/modeling/test_fast_rcnn.py"], "prob_info": {"func_start_lineno": 342, "func_end_lineno": 384, "key_block_start_lineno": 347, "key_block_end_lineno": 384, "new_func_code": "def patch_nonscriptable_classes():\n    \"\"\"\n    Apply patches on a few nonscriptable detectron2 classes.\n    Should not have side-effects on eager usage.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core._api.beta_decorator.beta", "project": "langchain_core", "func": "beta", "origin_file": "langchain_core/_api/beta_decorator.py", "test_list": ["tests/unit_tests/test_globals.py"], "prob_info": {"func_start_lineno": 33, "func_end_lineno": 225, "key_block_start_lineno": 74, "key_block_end_lineno": 225, "new_func_code": "def beta(\n    *,\n    message: str = \"\",\n    name: str = \"\",\n    obj_type: str = \"\",\n    addendum: str = \"\",\n) -> Callable[[T], T]:\n    \"\"\"Decorator to mark a function, a class, or a property as beta.\n\n    When marking a classmethod, a staticmethod, or a property, the\n    ``@beta`` decorator should go *under* ``@classmethod`` and\n    ``@staticmethod`` (i.e., `beta` should directly decorate the\n    underlying callable), but *over* ``@property``.\n\n    When marking a class ``C`` intended to be used as a base class in a\n    multiple inheritance hierarchy, ``C`` *must* define an ``__init__`` method\n    (if ``C`` instead inherited its ``__init__`` from its own base class, then\n    ``@beta`` would mess up ``__init__`` inheritance when installing its\n    own (annotation-emitting) ``C.__init__``).\n\n    Args:\n        message : str, optional\n            Override the default beta message. The %(since)s,\n            %(name)s, %(alternative)s, %(obj_type)s, %(addendum)s,\n            and %(removal)s format specifiers will be replaced by the\n            values of the respective arguments passed to this function.\n        name : str, optional\n            The name of the beta object.\n        obj_type : str, optional\n            The object type being beta.\n        addendum : str, optional\n            Additional text appended directly to the final message.\n\n    Examples:\n\n        .. code-block:: python\n\n            @beta\n            def the_function_to_annotate():\n                pass\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core._api.deprecation.deprecated", "project": "langchain_core", "func": "deprecated", "origin_file": "langchain_core/_api/deprecation.py", "test_list": ["tests/unit_tests/test_globals.py"], "prob_info": {"func_start_lineno": 68, "func_end_lineno": 384, "key_block_start_lineno": 133, "key_block_end_lineno": 384, "new_func_code": "def deprecated(\n    since: str,\n    *,\n    message: str = \"\",\n    name: str = \"\",\n    alternative: str = \"\",\n    alternative_import: str = \"\",\n    pending: bool = False,\n    obj_type: str = \"\",\n    addendum: str = \"\",\n    removal: str = \"\",\n    package: str = \"\",\n) -> Callable[[T], T]:\n    \"\"\"Decorator to mark a function, a class, or a property as deprecated.\n\n    When deprecating a classmethod, a staticmethod, or a property, the\n    ``@deprecated`` decorator should go *under* ``@classmethod`` and\n    ``@staticmethod`` (i.e., `deprecated` should directly decorate the\n    underlying callable), but *over* ``@property``.\n\n    When deprecating a class ``C`` intended to be used as a base class in a\n    multiple inheritance hierarchy, ``C`` *must* define an ``__init__`` method\n    (if ``C`` instead inherited its ``__init__`` from its own base class, then\n    ``@deprecated`` would mess up ``__init__`` inheritance when installing its\n    own (deprecation-emitting) ``C.__init__``).\n\n    Parameters are the same as for `warn_deprecated`, except that *obj_type*\n    defaults to 'class' if decorating a class, 'attribute' if decorating a\n    property, and 'function' otherwise.\n\n    Args:\n        since : str\n            The release at which this API became deprecated.\n        message : str, optional\n            Override the default deprecation message. The %(since)s,\n            %(name)s, %(alternative)s, %(obj_type)s, %(addendum)s,\n            and %(removal)s format specifiers will be replaced by the\n            values of the respective arguments passed to this function.\n        name : str, optional\n            The name of the deprecated object.\n        alternative : str, optional\n            An alternative API that the user may use in place of the\n            deprecated API. The deprecation warning will tell the user\n            about this alternative if provided.\n        pending : bool, optional\n            If True, uses a PendingDeprecationWarning instead of a\n            DeprecationWarning. Cannot be used together with removal.\n        obj_type : str, optional\n            The object type being deprecated.\n        addendum : str, optional\n            Additional text appended directly to the final message.\n        removal : str, optional\n            The expected removal version. With the default (an empty\n            string), a removal version is automatically computed from\n            since. Set to other Falsy values to not schedule a removal\n            date. Cannot be used together with pending.\n\n    Examples:\n\n        .. code-block:: python\n\n            @deprecated('1.4.0')\n            def the_function_to_deprecate():\n                pass\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.tracers.context.register_configure_hook", "project": "langchain_core", "func": "register_configure_hook", "origin_file": "langchain_core/tracers/context.py", "test_list": ["tests/unit_tests/test_globals.py"], "prob_info": {"func_start_lineno": 184, "func_end_lineno": 217, "key_block_start_lineno": 203, "key_block_end_lineno": 217, "new_func_code": "def register_configure_hook(\n    context_var: ContextVar[Optional[Any]],\n    inheritable: bool,\n    handle_class: Optional[type[BaseCallbackHandler]] = None,\n    env_var: Optional[str] = None,\n) -> None:\n    \"\"\"Register a configure hook.\n\n    Args:\n        context_var (ContextVar[Optional[Any]]): The context variable.\n        inheritable (bool): Whether the context variable is inheritable.\n        handle_class (Optional[Type[BaseCallbackHandler]], optional):\n          The callback handler class. Defaults to None.\n        env_var (Optional[str], optional): The environment variable. Defaults to None.\n\n    Raises:\n        ValueError: If env_var is set, handle_class must also be set\n          to a non-None value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.callbacks.manager.shielded", "project": "langchain_core", "func": "shielded", "origin_file": "langchain_core/callbacks/manager.py", "test_list": ["tests/unit_tests/test_globals.py"], "prob_info": {"func_start_lineno": 219, "func_end_lineno": 233, "key_block_start_lineno": 228, "key_block_end_lineno": 233, "new_func_code": "def shielded(func: Func) -> Func:\n    \"\"\"Makes so an awaitable method is always shielded from cancellation.\n\n    Args:\n        func (Callable): The function to shield.\n\n    Returns:\n        Callable: The shielded function\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.globals.get_debug", "project": "langchain_core", "func": "get_debug", "origin_file": "langchain_core/globals.py", "test_list": ["tests/unit_tests/test_globals.py"], "prob_info": {"func_start_lineno": 119, "func_end_lineno": 151, "key_block_start_lineno": 125, "key_block_end_lineno": 151, "new_func_code": "def get_debug() -> bool:\n    \"\"\"Get the value of the `debug` global setting.\n\n    Returns:\n        The value of the `debug` global setting.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.globals.set_debug", "project": "langchain_core", "func": "set_debug", "origin_file": "langchain_core/globals.py", "test_list": ["tests/unit_tests/test_globals.py"], "prob_info": {"func_start_lineno": 89, "func_end_lineno": 116, "key_block_start_lineno": 95, "key_block_end_lineno": 116, "new_func_code": "def set_debug(value: bool) -> None:\n    \"\"\"Set a new value for the `debug` global setting.\n\n    Args:\n        value: The new value for the `debug` global setting.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.ai.AIMessageChunk::init_tool_calls", "project": "langchain_core", "func": "AIMessageChunk::init_tool_calls", "origin_file": "langchain_core/messages/ai.py", "test_list": ["tests/unit_tests/test_prompt_values.py"], "prob_info": {"func_start_lineno": 328, "func_end_lineno": 394, "key_block_start_lineno": 340, "key_block_end_lineno": 394, "new_func_code": "def init_tool_calls(self) -> Self:\n        \"\"\"Initialize tool calls from tool call chunks.\n\n        Args:\n            values: The values to validate.\n\n        Returns:\n            The values with tool calls initialized.\n\n        Raises:\n            ValueError: If the tool call chunks are malformed.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.sys_info.print_sys_info", "project": "langchain_core", "func": "print_sys_info", "origin_file": "langchain_core/sys_info.py", "test_list": ["tests/unit_tests/test_sys_info.py"], "prob_info": {"func_start_lineno": 36, "func_end_lineno": 137, "key_block_start_lineno": 42, "key_block_end_lineno": 137, "new_func_code": "def print_sys_info(*, additional_pkgs: Sequence[str] = ()) -> None:\n    \"\"\"Print information about the environment for debugging purposes.\n\n    Args:\n        additional_pkgs: Additional packages to include in the output.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core._api.deprecation.warn_deprecated", "project": "langchain_core", "func": "warn_deprecated", "origin_file": "langchain_core/_api/deprecation.py", "test_list": ["tests/unit_tests/_api/test_deprecation.py"], "prob_info": {"func_start_lineno": 396, "func_end_lineno": 492, "key_block_start_lineno": 438, "key_block_end_lineno": 492, "new_func_code": "def warn_deprecated(\n    since: str,\n    *,\n    message: str = \"\",\n    name: str = \"\",\n    alternative: str = \"\",\n    alternative_import: str = \"\",\n    pending: bool = False,\n    obj_type: str = \"\",\n    addendum: str = \"\",\n    removal: str = \"\",\n    package: str = \"\",\n) -> None:\n    \"\"\"Display a standardized deprecation.\n\n    Arguments:\n        since : str\n            The release at which this API became deprecated.\n        message : str, optional\n            Override the default deprecation message. The %(since)s,\n            %(name)s, %(alternative)s, %(obj_type)s, %(addendum)s,\n            and %(removal)s format specifiers will be replaced by the\n            values of the respective arguments passed to this function.\n        name : str, optional\n            The name of the deprecated object.\n        alternative : str, optional\n            An alternative API that the user may use in place of the\n            deprecated API. The deprecation warning will tell the user\n            about this alternative if provided.\n        pending : bool, optional\n            If True, uses a PendingDeprecationWarning instead of a\n            DeprecationWarning. Cannot be used together with removal.\n        obj_type : str, optional\n            The object type being deprecated.\n        addendum : str, optional\n            Additional text appended directly to the final message.\n        removal : str, optional\n            The expected removal version. With the default (an empty\n            string), a removal version is automatically computed from\n            since. Set to other Falsy values to not schedule a removal\n            date. Cannot be used together with pending.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.indexing.base.InMemoryRecordManager::list_keys", "project": "langchain_core", "func": "InMemoryRecordManager::list_keys", "origin_file": "langchain_core/indexing/base.py", "test_list": ["tests/unit_tests/indexing/test_in_memory_record_manager.py"], "prob_info": {"func_start_lineno": 352, "func_end_lineno": 386, "key_block_start_lineno": 375, "key_block_end_lineno": 386, "new_func_code": "def list_keys(\n        self,\n        *,\n        before: Optional[float] = None,\n        after: Optional[float] = None,\n        group_ids: Optional[Sequence[str]] = None,\n        limit: Optional[int] = None,\n    ) -> list[str]:\n        \"\"\"List records in the database based on the provided filters.\n\n        Args:\n            before: Filter to list records updated before this time.\n                Defaults to None.\n            after: Filter to list records updated after this time.\n                Defaults to None.\n            group_ids: Filter to list records with specific group IDs.\n                Defaults to None.\n            limit: optional limit on the number of records to return.\n                Defaults to None.\n\n        Returns:\n            A list of keys for the matching records.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.indexing.base.InMemoryRecordManager::update", "project": "langchain_core", "func": "InMemoryRecordManager::update", "origin_file": "langchain_core/indexing/base.py", "test_list": ["tests/unit_tests/indexing/test_in_memory_record_manager.py"], "prob_info": {"func_start_lineno": 264, "func_end_lineno": 299, "key_block_start_lineno": 291, "key_block_end_lineno": 299, "new_func_code": "def update(\n        self,\n        keys: Sequence[str],\n        *,\n        group_ids: Optional[Sequence[Optional[str]]] = None,\n        time_at_least: Optional[float] = None,\n    ) -> None:\n        \"\"\"Upsert records into the database.\n\n        Args:\n            keys: A list of record keys to upsert.\n            group_ids: A list of group IDs corresponding to the keys.\n                Defaults to None.\n            time_at_least: Optional timestamp. Implementation can use this\n                to optionally verify that the timestamp IS at least this time\n                in the system that stores. Defaults to None.\n                E.g., use to validate that the time in the postgres database\n                is equal to or larger than the given timestamp, if not\n                raise an error.\n                This is meant to help prevent time-drift issues since\n                time may not be monotonically increasing!\n\n        Raises:\n            ValueError: If the length of keys doesn't match the length of group\n                ids.\n            ValueError: If time_at_least is in the future.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.globals.get_verbose", "project": "langchain_core", "func": "get_verbose", "origin_file": "langchain_core/globals.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 52, "func_end_lineno": 86, "key_block_start_lineno": 58, "key_block_end_lineno": 86, "new_func_code": "def get_verbose() -> bool:\n    \"\"\"Get the value of the `verbose` global setting.\n\n    Returns:\n        The value of the `verbose` global setting.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.tracers.context.collect_runs", "project": "langchain_core", "func": "collect_runs", "origin_file": "langchain_core/tracers/context.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 99, "func_end_lineno": 113, "key_block_start_lineno": 110, "key_block_end_lineno": 113, "new_func_code": "def collect_runs() -> Generator[RunCollectorCallbackHandler, None, None]:\n    \"\"\"Collect all run traces in context.\n\n    Yields:\n        run_collector.RunCollectorCallbackHandler: The run collector callback handler.\n\n    Example:\n        >>> with collect_runs() as runs_cb:\n                chain.invoke(\"foo\")\n                run_id = runs_cb.traced_runs[0].id\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.config.ensure_config", "project": "langchain_core", "func": "ensure_config", "origin_file": "langchain_core/runnables/config.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 149, "func_end_lineno": 199, "key_block_start_lineno": 159, "key_block_end_lineno": 199, "new_func_code": "def ensure_config(config: Optional[RunnableConfig] = None) -> RunnableConfig:\n    \"\"\"Ensure that a config is a dict with all keys present.\n\n    Args:\n        config (Optional[RunnableConfig], optional): The config to ensure.\n          Defaults to None.\n\n    Returns:\n        RunnableConfig: The ensured config.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.utils.convert_to_messages", "project": "langchain_core", "func": "convert_to_messages", "origin_file": "langchain_core/messages/utils.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 348, "func_end_lineno": 364, "key_block_start_lineno": 359, "key_block_end_lineno": 364, "new_func_code": "def convert_to_messages(\n    messages: Union[Iterable[MessageLikeRepresentation], PromptValue],\n) -> list[BaseMessage]:\n    \"\"\"Convert a sequence of messages to a list of messages.\n\n    Args:\n        messages: Sequence of messages to convert.\n\n    Returns:\n        list of messages (BaseMessages).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.utils._convert_to_message", "project": "langchain_core", "func": "_convert_to_message", "origin_file": "langchain_core/messages/utils.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 293, "func_end_lineno": 345, "key_block_start_lineno": 314, "key_block_end_lineno": 345, "new_func_code": "def _convert_to_message(message: MessageLikeRepresentation) -> BaseMessage:\n    \"\"\"Instantiate a message from a variety of message formats.\n\n    The message format can be one of the following:\n\n    - BaseMessagePromptTemplate\n    - BaseMessage\n    - 2-tuple of (role string, template); e.g., (\"human\", \"{user_input}\")\n    - dict: a message dict with role and content keys\n    - string: shorthand for (\"human\", template); e.g., \"{user_input}\"\n\n    Args:\n        message: a representation of a message in one of the supported formats.\n\n    Returns:\n        an instance of a message or a message template.\n\n    Raises:\n        NotImplementedError: if the message type is not supported.\n        ValueError: if the message dict does not contain the required keys.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.env.env_var_is_set", "project": "langchain_core", "func": "env_var_is_set", "origin_file": "langchain_core/utils/env.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 21, "key_block_start_lineno": 16, "key_block_end_lineno": 21, "new_func_code": "def env_var_is_set(env_var: str) -> bool:\n    \"\"\"Check if an environment variable is set.\n\n    Args:\n        env_var (str): The name of the environment variable.\n\n    Returns:\n        bool: True if the environment variable is set, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.load.dump.dumpd", "project": "langchain_core", "func": "dumpd", "origin_file": "langchain_core/load/dump.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 56, "func_end_lineno": 70, "key_block_start_lineno": 70, "key_block_end_lineno": 70, "new_func_code": "def dumpd(obj: Any) -> Any:\n    \"\"\"Return a dict representation of an object.\n\n    Note:\n        Unfortunately this function is not as efficient as it could be\n        because it first dumps the object to a json string and then loads it\n        back into a dictionary.\n\n    Args:\n        obj: The object to dump.\n\n    Returns:\n        dictionary that can be serialized to json using json.dumps\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.load.dump.dumps", "project": "langchain_core", "func": "dumps", "origin_file": "langchain_core/load/dump.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 23, "func_end_lineno": 53, "key_block_start_lineno": 39, "key_block_end_lineno": 53, "new_func_code": "def dumps(obj: Any, *, pretty: bool = False, **kwargs: Any) -> str:\n    \"\"\"Return a json string representation of an object.\n\n    Args:\n        obj: The object to dump.\n        pretty: Whether to pretty print the json. If true, the json will be\n            indented with 2 spaces (if no indent is provided as part of kwargs).\n            Default is False.\n        kwargs: Additional arguments to pass to json.dumps\n\n    Returns:\n        A json string representation of the object.\n\n    Raises:\n        ValueError: If `default` is passed as a kwarg.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.load.dump.default", "project": "langchain_core", "func": "default", "origin_file": "langchain_core/load/dump.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 7, "func_end_lineno": 20, "key_block_start_lineno": 17, "key_block_end_lineno": 20, "new_func_code": "def default(obj: Any) -> Any:\n    \"\"\"Return a default value for a Serializable object or\n    a SerializedNotImplemented object.\n\n    Args:\n        obj: The object to serialize to json if it is a Serializable object.\n\n    Returns:\n        A json serializable object or a SerializedNotImplemented object.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.config.get_config_list", "project": "langchain_core", "func": "get_config_list", "origin_file": "langchain_core/runnables/config.py", "test_list": ["tests/unit_tests/language_models/llms/test_base.py"], "prob_info": {"func_start_lineno": 202, "func_end_lineno": 246, "key_block_start_lineno": 221, "key_block_end_lineno": 246, "new_func_code": "def get_config_list(\n    config: Optional[Union[RunnableConfig, Sequence[RunnableConfig]]], length: int\n) -> list[RunnableConfig]:\n    \"\"\"Get a list of configs from a single config or a list of configs.\n\n     It is useful for subclasses overriding batch() or abatch().\n\n    Args:\n        config (Optional[Union[RunnableConfig, List[RunnableConfig]]]):\n          The config or list of configs.\n        length (int): The length of the list.\n\n    Returns:\n        List[RunnableConfig]: The list of configs.\n\n    Raises:\n        ValueError: If the length of the list is not equal to the length of the inputs.\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.language_models.llms.get_prompts", "project": "langchain_core", "func": "get_prompts", "origin_file": "langchain_core/language_models/llms.py", "test_list": ["tests/unit_tests/language_models/llms/test_base.py"], "prob_info": {"func_start_lineno": 151, "func_end_lineno": 184, "key_block_start_lineno": 170, "key_block_end_lineno": 184, "new_func_code": "def get_prompts(\n    params: dict[str, Any],\n    prompts: list[str],\n    cache: Optional[Union[BaseCache, bool, None]] = None,\n) -> tuple[dict[int, list], str, list[int], list[str]]:\n    \"\"\"Get prompts that are already cached.\n\n    Args:\n        params: Dictionary of parameters.\n        prompts: List of prompts.\n        cache: Cache object. Default is None.\n\n    Returns:\n        A tuple of existing prompts, llm_string, missing prompt indexes,\n            and missing prompts.\n\n    Raises:\n        ValueError: If the cache is not set and cache is True.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.globals.get_llm_cache", "project": "langchain_core", "func": "get_llm_cache", "origin_file": "langchain_core/globals.py", "test_list": ["tests/unit_tests/language_models/llms/test_base.py"], "prob_info": {"func_start_lineno": 186, "func_end_lineno": 222, "key_block_start_lineno": 192, "key_block_end_lineno": 222, "new_func_code": "def get_llm_cache() -> \"BaseCache\":\n    \"\"\"Get the value of the `llm_cache` global setting.\n\n    Returns:\n        The value of the `llm_cache` global setting.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.base.merge_content", "project": "langchain_core", "func": "merge_content", "origin_file": "langchain_core/messages/base.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 122, "func_end_lineno": 160, "key_block_start_lineno": 135, "key_block_end_lineno": 160, "new_func_code": "def merge_content(\n    first_content: Union[str, list[Union[str, dict]]],\n    *contents: Union[str, list[Union[str, dict]]],\n) -> Union[str, list[Union[str, dict]]]:\n    \"\"\"Merge two message contents.\n\n    Args:\n        first_content: The first content. Can be a string or a list.\n        second_content: The second content. Can be a string or a list.\n\n    Returns:\n        The merged content.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils._merge.merge_dicts", "project": "langchain_core", "func": "merge_dicts", "origin_file": "langchain_core/utils/_merge.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 6, "func_end_lineno": 69, "key_block_start_lineno": 29, "key_block_end_lineno": 69, "new_func_code": "def merge_dicts(left: dict[str, Any], *others: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Merge many dicts, handling specific scenarios where a key exists in both\n    dictionaries but has a value of None in 'left'. In such cases, the method uses the\n    value from 'right' for that key in the merged dictionary.\n\n    Args:\n        left: The first dictionary to merge.\n        others: The other dictionaries to merge.\n\n    Returns:\n        The merged dictionary.\n\n    Raises:\n        TypeError: If the key exists in both dictionaries but has a different type.\n        TypeError: If the value has an unsupported type.\n\n    Example:\n        If left = {\"function_call\": {\"arguments\": None}} and\n        right = {\"function_call\": {\"arguments\": \"{\\n\"}}\n        then, after merging, for the key \"function_call\",\n        the value from 'right' is used,\n        resulting in merged = {\"function_call\": {\"arguments\": \"{\\n\"}}.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.json.parse_partial_json", "project": "langchain_core", "func": "parse_partial_json", "origin_file": "langchain_core/utils/json.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 43, "func_end_lineno": 119, "key_block_start_lineno": 53, "key_block_end_lineno": 119, "new_func_code": "def parse_partial_json(s: str, *, strict: bool = False) -> Any:\n    \"\"\"Parse a JSON string that may be missing closing braces.\n\n    Args:\n        s: The JSON string to parse.\n        strict: Whether to use strict parsing. Defaults to False.\n\n    Returns:\n        The parsed JSON object as a Python dictionary.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils._merge.merge_lists", "project": "langchain_core", "func": "merge_lists", "origin_file": "langchain_core/utils/_merge.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 72, "func_end_lineno": 106, "key_block_start_lineno": 82, "key_block_end_lineno": 106, "new_func_code": "def merge_lists(left: Optional[list], *others: Optional[list]) -> Optional[list]:\n    \"\"\"Add many lists, handling None.\n\n    Args:\n        left: The first list to merge.\n        others: The other lists to merge.\n\n    Returns:\n        The merged list.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.is_async_generator", "project": "langchain_core", "func": "is_async_generator", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 723, "func_end_lineno": 739, "key_block_start_lineno": 735, "key_block_end_lineno": 739, "new_func_code": "def is_async_generator(\n    func: Any,\n) -> TypeGuard[Callable[..., AsyncIterator]]:\n    \"\"\"Check if a function is an async generator.\n\n    Args:\n        func: The function to check.\n\n    Returns:\n        TypeGuard[Callable[..., AsyncIterator]: True if the function is\n            an async generator, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.RunnableLambda::invoke", "project": "langchain_core", "func": "RunnableLambda::invoke", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 4701, "func_end_lineno": 4732, "key_block_start_lineno": 4720, "key_block_end_lineno": 4732, "new_func_code": "def invoke(\n        self,\n        input: Input,\n        config: Optional[RunnableConfig] = None,\n        **kwargs: Optional[Any],\n    ) -> Output:\n        \"\"\"Invoke this Runnable synchronously.\n\n        Args:\n            input: The input to this Runnable.\n            config: The config to use. Defaults to None.\n            kwargs: Additional keyword arguments.\n\n        Returns:\n            The output of this Runnable.\n\n        Raises:\n            TypeError: If the Runnable is a coroutine function.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.json.parse_json_markdown", "project": "langchain_core", "func": "parse_json_markdown", "origin_file": "langchain_core/utils/json.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 125, "func_end_lineno": 145, "key_block_start_lineno": 136, "key_block_end_lineno": 145, "new_func_code": "def parse_json_markdown(\n    json_string: str, *, parser: Callable[[str], Any] = parse_partial_json\n) -> dict:\n    \"\"\"Parse a JSON string from a Markdown string.\n\n    Args:\n        json_string: The Markdown string.\n\n    Returns:\n        The parsed JSON object as a Python dictionary.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.coerce_to_runnable", "project": "langchain_core", "func": "coerce_to_runnable", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 5823, "func_end_lineno": 5848, "key_block_start_lineno": 5835, "key_block_end_lineno": 5848, "new_func_code": "def coerce_to_runnable(thing: RunnableLike) -> Runnable[Input, Output]:\n    \"\"\"Coerce a Runnable-like object into a Runnable.\n\n    Args:\n        thing: A Runnable-like object.\n\n    Returns:\n        A Runnable.\n\n    Raises:\n        TypeError: If the object is not Runnable-like.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.config.patch_config", "project": "langchain_core", "func": "patch_config", "origin_file": "langchain_core/runnables/config.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 249, "func_end_lineno": 292, "key_block_start_lineno": 275, "key_block_end_lineno": 292, "new_func_code": "def patch_config(\n    config: Optional[RunnableConfig],\n    *,\n    callbacks: Optional[BaseCallbackManager] = None,\n    recursion_limit: Optional[int] = None,\n    max_concurrency: Optional[int] = None,\n    run_name: Optional[str] = None,\n    configurable: Optional[dict[str, Any]] = None,\n) -> RunnableConfig:\n    \"\"\"Patch a config with new values.\n\n    Args:\n        config (Optional[RunnableConfig]): The config to patch.\n        callbacks (Optional[BaseCallbackManager], optional): The callbacks to set.\n          Defaults to None.\n        recursion_limit (Optional[int], optional): The recursion limit to set.\n          Defaults to None.\n        max_concurrency (Optional[int], optional): The max concurrency to set.\n          Defaults to None.\n        run_name (Optional[str], optional): The run name to set. Defaults to None.\n        configurable (Optional[Dict[str, Any]], optional): The configurable to set.\n          Defaults to None.\n\n    Returns:\n        RunnableConfig: The patched config.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.output_parsers.json.JsonOutputParser::parse_result", "project": "langchain_core", "func": "JsonOutputParser::parse_result", "origin_file": "langchain_core/output_parsers/json.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 57, "func_end_lineno": 86, "key_block_start_lineno": 74, "key_block_end_lineno": 86, "new_func_code": "def parse_result(self, result: list[Generation], *, partial: bool = False) -> Any:\n        \"\"\"Parse the result of an LLM call to a JSON object.\n\n        Args:\n            result: The result of the LLM call.\n            partial: Whether to parse partial JSON objects.\n                If True, the output will be a JSON object containing\n                all the keys that have been returned so far.\n                If False, the output will be the full JSON object.\n                Default is False.\n\n        Returns:\n            The parsed JSON object.\n\n        Raises:\n            OutputParserException: If the output is not valid JSON.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.config.get_callback_manager_for_config", "project": "langchain_core", "func": "get_callback_manager_for_config", "origin_file": "langchain_core/runnables/config.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 440, "func_end_lineno": 455, "key_block_start_lineno": 449, "key_block_end_lineno": 455, "new_func_code": "def get_callback_manager_for_config(config: RunnableConfig) -> CallbackManager:\n    \"\"\"Get a callback manager for a config.\n\n    Args:\n        config (RunnableConfig): The config.\n\n    Returns:\n        CallbackManager: The callback manager.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.callbacks.manager.CallbackManager::on_chain_start", "project": "langchain_core", "func": "CallbackManager::on_chain_start", "origin_file": "langchain_core/callbacks/manager.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 1347, "func_end_lineno": 1389, "key_block_start_lineno": 1365, "key_block_end_lineno": 1389, "new_func_code": "def on_chain_start(\n        self,\n        serialized: Optional[dict[str, Any]],\n        inputs: Union[dict[str, Any], Any],\n        run_id: Optional[UUID] = None,\n        **kwargs: Any,\n    ) -> CallbackManagerForChainRun:\n        \"\"\"Run when chain starts running.\n\n        Args:\n            serialized (Optional[Dict[str, Any]]): The serialized chain.\n            inputs (Union[Dict[str, Any], Any]): The inputs to the chain.\n            run_id (UUID, optional): The ID of the run. Defaults to None.\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            CallbackManagerForChainRun: The callback manager for the chain run.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.callbacks.manager.handle_event", "project": "langchain_core", "func": "handle_event", "origin_file": "langchain_core/callbacks/manager.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 236, "func_end_lineno": 312, "key_block_start_lineno": 255, "key_block_end_lineno": 312, "new_func_code": "def handle_event(\n    handlers: list[BaseCallbackHandler],\n    event_name: str,\n    ignore_condition_name: Optional[str],\n    *args: Any,\n    **kwargs: Any,\n) -> None:\n    \"\"\"Generic event handler for CallbackManager.\n\n    Note: This function is used by LangServe to handle events.\n\n    Args:\n        handlers: The list of handlers that will handle the event.\n        event_name: The name of the event (e.g., \"on_llm_start\").\n        ignore_condition_name: Name of the attribute defined on handler\n            that if True will cause the handler to be skipped for the given event.\n        *args: The arguments to pass to the event handler.\n        **kwargs: The keyword arguments to pass to the event handler\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.accepts_config", "project": "langchain_core", "func": "accepts_config", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 90, "func_end_lineno": 102, "key_block_start_lineno": 99, "key_block_end_lineno": 102, "new_func_code": "def accepts_config(callable: Callable[..., Any]) -> bool:\n    \"\"\"Check if a callable accepts a config argument.\n\n    Args:\n        callable: The callable to check.\n\n    Returns:\n        bool: True if the callable accepts a config argument, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.accepts_run_manager", "project": "langchain_core", "func": "accepts_run_manager", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 75, "func_end_lineno": 87, "key_block_start_lineno": 84, "key_block_end_lineno": 87, "new_func_code": "def accepts_run_manager(callable: Callable[..., Any]) -> bool:\n    \"\"\"Check if a callable accepts a run_manager argument.\n\n    Args:\n        callable: The callable to check.\n\n    Returns:\n        bool: True if the callable accepts a run_manager argument, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.config._set_config_context", "project": "langchain_core", "func": "_set_config_context", "origin_file": "langchain_core/runnables/config.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 118, "func_end_lineno": 146, "key_block_start_lineno": 124, "key_block_end_lineno": 146, "new_func_code": "def _set_config_context(config: RunnableConfig) -> None:\n    \"\"\"Set the child Runnable config + tracing context.\n\n    Args:\n        config (RunnableConfig): The config to set.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.beta.runnables.context.config_with_context", "project": "langchain_core", "func": "config_with_context", "origin_file": "langchain_core/beta/runnables/context.py", "test_list": ["tests/unit_tests/output_parsers/test_json.py"], "prob_info": {"func_start_lineno": 140, "func_end_lineno": 153, "key_block_start_lineno": 153, "key_block_end_lineno": 153, "new_func_code": "def config_with_context(\n    config: RunnableConfig,\n    steps: list[Runnable],\n) -> RunnableConfig:\n    \"\"\"Patch a runnable config with context getters and setters.\n\n    Args:\n        config: The runnable config.\n        steps: The runnable steps.\n\n    Returns:\n        The patched runnable config.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.outputs.chat_generation.ChatGeneration::set_text", "project": "langchain_core", "func": "ChatGeneration::set_text", "origin_file": "langchain_core/outputs/chat_generation.py", "test_list": ["tests/unit_tests/output_parsers/test_openai_functions.py"], "prob_info": {"func_start_lineno": 36, "func_end_lineno": 70, "key_block_start_lineno": 48, "key_block_end_lineno": 70, "new_func_code": "def set_text(self) -> Self:\n        \"\"\"Set the text attribute to be the contents of the message.\n\n        Args:\n            values: The values of the object.\n\n        Returns:\n            The values of the object with the text attribute set.\n\n        Raises:\n            ValueError: If the message is not a string or a list.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.output_parsers.openai_functions.JsonOutputFunctionsParser::parse_result", "project": "langchain_core", "func": "JsonOutputFunctionsParser::parse_result", "origin_file": "langchain_core/output_parsers/openai_functions.py", "test_list": ["tests/unit_tests/output_parsers/test_openai_functions.py"], "prob_info": {"func_start_lineno": 74, "func_end_lineno": 140, "key_block_start_lineno": 87, "key_block_end_lineno": 140, "new_func_code": "def parse_result(self, result: list[Generation], *, partial: bool = False) -> Any:\n        \"\"\"Parse the result of an LLM call to a JSON object.\n\n        Args:\n            result: The result of the LLM call.\n            partial: Whether to parse partial JSON objects. Default is False.\n\n        Returns:\n            The parsed JSON object.\n\n        Raises:\n            OutputParserException: If the output is not valid JSON.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.output_parsers.openai_functions.PydanticOutputFunctionsParser::parse_result", "project": "langchain_core", "func": "PydanticOutputFunctionsParser::parse_result", "origin_file": "langchain_core/output_parsers/openai_functions.py", "test_list": ["tests/unit_tests/output_parsers/test_openai_functions.py"], "prob_info": {"func_start_lineno": 254, "func_end_lineno": 281, "key_block_start_lineno": 264, "key_block_end_lineno": 281, "new_func_code": "def parse_result(self, result: list[Generation], *, partial: bool = False) -> Any:\n        \"\"\"Parse the result of an LLM call to a JSON object.\n\n        Args:\n            result: The result of the LLM call.\n            partial: Whether to parse partial JSON objects. Default is False.\n\n        Returns:\n            The parsed JSON object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.formatting.StrictFormatter::vformat", "project": "langchain_core", "func": "StrictFormatter::vformat", "origin_file": "langchain_core/utils/formatting.py", "test_list": ["tests/unit_tests/prompts/test_chat.py"], "prob_info": {"func_start_lineno": 11, "func_end_lineno": 33, "key_block_start_lineno": 27, "key_block_end_lineno": 33, "new_func_code": "def vformat(\n        self, format_string: str, args: Sequence, kwargs: Mapping[str, Any]\n    ) -> str:\n        \"\"\"Check that no arguments are provided.\n\n        Args:\n            format_string: The format string.\n            args: The arguments.\n            kwargs: The keyword arguments.\n\n        Returns:\n            The formatted string.\n\n        Raises:\n            ValueError: If any arguments are provided.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.chat._convert_to_message", "project": "langchain_core", "func": "_convert_to_message", "origin_file": "langchain_core/prompts/chat.py", "test_list": ["tests/unit_tests/prompts/test_chat.py"], "prob_info": {"func_start_lineno": 1430, "func_end_lineno": 1492, "key_block_start_lineno": 1455, "key_block_end_lineno": 1492, "new_func_code": "def _convert_to_message(\n    message: MessageLikeRepresentation,\n    template_format: PromptTemplateFormat = \"f-string\",\n) -> Union[BaseMessage, BaseMessagePromptTemplate, BaseChatPromptTemplate]:\n    \"\"\"Instantiate a message from a variety of message formats.\n\n    The message format can be one of the following:\n\n    - BaseMessagePromptTemplate\n    - BaseMessage\n    - 2-tuple of (role string, template); e.g., (\"human\", \"{user_input}\")\n    - 2-tuple of (message class, template)\n    - string: shorthand for (\"human\", template); e.g., \"{user_input}\"\n\n    Args:\n        message: a representation of a message in one of the supported formats.\n        template_format: format of the template. Defaults to \"f-string\".\n\n    Returns:\n        an instance of a message or a message template.\n\n    Raises:\n        ValueError: If unexpected message type.\n        ValueError: If 2-tuple does not have 2 elements.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.string.get_template_variables", "project": "langchain_core", "func": "get_template_variables", "origin_file": "langchain_core/prompts/string.py", "test_list": ["tests/unit_tests/prompts/test_few_shot.py"], "prob_info": {"func_start_lineno": 239, "func_end_lineno": 265, "key_block_start_lineno": 252, "key_block_end_lineno": 265, "new_func_code": "def get_template_variables(template: str, template_format: str) -> list[str]:\n    \"\"\"Get the variables from the template.\n\n    Args:\n        template: The template string.\n        template_format: The template format. Should be one of \"f-string\" or \"jinja2\".\n\n    Returns:\n        The variables from the template.\n\n    Raises:\n        ValueError: If the template format is not supported.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.string.check_valid_template", "project": "langchain_core", "func": "check_valid_template", "origin_file": "langchain_core/prompts/string.py", "test_list": ["tests/unit_tests/prompts/test_few_shot.py"], "prob_info": {"func_start_lineno": 207, "func_end_lineno": 236, "key_block_start_lineno": 221, "key_block_end_lineno": 236, "new_func_code": "def check_valid_template(\n    template: str, template_format: str, input_variables: list[str]\n) -> None:\n    \"\"\"Check that template string is valid.\n\n    Args:\n        template: The template string.\n        template_format: The template format. Should be one of \"f-string\" or \"jinja2\".\n        input_variables: The input variables.\n\n    Raises:\n        ValueError: If the template format is not supported.\n        ValueError: If the prompt schema is invalid.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.formatting.StrictFormatter::validate_input_variables", "project": "langchain_core", "func": "StrictFormatter::validate_input_variables", "origin_file": "langchain_core/utils/formatting.py", "test_list": ["tests/unit_tests/prompts/test_few_shot.py"], "prob_info": {"func_start_lineno": 35, "func_end_lineno": 48, "key_block_start_lineno": 47, "key_block_end_lineno": 48, "new_func_code": "def validate_input_variables(\n        self, format_string: str, input_variables: list[str]\n    ) -> None:\n        \"\"\"Check that all input variables are used in the format string.\n\n        Args:\n            format_string: The format string.\n            input_variables: The input variables.\n\n        Raises:\n            ValueError: If any input variables are not used in the format string.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.few_shot.FewShotPromptTemplate::format", "project": "langchain_core", "func": "FewShotPromptTemplate::format", "origin_file": "langchain_core/prompts/few_shot.py", "test_list": ["tests/unit_tests/prompts/test_few_shot.py"], "prob_info": {"func_start_lineno": 171, "func_end_lineno": 197, "key_block_start_lineno": 182, "key_block_end_lineno": 197, "new_func_code": "def format(self, **kwargs: Any) -> str:\n        \"\"\"Format the prompt with inputs generating a string.\n\n        Use this method to generate a string representation of a prompt.\n\n        Args:\n            **kwargs: keyword arguments to use for formatting.\n\n        Returns:\n            A string representation of the prompt.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.chat._create_template_from_message_type", "project": "langchain_core", "func": "_create_template_from_message_type", "origin_file": "langchain_core/prompts/chat.py", "test_list": ["tests/unit_tests/prompts/test_image.py"], "prob_info": {"func_start_lineno": 1359, "func_end_lineno": 1427, "key_block_start_lineno": 1377, "key_block_end_lineno": 1427, "new_func_code": "def _create_template_from_message_type(\n    message_type: str,\n    template: Union[str, list],\n    template_format: PromptTemplateFormat = \"f-string\",\n) -> BaseMessagePromptTemplate:\n    \"\"\"Create a message prompt template from a message type and template string.\n\n    Args:\n        message_type: str the type of the message template (e.g., \"human\", \"ai\", etc.)\n        template: str the template string.\n        template_format: format of the template. Defaults to \"f-string\".\n\n    Returns:\n        a message prompt template of the appropriate type.\n\n    Raises:\n        ValueError: If unexpected message type.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.load.serializable._is_field_useful", "project": "langchain_core", "func": "_is_field_useful", "origin_file": "langchain_core/load/serializable.py", "test_list": ["tests/unit_tests/prompts/test_image.py"], "prob_info": {"func_start_lineno": 275, "func_end_lineno": 317, "key_block_start_lineno": 289, "key_block_end_lineno": 317, "new_func_code": "def _is_field_useful(inst: Serializable, key: str, value: Any) -> bool:\n    \"\"\"Check if a field is useful as a constructor argument.\n\n    Args:\n        inst: The instance.\n        key: The key.\n        value: The value.\n\n    Returns:\n        Whether the field is useful. If the field is required, it is useful.\n        If the field is not required, it is useful if the value is not None.\n        If the field is not required and the value is None, it is useful if the\n        default value is different from the value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.load.load.loads", "project": "langchain_core", "func": "loads", "origin_file": "langchain_core/load/load.py", "test_list": ["tests/unit_tests/prompts/test_image.py"], "prob_info": {"func_start_lineno": 163, "func_end_lineno": 195, "key_block_start_lineno": 190, "key_block_end_lineno": 195, "new_func_code": "def loads(\n    text: str,\n    *,\n    secrets_map: Optional[dict[str, str]] = None,\n    valid_namespaces: Optional[list[str]] = None,\n    secrets_from_env: bool = True,\n    additional_import_mappings: Optional[dict[tuple[str, ...], tuple[str, ...]]] = None,\n) -> Any:\n    \"\"\"Revive a LangChain class from a JSON string.\n    Equivalent to `load(json.loads(text))`.\n\n    Args:\n        text: The string to load.\n        secrets_map: A map of secrets to load. If a secret is not found in\n            the map, it will be loaded from the environment if `secrets_from_env`\n            is True. Defaults to None.\n        valid_namespaces: A list of additional namespaces (modules)\n            to allow to be deserialized. Defaults to None.\n        secrets_from_env: Whether to load secrets from the environment.\n            Defaults to True.\n        additional_import_mappings: A dictionary of additional namespace mappings\n            You can use this to override default mappings or add new mappings.\n            Defaults to None.\n\n    Returns:\n        Revived LangChain objects.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.loading.load_prompt", "project": "langchain_core", "func": "load_prompt", "origin_file": "langchain_core/prompts/loading.py", "test_list": ["tests/unit_tests/prompts/test_loading.py"], "prob_info": {"func_start_lineno": 141, "func_end_lineno": 163, "key_block_start_lineno": 156, "key_block_end_lineno": 163, "new_func_code": "def load_prompt(\n    path: Union[str, Path], encoding: Optional[str] = None\n) -> BasePromptTemplate:\n    \"\"\"Unified method for loading a prompt from LangChainHub or local fs.\n\n    Args:\n        path: Path to the prompt file.\n        encoding: Encoding of the file. Defaults to None.\n\n    Returns:\n        A PromptTemplate object.\n\n    Raises:\n        RuntimeError: If the path is a Lang Chain Hub path.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.loading.load_prompt_from_config", "project": "langchain_core", "func": "load_prompt_from_config", "origin_file": "langchain_core/prompts/loading.py", "test_list": ["tests/unit_tests/prompts/test_loading.py"], "prob_info": {"func_start_lineno": 20, "func_end_lineno": 41, "key_block_start_lineno": 32, "key_block_end_lineno": 41, "new_func_code": "def load_prompt_from_config(config: dict) -> BasePromptTemplate:\n    \"\"\"Load prompt from Config Dict.\n\n    Args:\n        config: Dict containing the prompt configuration.\n\n    Returns:\n        A PromptTemplate object.\n\n    Raises:\n        ValueError: If the prompt type is not supported.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.few_shot.FewShotPromptTemplate::save", "project": "langchain_core", "func": "FewShotPromptTemplate::save", "origin_file": "langchain_core/prompts/few_shot.py", "test_list": ["tests/unit_tests/prompts/test_loading.py"], "prob_info": {"func_start_lineno": 232, "func_end_lineno": 244, "key_block_start_lineno": 241, "key_block_end_lineno": 244, "new_func_code": "def save(self, file_path: Union[Path, str]) -> None:\n        \"\"\"Save the prompt template to a file.\n\n        Args:\n            file_path: The path to save the prompt template to.\n\n        Raises:\n            ValueError: If example_selector is provided.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.pipeline.PipelinePromptTemplate::format_prompt", "project": "langchain_core", "func": "PipelinePromptTemplate::format_prompt", "origin_file": "langchain_core/prompts/pipeline.py", "test_list": ["tests/unit_tests/prompts/test_pipeline_prompt.py"], "prob_info": {"func_start_lineno": 71, "func_end_lineno": 87, "key_block_start_lineno": 80, "key_block_end_lineno": 87, "new_func_code": "def format_prompt(self, **kwargs: Any) -> PromptValue:\n        \"\"\"Format the prompt with the inputs.\n\n        Args:\n            kwargs: Any arguments to be passed to the prompt template.\n\n        Returns:\n            A formatted string.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.utils.get_pydantic_field_names", "project": "langchain_core", "func": "get_pydantic_field_names", "origin_file": "langchain_core/utils/utils.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 196, "func_end_lineno": 216, "key_block_start_lineno": 205, "key_block_end_lineno": 216, "new_func_code": "def get_pydantic_field_names(pydantic_cls: Any) -> set[str]:\n    \"\"\"Get field names, including aliases, for a pydantic class.\n\n    Args:\n        pydantic_cls: Pydantic class.\n\n    Returns:\n        Set[str]: Field names.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.structured.StructuredPrompt::pipe", "project": "langchain_core", "func": "StructuredPrompt::pipe", "origin_file": "langchain_core/prompts/structured.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 121, "func_end_lineno": 159, "key_block_start_lineno": 144, "key_block_end_lineno": 159, "new_func_code": "def pipe(\n        self,\n        *others: Union[\n            Runnable[Any, Other],\n            Callable[[Any], Other],\n            Callable[[Iterator[Any]], Iterator[Other]],\n            Mapping[str, Union[Runnable[Any, Other], Callable[[Any], Other], Any]],\n        ],\n        name: Optional[str] = None,\n    ) -> RunnableSerializable[dict, Other]:\n        \"\"\"Pipe the structured prompt to a language model.\n\n        Args:\n            others: The language model to pipe the structured prompt to.\n            name: The name of the pipeline. Defaults to None.\n\n        Returns:\n            A RunnableSequence object.\n\n        Raises:\n            NotImplementedError: If the first element of `others`\n            is not a language model.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.is_async_callable", "project": "langchain_core", "func": "is_async_callable", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 742, "func_end_lineno": 758, "key_block_start_lineno": 754, "key_block_end_lineno": 758, "new_func_code": "def is_async_callable(\n    func: Any,\n) -> TypeGuard[Callable[..., Awaitable]]:\n    \"\"\"Check if a function is async.\n\n    Args:\n        func: The function to check.\n\n    Returns:\n        TypeGuard[Callable[..., Awaitable]: True if the function is async,\n            False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.RunnableLambda::deps", "project": "langchain_core", "func": "RunnableLambda::deps", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 4471, "func_end_lineno": 4491, "key_block_start_lineno": 4478, "key_block_end_lineno": 4491, "new_func_code": "def deps(self) -> list[Runnable]:\n        \"\"\"The dependencies of this Runnable.\n\n        Returns:\n            The dependencies of this Runnable. If the function has nonlocal\n            variables that are Runnables, they are considered dependencies.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.get_unique_config_specs", "project": "langchain_core", "func": "get_unique_config_specs", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 636, "func_end_lineno": 665, "key_block_start_lineno": 650, "key_block_end_lineno": 665, "new_func_code": "def get_unique_config_specs(\n    specs: Iterable[ConfigurableFieldSpec],\n) -> list[ConfigurableFieldSpec]:\n    \"\"\"Get the unique config specs from a sequence of config specs.\n\n    Args:\n        specs: The config specs.\n\n    Returns:\n        List[ConfigurableFieldSpec]: The unique config specs.\n\n    Raises:\n        ValueError: If the runnable sequence contains conflicting config specs.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.config.merge_configs", "project": "langchain_core", "func": "merge_configs", "origin_file": "langchain_core/runnables/config.py", "test_list": ["tests/unit_tests/runnables/test_configurable.py"], "prob_info": {"func_start_lineno": 295, "func_end_lineno": 358, "key_block_start_lineno": 304, "key_block_end_lineno": 358, "new_func_code": "def merge_configs(*configs: Optional[RunnableConfig]) -> RunnableConfig:\n    \"\"\"Merge multiple configs into one.\n\n    Args:\n        *configs (Optional[RunnableConfig]): The configs to merge.\n\n    Returns:\n        RunnableConfig: The merged config.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.callbacks.manager.CallbackManagerForChainRun::on_chain_end", "project": "langchain_core", "func": "CallbackManagerForChainRun::on_chain_end", "origin_file": "langchain_core/callbacks/manager.py", "test_list": ["tests/unit_tests/runnables/test_context.py"], "prob_info": {"func_start_lineno": 820, "func_end_lineno": 836, "key_block_start_lineno": 827, "key_block_end_lineno": 836, "new_func_code": "def on_chain_end(self, outputs: Union[dict[str, Any], Any], **kwargs: Any) -> None:\n        \"\"\"Run when chain ends running.\n\n        Args:\n            outputs (Union[Dict[str, Any], Any]): The outputs of the chain.\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.pydantic.create_model_v2", "project": "langchain_core", "func": "create_model_v2", "origin_file": "langchain_core/utils/pydantic.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 575, "func_end_lineno": 647, "key_block_start_lineno": 598, "key_block_end_lineno": 647, "new_func_code": "def create_model_v2(\n    model_name: str,\n    *,\n    module_name: Optional[str] = None,\n    field_definitions: Optional[dict[str, Any]] = None,\n    root: Optional[Any] = None,\n) -> type[BaseModel]:\n    \"\"\"Create a pydantic model with the given field definitions.\n\n    Attention:\n        Please do not use outside of langchain packages. This API\n        is subject to change at any time.\n\n    Args:\n        model_name: The name of the model.\n        module_name: The name of the module where the model is defined.\n            This is used by Pydantic to resolve any forward references.\n        field_definitions: The field definitions for the model.\n        root: Type for a root model (RootModel)\n\n    Returns:\n        Type[BaseModel]: The created model.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph.node_data_str", "project": "langchain_core", "func": "node_data_str", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 178, "func_end_lineno": 196, "key_block_start_lineno": 188, "key_block_end_lineno": 196, "new_func_code": "def node_data_str(id: str, data: Union[type[BaseModel], RunnableType]) -> str:\n    \"\"\"Convert the data of a node to a string.\n\n    Args:\n        id: The node id.\n        data: The node data.\n\n    Returns:\n        A string representation of the data.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph.is_uuid", "project": "langchain_core", "func": "is_uuid", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 42, "func_end_lineno": 55, "key_block_start_lineno": 51, "key_block_end_lineno": 55, "new_func_code": "def is_uuid(value: str) -> bool:\n    \"\"\"Check if a string is a valid UUID.\n\n    Args:\n        value: The string to check.\n\n    Returns:\n        True if the string is a valid UUID, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph.Graph::add_edge", "project": "langchain_core", "func": "Graph::add_edge", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 354, "func_end_lineno": 385, "key_block_start_lineno": 375, "key_block_end_lineno": 385, "new_func_code": "def add_edge(\n        self,\n        source: Node,\n        target: Node,\n        data: Optional[Stringifiable] = None,\n        conditional: bool = False,\n    ) -> Edge:\n        \"\"\"Add an edge to the graph and return it.\n\n        Args:\n            source: The source node of the edge.\n            target: The target node of the edge.\n            data: Optional data associated with the edge. Defaults to None.\n            conditional: Whether the edge is conditional. Defaults to False.\n\n        Returns:\n            The edge that was added to the graph.\n\n        Raises:\n            ValueError: If the source or target node is not in the graph.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph_ascii.draw_ascii", "project": "langchain_core", "func": "draw_ascii", "origin_file": "langchain_core/runnables/graph_ascii.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 213, "func_end_lineno": 328, "key_block_start_lineno": 256, "key_block_end_lineno": 328, "new_func_code": "def draw_ascii(vertices: Mapping[str, str], edges: Sequence[LangEdge]) -> str:\n    \"\"\"Build a DAG and draw it in ASCII.\n\n    Args:\n        vertices (list): list of graph vertices.\n        edges (list): list of graph edges.\n\n    Returns:\n        str: ASCII representation\n\n    Example:\n\n        .. code-block:: python\n\n            from langchain_core.runnables.graph_ascii import draw_ascii\n\n            vertices = {1: \"1\", 2: \"2\", 3: \"3\", 4: \"4\"}\n            edges = [\n                (source, target, None, None)\n                for source, target in [(1, 2), (2, 3), (2, 4), (1, 4)]\n            ]\n\n\n            print(draw_ascii(vertices, edges))\n\n        .. code-block:: none\n\n                 +---+\n                 | 1 |\n                 +---+\n                 *    *\n                *     *\n               *       *\n            +---+       *\n            | 2 |       *\n            +---+**     *\n              *    **   *\n              *      ** *\n              *        **\n            +---+     +---+\n            | 3 |     | 4 |\n            +---+     +---+\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph_ascii.AsciiCanvas::line", "project": "langchain_core", "func": "AsciiCanvas::line", "origin_file": "langchain_core/runnables/graph_ascii.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 87, "func_end_lineno": 117, "key_block_start_lineno": 97, "key_block_end_lineno": 117, "new_func_code": "def line(self, x0: int, y0: int, x1: int, y1: int, char: str) -> None:\n        \"\"\"Create a line on ASCII canvas.\n\n        Args:\n            x0 (int): x coordinate where the line should start.\n            y0 (int): y coordinate where the line should start.\n            x1 (int): x coordinate where the line should end.\n            y1 (int): y coordinate where the line should end.\n            char (str): character to draw the line with.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph_ascii.AsciiCanvas::point", "project": "langchain_core", "func": "AsciiCanvas::point", "origin_file": "langchain_core/runnables/graph_ascii.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 64, "func_end_lineno": 85, "key_block_start_lineno": 75, "key_block_end_lineno": 85, "new_func_code": "def point(self, x: int, y: int, char: str) -> None:\n        \"\"\"Create a point on ASCII canvas.\n\n        Args:\n            x (int): x coordinate. Should be >= 0 and < number of columns in\n                the canvas.\n            y (int): y coordinate. Should be >= 0 an < number of lines in the\n                canvas.\n            char (str): character to place in the specified point on the\n                canvas.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.utils.get_buffer_string", "project": "langchain_core", "func": "get_buffer_string", "origin_file": "langchain_core/messages/utils.py", "test_list": ["tests/unit_tests/runnables/test_history.py"], "prob_info": {"func_start_lineno": 82, "func_end_lineno": 133, "key_block_start_lineno": 111, "key_block_end_lineno": 133, "new_func_code": "def get_buffer_string(\n    messages: Sequence[BaseMessage], human_prefix: str = \"Human\", ai_prefix: str = \"AI\"\n) -> str:\n    \"\"\"Convert a sequence of Messages to strings and concatenate them into one string.\n\n    Args:\n        messages: Messages to be converted to strings.\n        human_prefix: The prefix to prepend to contents of HumanMessages.\n            Default is \"Human\".\n        ai_prefix: THe prefix to prepend to contents of AIMessages. Default is \"AI\".\n\n    Returns:\n        A single string concatenation of all input messages.\n\n    Raises:\n        ValueError: If an unsupported message type is encountered.\n\n    Example:\n        .. code-block:: python\n\n            from langchain_core import AIMessage, HumanMessage\n\n            messages = [\n                HumanMessage(content=\"Hi, how are you?\"),\n                AIMessage(content=\"Good, how are you?\"),\n            ]\n            get_buffer_string(messages)\n            # -> \"Human: Hi, how are you?\\nAI: Good, how are you?\"\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.FunctionNonLocals::visit_FunctionDef", "project": "langchain_core", "func": "FunctionNonLocals::visit_FunctionDef", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/runnables/test_history.py"], "prob_info": {"func_start_lineno": 297, "func_end_lineno": 308, "key_block_start_lineno": 306, "key_block_end_lineno": 308, "new_func_code": "def visit_FunctionDef(self, node: ast.FunctionDef) -> Any:\n        \"\"\"Visit a function definition.\n\n        Args:\n            node: The node to visit.\n\n        Returns:\n            Any: The result of the visit.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.NonLocals::visit_Name", "project": "langchain_core", "func": "NonLocals::visit_Name", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/runnables/test_history.py"], "prob_info": {"func_start_lineno": 241, "func_end_lineno": 253, "key_block_start_lineno": 250, "key_block_end_lineno": 253, "new_func_code": "def visit_Name(self, node: ast.Name) -> Any:\n        \"\"\"Visit a name node.\n\n        Args:\n            node: The node to visit.\n\n        Returns:\n            Any: The result of the visit.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.NonLocals::visit_Attribute", "project": "langchain_core", "func": "NonLocals::visit_Attribute", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/runnables/test_history.py"], "prob_info": {"func_start_lineno": 256, "func_end_lineno": 287, "key_block_start_lineno": 265, "key_block_end_lineno": 287, "new_func_code": "def visit_Attribute(self, node: ast.Attribute) -> Any:\n        \"\"\"Visit an attribute node.\n\n        Args:\n            node: The node to visit.\n\n        Returns:\n            Any: The result of the visit.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.FunctionNonLocals::visit_Lambda", "project": "langchain_core", "func": "FunctionNonLocals::visit_Lambda", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/runnables/test_history.py"], "prob_info": {"func_start_lineno": 325, "func_end_lineno": 336, "key_block_start_lineno": 334, "key_block_end_lineno": 336, "new_func_code": "def visit_Lambda(self, node: ast.Lambda) -> Any:\n        \"\"\"Visit a lambda function.\n\n        Args:\n            node: The node to visit.\n\n        Returns:\n            Any: The result of the visit.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.get_lambda_source", "project": "langchain_core", "func": "get_lambda_source", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/runnables/test_utils.py"], "prob_info": {"func_start_lineno": 382, "func_end_lineno": 402, "key_block_start_lineno": 391, "key_block_end_lineno": 402, "new_func_code": "def get_lambda_source(func: Callable) -> Optional[str]:\n    \"\"\"Get the source code of a lambda function.\n\n    Args:\n        func: a Callable that can be a lambda function.\n\n    Returns:\n        str: the source code of the lambda function.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.GetLambdaSource::visit_Lambda", "project": "langchain_core", "func": "GetLambdaSource::visit_Lambda", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/runnables/test_utils.py"], "prob_info": {"func_start_lineno": 348, "func_end_lineno": 359, "key_block_start_lineno": 357, "key_block_end_lineno": 359, "new_func_code": "def visit_Lambda(self, node: ast.Lambda) -> Any:\n        \"\"\"Visit a lambda function.\n\n        Args:\n            node: The node to visit.\n\n        Returns:\n            Any: The result of the visit.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.indent_lines_after_first", "project": "langchain_core", "func": "indent_lines_after_first", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/runnables/test_utils.py"], "prob_info": {"func_start_lineno": 449, "func_end_lineno": 462, "key_block_start_lineno": 459, "key_block_end_lineno": 462, "new_func_code": "def indent_lines_after_first(text: str, prefix: str) -> str:\n    \"\"\"Indent all lines of text after the first line.\n\n    Args:\n        text: The text to indent.\n        prefix: Used to determine the number of spaces to indent.\n\n    Returns:\n        str: The indented text.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.get_function_nonlocals", "project": "langchain_core", "func": "get_function_nonlocals", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/runnables/test_utils.py"], "prob_info": {"func_start_lineno": 406, "func_end_lineno": 446, "key_block_start_lineno": 415, "key_block_end_lineno": 446, "new_func_code": "def get_function_nonlocals(func: Callable) -> list[Any]:\n    \"\"\"Get the nonlocal variables accessed by a function.\n\n    Args:\n        func: The function to check.\n\n    Returns:\n        List[Any]: The nonlocal variables accessed by the function.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.env.get_runtime_environment", "project": "langchain_core", "func": "get_runtime_environment", "origin_file": "langchain_core/env.py", "test_list": ["tests/unit_tests/tracers/test_langchain.py"], "prob_info": {"func_start_lineno": 6, "func_end_lineno": 21, "key_block_start_lineno": 12, "key_block_end_lineno": 21, "new_func_code": "def get_runtime_environment() -> dict:\n    \"\"\"Get information about the LangChain runtime environment.\n\n    Returns:\n        A dictionary with information about the runtime environment.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.env.get_from_dict_or_env", "project": "langchain_core", "func": "get_from_dict_or_env", "origin_file": "langchain_core/utils/env.py", "test_list": ["tests/unit_tests/utils/test_env.py"], "prob_info": {"func_start_lineno": 24, "func_end_lineno": 51, "key_block_start_lineno": 41, "key_block_end_lineno": 51, "new_func_code": "def get_from_dict_or_env(\n    data: dict[str, Any],\n    key: Union[str, list[str]],\n    env_key: str,\n    default: Optional[str] = None,\n) -> str:\n    \"\"\"Get a value from a dictionary or an environment variable.\n\n    Args:\n        data: The dictionary to look up the key in.\n        key: The key to look up in the dictionary. This can be a list of keys to try\n            in order.\n        env_key: The environment variable to look up if the key is not\n            in the dictionary.\n        default: The default value to return if the key is not in the dictionary\n            or the environment. Defaults to None.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.env.get_from_env", "project": "langchain_core", "func": "get_from_env", "origin_file": "langchain_core/utils/env.py", "test_list": ["tests/unit_tests/utils/test_env.py"], "prob_info": {"func_start_lineno": 54, "func_end_lineno": 81, "key_block_start_lineno": 71, "key_block_end_lineno": 81, "new_func_code": "def get_from_env(key: str, env_key: str, default: Optional[str] = None) -> str:\n    \"\"\"Get a value from a dictionary or an environment variable.\n\n    Args:\n        key: The key to look up in the dictionary.\n        env_key: The environment variable to look up if the key is not\n            in the dictionary.\n        default: The default value to return if the key is not in the dictionary\n            or the environment. Defaults to None.\n\n    Returns:\n        str: The value of the key.\n\n    Raises:\n        ValueError: If the key is not in the dictionary and no default value is\n            provided or if the environment variable is not set.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.pydantic.is_basemodel_subclass", "project": "langchain_core", "func": "is_basemodel_subclass", "origin_file": "langchain_core/utils/pydantic.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 103, "func_end_lineno": 133, "key_block_start_lineno": 112, "key_block_end_lineno": 133, "new_func_code": "def is_basemodel_subclass(cls: type) -> bool:\n    \"\"\"Check if the given class is a subclass of Pydantic BaseModel.\n\n    Check if the given class is a subclass of any of the following:\n\n    * pydantic.BaseModel in Pydantic 1.x\n    * pydantic.BaseModel in Pydantic 2.x\n    * pydantic.v1.BaseModel in Pydantic 2.x\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.function_calling._convert_pydantic_to_openai_function", "project": "langchain_core", "func": "_convert_pydantic_to_openai_function", "origin_file": "langchain_core/utils/function_calling.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 78, "func_end_lineno": 116, "key_block_start_lineno": 98, "key_block_end_lineno": 116, "new_func_code": "def _convert_pydantic_to_openai_function(\n    model: type,\n    *,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    rm_titles: bool = True,\n) -> FunctionDescription:\n    \"\"\"Converts a Pydantic model to a function description for the OpenAI API.\n\n    Args:\n        model: The Pydantic model to convert.\n        name: The name of the function. If not provided, the title of the schema will be\n            used.\n        description: The description of the function. If not provided, the description\n            of the schema will be used.\n        rm_titles: Whether to remove titles from the schema. Defaults to True.\n\n    Returns:\n        The function description.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.json_schema.dereference_refs", "project": "langchain_core", "func": "dereference_refs", "origin_file": "langchain_core/utils/json_schema.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 92, "func_end_lineno": 114, "key_block_start_lineno": 108, "key_block_end_lineno": 114, "new_func_code": "def dereference_refs(\n    schema_obj: dict,\n    *,\n    full_schema: Optional[dict] = None,\n    skip_keys: Optional[Sequence[str]] = None,\n) -> dict:\n    \"\"\"Try to substitute $refs in JSON Schema.\n\n    Args:\n        schema_obj: The schema object to dereference.\n        full_schema: The full schema object. Defaults to None.\n        skip_keys: The keys to skip. Defaults to None.\n\n    Returns:\n        The dereferenced schema object.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.tools.base.create_schema_from_function", "project": "langchain_core", "func": "create_schema_from_function", "origin_file": "langchain_core/tools/base.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 210, "func_end_lineno": 307, "key_block_start_lineno": 238, "key_block_end_lineno": 307, "new_func_code": "def create_schema_from_function(\n    model_name: str,\n    func: Callable,\n    *,\n    filter_args: Optional[Sequence[str]] = None,\n    parse_docstring: bool = False,\n    error_on_invalid_docstring: bool = False,\n    include_injected: bool = True,\n) -> type[BaseModel]:\n    \"\"\"Create a pydantic schema from a function's signature.\n\n    Args:\n        model_name: Name to assign to the generated pydantic schema.\n        func: Function to generate the schema from.\n        filter_args: Optional list of arguments to exclude from the schema.\n            Defaults to FILTERED_ARGS.\n        parse_docstring: Whether to parse the function's docstring for descriptions\n            for each argument. Defaults to False.\n        error_on_invalid_docstring: if ``parse_docstring`` is provided, configure\n            whether to raise ValueError on invalid Google Style docstrings.\n            Defaults to False.\n        include_injected: Whether to include injected arguments in the schema.\n            Defaults to True, since we want to include them in the schema\n            when *validating* tool inputs.\n\n    Returns:\n        A pydantic model with the same arguments as the function.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.tools.base._infer_arg_descriptions", "project": "langchain_core", "func": "_infer_arg_descriptions", "origin_file": "langchain_core/tools/base.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 135, "func_end_lineno": 161, "key_block_start_lineno": 142, "key_block_end_lineno": 161, "new_func_code": "def _infer_arg_descriptions(\n    fn: Callable,\n    *,\n    parse_docstring: bool = False,\n    error_on_invalid_docstring: bool = False,\n) -> tuple[str, dict]:\n    \"\"\"Infer argument descriptions from a function's docstring.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.function_calling._parse_google_docstring", "project": "langchain_core", "func": "_parse_google_docstring", "origin_file": "langchain_core/utils/function_calling.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 608, "func_end_lineno": 664, "key_block_start_lineno": 618, "key_block_end_lineno": 664, "new_func_code": "def _parse_google_docstring(\n    docstring: Optional[str],\n    args: list[str],\n    *,\n    error_on_invalid_docstring: bool = False,\n) -> tuple[str, dict]:\n    \"\"\"Parse the function and argument descriptions from the docstring of a function.\n\n    Assumes the function docstring follows Google Python style guide.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.pydantic._create_subset_model_v2", "project": "langchain_core", "func": "_create_subset_model_v2", "origin_file": "langchain_core/utils/pydantic.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 272, "func_end_lineno": 310, "key_block_start_lineno": 281, "key_block_end_lineno": 310, "new_func_code": "def _create_subset_model_v2(\n    name: str,\n    model: type[pydantic.BaseModel],\n    field_names: list[str],\n    *,\n    descriptions: Optional[dict] = None,\n    fn_description: Optional[str] = None,\n) -> type[pydantic.BaseModel]:\n    \"\"\"Create a pydantic model with a subset of the model fields.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.tools.convert.convert_runnable_to_tool", "project": "langchain_core", "func": "convert_runnable_to_tool", "origin_file": "langchain_core/tools/convert.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 363, "func_end_lineno": 423, "key_block_start_lineno": 383, "key_block_end_lineno": 423, "new_func_code": "def convert_runnable_to_tool(\n    runnable: Runnable,\n    args_schema: Optional[type[BaseModel]] = None,\n    *,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    arg_types: Optional[dict[str, type]] = None,\n) -> BaseTool:\n    \"\"\"Convert a Runnable into a BaseTool.\n\n    Args:\n        runnable: The runnable to convert.\n        args_schema: The schema for the tool's input arguments. Defaults to None.\n        name: The name of the tool. Defaults to None.\n        description: The description of the tool. Defaults to None.\n        arg_types: The types of the arguments. Defaults to None.\n\n    Returns:\n        The tool.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.RunnableLambda::get_input_schema", "project": "langchain_core", "func": "RunnableLambda::get_input_schema", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 4375, "func_end_lineno": 4418, "key_block_start_lineno": 4386, "key_block_end_lineno": 4418, "new_func_code": "def get_input_schema(\n        self, config: Optional[RunnableConfig] = None\n    ) -> type[BaseModel]:\n        \"\"\"The pydantic schema for the input to this Runnable.\n\n        Args:\n            config: The config to use. Defaults to None.\n\n        Returns:\n            The input schema for this Runnable.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.html.find_all_links", "project": "langchain_core", "func": "find_all_links", "origin_file": "langchain_core/utils/html.py", "test_list": ["tests/unit_tests/utils/test_html.py"], "prob_info": {"func_start_lineno": 35, "func_end_lineno": 48, "key_block_start_lineno": 47, "key_block_end_lineno": 48, "new_func_code": "def find_all_links(\n    raw_html: str, *, pattern: Union[str, re.Pattern, None] = None\n) -> list[str]:\n    \"\"\"Extract all links from a raw HTML string.\n\n    Args:\n        raw_html: original HTML.\n        pattern: Regex to use for extracting links from raw HTML.\n\n    Returns:\n        List[str]: all links\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.html.extract_sub_links", "project": "langchain_core", "func": "extract_sub_links", "origin_file": "langchain_core/utils/html.py", "test_list": ["tests/unit_tests/utils/test_html.py"], "prob_info": {"func_start_lineno": 51, "func_end_lineno": 119, "key_block_start_lineno": 77, "key_block_end_lineno": 119, "new_func_code": "def extract_sub_links(\n    raw_html: str,\n    url: str,\n    *,\n    base_url: Optional[str] = None,\n    pattern: Union[str, re.Pattern, None] = None,\n    prevent_outside: bool = True,\n    exclude_prefixes: Sequence[str] = (),\n    continue_on_failure: bool = False,\n) -> list[str]:\n    \"\"\"Extract all links from a raw HTML string and convert into absolute paths.\n\n    Args:\n        raw_html: original HTML.\n        url: the url of the HTML.\n        base_url: the base URL to check for outside links against.\n        pattern: Regex to use for extracting links from raw HTML.\n        prevent_outside: If True, ignore external links which are not children\n            of the base URL.\n        exclude_prefixes: Exclude any URLs that start with one of these prefixes.\n        continue_on_failure: If True, continue if parsing a specific link raises an\n            exception. Otherwise, raise the exception.\n\n    Returns:\n        List[str]: sub links.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.iter.batch_iterate", "project": "langchain_core", "func": "batch_iterate", "origin_file": "langchain_core/utils/iter.py", "test_list": ["tests/unit_tests/utils/test_iter.py"], "prob_info": {"func_start_lineno": 182, "func_end_lineno": 197, "key_block_start_lineno": 192, "key_block_end_lineno": 197, "new_func_code": "def batch_iterate(size: Optional[int], iterable: Iterable[T]) -> Iterator[list[T]]:\n    \"\"\"Utility batching function.\n\n    Args:\n        size: The size of the batch. If None, returns a single batch.\n        iterable: The iterable to batch.\n\n    Yields:\n        The batches of the iterable.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.pydantic.pre_init", "project": "langchain_core", "func": "pre_init", "origin_file": "langchain_core/utils/pydantic.py", "test_list": ["tests/unit_tests/utils/test_pydantic.py"], "prob_info": {"func_start_lineno": 166, "func_end_lineno": 220, "key_block_start_lineno": 175, "key_block_end_lineno": 220, "new_func_code": "def pre_init(func: Callable) -> Any:\n    \"\"\"Decorator to run a function before model initialization.\n\n    Args:\n        func (Callable): The function to run before model initialization.\n\n    Returns:\n        Any: The decorated function.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.utils.check_package_version", "project": "langchain_core", "func": "check_package_version", "origin_file": "langchain_core/utils/utils.py", "test_list": ["tests/unit_tests/utils/test_utils.py"], "prob_info": {"func_start_lineno": 146, "func_end_lineno": 193, "key_block_start_lineno": 169, "key_block_end_lineno": 193, "new_func_code": "def check_package_version(\n    package: str,\n    lt_version: Optional[str] = None,\n    lte_version: Optional[str] = None,\n    gt_version: Optional[str] = None,\n    gte_version: Optional[str] = None,\n) -> None:\n    \"\"\"Check the version of a package.\n\n    Args:\n        package (str): The name of the package.\n        lt_version (str, optional): The version must be less than this.\n            Defaults to None.\n        lte_version (str, optional): The version must be less than or equal to this.\n            Defaults to None.\n        gt_version (str, optional): The version must be greater than this.\n            Defaults to None.\n        gte_version (str, optional): The version must be greater than or equal to this.\n            Defaults to None.\n\n    Raises:\n        ValueError: If the package version does not meet the requirements.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.vectorstores.utils._cosine_similarity", "project": "langchain_core", "func": "_cosine_similarity", "origin_file": "langchain_core/vectorstores/utils.py", "test_list": ["tests/unit_tests/vectorstores/test_in_memory.py"], "prob_info": {"func_start_lineno": 20, "func_end_lineno": 72, "key_block_start_lineno": 35, "key_block_end_lineno": 72, "new_func_code": "def _cosine_similarity(x: Matrix, y: Matrix) -> np.ndarray:\n    \"\"\"Row-wise cosine similarity between two equal-width matrices.\n\n    Args:\n        x: A matrix of shape (n, m).\n        y: A matrix of shape (k, m).\n\n    Returns:\n        A matrix of shape (n, k) where each element (i, j) is the cosine similarity\n        between the ith row of X and the jth row of Y.\n\n    Raises:\n        ValueError: If the number of columns in X and Y are not the same.\n        ImportError: If numpy is not installed.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.vectorstores.in_memory.InMemoryVectorStore::get_by_ids", "project": "langchain_core", "func": "InMemoryVectorStore::get_by_ids", "origin_file": "langchain_core/vectorstores/in_memory.py", "test_list": ["tests/unit_tests/vectorstores/test_in_memory.py"], "prob_info": {"func_start_lineno": 246, "func_end_lineno": 267, "key_block_start_lineno": 255, "key_block_end_lineno": 267, "new_func_code": "def get_by_ids(self, ids: Sequence[str], /) -> list[Document]:\n        \"\"\"Get documents by their ids.\n\n        Args:\n            ids: The ids of the documents to get.\n\n        Returns:\n            A list of Document objects.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core._api.beta_decorator.warn_beta", "project": "langchain_core", "func": "warn_beta", "origin_file": "langchain_core/_api/beta_decorator.py", "test_list": ["tests/unit_tests/_api/test_beta_decorator.py"], "prob_info": {"func_start_lineno": 236, "func_end_lineno": 272, "key_block_start_lineno": 258, "key_block_end_lineno": 272, "new_func_code": "def warn_beta(\n    *,\n    message: str = \"\",\n    name: str = \"\",\n    obj_type: str = \"\",\n    addendum: str = \"\",\n) -> None:\n    \"\"\"Display a standardized beta annotation.\n\n    Arguments:\n        message : str, optional\n            Override the default beta message. The\n            %(name)s, %(obj_type)s, %(addendum)s\n            format specifiers will be replaced by the\n            values of the respective arguments passed to this function.\n        name : str, optional\n            The name of the annotated object.\n        obj_type : str, optional\n            The object type being annotated.\n        addendum : str, optional\n            Additional text appended directly to the final message.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.load.serializable.to_json_not_implemented", "project": "langchain_core", "func": "to_json_not_implemented", "origin_file": "langchain_core/load/serializable.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 341, "func_end_lineno": 367, "key_block_start_lineno": 350, "key_block_end_lineno": 367, "new_func_code": "def to_json_not_implemented(obj: object) -> SerializedNotImplemented:\n    \"\"\"Serialize a \"not implemented\" object.\n\n    Args:\n        obj: object to serialize.\n\n    Returns:\n        SerializedNotImplemented\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.load.serializable.try_neq_default", "project": "langchain_core", "func": "try_neq_default", "origin_file": "langchain_core/load/serializable.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 67, "func_end_lineno": 82, "key_block_start_lineno": 81, "key_block_end_lineno": 82, "new_func_code": "def try_neq_default(value: Any, key: str, model: BaseModel) -> bool:\n    \"\"\"Try to determine if a value is different from the default.\n\n    Args:\n        value: The value.\n        key: The key.\n        model: The pydantic model.\n\n    Returns:\n        Whether the value is different from the default.\n\n    Raises:\n        Exception: If the key is not in the model.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.callbacks.manager.CallbackManager::on_chat_model_start", "project": "langchain_core", "func": "CallbackManager::on_chat_model_start", "origin_file": "langchain_core/callbacks/manager.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 1293, "func_end_lineno": 1345, "key_block_start_lineno": 1312, "key_block_end_lineno": 1345, "new_func_code": "def on_chat_model_start(\n        self,\n        serialized: dict[str, Any],\n        messages: list[list[BaseMessage]],\n        run_id: Optional[UUID] = None,\n        **kwargs: Any,\n    ) -> list[CallbackManagerForLLMRun]:\n        \"\"\"Run when chat model starts running.\n\n        Args:\n            serialized (Dict[str, Any]): The serialized LLM.\n            messages (List[List[BaseMessage]]): The list of messages.\n            run_id (UUID, optional): The ID of the run. Defaults to None.\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            List[CallbackManagerForLLMRun]: A callback manager for each\n                list of messages as an LLM run.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.callbacks.manager.CallbackManagerForLLMRun::on_llm_end", "project": "langchain_core", "func": "CallbackManagerForLLMRun::on_llm_end", "origin_file": "langchain_core/callbacks/manager.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 678, "func_end_lineno": 694, "key_block_start_lineno": 685, "key_block_end_lineno": 694, "new_func_code": "def on_llm_end(self, response: LLMResult, **kwargs: Any) -> None:\n        \"\"\"Run when LLM ends running.\n\n        Args:\n            response (LLMResult): The LLM result.\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.callbacks.manager.CallbackManagerForLLMRun::on_llm_new_token", "project": "langchain_core", "func": "CallbackManagerForLLMRun::on_llm_new_token", "origin_file": "langchain_core/callbacks/manager.py", "test_list": ["tests/unit_tests/language_models/chat_models/test_base.py"], "prob_info": {"func_start_lineno": 651, "func_end_lineno": 676, "key_block_start_lineno": 666, "key_block_end_lineno": 676, "new_func_code": "def on_llm_new_token(\n        self,\n        token: str,\n        *,\n        chunk: Optional[Union[GenerationChunk, ChatGenerationChunk]] = None,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Run when LLM generates a new token.\n\n        Args:\n            token (str): The new token.\n            chunk (Optional[Union[GenerationChunk, ChatGenerationChunk]], optional):\n                The chunk. Defaults to None.\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.callbacks.manager.CallbackManager::on_llm_start", "project": "langchain_core", "func": "CallbackManager::on_llm_start", "origin_file": "langchain_core/callbacks/manager.py", "test_list": ["tests/unit_tests/language_models/llms/test_base.py"], "prob_info": {"func_start_lineno": 1242, "func_end_lineno": 1291, "key_block_start_lineno": 1261, "key_block_end_lineno": 1291, "new_func_code": "def on_llm_start(\n        self,\n        serialized: dict[str, Any],\n        prompts: list[str],\n        run_id: Optional[UUID] = None,\n        **kwargs: Any,\n    ) -> list[CallbackManagerForLLMRun]:\n        \"\"\"Run when LLM starts running.\n\n        Args:\n            serialized (Dict[str, Any]): The serialized LLM.\n            prompts (List[str]): The list of prompts.\n            run_id (UUID, optional): The ID of the run. Defaults to None.\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            List[CallbackManagerForLLMRun]: A callback manager for each\n                prompt as an LLM run.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.outputs.llm_result.LLMResult::flatten", "project": "langchain_core", "func": "LLMResult::flatten", "origin_file": "langchain_core/outputs/llm_result.py", "test_list": ["tests/unit_tests/language_models/llms/test_base.py"], "prob_info": {"func_start_lineno": 54, "func_end_lineno": 88, "key_block_start_lineno": 66, "key_block_end_lineno": 88, "new_func_code": "def flatten(self) -> list[LLMResult]:\n        \"\"\"Flatten generations into a single list.\n\n        Unpack List[List[Generation]] -> List[LLMResult] where each returned LLMResult\n        contains only a single Generation. If token usage information is available,\n        it is kept only for the LLMResult corresponding to the top-choice\n        Generation, to avoid over-counting of token usage downstream.\n\n        Returns:\n            List of LLMResults where each returned LLMResult contains a single\n                Generation.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.load.load.load", "project": "langchain_core", "func": "load", "origin_file": "langchain_core/load/load.py", "test_list": ["tests/unit_tests/messages/test_ai.py"], "prob_info": {"func_start_lineno": 199, "func_end_lineno": 239, "key_block_start_lineno": 226, "key_block_end_lineno": 239, "new_func_code": "def load(\n    obj: Any,\n    *,\n    secrets_map: Optional[dict[str, str]] = None,\n    valid_namespaces: Optional[list[str]] = None,\n    secrets_from_env: bool = True,\n    additional_import_mappings: Optional[dict[tuple[str, ...], tuple[str, ...]]] = None,\n) -> Any:\n    \"\"\"Revive a LangChain class from a JSON object. Use this if you already\n    have a parsed JSON object, eg. from `json.load` or `orjson.loads`.\n\n    Args:\n        obj: The object to load.\n        secrets_map: A map of secrets to load. If a secret is not found in\n            the map, it will be loaded from the environment if `secrets_from_env`\n            is True. Defaults to None.\n        valid_namespaces: A list of additional namespaces (modules)\n            to allow to be deserialized. Defaults to None.\n        secrets_from_env: Whether to load secrets from the environment.\n            Defaults to True.\n        additional_import_mappings: A dictionary of additional namespace mappings\n            You can use this to override default mappings or add new mappings.\n            Defaults to None.\n\n    Returns:\n        Revived LangChain objects.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.ai.subtract_usage", "project": "langchain_core", "func": "subtract_usage", "origin_file": "langchain_core/messages/ai.py", "test_list": ["tests/unit_tests/messages/test_ai.py"], "prob_info": {"func_start_lineno": 512, "func_end_lineno": 566, "key_block_start_lineno": 552, "key_block_end_lineno": 566, "new_func_code": "def subtract_usage(\n    left: Optional[UsageMetadata], right: Optional[UsageMetadata]\n) -> UsageMetadata:\n    \"\"\"Recursively subtract two UsageMetadata objects.\n\n    Token counts cannot be negative so the actual operation is max(left - right, 0).\n\n    Example:\n        .. code-block:: python\n\n            from langchain_core.messages.ai import subtract_usage\n\n            left = UsageMetadata(\n                input_tokens=5,\n                output_tokens=10,\n                total_tokens=15,\n                input_token_details=InputTokenDetails(cache_read=4)\n            )\n            right = UsageMetadata(\n                input_tokens=3,\n                output_tokens=8,\n                total_tokens=11,\n                output_token_details=OutputTokenDetails(reasoning=4)\n            )\n\n            subtract_usage(left, right)\n\n        results in\n\n        .. code-block:: python\n\n            UsageMetadata(\n                input_tokens=2,\n                output_tokens=2,\n                total_tokens=4,\n                input_token_details=InputTokenDetails(cache_read=4),\n                output_token_details=OutputTokenDetails(reasoning=0)\n            )\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.config.call_func_with_variable_args", "project": "langchain_core", "func": "call_func_with_variable_args", "origin_file": "langchain_core/runnables/config.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 361, "func_end_lineno": 396, "key_block_start_lineno": 389, "key_block_end_lineno": 396, "new_func_code": "def call_func_with_variable_args(\n    func: Union[\n        Callable[[Input], Output],\n        Callable[[Input, RunnableConfig], Output],\n        Callable[[Input, CallbackManagerForChainRun], Output],\n        Callable[[Input, CallbackManagerForChainRun, RunnableConfig], Output],\n    ],\n    input: Input,\n    config: RunnableConfig,\n    run_manager: Optional[CallbackManagerForChainRun] = None,\n    **kwargs: Any,\n) -> Output:\n    \"\"\"Call function that may optionally accept a run_manager and/or config.\n\n    Args:\n        func (Union[Callable[[Input], Output],\n          Callable[[Input, CallbackManagerForChainRun], Output],\n          Callable[[Input, CallbackManagerForChainRun, RunnableConfig], Output]]):\n           The function to call.\n        input (Input): The input to the function.\n        config (RunnableConfig): The config to pass to the function.\n        run_manager (CallbackManagerForChainRun): The run manager to\n          pass to the function. Defaults to None.\n        **kwargs (Any): The keyword arguments to pass to the function.\n\n    Returns:\n        Output: The output of the function.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.utils.merge_message_runs", "project": "langchain_core", "func": "merge_message_runs", "origin_file": "langchain_core/messages/utils.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 484, "func_end_lineno": 579, "key_block_start_lineno": 555, "key_block_end_lineno": 579, "new_func_code": "def merge_message_runs(\n    messages: Union[Iterable[MessageLikeRepresentation], PromptValue],\n    *,\n    chunk_separator: str = \"\\n\",\n) -> list[BaseMessage]:\n    \"\"\"Merge consecutive Messages of the same type.\n\n    **NOTE**: ToolMessages are not merged, as each has a distinct tool call id that\n    can't be merged.\n\n    Args:\n        messages: Sequence Message-like objects to merge.\n        chunk_separator: Specify the string to be inserted between message chunks.\n        Default is \"\\n\".\n\n    Returns:\n        list of BaseMessages with consecutive runs of message types merged into single\n        messages. By default, if two messages being merged both have string contents,\n        the merged content is a concatenation of the two strings with a new-line separator.\n        The separator inserted between message chunks can be controlled by specifying\n        any string with ``chunk_separator``. If at least one of the messages has a list of\n        content blocks, the merged content is a list of content blocks.\n\n    Example:\n        .. code-block:: python\n\n            from langchain_core.messages import (\n                merge_message_runs,\n                AIMessage,\n                HumanMessage,\n                SystemMessage,\n                ToolCall,\n            )\n\n            messages = [\n                SystemMessage(\"you're a good assistant.\"),\n                HumanMessage(\"what's your favorite color\", id=\"foo\",),\n                HumanMessage(\"wait your favorite food\", id=\"bar\",),\n                AIMessage(\n                    \"my favorite colo\",\n                    tool_calls=[ToolCall(name=\"blah_tool\", args={\"x\": 2}, id=\"123\", type=\"tool_call\")],\n                    id=\"baz\",\n                ),\n                AIMessage(\n                    [{\"type\": \"text\", \"text\": \"my favorite dish is lasagna\"}],\n                    tool_calls=[ToolCall(name=\"blah_tool\", args={\"x\": -10}, id=\"456\", type=\"tool_call\")],\n                    id=\"blur\",\n                ),\n            ]\n\n            merge_message_runs(messages)\n\n        .. code-block:: python\n\n            [\n                SystemMessage(\"you're a good assistant.\"),\n                HumanMessage(\"what's your favorite color\\\\nwait your favorite food\", id=\"foo\",),\n                AIMessage(\n                    [\n                        \"my favorite colo\",\n                        {\"type\": \"text\", \"text\": \"my favorite dish is lasagna\"}\n                    ],\n                    tool_calls=[\n                        ToolCall({\"name\": \"blah_tool\", \"args\": {\"x\": 2}, \"id\": \"123\", \"type\": \"tool_call\"}),\n                        ToolCall({\"name\": \"blah_tool\", \"args\": {\"x\": -10}, \"id\": \"456\", \"type\": \"tool_call\"})\n                    ]\n                    id=\"baz\"\n                ),\n            ]\n\n    \"\"\"  # noqa: E501\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.utils.filter_messages", "project": "langchain_core", "func": "filter_messages", "origin_file": "langchain_core/messages/utils.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 397, "func_end_lineno": 480, "key_block_start_lineno": 457, "key_block_end_lineno": 480, "new_func_code": "def filter_messages(\n    messages: Union[Iterable[MessageLikeRepresentation], PromptValue],\n    *,\n    include_names: Optional[Sequence[str]] = None,\n    exclude_names: Optional[Sequence[str]] = None,\n    include_types: Optional[Sequence[Union[str, type[BaseMessage]]]] = None,\n    exclude_types: Optional[Sequence[Union[str, type[BaseMessage]]]] = None,\n    include_ids: Optional[Sequence[str]] = None,\n    exclude_ids: Optional[Sequence[str]] = None,\n) -> list[BaseMessage]:\n    \"\"\"Filter messages based on name, type or id.\n\n    Args:\n        messages: Sequence Message-like objects to filter.\n        include_names: Message names to include. Default is None.\n        exclude_names: Messages names to exclude. Default is None.\n        include_types: Message types to include. Can be specified as string names (e.g.\n            \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n            SystemMessage, HumanMessage, AIMessage, ...). Default is None.\n        exclude_types: Message types to exclude. Can be specified as string names (e.g.\n            \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n            SystemMessage, HumanMessage, AIMessage, ...). Default is None.\n        include_ids: Message IDs to include. Default is None.\n        exclude_ids: Message IDs to exclude. Default is None.\n\n    Returns:\n        A list of Messages that meets at least one of the incl_* conditions and none\n        of the excl_* conditions. If not incl_* conditions are specified then\n        anything that is not explicitly excluded will be included.\n\n    Raises:\n        ValueError if two incompatible arguments are provided.\n\n    Example:\n        .. code-block:: python\n\n            from langchain_core.messages import filter_messages, AIMessage, HumanMessage, SystemMessage\n\n            messages = [\n                SystemMessage(\"you're a good assistant.\"),\n                HumanMessage(\"what's your name\", id=\"foo\", name=\"example_user\"),\n                AIMessage(\"steve-o\", id=\"bar\", name=\"example_assistant\"),\n                HumanMessage(\"what's your favorite color\", id=\"baz\",),\n                AIMessage(\"silicon blue\", id=\"blah\",),\n            ]\n\n            filter_messages(\n                messages,\n                incl_names=(\"example_user\", \"example_assistant\"),\n                incl_types=(\"system\",),\n                excl_ids=(\"bar\",),\n            )\n\n        .. code-block:: python\n\n            [\n                SystemMessage(\"you're a good assistant.\"),\n                HumanMessage(\"what's your name\", id=\"foo\", name=\"example_user\"),\n            ]\n    \"\"\"  # noqa: E501\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.utils.trim_messages", "project": "langchain_core", "func": "trim_messages", "origin_file": "langchain_core/messages/utils.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 585, "func_end_lineno": 887, "key_block_start_lineno": 827, "key_block_end_lineno": 887, "new_func_code": "def trim_messages(\n    messages: Union[Iterable[MessageLikeRepresentation], PromptValue],\n    *,\n    max_tokens: int,\n    token_counter: Union[\n        Callable[[list[BaseMessage]], int],\n        Callable[[BaseMessage], int],\n        BaseLanguageModel,\n    ],\n    strategy: Literal[\"first\", \"last\"] = \"last\",\n    allow_partial: bool = False,\n    end_on: Optional[\n        Union[str, type[BaseMessage], Sequence[Union[str, type[BaseMessage]]]]\n    ] = None,\n    start_on: Optional[\n        Union[str, type[BaseMessage], Sequence[Union[str, type[BaseMessage]]]]\n    ] = None,\n    include_system: bool = False,\n    text_splitter: Optional[Union[Callable[[str], list[str]], TextSplitter]] = None,\n) -> list[BaseMessage]:\n    r\"\"\"Trim messages to be below a token count.\n\n    trim_messages can be used to reduce the size of a chat history to a specified token\n    count or specified message count.\n\n    In either case, if passing the trimmed chat history back into a chat model\n    directly, the resulting chat history should usually satisfy the following\n    properties:\n\n    1. The resulting chat history should be valid. Most chat models expect that chat\n       history starts with either (1) a `HumanMessage` or (2) a `SystemMessage` followed\n       by a `HumanMessage`. To achieve this, set `start_on=\"human\"`.\n       In addition, generally a `ToolMessage` can only appear after an `AIMessage`\n       that involved a tool call.\n       Please see the following link for more information about messages:\n       https://python.langchain.com/docs/concepts/#messages\n    2. It includes recent messages and drops old messages in the chat history.\n       To achieve this set the `strategy=\"last\"`.\n    3. Usually, the new chat history should include the `SystemMessage` if it\n       was present in the original chat history since the `SystemMessage` includes\n       special instructions to the chat model. The `SystemMessage` is almost always\n       the first message in the history if present. To achieve this set the\n       `include_system=True`.\n\n    **Note** The examples below show how to configure `trim_messages` to achieve\n        a behavior consistent with the above properties.\n\n    Args:\n        messages: Sequence of Message-like objects to trim.\n        max_tokens: Max token count of trimmed messages.\n        token_counter: Function or llm for counting tokens in a BaseMessage or a list of\n            BaseMessage. If a BaseLanguageModel is passed in then\n            BaseLanguageModel.get_num_tokens_from_messages() will be used.\n            Set to `len` to count the number of **messages** in the chat history.\n        strategy: Strategy for trimming.\n            - \"first\": Keep the first <= n_count tokens of the messages.\n            - \"last\": Keep the last <= n_count tokens of the messages.\n            Default is \"last\".\n        allow_partial: Whether to split a message if only part of the message can be\n            included. If ``strategy=\"last\"`` then the last partial contents of a message\n            are included. If ``strategy=\"first\"`` then the first partial contents of a\n            message are included.\n            Default is False.\n        end_on: The message type to end on. If specified then every message after the\n            last occurrence of this type is ignored. If ``strategy==\"last\"`` then this\n            is done before we attempt to get the last ``max_tokens``. If\n            ``strategy==\"first\"`` then this is done after we get the first\n            ``max_tokens``. Can be specified as string names (e.g. \"system\", \"human\",\n            \"ai\", ...) or as BaseMessage classes (e.g. SystemMessage, HumanMessage,\n            AIMessage, ...). Can be a single type or a list of types.\n            Default is None.\n        start_on: The message type to start on. Should only be specified if\n            ``strategy=\"last\"``. If specified then every message before\n            the first occurrence of this type is ignored. This is done after we trim\n            the initial messages to the last ``max_tokens``. Does not\n            apply to a SystemMessage at index 0 if ``include_system=True``. Can be\n            specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as\n            BaseMessage classes (e.g. SystemMessage, HumanMessage, AIMessage, ...). Can\n            be a single type or a list of types.\n            Default is None.\n        include_system: Whether to keep the SystemMessage if there is one at index 0.\n            Should only be specified if ``strategy=\"last\"``.\n            Default is False.\n        text_splitter: Function or ``langchain_text_splitters.TextSplitter`` for\n            splitting the string contents of a message. Only used if\n            ``allow_partial=True``. If ``strategy=\"last\"`` then the last split tokens\n            from a partial message will be included. if ``strategy==\"first\"`` then the\n            first split tokens from a partial message will be included. Token splitter\n            assumes that separators are kept, so that split contents can be directly\n            concatenated to recreate the original text. Defaults to splitting on\n            newlines.\n\n    Returns:\n        list of trimmed BaseMessages.\n\n    Raises:\n        ValueError: if two incompatible arguments are specified or an unrecognized\n            ``strategy`` is specified.\n\n    Example:\n        Trim chat history based on token count, keeping the SystemMessage if\n        present, and ensuring that the chat history starts with a HumanMessage (\n        or a SystemMessage followed by a HumanMessage).\n\n        .. code-block:: python\n\n            from typing import list\n\n            from langchain_core.messages import (\n                AIMessage,\n                HumanMessage,\n                BaseMessage,\n                SystemMessage,\n                trim_messages,\n            )\n\n            messages = [\n                SystemMessage(\"you're a good assistant, you always respond with a joke.\"),\n                HumanMessage(\"i wonder why it's called langchain\"),\n                AIMessage(\n                    'Well, I guess they thought \"WordRope\" and \"SentenceString\" just didn\\'t have the same ring to it!'\n                ),\n                HumanMessage(\"and who is harrison chasing anyways\"),\n                AIMessage(\n                    \"Hmmm let me think.\\n\\nWhy, he's probably chasing after the last cup of coffee in the office!\"\n                ),\n                HumanMessage(\"what do you call a speechless parrot\"),\n            ]\n\n\n            trim_messages(\n                messages,\n                max_tokens=45,\n                strategy=\"last\",\n                token_counter=ChatOpenAI(model=\"gpt-4o\"),\n                # Most chat models expect that chat history starts with either:\n                # (1) a HumanMessage or\n                # (2) a SystemMessage followed by a HumanMessage\n                start_on=\"human\",\n                # Usually, we want to keep the SystemMessage\n                # if it's present in the original history.\n                # The SystemMessage has special instructions for the model.\n                include_system=True,\n                allow_partial=False,\n            )\n\n        .. code-block:: python\n\n            [\n                SystemMessage(content=\"you're a good assistant, you always respond with a joke.\"),\n                HumanMessage(content='what do you call a speechless parrot'),\n            ]\n\n        Trim chat history based on the message count, keeping the SystemMessage if\n        present, and ensuring that the chat history starts with a HumanMessage (\n        or a SystemMessage followed by a HumanMessage).\n\n            trim_messages(\n                messages,\n                # When `len` is passed in as the token counter function,\n                # max_tokens will count the number of messages in the chat history.\n                max_tokens=4,\n                strategy=\"last\",\n                # Passing in `len` as a token counter function will\n                # count the number of messages in the chat history.\n                token_counter=len,\n                # Most chat models expect that chat history starts with either:\n                # (1) a HumanMessage or\n                # (2) a SystemMessage followed by a HumanMessage\n                start_on=\"human\",\n                # Usually, we want to keep the SystemMessage\n                # if it's present in the original history.\n                # The SystemMessage has special instructions for the model.\n                include_system=True,\n                allow_partial=False,\n            )\n\n        .. code-block:: python\n\n            [\n                SystemMessage(content=\"you're a good assistant, you always respond with a joke.\"),\n                HumanMessage(content='and who is harrison chasing anyways'),\n                AIMessage(content=\"Hmmm let me think.\\n\\nWhy, he's probably chasing after the last cup of coffee in the office!\"),\n                HumanMessage(content='what do you call a speechless parrot'),\n            ]\n\n\n        Trim chat history using a custom token counter function that counts the\n        number of tokens in each message.\n\n        .. code-block:: python\n\n            messages = [\n                SystemMessage(\"This is a 4 token text. The full message is 10 tokens.\"),\n                HumanMessage(\"This is a 4 token text. The full message is 10 tokens.\", id=\"first\"),\n                AIMessage(\n                    [\n                        {\"type\": \"text\", \"text\": \"This is the FIRST 4 token block.\"},\n                        {\"type\": \"text\", \"text\": \"This is the SECOND 4 token block.\"},\n                    ],\n                    id=\"second\",\n                ),\n                HumanMessage(\"This is a 4 token text. The full message is 10 tokens.\", id=\"third\"),\n                AIMessage(\"This is a 4 token text. The full message is 10 tokens.\", id=\"fourth\"),\n            ]\n\n            def dummy_token_counter(messages: list[BaseMessage]) -> int:\n                # treat each message like it adds 3 default tokens at the beginning\n                # of the message and at the end of the message. 3 + 4 + 3 = 10 tokens\n                # per message.\n\n                default_content_len = 4\n                default_msg_prefix_len = 3\n                default_msg_suffix_len = 3\n\n                count = 0\n                for msg in messages:\n                    if isinstance(msg.content, str):\n                        count += default_msg_prefix_len + default_content_len + default_msg_suffix_len\n                    if isinstance(msg.content, list):\n                        count += default_msg_prefix_len + len(msg.content) *  default_content_len + default_msg_suffix_len\n                return count\n\n        First 30 tokens, allowing partial messages:\n            .. code-block:: python\n\n                trim_messages(\n                    messages,\n                    max_tokens=30,\n                    token_counter=dummy_token_counter,\n                    strategy=\"first\",\n                    allow_partial=True,\n                )\n\n            .. code-block:: python\n\n                [\n                    SystemMessage(\"This is a 4 token text. The full message is 10 tokens.\"),\n                    HumanMessage(\"This is a 4 token text. The full message is 10 tokens.\", id=\"first\"),\n                    AIMessage( [{\"type\": \"text\", \"text\": \"This is the FIRST 4 token block.\"}], id=\"second\"),\n                ]\n    \"\"\"  # noqa: E501\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.callbacks.manager.CallbackManagerForChainRun::on_chain_error", "project": "langchain_core", "func": "CallbackManagerForChainRun::on_chain_error", "origin_file": "langchain_core/callbacks/manager.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 838, "func_end_lineno": 858, "key_block_start_lineno": 849, "key_block_end_lineno": 858, "new_func_code": "def on_chain_error(\n        self,\n        error: BaseException,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Run when chain errors.\n\n        Args:\n            error (Exception or KeyboardInterrupt): The error.\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.utils._create_message_from_message_type", "project": "langchain_core", "func": "_create_message_from_message_type", "origin_file": "langchain_core/messages/utils.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 206, "func_end_lineno": 290, "key_block_start_lineno": 233, "key_block_end_lineno": 290, "new_func_code": "def _create_message_from_message_type(\n    message_type: str,\n    content: str,\n    name: Optional[str] = None,\n    tool_call_id: Optional[str] = None,\n    tool_calls: Optional[list[dict[str, Any]]] = None,\n    id: Optional[str] = None,\n    **additional_kwargs: Any,\n) -> BaseMessage:\n    \"\"\"Create a message from a message type and content string.\n\n    Args:\n        message_type: (str) the type of the message (e.g., \"human\", \"ai\", etc.).\n        content: (str) the content string.\n        name: (str) the name of the message. Default is None.\n        tool_call_id: (str) the tool call id. Default is None.\n        tool_calls: (list[dict[str, Any]]) the tool calls. Default is None.\n        id: (str) the id of the message. Default is None.\n        additional_kwargs: (dict[str, Any]) additional keyword arguments.\n\n    Returns:\n        a message of the appropriate type.\n\n    Raises:\n        ValueError: if the message type is not one of \"human\", \"user\", \"ai\",\n            \"assistant\", \"function\", \"tool\", \"system\", or \"developer\".\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.utils.convert_to_openai_messages", "project": "langchain_core", "func": "convert_to_openai_messages", "origin_file": "langchain_core/messages/utils.py", "test_list": ["tests/unit_tests/messages/test_utils.py"], "prob_info": {"func_start_lineno": 890, "func_end_lineno": 1216, "key_block_start_lineno": 952, "key_block_end_lineno": 1216, "new_func_code": "def convert_to_openai_messages(\n    messages: Union[MessageLikeRepresentation, Sequence[MessageLikeRepresentation]],\n    *,\n    text_format: Literal[\"string\", \"block\"] = \"string\",\n) -> Union[dict, list[dict]]:\n    \"\"\"Convert LangChain messages into OpenAI message dicts.\n\n    Args:\n        messages: Message-like object or iterable of objects whose contents are\n            in OpenAI, Anthropic, Bedrock Converse, or VertexAI formats.\n        text_format: How to format string or text block contents:\n\n                - \"string\":\n                    If a message has a string content, this is left as a string. If\n                    a message has content blocks that are all of type 'text', these are\n                    joined with a newline to make a single string. If a message has\n                    content blocks and at least one isn't of type 'text', then\n                    all blocks are left as dicts.\n                - \"block\":\n                    If a message has a string content, this is turned into a list\n                    with a single content block of type 'text'. If a message has content\n                    blocks these are left as is.\n\n    Returns:\n        The return type depends on the input type:\n            - dict:\n                If a single message-like object is passed in, a single OpenAI message\n                dict is returned.\n            - list[dict]:\n                If a sequence of message-like objects are passed in, a list of OpenAI\n                message dicts is returned.\n\n    Example:\n\n        .. code-block:: python\n\n            from langchain_core.messages import (\n                convert_to_openai_messages,\n                AIMessage,\n                SystemMessage,\n                ToolMessage,\n            )\n\n            messages = [\n                SystemMessage([{\"type\": \"text\", \"text\": \"foo\"}]),\n                {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"whats in this\"}, {\"type\": \"image_url\", \"image_url\": {\"url\": \"data:image/png;base64,'/9j/4AAQSk'\"}}]},\n                AIMessage(\"\", tool_calls=[{\"name\": \"analyze\", \"args\": {\"baz\": \"buz\"}, \"id\": \"1\", \"type\": \"tool_call\"}]),\n                ToolMessage(\"foobar\", tool_call_id=\"1\", name=\"bar\"),\n                {\"role\": \"assistant\", \"content\": \"thats nice\"},\n            ]\n            oai_messages = convert_to_openai_messages(messages)\n            # -> [\n            #   {'role': 'system', 'content': 'foo'},\n            #   {'role': 'user', 'content': [{'type': 'text', 'text': 'whats in this'}, {'type': 'image_url', 'image_url': {'url': \"data:image/png;base64,'/9j/4AAQSk'\"}}]},\n            #   {'role': 'assistant', 'tool_calls': [{'type': 'function', 'id': '1','function': {'name': 'analyze', 'arguments': '{\"baz\": \"buz\"}'}}], 'content': ''},\n            #   {'role': 'tool', 'name': 'bar', 'content': 'foobar'},\n            #   {'role': 'assistant', 'content': 'thats nice'}\n            # ]\n\n    .. versionadded:: 0.3.11\n\n    \"\"\"  # noqa: E501\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.ai.add_ai_message_chunks", "project": "langchain_core", "func": "add_ai_message_chunks", "origin_file": "langchain_core/messages/ai.py", "test_list": ["tests/unit_tests/output_parsers/test_openai_tools.py"], "prob_info": {"func_start_lineno": 406, "func_end_lineno": 454, "key_block_start_lineno": 410, "key_block_end_lineno": 454, "new_func_code": "def add_ai_message_chunks(\n    left: AIMessageChunk, *others: AIMessageChunk\n) -> AIMessageChunk:\n    \"\"\"Add multiple AIMessageChunks together.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.output_parsers.openai_tools.JsonOutputToolsParser::parse_result", "project": "langchain_core", "func": "JsonOutputToolsParser::parse_result", "origin_file": "langchain_core/output_parsers/openai_tools.py", "test_list": ["tests/unit_tests/output_parsers/test_openai_tools.py"], "prob_info": {"func_start_lineno": 154, "func_end_lineno": 198, "key_block_start_lineno": 171, "key_block_end_lineno": 198, "new_func_code": "def parse_result(self, result: list[Generation], *, partial: bool = False) -> Any:\n        \"\"\"Parse the result of an LLM call to a list of tool calls.\n\n        Args:\n            result: The result of the LLM call.\n            partial: Whether to parse partial JSON.\n                If True, the output will be a JSON object containing\n                all the keys that have been returned so far.\n                If False, the output will be the full JSON object.\n                Default is False.\n\n        Returns:\n            The parsed tool calls.\n\n        Raises:\n            OutputParserException: If the output is not valid JSON.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.mustache.render", "project": "langchain_core", "func": "render", "origin_file": "langchain_core/utils/mustache.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 412, "func_end_lineno": 653, "key_block_start_lineno": 452, "key_block_end_lineno": 653, "new_func_code": "def render(\n    template: Union[str, list[tuple[str, str]]] = \"\",\n    data: Mapping[str, Any] = EMPTY_DICT,\n    partials_dict: Mapping[str, str] = EMPTY_DICT,\n    padding: str = \"\",\n    def_ldel: str = \"{{\",\n    def_rdel: str = \"}}\",\n    scopes: Optional[Scopes] = None,\n    warn: bool = False,\n    keep: bool = False,\n) -> str:\n    \"\"\"Render a mustache template.\n\n    Renders a mustache template with a data scope and inline partial capability.\n\n    Args:\n        template: A file-like object or a string containing the template.\n        data: A python dictionary with your data scope.\n        partials_path: The path to where your partials are stored.\n             If set to None, then partials won't be loaded from the file system\n             (defaults to '.').\n        partials_ext: The extension that you want the parser to look for\n            (defaults to 'mustache').\n        partials_dict: A python dictionary which will be search for partials\n             before the filesystem is. {'include': 'foo'} is the same\n             as a file called include.mustache\n             (defaults to {}).\n        padding: This is for padding partials, and shouldn't be used\n            (but can be if you really want to).\n        def_ldel: The default left delimiter\n             (\"{{\" by default, as in spec compliant mustache).\n        def_rdel: The default right delimiter\n             (\"}}\" by default, as in spec compliant mustache).\n        scopes: The list of scopes that get_key will look through.\n        warn: Log a warning when a template substitution isn't found in the data\n        keep: Keep unreplaced tags when a substitution isn't found in the data.\n\n    Returns:\n        A string containing the rendered template.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.mustache.tokenize", "project": "langchain_core", "func": "tokenize", "origin_file": "langchain_core/utils/mustache.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 189, "func_end_lineno": 308, "key_block_start_lineno": 217, "key_block_end_lineno": 308, "new_func_code": "def tokenize(\n    template: str, def_ldel: str = \"{{\", def_rdel: str = \"}}\"\n) -> Iterator[tuple[str, str]]:\n    \"\"\"Tokenize a mustache template.\n\n    Tokenizes a mustache template in a generator fashion,\n    using file-like objects. It also accepts a string containing\n    the template.\n\n    Args:\n        template: a file-like object, or a string of a mustache template\n        def_ldel: The default left delimiter\n            (\"{{\" by default, as in spec compliant mustache)\n        def_rdel: The default right delimiter\n            (\"}}\" by default, as in spec compliant mustache)\n\n    Returns:\n        A generator of mustache tags in the form of a tuple (tag_type, tag_key)\n            Where tag_type is one of:\n             * literal\n             * section\n             * inverted section\n             * end\n             * partial\n             * no escape\n            And tag_key is either the key or in the case of a literal tag,\n            the literal itself.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.mustache.grab_literal", "project": "langchain_core", "func": "grab_literal", "origin_file": "langchain_core/utils/mustache.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 40, "func_end_lineno": 62, "key_block_start_lineno": 50, "key_block_end_lineno": 62, "new_func_code": "def grab_literal(template: str, l_del: str) -> tuple[str, str]:\n    \"\"\"Parse a literal from the template.\n\n    Args:\n        template: The template to parse.\n        l_del: The left delimiter.\n\n    Returns:\n        Tuple[str, str]: The literal and the template.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.mustache.l_sa_check", "project": "langchain_core", "func": "l_sa_check", "origin_file": "langchain_core/utils/mustache.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 65, "func_end_lineno": 85, "key_block_start_lineno": 76, "key_block_end_lineno": 85, "new_func_code": "def l_sa_check(template: str, literal: str, is_standalone: bool) -> bool:\n    \"\"\"Do a preliminary check to see if a tag could be a standalone.\n\n    Args:\n        template: The template. (Not used.)\n        literal: The literal.\n        is_standalone: Whether the tag is standalone.\n\n    Returns:\n        bool: Whether the tag could be a standalone.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.mustache.parse_tag", "project": "langchain_core", "func": "parse_tag", "origin_file": "langchain_core/utils/mustache.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 111, "func_end_lineno": 181, "key_block_start_lineno": 126, "key_block_end_lineno": 181, "new_func_code": "def parse_tag(template: str, l_del: str, r_del: str) -> tuple[tuple[str, str], str]:\n    \"\"\"Parse a tag from a template.\n\n    Args:\n        template: The template.\n        l_del: The left delimiter.\n        r_del: The right delimiter.\n\n    Returns:\n        Tuple[Tuple[str, str], str]: The tag and the template.\n\n    Raises:\n        ChevronError: If the tag is unclosed.\n        ChevronError: If the set delimiter tag is unclosed.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.mustache.r_sa_check", "project": "langchain_core", "func": "r_sa_check", "origin_file": "langchain_core/utils/mustache.py", "test_list": ["tests/unit_tests/prompts/test_structured.py"], "prob_info": {"func_start_lineno": 88, "func_end_lineno": 108, "key_block_start_lineno": 99, "key_block_end_lineno": 108, "new_func_code": "def r_sa_check(template: str, tag_type: str, is_standalone: bool) -> bool:\n    \"\"\"Do a final check to see if a tag could be a standalone.\n\n    Args:\n        template: The template.\n        tag_type: The type of the tag.\n        is_standalone: Whether the tag is standalone.\n\n    Returns:\n        bool: Whether the tag could be a standalone.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.RunnableSequence::config_specs", "project": "langchain_core", "func": "RunnableSequence::config_specs", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/runnables/test_context.py"], "prob_info": {"func_start_lineno": 2853, "func_end_lineno": 2901, "key_block_start_lineno": 2859, "key_block_end_lineno": 2901, "new_func_code": "def config_specs(self) -> list[ConfigurableFieldSpec]:\n        \"\"\"Get the config specs of the Runnable.\n\n        Returns:\n            The config specs of the Runnable.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.config.get_executor_for_config", "project": "langchain_core", "func": "get_executor_for_config", "origin_file": "langchain_core/runnables/config.py", "test_list": ["tests/unit_tests/runnables/test_context.py"], "prob_info": {"func_start_lineno": 538, "func_end_lineno": 553, "key_block_start_lineno": 549, "key_block_end_lineno": 553, "new_func_code": "def get_executor_for_config(\n    config: Optional[RunnableConfig],\n) -> Generator[Executor, None, None]:\n    \"\"\"Get an executor for a config.\n\n    Args:\n        config (RunnableConfig): The config.\n\n    Yields:\n        Generator[Executor, None, None]: The executor.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.config.ContextThreadPoolExecutor::map", "project": "langchain_core", "func": "ContextThreadPoolExecutor::map", "origin_file": "langchain_core/runnables/config.py", "test_list": ["tests/unit_tests/runnables/test_context.py"], "prob_info": {"func_start_lineno": 505, "func_end_lineno": 534, "key_block_start_lineno": 524, "key_block_end_lineno": 534, "new_func_code": "def map(\n        self,\n        fn: Callable[..., T],\n        *iterables: Iterable[Any],\n        timeout: float | None = None,\n        chunksize: int = 1,\n    ) -> Iterator[T]:\n        \"\"\"Map a function to multiple iterables.\n\n        Args:\n            fn (Callable[..., T]): The function to map.\n            *iterables (Iterable[Any]): The iterables to map over.\n            timeout (float | None, optional): The timeout for the map.\n                Defaults to None.\n            chunksize (int, optional): The chunksize for the map. Defaults to 1.\n\n        Returns:\n            Iterator[T]: The iterator for the mapped function.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.config.ContextThreadPoolExecutor::submit", "project": "langchain_core", "func": "ContextThreadPoolExecutor::submit", "origin_file": "langchain_core/runnables/config.py", "test_list": ["tests/unit_tests/runnables/test_context.py"], "prob_info": {"func_start_lineno": 485, "func_end_lineno": 503, "key_block_start_lineno": 501, "key_block_end_lineno": 503, "new_func_code": "def submit(  # type: ignore[override]\n        self,\n        func: Callable[P, T],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -> Future[T]:\n        \"\"\"Submit a function to the executor.\n\n        Args:\n            func (Callable[..., T]): The function to submit.\n            *args (Any): The positional arguments to the function.\n            **kwargs (Any): The keyword arguments to the function.\n\n        Returns:\n            Future[T]: The future for the function.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.utils.add", "project": "langchain_core", "func": "add", "origin_file": "langchain_core/runnables/utils.py", "test_list": ["tests/unit_tests/runnables/test_context.py"], "prob_info": {"func_start_lineno": 508, "func_end_lineno": 520, "key_block_start_lineno": 517, "key_block_end_lineno": 520, "new_func_code": "def add(addables: Iterable[Addable]) -> Optional[Addable]:\n    \"\"\"Add a sequence of addable objects together.\n\n    Args:\n        addables: The addable objects to add.\n\n    Returns:\n        Optional[Addable]: The result of adding the addable objects.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.RunnableParallel::get_name", "project": "langchain_core", "func": "RunnableParallel::get_name", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/runnables/test_context.py"], "prob_info": {"func_start_lineno": 3557, "func_end_lineno": 3570, "key_block_start_lineno": 3569, "key_block_end_lineno": 3570, "new_func_code": "def get_name(\n        self, suffix: Optional[str] = None, *, name: Optional[str] = None\n    ) -> str:\n        \"\"\"Get the name of the Runnable.\n\n        Args:\n            suffix: The suffix to use. Defaults to None.\n            name: The name to use. Defaults to None.\n\n        Returns:\n            The name of the Runnable.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.callbacks.manager.CallbackManagerForLLMRun::on_llm_error", "project": "langchain_core", "func": "CallbackManagerForLLMRun::on_llm_error", "origin_file": "langchain_core/callbacks/manager.py", "test_list": ["tests/unit_tests/runnables/test_fallbacks.py"], "prob_info": {"func_start_lineno": 696, "func_end_lineno": 718, "key_block_start_lineno": 709, "key_block_end_lineno": 718, "new_func_code": "def on_llm_error(\n        self,\n        error: BaseException,\n        **kwargs: Any,\n    ) -> None:\n        \"\"\"Run when LLM errors.\n\n        Args:\n            error (Exception or KeyboardInterrupt): The error.\n            kwargs (Any): Additional keyword arguments.\n                - response (LLMResult): The response which was generated before\n                    the error occurred.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph_ascii.AsciiCanvas::box", "project": "langchain_core", "func": "AsciiCanvas::box", "origin_file": "langchain_core/runnables/graph_ascii.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 130, "func_end_lineno": 157, "key_block_start_lineno": 139, "key_block_end_lineno": 157, "new_func_code": "def box(self, x0: int, y0: int, width: int, height: int) -> None:\n        \"\"\"Create a box on ASCII canvas.\n\n        Args:\n            x0 (int): x coordinate of the box corner.\n            y0 (int): y coordinate of the box corner.\n            width (int): box width.\n            height (int): box height.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph.node_data_json", "project": "langchain_core", "func": "node_data_json", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 199, "func_end_lineno": 252, "key_block_start_lineno": 212, "key_block_end_lineno": 252, "new_func_code": "def node_data_json(\n    node: Node, *, with_schemas: bool = False\n) -> dict[str, Union[str, dict[str, Any]]]:\n    \"\"\"Convert the data of a node to a JSON-serializable format.\n\n    Args:\n        node: The node to convert.\n        with_schemas: Whether to include the schema of the data if\n            it is a Pydantic model. Defaults to False.\n\n    Returns:\n        A dictionary with the type of the data and the data itself.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.RunnableSequence::get_graph", "project": "langchain_core", "func": "RunnableSequence::get_graph", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 2903, "func_end_lineno": 2932, "key_block_start_lineno": 2915, "key_block_end_lineno": 2932, "new_func_code": "def get_graph(self, config: Optional[RunnableConfig] = None) -> Graph:\n        \"\"\"Get the graph representation of the Runnable.\n\n        Args:\n            config: The config to use. Defaults to None.\n\n        Returns:\n            The graph representation of the Runnable.\n\n        Raises:\n            ValueError: If a Runnable has no first or last node.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.prompts.prompt.PromptTemplate::get_input_schema", "project": "langchain_core", "func": "PromptTemplate::get_input_schema", "origin_file": "langchain_core/prompts/prompt.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 117, "func_end_lineno": 129, "key_block_start_lineno": 126, "key_block_end_lineno": 129, "new_func_code": "def get_input_schema(self, config: RunnableConfig | None = None) -> type[BaseModel]:\n        \"\"\"Get the input schema for the prompt.\n\n        Args:\n            config: The runnable configuration.\n\n        Returns:\n            The input schema for the prompt.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph.Graph::remove_node", "project": "langchain_core", "func": "Graph::remove_node", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 341, "func_end_lineno": 352, "key_block_start_lineno": 347, "key_block_end_lineno": 352, "new_func_code": "def remove_node(self, node: Node) -> None:\n        \"\"\"Remove a node from the graph and all edges connected to it.\n\n        Args:\n            node: The node to remove.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph.Graph::extend", "project": "langchain_core", "func": "Graph::extend", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 387, "func_end_lineno": 422, "key_block_start_lineno": 400, "key_block_end_lineno": 422, "new_func_code": "def extend(\n        self, graph: Graph, *, prefix: str = \"\"\n    ) -> tuple[Optional[Node], Optional[Node]]:\n        \"\"\"Add all nodes and edges from another graph.\n        Note this doesn't check for duplicates, nor does it connect the graphs.\n\n        Args:\n            graph: The graph to add.\n            prefix: The prefix to add to the node ids. Defaults to \"\".\n\n        Returns:\n            A tuple of the first and last nodes of the subgraph.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph.Node::copy", "project": "langchain_core", "func": "Node::copy", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 108, "func_end_lineno": 123, "key_block_start_lineno": 118, "key_block_end_lineno": 123, "new_func_code": "def copy(self, *, id: Optional[str] = None, name: Optional[str] = None) -> Node:\n        \"\"\"Return a copy of the node with optional new id and name.\n\n        Args:\n            id: The new node id. Defaults to None.\n            name: The new node name. Defaults to None.\n\n        Returns:\n            A copy of the node with the new id and name.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph.Edge::copy", "project": "langchain_core", "func": "Edge::copy", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 73, "func_end_lineno": 90, "key_block_start_lineno": 85, "key_block_end_lineno": 90, "new_func_code": "def copy(\n        self, *, source: Optional[str] = None, target: Optional[str] = None\n    ) -> Edge:\n        \"\"\"Return a copy of the edge with optional new source and target nodes.\n\n        Args:\n            source: The new source node id. Defaults to None.\n            target: The new target node id. Defaults to None.\n\n        Returns:\n            A copy of the edge with the new source and target nodes.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.RunnableParallel::get_graph", "project": "langchain_core", "func": "RunnableParallel::get_graph", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 3636, "func_end_lineno": 3670, "key_block_start_lineno": 3648, "key_block_end_lineno": 3670, "new_func_code": "def get_graph(self, config: Optional[RunnableConfig] = None) -> Graph:\n        \"\"\"Get the graph representation of the Runnable.\n\n        Args:\n            config: The config to use. Defaults to None.\n\n        Returns:\n            The graph representation of the Runnable.\n\n        Raises:\n            ValueError: If a Runnable has no first or last node.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.RunnableParallel::get_input_schema", "project": "langchain_core", "func": "RunnableParallel::get_input_schema", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 3582, "func_end_lineno": 3609, "key_block_start_lineno": 3593, "key_block_end_lineno": 3609, "new_func_code": "def get_input_schema(\n        self, config: Optional[RunnableConfig] = None\n    ) -> type[BaseModel]:\n        \"\"\"Get the input schema of the Runnable.\n\n        Args:\n            config: The config to use. Defaults to None.\n\n        Returns:\n            The input schema of the Runnable.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.RunnableParallel::get_output_schema", "project": "langchain_core", "func": "RunnableParallel::get_output_schema", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 3611, "func_end_lineno": 3623, "key_block_start_lineno": 3622, "key_block_end_lineno": 3623, "new_func_code": "def get_output_schema(\n        self, config: Optional[RunnableConfig] = None\n    ) -> type[BaseModel]:\n        \"\"\"Get the output schema of the Runnable.\n\n        Args:\n            config: The config to use. Defaults to None.\n\n        Returns:\n            The output schema of the Runnable.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.base.RunnableLambda::OutputType", "project": "langchain_core", "func": "RunnableLambda::OutputType", "origin_file": "langchain_core/runnables/base.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 4422, "func_end_lineno": 4442, "key_block_start_lineno": 4428, "key_block_end_lineno": 4442, "new_func_code": "def OutputType(self) -> Any:\n        \"\"\"The type of the output of this Runnable as a type annotation.\n\n        Returns:\n            The type of the output of this Runnable.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph.Graph::draw_mermaid", "project": "langchain_core", "func": "Graph::draw_mermaid", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 558, "func_end_lineno": 593, "key_block_start_lineno": 578, "key_block_end_lineno": 593, "new_func_code": "def draw_mermaid(\n        self,\n        *,\n        with_styles: bool = True,\n        curve_style: CurveStyle = CurveStyle.LINEAR,\n        node_colors: Optional[NodeStyles] = None,\n        wrap_label_n_words: int = 9,\n    ) -> str:\n        \"\"\"Draw the graph as a Mermaid syntax string.\n\n        Args:\n            with_styles: Whether to include styles in the syntax. Defaults to True.\n            curve_style: The style of the edges. Defaults to CurveStyle.LINEAR.\n            node_colors: The colors of the nodes. Defaults to NodeStyles().\n            wrap_label_n_words: The number of words to wrap the node labels at.\n                Defaults to 9.\n\n        Returns:\n            The Mermaid syntax string.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph_mermaid.draw_mermaid", "project": "langchain_core", "func": "draw_mermaid", "origin_file": "langchain_core/runnables/graph_mermaid.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 18, "func_end_lineno": 164, "key_block_start_lineno": 49, "key_block_end_lineno": 164, "new_func_code": "def draw_mermaid(\n    nodes: dict[str, Node],\n    edges: list[Edge],\n    *,\n    first_node: Optional[str] = None,\n    last_node: Optional[str] = None,\n    with_styles: bool = True,\n    curve_style: CurveStyle = CurveStyle.LINEAR,\n    node_styles: Optional[NodeStyles] = None,\n    wrap_label_n_words: int = 9,\n) -> str:\n    \"\"\"Draws a Mermaid graph using the provided graph data.\n\n    Args:\n        nodes (dict[str, str]): List of node ids.\n        edges (List[Edge]): List of edges, object with a source,\n            target and data.\n        first_node (str, optional): Id of the first node. Defaults to None.\n        last_node (str, optional): Id of the last node. Defaults to None.\n        with_styles (bool, optional): Whether to include styles in the graph.\n            Defaults to True.\n        curve_style (CurveStyle, optional): Curve style for the edges.\n            Defaults to CurveStyle.LINEAR.\n        node_styles (NodeStyles, optional): Node colors for different types.\n            Defaults to NodeStyles().\n        wrap_label_n_words (int, optional): Words to wrap the edge labels.\n            Defaults to 9.\n\n    Returns:\n        str: Mermaid graph syntax.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.tools.base._function_annotations_are_pydantic_v1", "project": "langchain_core", "func": "_function_annotations_are_pydantic_v1", "origin_file": "langchain_core/tools/base.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 173, "func_end_lineno": 191, "key_block_start_lineno": 177, "key_block_end_lineno": 191, "new_func_code": "def _function_annotations_are_pydantic_v1(\n    signature: inspect.Signature, func: Callable\n) -> bool:\n    \"\"\"Determine if all Pydantic annotations in a function signature are from V1.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.function_calling.tool_example_to_messages", "project": "langchain_core", "func": "tool_example_to_messages", "origin_file": "langchain_core/utils/function_calling.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 505, "func_end_lineno": 605, "key_block_start_lineno": 578, "key_block_end_lineno": 605, "new_func_code": "def tool_example_to_messages(\n    input: str,\n    tool_calls: list[BaseModel],\n    tool_outputs: Optional[list[str]] = None,\n    *,\n    ai_response: Optional[str] = None,\n) -> list[BaseMessage]:\n    \"\"\"Convert an example into a list of messages that can be fed into an LLM.\n\n    This code is an adapter that converts a single example to a list of messages\n    that can be fed into a chat model.\n\n    The list of messages per example by default corresponds to:\n\n    1) HumanMessage: contains the content from which content should be extracted.\n    2) AIMessage: contains the extracted information from the model\n    3) ToolMessage: contains confirmation to the model that the model requested a tool\n        correctly.\n\n    If `ai_response` is specified, there will be a final AIMessage with that response.\n\n    The ToolMessage is required because some chat models are hyper-optimized for agents\n    rather than for an extraction use case.\n\n    Arguments:\n        input: string, the user input\n        tool_calls: List[BaseModel], a list of tool calls represented as Pydantic\n            BaseModels\n        tool_outputs: Optional[List[str]], a list of tool call outputs.\n            Does not need to be provided. If not provided, a placeholder value\n            will be inserted. Defaults to None.\n        ai_response: Optional[str], if provided, content for a final AIMessage.\n\n    Returns:\n        A list of messages\n\n    Examples:\n\n        .. code-block:: python\n\n            from typing import List, Optional\n            from pydantic import BaseModel, Field\n            from langchain_openai import ChatOpenAI\n\n            class Person(BaseModel):\n                '''Information about a person.'''\n                name: Optional[str] = Field(..., description=\"The name of the person\")\n                hair_color: Optional[str] = Field(\n                    ..., description=\"The color of the person's hair if known\"\n                )\n                height_in_meters: Optional[str] = Field(\n                    ..., description=\"Height in METERs\"\n                )\n\n            examples = [\n                (\n                    \"The ocean is vast and blue. It's more than 20,000 feet deep.\",\n                    Person(name=None, height_in_meters=None, hair_color=None),\n                ),\n                (\n                    \"Fiona traveled far from France to Spain.\",\n                    Person(name=\"Fiona\", height_in_meters=None, hair_color=None),\n                ),\n            ]\n\n\n            messages = []\n\n            for txt, tool_call in examples:\n                messages.extend(\n                    tool_example_to_messages(txt, [tool_call])\n                )\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.vectorstores.in_memory.InMemoryVectorStore::add_documents", "project": "langchain_core", "func": "InMemoryVectorStore::add_documents", "origin_file": "langchain_core/vectorstores/in_memory.py", "test_list": ["tests/unit_tests/vectorstores/test_in_memory.py"], "prob_info": {"func_start_lineno": 178, "func_end_lineno": 212, "key_block_start_lineno": 185, "key_block_end_lineno": 212, "new_func_code": "def add_documents(\n        self,\n        documents: list[Document],\n        ids: Optional[list[str]] = None,\n        **kwargs: Any,\n    ) -> list[str]:\n        \"\"\"Add documents to the store.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.messages.ai.add_usage", "project": "langchain_core", "func": "add_usage", "origin_file": "langchain_core/messages/ai.py", "test_list": ["tests/unit_tests/messages/test_ai.py"], "prob_info": {"func_start_lineno": 457, "func_end_lineno": 509, "key_block_start_lineno": 495, "key_block_end_lineno": 509, "new_func_code": "def add_usage(\n    left: Optional[UsageMetadata], right: Optional[UsageMetadata]\n) -> UsageMetadata:\n    \"\"\"Recursively add two UsageMetadata objects.\n\n    Example:\n        .. code-block:: python\n\n            from langchain_core.messages.ai import add_usage\n\n            left = UsageMetadata(\n                input_tokens=5,\n                output_tokens=0,\n                total_tokens=5,\n                input_token_details=InputTokenDetails(cache_read=3)\n            )\n            right = UsageMetadata(\n                input_tokens=0,\n                output_tokens=10,\n                total_tokens=10,\n                output_token_details=OutputTokenDetails(reasoning=4)\n            )\n\n            add_usage(left, right)\n\n        results in\n\n        .. code-block:: python\n\n            UsageMetadata(\n                input_tokens=5,\n                output_tokens=10,\n                total_tokens=15,\n                input_token_details=InputTokenDetails(cache_read=3),\n                output_token_details=OutputTokenDetails(reasoning=4)\n            )\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.language_models.fake.FakeListLLM::_call", "project": "langchain_core", "func": "FakeListLLM::_call", "origin_file": "langchain_core/language_models/fake.py", "test_list": ["tests/unit_tests/runnables/test_fallbacks.py"], "prob_info": {"func_start_lineno": 38, "func_end_lineno": 51, "key_block_start_lineno": 46, "key_block_end_lineno": 51, "new_func_code": "def _call(\n        self,\n        prompt: str,\n        stop: Optional[list[str]] = None,\n        run_manager: Optional[CallbackManagerForLLMRun] = None,\n        **kwargs: Any,\n    ) -> str:\n        \"\"\"Return next response.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph._last_node", "project": "langchain_core", "func": "_last_node", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 653, "func_end_lineno": 664, "key_block_start_lineno": 659, "key_block_end_lineno": 664, "new_func_code": "def _last_node(graph: Graph, exclude: Sequence[str] = ()) -> Optional[Node]:\n    \"\"\"Find the single node that is not a source of any edge.\n    Exclude nodes/targets with ids in the exclude list.\n    If there is no such node, or there are multiple, return None.\n    When drawing the graph, this node would be the destination.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.pydantic._create_subset_model", "project": "langchain_core", "func": "_create_subset_model", "origin_file": "langchain_core/utils/pydantic.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 317, "func_end_lineno": 355, "key_block_start_lineno": 326, "key_block_end_lineno": 355, "new_func_code": "def _create_subset_model(\n    name: str,\n    model: TypeBaseModel,\n    field_names: list[str],\n    *,\n    descriptions: Optional[dict] = None,\n    fn_description: Optional[str] = None,\n) -> type[BaseModel]:\n    \"\"\"Create subset model using the same pydantic version as the input model.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.tools.convert._get_schema_from_runnable_and_arg_types", "project": "langchain_core", "func": "_get_schema_from_runnable_and_arg_types", "origin_file": "langchain_core/tools/convert.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 343, "func_end_lineno": 360, "key_block_start_lineno": 349, "key_block_end_lineno": 360, "new_func_code": "def _get_schema_from_runnable_and_arg_types(\n    runnable: Runnable,\n    name: str,\n    arg_types: Optional[dict[str, type]] = None,\n) -> type[BaseModel]:\n    \"\"\"Infer args_schema for tool.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.tools.base._parse_python_function_docstring", "project": "langchain_core", "func": "_parse_python_function_docstring", "origin_file": "langchain_core/tools/base.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 110, "func_end_lineno": 122, "key_block_start_lineno": 117, "key_block_end_lineno": 122, "new_func_code": "def _parse_python_function_docstring(\n    function: Callable, annotations: dict, error_on_invalid_docstring: bool = False\n) -> tuple[str, dict]:\n    \"\"\"Parse the function and argument descriptions from the docstring of a function.\n\n    Assumes the function docstring follows Google Python style guide.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.sys_info._get_sub_deps", "project": "langchain_core", "func": "_get_sub_deps", "origin_file": "langchain_core/sys_info.py", "test_list": ["tests/unit_tests/test_sys_info.py"], "prob_info": {"func_start_lineno": 8, "func_end_lineno": 33, "key_block_start_lineno": 10, "key_block_end_lineno": 33, "new_func_code": "def _get_sub_deps(packages: Sequence[str]) -> list[str]:\n    \"\"\"Get any specified sub-dependencies.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.runnables.graph.Graph::add_node", "project": "langchain_core", "func": "Graph::add_node", "origin_file": "langchain_core/runnables/graph.py", "test_list": ["tests/unit_tests/runnables/test_graph.py"], "prob_info": {"func_start_lineno": 313, "func_end_lineno": 339, "key_block_start_lineno": 333, "key_block_end_lineno": 339, "new_func_code": "def add_node(\n        self,\n        data: Union[type[BaseModel], RunnableType],\n        id: Optional[str] = None,\n        *,\n        metadata: Optional[dict[str, Any]] = None,\n    ) -> Node:\n        \"\"\"Add a node to the graph and return it.\n\n        Args:\n            data: The data of the node.\n            id: The id of the node. Defaults to None.\n            metadata: Optional metadata for the node. Defaults to None.\n\n        Returns:\n            The node that was added to the graph.\n\n        Raises:\n            ValueError: If a node with the same id already exists.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.function_calling.convert_to_openai_function", "project": "langchain_core", "func": "convert_to_openai_function", "origin_file": "langchain_core/utils/function_calling.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 339, "func_end_lineno": 452, "key_block_start_lineno": 382, "key_block_end_lineno": 452, "new_func_code": "def convert_to_openai_function(\n    function: Union[dict[str, Any], type, Callable, BaseTool],\n    *,\n    strict: Optional[bool] = None,\n) -> dict[str, Any]:\n    \"\"\"Convert a raw function/class to an OpenAI function.\n\n    Args:\n        function:\n            A dictionary, Pydantic BaseModel class, TypedDict class, a LangChain\n            Tool object, or a Python function. If a dictionary is passed in, it is\n            assumed to already be a valid OpenAI function, a JSON schema with\n            top-level 'title' key specified, an Anthropic format\n            tool, or an Amazon Bedrock Converse format tool.\n        strict:\n            If True, model output is guaranteed to exactly match the JSON Schema\n            provided in the function definition. If None, ``strict`` argument will not\n            be included in function definition.\n\n    Returns:\n        A dict version of the passed in function which is compatible with the OpenAI\n        function-calling API.\n\n    Raises:\n        ValueError: If function is not in a supported format.\n\n    .. versionchanged:: 0.2.29\n\n        ``strict`` arg added.\n\n    .. versionchanged:: 0.3.13\n\n        Support for Anthropic format tools added.\n\n    .. versionchanged:: 0.3.14\n\n        Support for Amazon Bedrock Converse format tools added.\n\n    .. versionchanged:: 0.3.16\n\n        'description' and 'parameters' keys are now optional. Only 'name' is\n        required and guaranteed to be part of the output.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.function_calling._convert_python_function_to_openai_function", "project": "langchain_core", "func": "_convert_python_function_to_openai_function", "origin_file": "langchain_core/utils/function_calling.py", "test_list": ["tests/unit_tests/utils/test_function_calling.py"], "prob_info": {"func_start_lineno": 160, "func_end_lineno": 190, "key_block_start_lineno": 175, "key_block_end_lineno": 190, "new_func_code": "def _convert_python_function_to_openai_function(\n    function: Callable,\n) -> FunctionDescription:\n    \"\"\"Convert a Python function to an OpenAI function-calling API compatible dict.\n\n    Assumes the Python function has type hints and a docstring with a description. If\n        the docstring has Google Python style argument descriptions, these will be\n        included as well.\n\n    Args:\n        function: The Python function to convert.\n\n    Returns:\n        The OpenAI function description.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "langchain_core.libs.core.langchain_core.utils.utils.guard_import", "project": "langchain_core", "func": "guard_import", "origin_file": "langchain_core/utils/utils.py", "test_list": ["tests/unit_tests/utils/test_utils.py"], "prob_info": {"func_start_lineno": 115, "func_end_lineno": 143, "key_block_start_lineno": 134, "key_block_end_lineno": 143, "new_func_code": "def guard_import(\n    module_name: str, *, pip_name: Optional[str] = None, package: Optional[str] = None\n) -> Any:\n    \"\"\"Dynamically import a module and raise an exception if the module is not\n    installed.\n\n    Args:\n        module_name (str): The name of the module to import.\n        pip_name (str, optional): The name of the module to install with pip.\n            Defaults to None.\n        package (str, optional): The package to import the module from.\n            Defaults to None.\n\n    Returns:\n        Any: The imported module.\n\n    Raises:\n        ImportError: If the module is not installed.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.output.Output::chain", "project": "finam", "func": "Output::chain", "origin_file": "finam/sdk/output.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 428, "func_end_lineno": 444, "key_block_start_lineno": 441, "key_block_end_lineno": 444, "new_func_code": "def chain(self, other):\n        \"\"\"Chain outputs and adapters.\n\n        Parameters\n        ----------\n        other : :class:`.IInput` or :class:`.IAdapter`\n            The adapter or input to add as target to this output.\n\n        Returns\n        -------\n        :class:`.IOutput`\n            The last element of the chain.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.output.Output::add_target", "project": "finam", "func": "Output::add_target", "origin_file": "finam/sdk/output.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 117, "func_end_lineno": 130, "key_block_start_lineno": 125, "key_block_end_lineno": 130, "new_func_code": "def add_target(self, target):\n        \"\"\"Add a target input or adapter for this output.\n\n        Parameters\n        ----------\n        target : :class:`.IInput`\n            The target to add.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.tools.log_helper.is_loggable", "project": "finam", "func": "is_loggable", "origin_file": "finam/tools/log_helper.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 12, "func_end_lineno": 26, "key_block_start_lineno": 26, "key_block_end_lineno": 26, "new_func_code": "def is_loggable(obj):\n    \"\"\"\n    Check if given object is loggable.\n\n    Parameters\n    ----------\n    obj : object\n        Object to check for loggability\n\n    Returns\n    -------\n    bool\n        Loggability of the object.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.mask.mask_specified", "project": "finam", "func": "mask_specified", "origin_file": "finam/data/tools/mask.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 364, "func_end_lineno": 378, "key_block_start_lineno": 378, "key_block_end_lineno": 378, "new_func_code": "def mask_specified(mask):\n    \"\"\"\n    Determine whether given mask selection indicates a masked array.\n\n    Parameters\n    ----------\n    mask : :any:`Mask` value or valid boolean mask for :any:`MaskedArray`\n        mask to check\n\n    Returns\n    -------\n    bool\n        False if mask is Mask.FLEX or Mask.NONE, True otherwise\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.output.Output::push_info", "project": "finam", "func": "Output::push_info", "origin_file": "finam/sdk/output.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 204, "func_end_lineno": 216, "key_block_start_lineno": 212, "key_block_end_lineno": 216, "new_func_code": "def push_info(self, info):\n        \"\"\"Push data info into the output.\n\n        Parameters\n        ----------\n        info : :class:`.Info`\n            Delivered data info\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.input.Input::exchange_info", "project": "finam", "func": "Input::exchange_info", "origin_file": "finam/sdk/input.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 165, "func_end_lineno": 217, "key_block_start_lineno": 178, "key_block_end_lineno": 217, "new_func_code": "def exchange_info(self, info=None):\n        \"\"\"Exchange the data info with the input's source.\n\n        Parameters\n        ----------\n        info : :class:`.Info`\n            request parameters\n\n        Returns\n        -------\n        dict\n            delivered parameters\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.output.Output::get_info", "project": "finam", "func": "Output::get_info", "origin_file": "finam/sdk/output.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 360, "func_end_lineno": 426, "key_block_start_lineno": 380, "key_block_end_lineno": 426, "new_func_code": "def get_info(self, info):\n        \"\"\"Exchange and get the output's data info.\n\n        For internal use. To get the info in a component, use property :attr:`.info`.\n\n        Parameters\n        ----------\n        info : :class:`Info`\n            Requested data info\n\n        Returns\n        -------\n        dict\n            Delivered data info\n\n        Raises\n        ------\n        FinamNoDataError\n            Raises the error if no info is available\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.info.Info::accepts", "project": "finam", "func": "Info::accepts", "origin_file": "finam/data/tools/info.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 157, "func_end_lineno": 201, "key_block_start_lineno": 177, "key_block_end_lineno": 201, "new_func_code": "def accepts(self, incoming, fail_info, incoming_donwstream=False):\n        \"\"\"\n        Tests whether this info can accept/is compatible with an incoming info.\n\n        Tested attributes are: \"grid\", \"mask\" and \"units\"\n\n        Parameters\n        ----------\n        incoming : Info\n            Incoming/source info to check. This is the info from upstream.\n        fail_info : dict\n            Dictionary that will be filled with failed properties; name: (source, target).\n        incoming_donwstream : bool, optional\n            Whether the incoming info is from downstream data. Default: False\n\n        Returns\n        -------\n        bool\n            Whether the incoming info is accepted\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_spec.NoGrid::compatible_with", "project": "finam", "func": "NoGrid::compatible_with", "origin_file": "finam/data/grid_spec.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 71, "func_end_lineno": 87, "key_block_start_lineno": 87, "key_block_end_lineno": 87, "new_func_code": "def compatible_with(self, other, check_location=True):\n        \"\"\"\n        Check for compatibility with other Grid.\n\n        Parameters\n        ----------\n        other : instance of Grid\n            Other grid to compatibility with.\n        check_location : bool, optional\n            Whether to check location for equality, by default True\n\n        Returns\n        -------\n        bool\n            compatibility\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.mask.masks_compatible", "project": "finam", "func": "masks_compatible", "origin_file": "finam/data/tools/mask.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 285, "key_block_start_lineno": 267, "key_block_end_lineno": 285, "new_func_code": "def masks_compatible(\n    this, incoming, incoming_donwstream, this_grid=None, incoming_grid=None\n):\n    \"\"\"\n    Check if an incoming mask is compatible with a given mask.\n\n    Parameters\n    ----------\n    this : :any:`Mask` value or valid boolean mask for :any:`MaskedArray` or None\n        mask specification to check against\n    incoming : :any:`Mask` value or valid boolean mask for :any:`MaskedArray` or None\n        incoming mask to check for compatibility\n    incoming_donwstream : bool\n        Whether the incoming mask is from downstream data\n    this_grid : Grid or NoGrid or None, optional\n        grid for first mask (to check shape and value equality)\n    incoming_grid : Grid or NoGrid or None, optional\n        grid for second mask (to check shape and value equality)\n\n    Returns\n    -------\n    bool\n        mask compatibility\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.check_axes_monotonicity", "project": "finam", "func": "check_axes_monotonicity", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 218, "func_end_lineno": 251, "key_block_start_lineno": 238, "key_block_end_lineno": 251, "new_func_code": "def check_axes_monotonicity(axes):\n    \"\"\"\n    Check axes to be strictly monotonic, and makes them strictly monotonic increasing.\n\n    Parameters\n    ----------\n    axes : list of np.ndarray\n        Axes defining the coordinates in each direction (xyz order).\n        Will be modified inplace to be increasing.\n\n    Returns\n    -------\n    axes_increase : list of bool\n        False to indicate a bottom up axis.\n\n    Raises\n    ------\n    ValueError\n        In case an axis in not strictly monotonic.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.tools.enum_helper.get_enum_value", "project": "finam", "func": "get_enum_value", "origin_file": "finam/tools/enum_helper.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 6, "func_end_lineno": 40, "key_block_start_lineno": 32, "key_block_end_lineno": 40, "new_func_code": "def get_enum_value(value, enum_cls, error=ValueError):\n    \"\"\"\n    Convert value to corresponding enum value.\n\n    Parameters\n    ----------\n    value : any\n        Value to convert to enum value.\n    enum_cls : Enum\n        Enumeration class to get value from.\n    error : Exception, optional\n        Error to raise if value is not present in enum class,\n        by default ValueError\n\n    Returns\n    -------\n    enum\n        Corresponding Enum value.\n\n    Raises\n    ------\n    ValueError\n        If enum_cls is not a subclass of Enum\n    error\n        If value couldn't be found in given enum class.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.component.IOList::add", "project": "finam", "func": "IOList::add", "origin_file": "finam/sdk/component.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 602, "func_end_lineno": 635, "key_block_start_lineno": 624, "key_block_end_lineno": 635, "new_func_code": "def add(self, io=None, *, name=None, info=None, static=False, **info_kwargs):\n        \"\"\"\n        Add a new IO object either directly ob by attributes.\n\n        Parameters\n        ----------\n        io : :class:`.IInput` or :class:`.IOutput`, optional\n            IO object to add, by default None\n        name : str, optional\n            Name of the new IO object to add, by default None\n        info : :class:`.Info`, optional\n            Info of the new IO object to add, by default None\n        static : bool, optional\n            Whether the new IO object in static, by default False\n        **info_kwargs\n            Optional keyword arguments to instantiate an Info object\n\n        Raises\n        ------\n        ValueError\n            If io is not of the correct type.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.component.IOList::set_logger", "project": "finam", "func": "IOList::set_logger", "origin_file": "finam/sdk/component.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 642, "func_end_lineno": 667, "key_block_start_lineno": 656, "key_block_end_lineno": 667, "new_func_code": "def set_logger(self, module):\n        \"\"\"\n        Set the logger in the items of the IOList.\n\n        Parameters\n        ----------\n        module : :class:`.IComponent`\n            Module holding the IOList.\n\n        Raises\n        ------\n        FinamLogError\n            When item is loggable but not the base module.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.tools.connect_helper.ConnectHelper::connect", "project": "finam", "func": "ConnectHelper::connect", "origin_file": "finam/tools/connect_helper.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 331, "func_end_lineno": 425, "key_block_start_lineno": 355, "key_block_end_lineno": 425, "new_func_code": "def connect(self, start_time, exchange_infos=None, push_infos=None, push_data=None):\n        \"\"\"Exchange the info and data with linked components.\n\n        Values passed by the arguments are cached internally for later calls to the method\n        if constructed with ``cache=True`` (the default).\n        Thus, it is sufficient to provide only data and infos that became newly available.\n        Giving the same data or infos repeatedly overwrites the cache.\n\n        Parameters\n        ----------\n        start_time : :class:`datetime <datetime.datetime>`\n            the composition's starting time as passed to :meth:`.Component.try_connect`\n        exchange_infos : dict\n            currently or newly available input data infos by input name\n        push_infos : dict\n            currently or newly available output data infos by output name\n        push_data : dict\n            currently or newly available output data by output name\n\n        Returns\n        -------\n        ComponentStatus\n            the new component status\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.output.Output::push_data", "project": "finam", "func": "Output::push_data", "origin_file": "finam/sdk/output.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 152, "func_end_lineno": 202, "key_block_start_lineno": 164, "key_block_end_lineno": 202, "new_func_code": "def push_data(self, data, time):\n        \"\"\"Push data into the output.\n\n        Should notify targets, and can handle the provided date.\n\n        Parameters\n        ----------\n        data : array_like\n            Data set to push.\n        time : :class:`datetime <datetime.datetime>`\n            Simulation time of the data set.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.info.Info::copy_with", "project": "finam", "func": "Info::copy_with", "origin_file": "finam/data/tools/info.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 125, "func_end_lineno": 155, "key_block_start_lineno": 135, "key_block_end_lineno": 155, "new_func_code": "def copy_with(self, use_none=True, **kwargs):\n        \"\"\"Copies the info object and sets variables and meta values according to the kwargs\n\n        Parameters\n        ----------\n        use_none : bool\n            whether properties with None value should also be transferred\n        **kwargs\n            key values pairs for properties to change\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.gen_axes", "project": "finam", "func": "gen_axes", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/adapters/test_regrid_mask.py"], "prob_info": {"func_start_lineno": 78, "func_end_lineno": 107, "key_block_start_lineno": 98, "key_block_end_lineno": 107, "new_func_code": "def gen_axes(dims, spacing, origin, axes_increase=None):\n    \"\"\"\n    Generate uniform axes.\n\n    Parameters\n    ----------\n    dims : iterable\n        Dimensions of the uniform grid for each direction.\n    spacing : iterable\n        Spacing of the uniform in each dimension. Must be positive.\n    origin : iterable\n        Origin of the uniform grid.\n    axes_increase : arraylike or None, optional\n        False to indicate a bottom up axis (in xyz order), by default None\n\n    Returns\n    -------\n    list of np.ndarray\n        Axes of the uniform grid.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.gen_node_centers", "project": "finam", "func": "gen_node_centers", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/adapters/test_regrid_mask.py"], "prob_info": {"func_start_lineno": 54, "func_end_lineno": 75, "key_block_start_lineno": 68, "key_block_end_lineno": 75, "new_func_code": "def gen_node_centers(grid):\n    \"\"\"\n    Calculate the node centers of the given grid cells.\n\n    Parameters\n    ----------\n    grid : Grid\n        Grid to take the cells from.\n\n    Returns\n    -------\n    np.ndarray\n        Centroids for all cells.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.point_order", "project": "finam", "func": "point_order", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/adapters/test_regrid_mask.py"], "prob_info": {"func_start_lineno": 9, "func_end_lineno": 27, "key_block_start_lineno": 26, "key_block_end_lineno": 27, "new_func_code": "def point_order(order, axes_reversed=False):\n    \"\"\"\n    Determine apparent point order incorporating axes order reversion.\n\n    Parameters\n    ----------\n    order : str\n        Point and cell ordering.\n        Either Fortran-like (\"F\") or C-like (\"C\"), by default \"F\"\n    axes_reversed : arraylike or None, optional\n        Indicate reversed axes order for the associated data, by default False\n\n    Returns\n    -------\n    str\n        Apparent point ordering.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.gen_points", "project": "finam", "func": "gen_points", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/adapters/test_regrid_mask.py"], "prob_info": {"func_start_lineno": 110, "func_end_lineno": 149, "key_block_start_lineno": 129, "key_block_end_lineno": 149, "new_func_code": "def gen_points(axes, order=\"F\", axes_increase=None):\n    \"\"\"\n    Generate points from axes of a rectilinear grid.\n\n    Parameters\n    ----------\n    axes : list of np.ndarray\n        Axes defining the coordinates in each direction (xyz order).\n    order : str, optional\n        Point and cell ordering.\n        Either Fortran-like (\"F\") or C-like (\"C\"), by default \"F\"\n    axes_increase : arraylike or None, optional\n        False to indicate a bottom up axis (in xyz order), by default None\n\n    Returns\n    -------\n    np.ndarray\n        Points of the grid in given order and orientation.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.mask.from_compressed", "project": "finam", "func": "from_compressed", "origin_file": "finam/data/tools/mask.py", "test_list": ["../tests/adapters/test_regrid_mask.py"], "prob_info": {"func_start_lineno": 151, "func_end_lineno": 205, "key_block_start_lineno": 192, "key_block_end_lineno": 205, "new_func_code": "def from_compressed(xdata, shape, order=\"C\", mask=None, **kwargs):\n    \"\"\"\n    Fill a (masked) array following a given mask or shape with the provided data.\n\n    This will only create a masked array if kwargs are given (especially a mask).\n    Otherwise this is simply reshaping the given data.\n    Filling is performed in the given array order.\n\n    Parameters\n    ----------\n    data : :class:`pint.Quantity` or :class:`numpy.ndarray` or :class:`numpy.ma.MaskedArray`\n        The reference object input.\n    shape : str\n        shape argument for :any:`numpy.reshape`\n    order : str\n        order argument for :any:`numpy.reshape`\n    mask : :any:`Mask` value or valid boolean mask for :any:`MaskedArray`\n        mask to use\n    **kwargs\n        keyword arguments forwarded to :any:`numpy.ma.array`\n\n    Returns\n    -------\n    :class:`pint.Quantity` or :class:`numpy.ndarray` or :class:`numpy.ma.MaskedArray`\n        New object with the desired shape and same type as input.\n        Units will be taken from the input if present.\n        Will only be a masked array if kwargs are given.\n\n    See also\n    --------\n    to_compressed:\n        Inverse operation.\n    :any:`numpy.ma.array`:\n        Routine consuming kwargs to create a masked array.\n    :any:`numpy.reshape`:\n        Equivalent routine if no mask is provided.\n\n    Notes\n    -----\n    If both `mask` and `shape` are given, they need to match in size.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.schedule.Composition::run", "project": "finam", "func": "Composition::run", "origin_file": "finam/schedule.py", "test_list": ["../tests/adapters/test_time_integration.py"], "prob_info": {"func_start_lineno": 212, "func_end_lineno": 267, "key_block_start_lineno": 228, "key_block_end_lineno": 267, "new_func_code": "def run(self, start_time=None, end_time=None):\n        \"\"\"Run this composition using the loop-based update strategy.\n\n        Performs the connect phase if it ``connect()`` was not already called.\n\n        Parameters\n        ----------\n        start_time : :class:`datetime <datetime.datetime>`, optional\n            Starting time of the composition.\n            If provided, it should be the starting time of the earliest component.\n            If not provided, the composition tries to determine the starting time automatically.\n            Ignored if :meth:`.connect` was already called.\n        end_time : :class:`datetime <datetime.datetime>`, optional\n            Simulation time up to which to simulate.\n            Should be ``None`` if no components with time are present.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.cf_units.short_formatter", "project": "finam", "func": "short_formatter", "origin_file": "finam/data/tools/cf_units.py", "test_list": ["../tests/data/test_cf_units.py"], "prob_info": {"func_start_lineno": 17, "func_end_lineno": 60, "key_block_start_lineno": 34, "key_block_end_lineno": 60, "new_func_code": "def short_formatter(unit, registry, **options):\n    \"\"\"Return a CF-compliant unit string from a `pint` unit.\n\n    Parameters\n    ----------\n    unit : pint.UnitContainer\n        Input unit.\n    registry : pint.UnitRegistry\n        The associated registry\n    **options\n        Additional options (may be ignored)\n\n    Returns\n    -------\n    out : str\n        Units following CF-Convention, using symbols.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.esri_tools.standardize_header", "project": "finam", "func": "standardize_header", "origin_file": "finam/data/esri_tools.py", "test_list": ["../tests/data/test_grid_spec.py"], "prob_info": {"func_start_lineno": 39, "func_end_lineno": 72, "key_block_start_lineno": 59, "key_block_end_lineno": 72, "new_func_code": "def standardize_header(header):\n    \"\"\"\n    Standardize an ASCII grid header dictionary.\n\n    Parameters\n    ----------\n    header : :class:`dict`\n        Raw header as dictionary.\n\n    Returns\n    -------\n    :class:`dict`\n        Standardized header as dictionary.\n\n    Raises\n    ------\n    ValueError\n        If the header is missing required information.\n        See :any:`ESRI_REQ`\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_spec.EsriGrid::to_uniform", "project": "finam", "func": "EsriGrid::to_uniform", "origin_file": "finam/data/grid_spec.py", "test_list": ["../tests/data/test_grid_spec.py"], "prob_info": {"func_start_lineno": 451, "func_end_lineno": 471, "key_block_start_lineno": 460, "key_block_end_lineno": 471, "new_func_code": "def to_uniform(self):\n        \"\"\"\n        Cast grid to an uniform grid.\n\n        Returns\n        -------\n        UniformGrid\n            Grid as uniform grid.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_spec.UniformGrid::to_rectilinear", "project": "finam", "func": "UniformGrid::to_rectilinear", "origin_file": "finam/data/grid_spec.py", "test_list": ["../tests/data/test_grid_spec.py"], "prob_info": {"func_start_lineno": 344, "func_end_lineno": 364, "key_block_start_lineno": 353, "key_block_end_lineno": 364, "new_func_code": "def to_rectilinear(self):\n        \"\"\"\n        Cast grid to a rectilinear grid.\n\n        Returns\n        -------\n        UniformGrid\n            Grid as rectilinear grid.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_spec.UniformGrid::export_vtk", "project": "finam", "func": "UniformGrid::export_vtk", "origin_file": "finam/data/grid_spec.py", "test_list": ["../tests/data/test_grid_spec.py"], "prob_info": {"func_start_lineno": 298, "func_end_lineno": 342, "key_block_start_lineno": 332, "key_block_end_lineno": 342, "new_func_code": "def export_vtk(\n        self,\n        path,\n        data=None,\n        cell_data=None,\n        point_data=None,\n        field_data=None,\n        mesh_type=\"uniform\",\n    ):\n        \"\"\"\n        Export grid and data to a VTK file.\n\n        Parameters\n        ----------\n        path : pathlike\n            File path.\n            Suffix will be replaced according to mesh type (.vti, .vtr, .vtu)\n        data : dict or None, optional\n            Data in the corresponding shape given by name, by default None\n        cell_data : dict or None, optional\n            Additional cell data, by default None\n        point_data : dict or None, optional\n            Additional point data, by default None\n        field_data : dict or None, optional\n            Additional field data, by default None\n        mesh_type : str, optional\n            Mesh type (\"uniform\"/\"structured\"/\"unstructured\"),\n            by default \"structured\"\n\n        Raises\n        ------\n        ValueError\n            If mesh type is not supported.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.prepare_vtk_data", "project": "finam", "func": "prepare_vtk_data", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/data/test_grid_spec.py"], "prob_info": {"func_start_lineno": 332, "func_end_lineno": 363, "key_block_start_lineno": 357, "key_block_end_lineno": 363, "new_func_code": "def prepare_vtk_data(\n    data, axes_reversed=False, axes_increase=None, flat=False, order=\"F\"\n):\n    \"\"\"\n    Prepare data dictionary for VTK export.\n\n    Parameters\n    ----------\n    data : dict or None\n        Dictionary containing data arrays by name.\n    axes_reversed : bool, optional\n        Indicate reversed axes order for the associated data, by default False\n    axes_increase : arraylike or None, optional\n        False to indicate a bottom up axis (xyz order), by default None\n    flat : bool, optional\n        True to flatten data, by default False\n    order : str, optional\n        Point and cell ordering.\n        Either Fortran-like (\"F\") or C-like (\"C\"), by default \"F\"\n\n    Returns\n    -------\n    dict or None\n        Prepared data.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.check_axes_uniformity", "project": "finam", "func": "check_axes_uniformity", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/data/test_grid_tools.py"], "prob_info": {"func_start_lineno": 254, "func_end_lineno": 268, "key_block_start_lineno": 268, "key_block_end_lineno": 268, "new_func_code": "def check_axes_uniformity(axes):\n    \"\"\"\n    Check axes to be uniform.\n\n    Parameters\n    ----------\n    axes : list of np.ndarray\n        Axes defining the coordinates in each direction (xyz order).\n\n    Returns\n    -------\n    is_uniform : list of float\n        Spacing or NaN for each axis. NaN indicates non-uniformity\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.flatten_cells", "project": "finam", "func": "flatten_cells", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/data/test_grid_tools.py"], "prob_info": {"func_start_lineno": 382, "func_end_lineno": 401, "key_block_start_lineno": 397, "key_block_end_lineno": 401, "new_func_code": "def flatten_cells(cells):\n    \"\"\"\n    Flatten cells array.\n\n    Parameters\n    ----------\n    cells : np.ndarray\n        Cells given as 2D array containing cell defining node IDs.\n        -1 will be interpreted as used entries.\n\n    Returns\n    -------\n    np.ndarray\n        All cell definitions concatenated.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.get_cells_matrix", "project": "finam", "func": "get_cells_matrix", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/data/test_grid_tools.py"], "prob_info": {"func_start_lineno": 404, "func_end_lineno": 456, "key_block_start_lineno": 428, "key_block_end_lineno": 456, "new_func_code": "def get_cells_matrix(cell_types, cells, connectivity=False):\n    \"\"\"\n    Create the cells matrix as used in the Grid class.\n\n    Parameters\n    ----------\n    cell_types : np.ndarray\n        Cell types.\n\n    cells : np.ndarray\n        Either cell definitions given as list of number of nodes with node IDs:\n        ``[n0, p0_0, p0_1, ..., p0_n, n1, p1_0, p1_1, ..., p1_n, ...]``\n\n        Or cell connectivity given as list of node IDs:\n        ``[p0_0, p0_1, ..., p0_n, p1_0, p1_1, ..., p1_n, ...]``\n\n    connectivity : bool, optional\n        Indicate that cells are given by connectivity. Default: False\n\n    Returns\n    -------\n    np.ndarray\n        Cell nodes as 2D array.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.prepare_vtk_kwargs", "project": "finam", "func": "prepare_vtk_kwargs", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/data/test_grid_tools.py"], "prob_info": {"func_start_lineno": 295, "func_end_lineno": 329, "key_block_start_lineno": 317, "key_block_end_lineno": 329, "new_func_code": "def prepare_vtk_kwargs(data_location, data, cell_data, point_data, field_data):\n    \"\"\"\n    Prepare keyword arguments for evtk routines.\n\n    Parameters\n    ----------\n    data_location : Location\n        Data location in the grid, by default Location.CELLS\n    data : dict or None\n        Data in the corresponding shape given by name\n    cell_data : dict or None\n        Additional cell data\n    point_data : dict or None\n        Additional point data\n    field_data : dict or None\n        Additional field data\n\n    Returns\n    -------\n    dict\n        Keyword arguments.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.core.prepare", "project": "finam", "func": "prepare", "origin_file": "finam/data/tools/core.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 26, "func_end_lineno": 113, "key_block_start_lineno": 64, "key_block_end_lineno": 113, "new_func_code": "def prepare(data, info, time_entries=1, force_copy=False, report_conversion=False):\n    \"\"\"\n    Prepares data in FINAM's internal transmission format.\n\n    Checks tha shape of the data.\n    Checks or adds units and time dimension.\n\n    Parameters\n    ----------\n    data : arraylike\n        The input data.\n    info : Info\n        Info associated with the data.\n    time_entries : int, optional\n        Number of time slices in the data. Default 1.\n    force_copy : bool, optional\n        Forces the result to be a copy of the passed data. Default ``False``.\n\n        If not used, the result is a view of the data if no units conversion needs to be done.\n    report_conversion : bool, optional\n        If true, returns a tuple with the second element indicating the unit conversion if it was required.\n\n    Returns\n    -------\n    pint.Quantity or tuple(pint.Quantity, tuple(pint.Unit, pint.Unit) or None)\n        The prepared data as a numpy array, wrapped into a :class:`pint.Quantity`.\n\n        If ``report_conversion`` is ``True``, a tuple is returned with the second element\n        indicating the unit conversion if it was required.\n\n        The second element is ``None`` if no conversion was required,\n        and a tuple of two :class:`pint.Unit` objects otherwise.\n\n    Raises\n    ------\n    FinamDataError\n        If the data doesn't match its info.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.units.is_quantified", "project": "finam", "func": "is_quantified", "origin_file": "finam/data/tools/units.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 115, "func_end_lineno": 129, "key_block_start_lineno": 129, "key_block_end_lineno": 129, "new_func_code": "def is_quantified(xdata):\n    \"\"\"\n    Check if data is a quantified DataArray.\n\n    Parameters\n    ----------\n    xdata : Any\n        The given data array.\n\n    Returns\n    -------\n    bool\n        Whether the data is a quantified DataArray.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.units.compatible_units", "project": "finam", "func": "compatible_units", "origin_file": "finam/data/tools/units.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 186, "func_end_lineno": 207, "key_block_start_lineno": 202, "key_block_end_lineno": 207, "new_func_code": "def compatible_units(unit1, unit2):\n    \"\"\"\n    Checks if two units are compatible/convertible.\n\n    Parameters\n    ----------\n    unit1 : UnitLike or Quantified\n        First unit to compare.\n    unit2 : UnitLike or Quantified\n        Second unit to compare.\n\n    Returns\n    -------\n    bool\n        Unit compatibility.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.units.equivalent_units", "project": "finam", "func": "equivalent_units", "origin_file": "finam/data/tools/units.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 210, "func_end_lineno": 231, "key_block_start_lineno": 226, "key_block_end_lineno": 231, "new_func_code": "def equivalent_units(unit1, unit2):\n    \"\"\"\n    Check if two given units are equivalent.\n\n    Parameters\n    ----------\n    unit1 : UnitLike or Quantified\n        First unit to compare.\n    unit2 : UnitLike or Quantified\n        Second unit to compare.\n\n    Returns\n    -------\n    bool\n        Unit equivalence.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.output.Output::notify_targets", "project": "finam", "func": "Output::notify_targets", "origin_file": "finam/sdk/output.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 218, "func_end_lineno": 232, "key_block_start_lineno": 226, "key_block_end_lineno": 232, "new_func_code": "def notify_targets(self, time):\n        \"\"\"Notify all targets by calling their ``source_updated(time)`` method.\n\n        Parameters\n        ----------\n        time : :class:`datetime <datetime.datetime>`\n            Simulation time of the simulation.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.input.Input::pull_data", "project": "finam", "func": "Input::pull_data", "origin_file": "finam/sdk/input.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 101, "func_end_lineno": 136, "key_block_start_lineno": 119, "key_block_end_lineno": 136, "new_func_code": "def pull_data(self, time, target=None):\n        \"\"\"Retrieve the data from the input's source.\n\n        Parameters\n        ----------\n        time : :class:`datetime <datetime.datetime>`\n            Simulation time to get the data for.\n        target : :class:`.IInput` or None\n            Requesting end point of this pull.\n            Should be ``None`` for normal input pulls in components.\n            Simple adapters should forward the source in :meth:`.Adapter._get_data`.\n            Push-based adapters should use ``self`` in :meth:`.Adapter._source_updated`.\n\n        Returns\n        -------\n        :class:`pint.Quantity`\n            Data set for the given simulation time.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.adapters.probe.CallbackProbe::_get_data", "project": "finam", "func": "CallbackProbe::_get_data", "origin_file": "finam/adapters/probe.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 33, "func_end_lineno": 48, "key_block_start_lineno": 46, "key_block_end_lineno": 48, "new_func_code": "def _get_data(self, time, target):\n        \"\"\"Get the output's data-set for the given time.\n\n        Parameters\n        ----------\n        time : datetime\n            simulation time to get the data for.\n\n        Returns\n        -------\n        array_like\n            data-set for the requested time.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.output.Output::get_data", "project": "finam", "func": "Output::get_data", "origin_file": "finam/sdk/output.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 234, "func_end_lineno": 282, "key_block_start_lineno": 254, "key_block_end_lineno": 282, "new_func_code": "def get_data(self, time, target):\n        \"\"\"Get the output's data-set for the given time.\n\n        Parameters\n        ----------\n        time : :class:`datetime <datetime.datetime>`\n            simulation time to get the data for.\n        target : :class:`.IInput` or None\n            Requesting end point of this pull.\n\n        Returns\n        -------\n        :class:`pint.Quantity`\n            data-set for the requested time.\n\n        Raises\n        ------\n        FinamNoDataError\n            Raises the error if no data is available\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.units.to_units", "project": "finam", "func": "to_units", "origin_file": "finam/data/tools/units.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 73, "func_end_lineno": 112, "key_block_start_lineno": 99, "key_block_end_lineno": 112, "new_func_code": "def to_units(xdata, units, check_equivalent=False, report_conversion=False):\n    \"\"\"\n    Convert data to given units.\n\n    Parameters\n    ----------\n    xdata : pint.Quantity\n        The given data array.\n    units : str or pint.Unit\n        Desired units.\n    check_equivalent : bool, optional\n        Checks for equivalent units and simply re-assigns if possible.\n    report_conversion : bool, optional\n        If true, returns a tuple with the second element indicating the unit conversion if it was required.\n\n    Returns\n    -------\n    pint.Quantity or tuple(pint.Quantity, tuple(pint.Unit, pint.Unit) or None)\n        The converted data.\n\n        If ``report_conversion`` is ``True``, a tuple is returned with the second element\n        indicating the unit conversion if it was required.\n\n        The second element is ``None`` if no conversion was required,\n        and a tuple of two :class:`pint.Unit` objects otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.units.check_quantified", "project": "finam", "func": "check_quantified", "origin_file": "finam/data/tools/units.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 153, "func_end_lineno": 170, "key_block_start_lineno": 169, "key_block_end_lineno": 170, "new_func_code": "def check_quantified(xdata, routine=\"check_quantified\"):\n    \"\"\"\n    Check if data is a quantified DataArray.\n\n    Parameters\n    ----------\n    xdata : numpy.ndarray\n        The given data array.\n    routine : str, optional\n        Name of the routine to show in the Error, by default \"check_quantified\"\n\n    Raises\n    ------\n    FinamDataError\n        If the array is not a quantified DataArray.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.core.check", "project": "finam", "func": "check", "origin_file": "finam/data/tools/core.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 338, "key_block_start_lineno": 326, "key_block_end_lineno": 338, "new_func_code": "def check(xdata, info):\n    \"\"\"\n    Check if data matches given info.\n\n    Parameters\n    ----------\n    xdata : numpy.ndarray\n        The given data array.\n    info : Info\n        Info associated with the data.\n\n    Raises\n    ------\n    FinamDataError\n        If data doesn't match given info.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.core.has_time_axis", "project": "finam", "func": "has_time_axis", "origin_file": "finam/data/tools/core.py", "test_list": ["../tests/adapters/test_probe.py"], "prob_info": {"func_start_lineno": 187, "func_end_lineno": 219, "key_block_start_lineno": 202, "key_block_end_lineno": 219, "new_func_code": "def has_time_axis(xdata, grid):\n    \"\"\"\n    Check if the data array has a time axis.\n\n    Parameters\n    ----------\n    xdata : numpy.ndarray\n        The given data array.\n    grid : GridBase\n        The associated grid specification\n    Returns\n    -------\n    bool\n        Whether the data has a time axis.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.mask.is_masked_array", "project": "finam", "func": "is_masked_array", "origin_file": "finam/data/tools/mask.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 22, "func_end_lineno": 38, "key_block_start_lineno": 36, "key_block_end_lineno": 38, "new_func_code": "def is_masked_array(data):\n    \"\"\"\n    Check if data is a masked array.\n\n    Parameters\n    ----------\n    data : Any\n        The given data array.\n\n    Returns\n    -------\n    bool\n        Whether the data is a MaskedArray.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.mask.to_masked", "project": "finam", "func": "to_masked", "origin_file": "finam/data/tools/mask.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 93, "func_end_lineno": 114, "key_block_start_lineno": 110, "key_block_end_lineno": 114, "new_func_code": "def to_masked(data, **kwargs):\n    \"\"\"\n    Return a masked version of the data.\n\n    Parameters\n    ----------\n    data : :class:`pint.Quantity` or :class:`numpy.ndarray` or :class:`numpy.ma.MaskedArray`\n        The reference object input.\n    **kwargs\n        keyword arguments forwarded to :any:`numpy.ma.array`\n\n    Returns\n    -------\n    pint.Quantity or numpy.ma.MaskedArray\n        New object with the same shape and type but as a masked array.\n        Units will be taken from the input if present.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.units.get_magnitude", "project": "finam", "func": "get_magnitude", "origin_file": "finam/data/tools/units.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 19, "func_end_lineno": 34, "key_block_start_lineno": 33, "key_block_end_lineno": 34, "new_func_code": "def get_magnitude(xdata):\n    \"\"\"\n    Get magnitude of given data.\n\n    Parameters\n    ----------\n    xdata : pint.Quantity\n        The given data array.\n\n    Returns\n    -------\n    numpy.ndarray\n        Magnitude of given data.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.mask.to_compressed", "project": "finam", "func": "to_compressed", "origin_file": "finam/data/tools/mask.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 117, "func_end_lineno": 148, "key_block_start_lineno": 141, "key_block_end_lineno": 148, "new_func_code": "def to_compressed(xdata, order=\"C\", mask=None):\n    \"\"\"\n    Return all the non-masked data as a 1-D array respecting the given array order.\n\n    Parameters\n    ----------\n    data : :class:`pint.Quantity` or :class:`numpy.ndarray` or :class:`numpy.ma.MaskedArray`\n        The reference object input.\n    order : str\n        order argument for :any:`numpy.ravel`\n    mask : :any:`Mask` value or valid boolean mask for :any:`MaskedArray`, optional\n        mask to use when data is not masked already\n\n    Returns\n    -------\n    :class:`pint.Quantity` or :class:`numpy.ndarray` or :class:`numpy.ma.MaskedArray`\n        New object with the flat shape and only unmasked data but and same type as input.\n        Units will be taken from the input if present.\n\n    See also\n    --------\n    :func:`numpy.ma.compressed`:\n        Numpy routine doing the same but only for C-order.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.mask.masks_equal", "project": "finam", "func": "masks_equal", "origin_file": "finam/data/tools/mask.py", "test_list": ["../tests/adapters/test_regrid_mask.py"], "prob_info": {"func_start_lineno": 288, "func_end_lineno": 332, "key_block_start_lineno": 308, "key_block_end_lineno": 332, "new_func_code": "def masks_equal(this, other, this_grid=None, other_grid=None):\n    \"\"\"\n    Check two masks for equality.\n\n    Parameters\n    ----------\n    this : :any:`Mask` value or valid boolean mask for :any:`MaskedArray` or None\n        first mask\n    other : :any:`Mask` value or valid boolean mask for :any:`MaskedArray` or None\n        second mask\n    this_grid : Grid or NoGrid or None, optional\n        grid for first mask (to check shape and value equality)\n    other_grid : Grid or NoGrid or None, optional\n        grid for second mask (to check shape and value equality)\n\n    Returns\n    -------\n    bool\n        mask equality\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.input.CallbackInput::source_updated", "project": "finam", "func": "CallbackInput::source_updated", "origin_file": "finam/sdk/input.py", "test_list": ["../tests/adapters/test_regrid_mask.py"], "prob_info": {"func_start_lineno": 262, "func_end_lineno": 275, "key_block_start_lineno": 270, "key_block_end_lineno": 275, "new_func_code": "def source_updated(self, time):\n        \"\"\"Informs the input that a new output is available.\n\n        Parameters\n        ----------\n        time : :class:`datetime <datetime.datetime>`\n            Simulation time of the notification.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.units.quantify", "project": "finam", "func": "quantify", "origin_file": "finam/data/tools/units.py", "test_list": ["../tests/adapters/test_regrid_mask.py"], "prob_info": {"func_start_lineno": 132, "func_end_lineno": 150, "key_block_start_lineno": 148, "key_block_end_lineno": 150, "new_func_code": "def quantify(xdata, units=None):\n    \"\"\"\n    Quantifies data.\n\n    Parameters\n    ----------\n    xdata : Any\n        The given data array.\n    units : UnitLike or Quantified or None, optional\n        units to use, dimensionless by default\n\n    Returns\n    -------\n    pint.Quantity\n        The quantified array.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.output.CallbackOutput::get_data", "project": "finam", "func": "CallbackOutput::get_data", "origin_file": "finam/sdk/output.py", "test_list": ["../tests/adapters/test_stats.py"], "prob_info": {"func_start_lineno": 493, "func_end_lineno": 541, "key_block_start_lineno": 513, "key_block_end_lineno": 541, "new_func_code": "def get_data(self, time, target):\n        \"\"\"Get the output's data-set for the given time.\n\n        Parameters\n        ----------\n        time : :class:`datetime <datetime.datetime>`\n            Simulation time to get the data for.\n        target : :class:`.IInput`\n            Requesting end point of this pull\n\n        Returns\n        -------\n        :class:`pint.Quantity`\n            Data-set for the requested time.\n\n        Raises\n        ------\n        FinamNoDataError\n            Raises the error if no data is available\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.units.get_units", "project": "finam", "func": "get_units", "origin_file": "finam/data/tools/units.py", "test_list": ["../tests/adapters/test_stats.py"], "prob_info": {"func_start_lineno": 37, "func_end_lineno": 52, "key_block_start_lineno": 51, "key_block_end_lineno": 52, "new_func_code": "def get_units(xdata):\n    \"\"\"\n    Get units of the data.\n\n    Parameters\n    ----------\n    xdata : DataArray\n        The given data array.\n\n    Returns\n    -------\n    pint.Unit\n        Units of the data.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.adapters.time.DelayToPull::_get_data", "project": "finam", "func": "DelayToPull::_get_data", "origin_file": "finam/adapters/time.py", "test_list": ["../tests/adapters/test_time.py"], "prob_info": {"func_start_lineno": 206, "func_end_lineno": 220, "key_block_start_lineno": 219, "key_block_end_lineno": 220, "new_func_code": "def _get_data(self, time, target):\n        \"\"\"Get the output's data-set for the given time.\n\n        Parameters\n        ----------\n        time : datetime\n            simulation time to get the data for.\n\n        Returns\n        -------\n        array_like\n            data-set for the requested time.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.adapters.time.check_time", "project": "finam", "func": "check_time", "origin_file": "finam/adapters/time.py", "test_list": ["../tests/adapters/test_time.py"], "prob_info": {"func_start_lineno": 528, "func_end_lineno": 563, "key_block_start_lineno": 549, "key_block_end_lineno": 563, "new_func_code": "def check_time(logger, time, time_range=(None, None)):\n    \"\"\"\n    Checks time.\n\n    Checks time for being of type :class:`datetime <datetime.datetime>`, and to be in range of time_range\n    (upper and lower limits inclusive).\n\n    Parameters\n    ----------\n    logger : logging.Logger\n        Logger to print to\n    time : any\n        Time to be tested\n    time_range : tuple, optional\n        Tuple of (min, max) time, elements can be `None`, by default (None, None)\n\n    Raises\n    ------\n    FinamTimeError\n        if any of the checks fails\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.adapters.time.interpolate", "project": "finam", "func": "interpolate", "origin_file": "finam/adapters/time.py", "test_list": ["../tests/adapters/test_time.py"], "prob_info": {"func_start_lineno": 481, "func_end_lineno": 498, "key_block_start_lineno": 498, "key_block_end_lineno": 498, "new_func_code": "def interpolate(old_value, new_value, dt):\n    \"\"\"Interpolate between old and new value.\n\n    Parameters\n    ----------\n    old_value : array_like\n        Old value.\n    new_value : array_like\n        New value.\n    dt : float\n        Time step between values.\n\n    Returns\n    -------\n    array_like\n        Interpolated value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.adapters.time.interpolate_step", "project": "finam", "func": "interpolate_step", "origin_file": "finam/adapters/time.py", "test_list": ["../tests/adapters/test_time.py"], "prob_info": {"func_start_lineno": 501, "func_end_lineno": 525, "key_block_start_lineno": 525, "key_block_end_lineno": 525, "new_func_code": "def interpolate_step(old_value, new_value, dt, step):\n    \"\"\"Interpolate step-wise between old and new value.\n\n    Parameters\n    ----------\n    old_value : array_like\n        Old value.\n    new_value : array_like\n        New value.\n    dt : float\n        Time step between values.\n    step : float\n        Value in range [0, 1] that determines the relative step position.\n\n        * For a value of 0.0, the new value is returned for any dt > 0.0.\n        * For a value of 1.0, the old value is returned for any dt <= 1.0.\n        * Values between 0.0 and 1.0 shift the step between the first and the second time.\n        * A value of 0.5 results in nearest interpolation.\n\n    Returns\n    -------\n    array_like\n        Interpolated value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.tools.core.strip_time", "project": "finam", "func": "strip_time", "origin_file": "finam/data/tools/core.py", "test_list": ["../tests/adapters/test_time.py"], "prob_info": {"func_start_lineno": 236, "func_end_lineno": 263, "key_block_start_lineno": 256, "key_block_end_lineno": 263, "new_func_code": "def strip_time(xdata, grid):\n    \"\"\"Returns a view of the data with the time dimension squeezed if there is only a single entry\n\n    Parameters\n    ----------\n    xdata : arraylike\n        Data to strip time dimension from\n    grid : GridBase\n        The associated grid specification\n\n    Returns\n    -------\n    arraylike\n        Stripped data\n\n    Raises\n    ------\n    FinamDataError\n        If the data has multiple time entries.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.components.generators.CallbackGenerator::_update", "project": "finam", "func": "CallbackGenerator::_update", "origin_file": "finam/components/generators.py", "test_list": ["../tests/components/test_callback.py"], "prob_info": {"func_start_lineno": 110, "func_end_lineno": 121, "key_block_start_lineno": 116, "key_block_end_lineno": 121, "new_func_code": "def _update(self):\n        \"\"\"Update the component by one time step.\n        Push new values to outputs.\n\n        After the method call, the component should have status UPDATED or FINISHED.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.adapters.base.Scale::_get_data", "project": "finam", "func": "Scale::_get_data", "origin_file": "finam/adapters/base.py", "test_list": ["../tests/components/test_debug.py"], "prob_info": {"func_start_lineno": 84, "func_end_lineno": 98, "key_block_start_lineno": 97, "key_block_end_lineno": 98, "new_func_code": "def _get_data(self, time, target):\n        \"\"\"Get the output's data-set for the given time.\n\n        Parameters\n        ----------\n        time : datetime\n            simulation time to get the data for.\n\n        Returns\n        -------\n        array_like\n            data-set for the requested time.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.sdk.component.IOList::__getitem__", "project": "finam", "func": "IOList::__getitem__", "origin_file": "finam/sdk/component.py", "test_list": ["../tests/components/test_noise.py"], "prob_info": {"func_start_lineno": 678, "func_end_lineno": 692, "key_block_start_lineno": 680, "key_block_end_lineno": 692, "new_func_code": "def __getitem__(self, key):\n        \"\"\"Access an item by name.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.check_uniformity", "project": "finam", "func": "check_uniformity", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/data/test_grid_tools.py"], "prob_info": {"func_start_lineno": 271, "func_end_lineno": 292, "key_block_start_lineno": 284, "key_block_end_lineno": 292, "new_func_code": "def check_uniformity(values):\n    \"\"\"Checks for uniform spacing of values\n\n    Parameters\n    ----------\n    values : np.ndarray\n        Values to check.\n\n    Returns\n    -------\n    is_uniform : float\n        Average spacing, of NaN if not uniform.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.data.grid_tools.order_map", "project": "finam", "func": "order_map", "origin_file": "finam/data/grid_tools.py", "test_list": ["../tests/data/test_grid_tools.py"], "prob_info": {"func_start_lineno": 30, "func_end_lineno": 51, "key_block_start_lineno": 50, "key_block_end_lineno": 51, "new_func_code": "def order_map(shape, of=\"F\", to=\"C\"):\n    \"\"\"\n    Generate order mapping.\n\n    Parameters\n    ----------\n    shape : tuple\n        Array shape of interest.\n    of : str, optional\n        Starting ordering.\n        Either Fortran-like (\"F\") or C-like (\"C\"), by default \"F\"\n    to : str, optional\n        Target ordering.\n        Either Fortran-like (\"F\") or C-like (\"C\"), by default \"C\"\n\n    Returns\n    -------\n    np.ndarray\n        Mapping indices.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.components.generators.CallbackGenerator::_connect", "project": "finam", "func": "CallbackGenerator::_connect", "origin_file": "finam/components/generators.py", "test_list": ["../tests/adapters/test_time_integration.py"], "prob_info": {"func_start_lineno": 82, "func_end_lineno": 102, "key_block_start_lineno": 87, "key_block_end_lineno": 102, "new_func_code": "def _connect(self, start_time):\n        \"\"\"Push initial values to outputs.\n\n        After the method call, the component should have status CONNECTED.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.schedule.Composition::connect", "project": "finam", "func": "Composition::connect", "origin_file": "finam/schedule.py", "test_list": ["../tests/adapters/test_regrid.py"], "prob_info": {"func_start_lineno": 159, "func_end_lineno": 210, "key_block_start_lineno": 171, "key_block_end_lineno": 210, "new_func_code": "def connect(self, start_time=None):\n        \"\"\"Performs the connect and validate phases of the composition\n\n        If this was not called by the user, it is called at the start of :meth:`.run`.\n\n        Parameters\n        ----------\n        start_time : :class:`datetime <datetime.datetime>`, optional\n            Starting time of the composition.\n            If provided, it should be the starting time of the earliest component.\n            If not provided, the composition tries to determine the starting time automatically.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "finam.src.finam.schedule.Composition::_validate_composition", "project": "finam", "func": "Composition::_validate_composition", "origin_file": "finam/schedule.py", "test_list": ["../tests/adapters/test_stats.py"], "prob_info": {"func_start_lineno": 324, "func_end_lineno": 337, "key_block_start_lineno": 326, "key_block_end_lineno": 337, "new_func_code": "def _validate_composition(self):\n        \"\"\"Validates the coupling setup by checking for dangling inputs and disallowed branching connections.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.datasets._base.load_gzip_compressed_csv_data", "project": "skfolio", "func": "load_gzip_compressed_csv_data", "origin_file": "skfolio/datasets/_base.py", "test_list": ["../tests/test_cluster/test_hierarchical.py"], "prob_info": {"func_start_lineno": 71, "func_end_lineno": 113, "key_block_start_lineno": 107, "key_block_end_lineno": 113, "new_func_code": "def load_gzip_compressed_csv_data(\n    data_filename: str,\n    data_module: str = DATA_MODULE,\n    encoding=\"utf-8\",\n    datetime_index: bool = True,\n) -> pd.DataFrame:\n    \"\"\"Load gzip-compressed csv files with `importlib.resources`.\n\n    1) Open resource file with `importlib.resources.open_binary`\n    2) Decompress csv file with `gzip.open`\n    3) Load decompressed data with `pd.read_csv`\n\n    Parameters\n    ----------\n    data_filename : str\n        Name of gzip-compressed csv file  (`'*.csv.gz'`) to be loaded from\n        `data_module/data_file_name`. For example `'SPX500.csv.gz'`.\n\n    data_module : str or module, default='skfolio.datasets.data'\n        Module where data lives. The default is `'skfolio.datasets.data'`.\n\n    encoding : str, default=\"utf-8\"\n        Name of the encoding that the gzip-decompressed file will be\n        decoded with. The default is 'utf-8'.\n\n    datetime_index: bool, default=True\n        If this is set to True, the DataFrame index is converted to datetime with\n        format=\"%Y-%m-%d\".\n        The default is `True`.\n\n    Returns\n    -------\n    df : DataFrame of shape (n_observations, n_assets)\n        DataFrame with each row representing one observation and each column\n        representing the asset price of a given observation.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.preprocessing._returns.prices_to_returns", "project": "skfolio", "func": "prices_to_returns", "origin_file": "skfolio/preprocessing/_returns.py", "test_list": ["../tests/test_cluster/test_hierarchical.py"], "prob_info": {"func_start_lineno": 13, "func_end_lineno": 132, "key_block_start_lineno": 91, "key_block_end_lineno": 132, "new_func_code": "def prices_to_returns(\n    X: pd.DataFrame,\n    y: pd.DataFrame | None = None,\n    log_returns: bool = False,\n    nan_threshold: float = 1,\n    join: Literal[\"left\", \"right\", \"inner\", \"outer\", \"cross\"] = \"outer\",\n    drop_inceptions_nan: bool = True,\n    fill_nan: bool = True,\n) -> pd.DataFrame | tuple[pd.DataFrame, pd.DataFrame]:\n    r\"\"\"Transform a DataFrame of prices to linear or logarithmic returns.\n\n    Linear returns (also called simple returns) are defined as:\n        .. math:: \\frac{S_{t}}{S_{t-1}} - 1\n\n    Logarithmic returns (also called continuously compounded return) are defined as:\n        .. math:: ln\\Biggl(\\frac{S_{t}}{S_{t-1}}\\Biggr)\n\n    With :math:`S_{t}` the asset price at time :math:`t`.\n\n    .. warning::\n\n        The linear returns aggregate across securities, meaning that the linear return\n        of the portfolio is the weighted average of the linear returns of the\n        securities. For this reason, **portfolio optimization should be performed\n        using linear returns** [1]_.\n\n        On the other hand, the logarithmic returns aggregate across time, meaning that\n        the total logarithmic return over K time periods is the sum of all K\n        single-period logarithmic returns.\n\n    .. seealso::\n\n        :ref:`data preparation <data_preparation>`\n\n    Parameters\n    ----------\n    X : DataFrame\n        The DataFrame of assets prices.\n\n    y : DataFrame, optional\n        The DataFrame of target or factors prices.\n        If provided, it is joined with the DataFrame of prices to ensure identical\n        observations.\n\n    log_returns : bool, default=True\n        If this is set to True, logarithmic returns are used instead of simple returns.\n\n    join : str, default=\"outer\"\n        The join method between `X` and `y` when `y` is provided.\n\n    nan_threshold : float, default=1.0\n        Drop observations (rows) that have a percentage of missing assets prices above\n        this threshold. The default (`1.0`) is to keep all the observations.\n\n    drop_inceptions_nan : bool, default=True\n        If set to True, observations at the beginning are dropped if any of\n        the asset values are missing, otherwise we keep the NaNs. This is useful when\n        you work with a large universe of assets with different inception dates coupled\n        with a pre-selection Transformer.\n\n    fill_nan : bool, default=True\n        If set to True, missing prices (NaNs) are forward filled using the previous\n        price. Otherwise, NaNs are kept.\n\n    Returns\n    -------\n    X : DataFrame\n        The DataFrame of price returns of the input `X`.\n\n    y : DataFrame, optional\n        The DataFrame of price returns of the input `y` when provided.\n\n    References\n    ----------\n    .. [1]  \"Linear vs. Compounded Returns - Common Pitfalls in Portfolio Management\".\n        GARP Risk Professional.\n        Attilio Meucci (2010).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distance._distance.PearsonDistance::fit", "project": "skfolio", "func": "PearsonDistance::fit", "origin_file": "skfolio/distance/_distance.py", "test_list": ["../tests/test_cluster/test_hierarchical.py"], "prob_info": {"func_start_lineno": 73, "func_end_lineno": 94, "key_block_start_lineno": 89, "key_block_end_lineno": 94, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"PearsonDistance\":\n        \"\"\"Fit the Pearson Distance estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : PearsonDistance\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distance._distance._corr_to_distance", "project": "skfolio", "func": "_corr_to_distance", "origin_file": "skfolio/distance/_distance.py", "test_list": ["../tests/test_cluster/test_hierarchical.py"], "prob_info": {"func_start_lineno": 549, "func_end_lineno": 586, "key_block_start_lineno": 578, "key_block_end_lineno": 586, "new_func_code": "def _corr_to_distance(\n    corr: np.ndarray, absolute: bool, power: float\n) -> tuple[np.ndarray, np.ndarray]:\n    r\"\"\"Transform a correlation matrix to a codependence and distance matrix.\n\n    Some widely used distances are:\n\n        * Standard angular distance = :math:`\\sqrt{0.5 \\times (1 - corr)}`\n        * Absolute angular distance = :math:`\\sqrt{1 - |corr|}`\n        * Squared angular distance = :math:`\\sqrt{1 - corr^2}`\n\n\n    Parameters\n    ----------\n    corr : ndarray of shape (n_assets, n_assets)\n        Correlation matrix.\n\n    absolute : bool\n        If this is set to True, the absolute transformation is applied to the\n        correlation matrix.\n\n    power : float\n        Exponent of the power transformation applied to the correlation matrix.\n\n    Returns\n    -------\n    codependence, distance : tuple[np.ndarray, np.ndarray]\n        Codependence and distance matrices.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.cluster._hierarchical.HierarchicalClustering::fit", "project": "skfolio", "func": "HierarchicalClustering::fit", "origin_file": "skfolio/cluster/_hierarchical.py", "test_list": ["../tests/test_cluster/test_hierarchical.py"], "prob_info": {"func_start_lineno": 167, "func_end_lineno": 208, "key_block_start_lineno": 183, "key_block_end_lineno": 208, "new_func_code": "def fit(self, X: npt.ArrayLike, y: None = None) -> \"HierarchicalClustering\":\n        \"\"\"Fit the Hierarchical Equal Risk Contribution estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_assets, n_assets)\n            Distance matrix of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : HierarchicalClustering\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.assert_is_distance", "project": "skfolio", "func": "assert_is_distance", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_cluster/test_hierarchical.py"], "prob_info": {"func_start_lineno": 241, "func_end_lineno": 257, "key_block_start_lineno": 253, "key_block_end_lineno": 257, "new_func_code": "def assert_is_distance(x: np.ndarray) -> None:\n    \"\"\"Raises an error if the matrix is not a distance matrix.\n\n    Parameters\n    ----------\n    x : ndarray of shape (n, n)\n       The matrix.\n\n    Raises\n    ------\n    ValueError: if the matrix is a distance matrix.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.assert_is_symmetric", "project": "skfolio", "func": "assert_is_symmetric", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_cluster/test_hierarchical.py"], "prob_info": {"func_start_lineno": 224, "func_end_lineno": 238, "key_block_start_lineno": 236, "key_block_end_lineno": 238, "new_func_code": "def assert_is_symmetric(x: np.ndarray) -> None:\n    \"\"\"Raises an error if the matrix is not symmetric.\n\n    Parameters\n    ----------\n    x : ndarray of shape (n, m)\n       The matrix.\n\n    Raises\n    ------\n    ValueError: if the matrix is not symmetric.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.assert_is_square", "project": "skfolio", "func": "assert_is_square", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_cluster/test_hierarchical.py"], "prob_info": {"func_start_lineno": 208, "func_end_lineno": 221, "key_block_start_lineno": 220, "key_block_end_lineno": 221, "new_func_code": "def assert_is_square(x: np.ndarray) -> None:\n    \"\"\"Raises an error if the matrix is not square.\n\n    Parameters\n    ----------\n    x : ndarray of shape (n, n)\n       The matrix.\n\n    Raises\n    ------\n    ValueError: if the matrix is not square.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.datasets._base.load_sp500_dataset", "project": "skfolio", "func": "load_sp500_dataset", "origin_file": "skfolio/datasets/_base.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 168, "func_end_lineno": 204, "key_block_start_lineno": 202, "key_block_end_lineno": 204, "new_func_code": "def load_sp500_dataset() -> pd.DataFrame:\n    \"\"\"Load the prices of 20 assets from the S&P 500 Index composition.\n\n    This dataset is composed of the daily prices of 20 assets from the S&P 500\n    composition starting from 1990-01-02 up to 2022-12-28.\n\n    The data comes from the Yahoo public API.\n    The price is the adjusted close which is the closing price after adjustments for\n    all applicable splits and dividend distributions.\n    The adjustment uses appropriate split and dividend multipliers, adhering to\n    the Center for Research in Security Prices (CRSP) standards.\n\n    ==============   ==================\n    Observations     8313\n    Assets           20\n    ==============   ==================\n\n    Returns\n    -------\n    df : DataFrame of shape (n_observations, n_assets)\n        Prices DataFrame\n\n    Examples\n    --------\n    >>> from skfolio.datasets import load_sp500_dataset\n    >>> prices = load_sp500_dataset()\n    >>> prices.head()\n                    AAPL     AMD       BAC  ...       UNH       WMT      XOM\n    1990-01-02  0.332589  4.1250  11.65625  ...  0.382813  5.890625  12.5000\n    1990-01-03  0.334821  4.0000  11.75000  ...  0.375000  5.890625  12.3750\n    1990-01-04  0.335938  3.9375  11.50000  ...  0.371094  5.859375  12.2500\n    1990-01-05  0.337054  3.8125  11.25000  ...  0.355469  5.796875  12.1875\n    1990-01-08  0.339286  3.8125  11.31250  ...  0.347656  5.875000  12.3750\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distance._distance.KendallDistance::fit", "project": "skfolio", "func": "KendallDistance::fit", "origin_file": "skfolio/distance/_distance.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 145, "func_end_lineno": 166, "key_block_start_lineno": 161, "key_block_end_lineno": 166, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"KendallDistance\":\n        \"\"\"Fit the Kendall estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : KendallDistance\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distance._distance.SpearmanDistance::fit", "project": "skfolio", "func": "SpearmanDistance::fit", "origin_file": "skfolio/distance/_distance.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 217, "func_end_lineno": 238, "key_block_start_lineno": 233, "key_block_end_lineno": 238, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"SpearmanDistance\":\n        \"\"\"Fit the Spearman estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : SpearmanDistance\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.check_estimator", "project": "skfolio", "func": "check_estimator", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 328, "func_end_lineno": 354, "key_block_start_lineno": 350, "key_block_end_lineno": 354, "new_func_code": "def check_estimator(\n    estimator: skb.BaseEstimator | None, default: skb.BaseEstimator, check_type: Any\n):\n    \"\"\"Check the estimator type and returns its cloned version it provided, otherwise\n     return the default estimator.\n\n    Parameters\n    ----------\n    estimator : BaseEstimator, optional\n        Estimator.\n\n    default : BaseEstimator\n        Default estimator to return when `estimator` is `None`.\n\n    check_type : Any\n        Expected type of the estimator to check against.\n\n    Returns\n    -------\n    estimator : Estimator\n        The checked estimator or the default.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.covariance._gerber_covariance.GerberCovariance::fit", "project": "skfolio", "func": "GerberCovariance::fit", "origin_file": "skfolio/moments/covariance/_gerber_covariance.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 119, "func_end_lineno": 158, "key_block_start_lineno": 135, "key_block_end_lineno": 158, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"GerberCovariance\":\n        \"\"\"Fit the Gerber covariance estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n          Price returns of the assets.\n\n        y : Ignored\n           Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : GerberCovariance\n           Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.corr_to_cov", "project": "skfolio", "func": "corr_to_cov", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 280, "func_end_lineno": 302, "key_block_start_lineno": 297, "key_block_end_lineno": 302, "new_func_code": "def corr_to_cov(corr: np.ndarray, std: np.ndarray):\n    \"\"\"Convert a correlation matrix to a covariance matrix given its\n    standard-deviation vector.\n\n    Parameters\n    ----------\n    corr : ndarray of shape (n, n)\n        Correlation matrix.\n\n    std : ndarray of shape (n, )\n        Standard-deviation vector.\n\n    Returns\n    -------\n    cov : ndarray of shape (n, n)\n        Covariance matrix\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._utils._select_rotation_itau", "project": "skfolio", "func": "_select_rotation_itau", "origin_file": "skfolio/distribution/copula/_utils.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 237, "func_end_lineno": 269, "key_block_start_lineno": 264, "key_block_end_lineno": 269, "new_func_code": "def _select_rotation_itau(\n    func: Callable, X: np.ndarray, theta: float\n) -> CopulaRotation:\n    \"\"\"\n    Select the optimal copula rotation based on a provided function.\n\n    This helper function applies each rotation defined in CopulaRotation to the data X,\n    computes a criterion value using the provided function (which takes X and theta as\n    arguments), and returns the rotation that minimizes this value.\n\n    Parameters\n    ----------\n    func : Callable\n       A function that computes a criterion (e.g., a negative log-likelihood) for a given\n       rotated dataset and copula parameter theta.\n\n    X : ndarray of shape (n_observations, 2)\n       A 2D array of bivariate inputs.\n\n    theta : float\n       The copula parameter to be used in the criterion function.\n\n    Returns\n    -------\n    CopulaRotation\n       The rotation (an element of CopulaRotation) that minimizes the criterion value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._utils._apply_copula_rotation", "project": "skfolio", "func": "_apply_copula_rotation", "origin_file": "skfolio/distribution/copula/_utils.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 341, "func_end_lineno": 380, "key_block_start_lineno": 365, "key_block_end_lineno": 380, "new_func_code": "def _apply_copula_rotation(X: npt.ArrayLike, rotation: CopulaRotation) -> np.ndarray:\n    r\"\"\"Apply a bivariate copula rotation using the standard (clockwise) convention.\n\n    The transformations are defined as follows:\n\n    - `CopulaRotation.R0` (0): :math:`(u, v) \\mapsto (u, v)`\n    - `CopulaRotation.R90` (90): :math:`(u, v) \\mapsto (v,\\, 1 - u)`\n    - `CopulaRotation.R180` (180): :math:`(u, v) \\mapsto (1 - u,\\, 1 - v)`\n    - `CopulaRotation.R270` (270): :math:`(u, v) \\mapsto (1 - v,\\, u)`\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        An array of bivariate inputs `(u, v)` where each row represents a\n        bivariate observation.\n\n    rotation : CopulaRotation\n        The rotation to apply to the copula (default is no rotation).\n\n    Returns\n    -------\n    rotated_X: ndarray of shape (n_observations, 2)\n        The rotated data array.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._clayton._neg_log_likelihood", "project": "skfolio", "func": "_neg_log_likelihood", "origin_file": "skfolio/distribution/copula/_clayton.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 395, "func_end_lineno": 413, "key_block_start_lineno": 413, "key_block_end_lineno": 413, "new_func_code": "def _neg_log_likelihood(theta: float, X: np.ndarray) -> float:\n    \"\"\"Negative log-likelihood function for the Clayton copula.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        An array of bivariate inputs `(u, v)` where each row represents a\n        bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n        having been transformed to uniform marginals.\n\n    theta : float\n        The dependence parameter (must be greater than 0).\n\n    Returns\n    -------\n    value : float\n        The negative log-likelihood value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._clayton._base_sample_scores", "project": "skfolio", "func": "_base_sample_scores", "origin_file": "skfolio/distribution/copula/_clayton.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 416, "func_end_lineno": 448, "key_block_start_lineno": 438, "key_block_end_lineno": 448, "new_func_code": "def _base_sample_scores(X: np.ndarray, theta: float) -> np.ndarray:\n    r\"\"\"Compute the log-likelihood of each sample (log-pdf) under the bivariate Clayton\n    copula.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        Bivariate samples `(u, v)`, with each component in [0,1].\n\n    theta : float\n        The dependence parameter (must be greater than 0).\n\n    Returns\n    -------\n    logpdf : ndarray of shape (n_observations,)\n        Log-likelihood values for each observation.\n\n    Raises\n    ------\n    ValueError\n        If theta is not greater than 0.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._utils._select_theta_and_rotation_mle", "project": "skfolio", "func": "_select_theta_and_rotation_mle", "origin_file": "skfolio/distribution/copula/_utils.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 272, "func_end_lineno": 338, "key_block_start_lineno": 310, "key_block_end_lineno": 338, "new_func_code": "def _select_theta_and_rotation_mle(\n    func: Callable, X: np.ndarray, bounds: tuple[float, float], tolerance: float = 1e-4\n) -> tuple[float, CopulaRotation]:\n    \"\"\"\n    Select the optimal copula parameter theta and rotation using maximum likelihood\n    estimation.\n\n    For each rotation defined in CopulaRotation, this function applies the rotation to\n    X, then minimizes the negative log-likelihood over theta using a bounded scalar\n    optimization. It returns the theta and rotation that yield the minimum criterion\n    value.\n\n    Parameters\n    ----------\n    func : Callable\n        A function that computes the negative log-likelihood (or similar criterion) for a\n        given value of theta and rotated data X.\n\n    X : ndarray of shape (n_observations, 2)\n        A 2D array of bivariate inputs.\n\n    bounds : tuple[float, float]\n        The lower and upper bounds for the copula parameter theta.\n\n    tolerance : float, default=1e-4\n        The tolerance for the scalar minimization optimization.\n\n    Returns\n    -------\n    tuple\n        A tuple (theta, rotation) where theta is the optimal copula parameter and\n        rotation is the corresponding CopulaRotation.\n\n    Raises\n    ------\n    RuntimeError\n        If the optimization fails for all rotations.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._clayton.ClaytonCopula::partial_derivative", "project": "skfolio", "func": "ClaytonCopula::partial_derivative", "origin_file": "skfolio/distribution/copula/_clayton.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 249, "func_end_lineno": 291, "key_block_start_lineno": 282, "key_block_end_lineno": 291, "new_func_code": "def partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the h-function (partial derivative) for the bivariate Clayton copula\n        with respect to a specified margin.\n\n        The h-function with respect to the second margin represents the conditional\n        distribution function of :math:`u` given :math:`v`:\n\n        .. math::  \\begin{aligned}\n                   C(u,v)&=\\Bigl(u^{-\\theta}+v^{-\\theta}-1\\Bigr)^{-1/\\theta},\\\\[6pt]\n                   h(u \\mid v)\n                     &= \\frac{\\partial C(u,v)}{\\partial v}\n                     = \\Bigl(u^{-\\theta}+v^{-\\theta}-1\\Bigr)^{-1/\\theta-1}\\,v^{-\\theta-1}.\n                   \\end{aligned}\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        first_margin : bool, default=False\n            If True, compute the partial derivative with respect to the first\n            margin `u`; otherwise, compute the partial derivative with respect to the\n            second margin `v`.\n\n        Returns\n        -------\n        p  : ndarray of shape (n_observations,)\n            h-function values :math:`h(u \\mid v)` for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._utils._apply_rotation_partial_derivatives", "project": "skfolio", "func": "_apply_rotation_partial_derivatives", "origin_file": "skfolio/distribution/copula/_utils.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 452, "func_end_lineno": 509, "key_block_start_lineno": 490, "key_block_end_lineno": 509, "new_func_code": "def _apply_rotation_partial_derivatives(\n    func: Callable,\n    X: np.ndarray,\n    rotation: CopulaRotation,\n    first_margin: bool,\n    **kwargs,\n) -> np.ndarray:\n    \"\"\"\n    Apply a copula rotation to X and compute the corresponding partial derivatives.\n\n    This function rotates the data X using the specified rotation and then computes\n    the partial derivative (h-function) using the provided function. The result is then\n    adjusted according to the rotation and the margin of interest.\n\n    Parameters\n    ----------\n    func : Callable\n        A function that computes the partial derivative (h-function) given X, the\n        margin, and any additional keyword arguments.\n\n    X : ndarray of shape (n_observations, 2)\n        A 2D array of bivariate inputs.\n\n    rotation : CopulaRotation\n        The rotation to apply.\n\n    first_margin : bool\n        If True, compute the partial derivative with respect to the first margin;\n        otherwise, compute it with respect to the second margin.\n\n    **kwargs\n        Additional keyword arguments to pass to the partial derivative function.\n\n    Returns\n    -------\n    z : ndarray of shape (n_observations,)\n        The transformed partial derivative values after applying the rotation.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gaussian._neg_log_likelihood", "project": "skfolio", "func": "_neg_log_likelihood", "origin_file": "skfolio/distribution/copula/_gaussian.py", "test_list": ["../tests/test_distribution/test_copula/test_gaussian.py"], "prob_info": {"func_start_lineno": 352, "func_end_lineno": 370, "key_block_start_lineno": 370, "key_block_end_lineno": 370, "new_func_code": "def _neg_log_likelihood(rho: float, X: np.ndarray) -> float:\n    \"\"\"Negative log-likelihood function for optimization.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        An array of bivariate inputs `(u, v)` where each row represents a\n        bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n        having been transformed to uniform marginals.\n\n    rho : float\n        Correlation copula parameter.\n\n    Returns\n    -------\n    value : float\n        The negative log-likelihood value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gaussian.GaussianCopula::cdf", "project": "skfolio", "func": "GaussianCopula::cdf", "origin_file": "skfolio/distribution/copula/_gaussian.py", "test_list": ["../tests/test_distribution/test_copula/test_gaussian.py"], "prob_info": {"func_start_lineno": 194, "func_end_lineno": 216, "key_block_start_lineno": 209, "key_block_end_lineno": 216, "new_func_code": "def cdf(self, X: npt.ArrayLike) -> np.ndarray:\n        \"\"\"Compute the CDF of the bivariate Gaussian copula.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        cdf : ndarray of shape (n_observations,)\n            CDF values for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gaussian.GaussianCopula::partial_derivative", "project": "skfolio", "func": "GaussianCopula::partial_derivative", "origin_file": "skfolio/distribution/copula/_gaussian.py", "test_list": ["../tests/test_distribution/test_copula/test_gaussian.py"], "prob_info": {"func_start_lineno": 218, "func_end_lineno": 259, "key_block_start_lineno": 252, "key_block_end_lineno": 259, "new_func_code": "def partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the h-function (partial derivative) for the bivariate Gaussian\n        copula.\n\n        The h-function with respect to the second margin represents the conditional\n        distribution function of :math:`u` given :math:`v`:\n\n        .. math:: \\begin{aligned}\n                  h(u \\mid v) &= \\frac{\\partial C(u,v)}{\\partial v} \\\\\n                  &= \\Phi\\Bigl(\\frac{\\Phi^{-1}(u)-\\rho\\,\\Phi^{-1}(v)}{\\sqrt{1-\\rho^2}}\\Bigr)\n                  \\end{aligned}\n\n        where :math:`\\Phi` is the standard normal CDF and :math:`\\Phi^{-1}` is its\n        inverse (the quantile function).\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        first_margin : bool, default=False\n            If True, compute the partial derivative with respect to the first\n            margin `u`; otherwise, compute the partial derivative with respect to the\n            second margin `v`.\n\n        Returns\n        -------\n        p : ndarray of shape (n_observations,)\n            h-function values :math:`h(u \\mid v) \\;=\\; p` for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._utils._apply_margin_swap", "project": "skfolio", "func": "_apply_margin_swap", "origin_file": "skfolio/distribution/copula/_utils.py", "test_list": ["../tests/test_distribution/test_copula/test_gaussian.py"], "prob_info": {"func_start_lineno": 383, "func_end_lineno": 406, "key_block_start_lineno": 402, "key_block_end_lineno": 406, "new_func_code": "def _apply_margin_swap(X: np.ndarray, first_margin: bool) -> np.ndarray:\n    \"\"\"\n    Swap the columns of X if first_margin is False.\n\n    If first_margin is True, X is returned unchanged; otherwise, the columns\n    of X are swapped.\n\n    Parameters\n    ----------\n    X : ndarray of shape (n_observations, 2)\n        A 2D array of bivariate inputs (u, v).\n    first_margin : bool\n        If True, no swap is performed; if False, the columns of X are swapped.\n\n    Returns\n    -------\n    X_swapped : ndarray of shape (n_observations, 2)\n        The data array with columns swapped if first_margin is False.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gaussian.GaussianCopula::inverse_partial_derivative", "project": "skfolio", "func": "GaussianCopula::inverse_partial_derivative", "origin_file": "skfolio/distribution/copula/_gaussian.py", "test_list": ["../tests/test_distribution/test_copula/test_gaussian.py"], "prob_info": {"func_start_lineno": 261, "func_end_lineno": 314, "key_block_start_lineno": 308, "key_block_end_lineno": 314, "new_func_code": "def inverse_partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the inverse of the bivariate copula's partial derivative, commonly\n        known as the inverse h-function [1]_.\n\n        Let :math:`C(u, v)` be a bivariate copula. The h-function with respect to the\n        second margin is defined by\n\n        .. math::\n            h(u \\mid v) \\;=\\; \\frac{\\partial\\,C(u, v)}{\\partial\\,v},\n\n        which is the conditional distribution of :math:`U` given :math:`V = v`.\n        The **inverse h-function**, denoted :math:`h^{-1}(p \\mid v)`, is the unique\n        value :math:`u \\in [0,1]` such that\n\n        .. math::\n            h(u \\mid v) \\;=\\; p,\n            \\quad \\text{where } p \\in [0,1].\n\n        In practical terms, given :math:`(p, v)` in :math:`[0, 1]^2`,\n        :math:`h^{-1}(p \\mid v)` solves for the :math:`u` satisfying\n        :math:`p = \\partial C(u, v)/\\partial v`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(p, v)`, each in the interval `[0, 1]`.\n            - The first column `p` corresponds to the value of the h-function.\n            - The second column `v` is the conditioning variable.\n\n        first_margin : bool, default=False\n            If True, compute the inverse partial derivative with respect to the first\n            margin `u`; otherwise, compute the inverse partial derivative with respect\n            to the second margin `v`.\n\n        Returns\n        -------\n        u : ndarray of shape (n_observations,)\n            A 1D-array of length `n_observations`, where each element is the computed\n            :math:`u = h^{-1}(p \\mid v)` for the corresponding pair in `X`.\n\n        References\n        ----------\n        .. [1] \"Multivariate Models and Dependence Concepts\", Joe, H. (1997)\n        .. [2] \"An Introduction to Copulas\", Nelsen, R. B. (2006)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gaussian.GaussianCopula::score_samples", "project": "skfolio", "func": "GaussianCopula::score_samples", "origin_file": "skfolio/distribution/copula/_gaussian.py", "test_list": ["../tests/test_distribution/test_copula/test_gaussian.py"], "prob_info": {"func_start_lineno": 316, "func_end_lineno": 334, "key_block_start_lineno": 331, "key_block_end_lineno": 334, "new_func_code": "def score_samples(self, X: npt.ArrayLike) -> np.ndarray:\n        \"\"\"Compute the log-likelihood of each sample (log-pdf) under the model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        density : ndarray of shape (n_observations,)\n            The log-likelihood of each sample under the fitted copula.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._utils.plot_tail_concentration", "project": "skfolio", "func": "plot_tail_concentration", "origin_file": "skfolio/distribution/copula/_utils.py", "test_list": ["../tests/test_distribution/test_copula/test_gaussian.py"], "prob_info": {"func_start_lineno": 147, "func_end_lineno": 234, "key_block_start_lineno": 186, "key_block_end_lineno": 234, "new_func_code": "def plot_tail_concentration(\n    tail_concentration_dict: dict[str, npt.ArrayLike],\n    quantiles: np.ndarray,\n    title: str = \"Empirical Tail Dependencies\",\n    smoothing: float | None = 0.5,\n) -> go.Figure:\n    \"\"\"\n    Plot the empirical tail concentration curves.\n\n    This function takes a dictionary where keys are dataset names and values are the\n    corresponding tail concentration arrays computed at the given quantiles. It then\n    creates a Plotly figure with the tail concentration curves. The x-axis (quantiles)\n    and y-axis (tail concentration) are both formatted as percentages.\n\n    Parameters\n    ----------\n    tail_concentration_dict : dict[str, ArrayLike]\n        A dictionary mapping dataset names to their tail concentration values.\n\n    quantiles : array-like of shape (n_quantiles,)\n        The quantile levels at which the tail concentration has been computed.\n\n    title : str, default=\"Empirical Tail Dependencies\"\n        The title for the plot.\n\n    smoothing : float or None, default=0.5\n        Smoothing parameter for the spline line shape. If provided, the curves will be\n        smoothed using a spline interpolation.\n\n    Returns\n    -------\n    fig : go.Figure\n        A Plotly figure object containing the tail concentration curves.\n\n    Raises\n    ------\n    ValueError\n        If the smoothing parameter is not in the allowed range.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gumbel._neg_log_likelihood", "project": "skfolio", "func": "_neg_log_likelihood", "origin_file": "skfolio/distribution/copula/_gumbel.py", "test_list": ["../tests/test_distribution/test_copula/test_gumbel.py"], "prob_info": {"func_start_lineno": 401, "func_end_lineno": 419, "key_block_start_lineno": 419, "key_block_end_lineno": 419, "new_func_code": "def _neg_log_likelihood(theta: float, X: np.ndarray) -> float:\n    \"\"\"Negative log-likelihood function for the Gumbel copula.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        An array of bivariate inputs `(u, v)` where each row represents a\n        bivariate observation. Both `u` and `v` must be in the interval [0, 1],\n        having been transformed to uniform marginals.\n\n    theta : float\n        The dependence parameter (must be greater than 1).\n\n    Returns\n    -------\n    value : float\n        The negative log-likelihood value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gumbel.GumbelCopula::partial_derivative", "project": "skfolio", "func": "GumbelCopula::partial_derivative", "origin_file": "skfolio/distribution/copula/_gumbel.py", "test_list": ["../tests/test_distribution/test_copula/test_gumbel.py"], "prob_info": {"func_start_lineno": 252, "func_end_lineno": 294, "key_block_start_lineno": 285, "key_block_end_lineno": 294, "new_func_code": "def partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the h-function (partial derivative) for the bivariate Gumbel copula\n        with respect to a specified margin.\n\n        The h-function with respect to the second margin represents the conditional\n        distribution function of :math:`u` given :math:`v`:\n\n        .. math::  \\begin{aligned}\n                   h(u \\mid v)\n                     &= \\frac{\\partial C(u,v)}{\\partial v}\\\\[6pt]\n                     &= C(u,v)\\,\\Bigl[(-\\ln u)^{\\theta}+(-\\ln v)^{\\theta}\\Bigr]^{\\frac{1}{\\theta}-1}\n                         \\,(-\\ln v)^{\\theta-1}\\,\\frac{1}{v}.\n                   \\end{aligned}\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval [0, 1],\n            having been transformed to uniform marginals.\n\n        first_margin : bool, default=False\n            If True, compute the partial derivative with respect to the first\n            margin `u`; otherwise, compute the partial derivative with respect to the\n            second margin `v`.\n\n        Returns\n        -------\n        p  : ndarray of shape (n_observations,)\n            h-function values :math:`h(u \\mid v)` for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._independent.IndependentCopula::fit", "project": "skfolio", "func": "IndependentCopula::fit", "origin_file": "skfolio/distribution/copula/_independent.py", "test_list": ["../tests/test_distribution/test_copula/test_independent.py"], "prob_info": {"func_start_lineno": 51, "func_end_lineno": 72, "key_block_start_lineno": 71, "key_block_end_lineno": 72, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"IndependentCopula\":\n        \"\"\"Fit the Bivariate Independent Copula.\n\n        Provided for compatibility with the API.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval [0, 1],\n            having been transformed to uniform marginals.\n\n        y : None\n            Ignored. Provided for compatibility with scikit-learn's API.\n\n        Returns\n        -------\n        self : IndependentCopula\n            Returns the instance itself.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._independent.IndependentCopula::cdf", "project": "skfolio", "func": "IndependentCopula::cdf", "origin_file": "skfolio/distribution/copula/_independent.py", "test_list": ["../tests/test_distribution/test_copula/test_independent.py"], "prob_info": {"func_start_lineno": 74, "func_end_lineno": 92, "key_block_start_lineno": 89, "key_block_end_lineno": 92, "new_func_code": "def cdf(self, X: npt.ArrayLike) -> np.ndarray:\n        \"\"\"Compute the CDF of the bivariate Independent copula.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        cdf : ndarray of shape (n_observations,)\n            CDF values for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._independent.IndependentCopula::partial_derivative", "project": "skfolio", "func": "IndependentCopula::partial_derivative", "origin_file": "skfolio/distribution/copula/_independent.py", "test_list": ["../tests/test_distribution/test_copula/test_independent.py"], "prob_info": {"func_start_lineno": 94, "func_end_lineno": 119, "key_block_start_lineno": 116, "key_block_end_lineno": 119, "new_func_code": "def partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the h-function (partial derivative) for the bivariate Independent\n        copula.\n\n        The h-function with respect to the second margin represents the conditional\n        distribution function of :math:`u` given :math:`v`:\n\n        .. math::\n            \\frac{\\partial C(u,v)}{\\partial v}=u,\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, 2)\n            Array of pairs :math:`(u,v)`, where each value is in the interval [0,1].\n\n        Returns\n        -------\n        np.ndarray\n            Array of h-function values for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._independent.IndependentCopula::inverse_partial_derivative", "project": "skfolio", "func": "IndependentCopula::inverse_partial_derivative", "origin_file": "skfolio/distribution/copula/_independent.py", "test_list": ["../tests/test_distribution/test_copula/test_independent.py"], "prob_info": {"func_start_lineno": 121, "func_end_lineno": 163, "key_block_start_lineno": 160, "key_block_end_lineno": 163, "new_func_code": "def inverse_partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the inverse of the bivariate copula's partial derivative, commonly\n        known as the inverse h-function.\n\n        For the independent copula, the h-function with respect to the second margin is\n\n        .. math::\n             h(u\\mid v)= u,\n\n        and the derivative with respect to the first margin is\n\n        .. math::\n             g(u,v)= v.\n\n        Their inverses are trivial:\n\n          - Given (p,v) for h(u|v)= p, we have u = p.\n          - Given (p,u) for g(u,v)= p, we have v = p.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(p, v)`, each in the interval `[0, 1]`.\n            - The first column `p` corresponds to the value of the h-function.\n            - The second column `v` is the conditioning variable.\n\n        first_margin : bool, default=False\n            If True, compute the inverse partial derivative with respect to the first\n            margin `u`; otherwise, compute the inverse partial derivative with respect\n            to the second margin `v`.\n\n        Returns\n        -------\n        u : ndarray of shape (n_observations,)\n            A 1D-array of length `n_observations`, where each element is the computed\n            :math:`u = h^{-1}(p \\mid v)` for the corresponding pair in `X`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._independent.IndependentCopula::score_samples", "project": "skfolio", "func": "IndependentCopula::score_samples", "origin_file": "skfolio/distribution/copula/_independent.py", "test_list": ["../tests/test_distribution/test_copula/test_independent.py"], "prob_info": {"func_start_lineno": 165, "func_end_lineno": 181, "key_block_start_lineno": 179, "key_block_end_lineno": 181, "new_func_code": "def score_samples(self, X: npt.ArrayLike) -> np.ndarray:\n        \"\"\"Compute the log-likelihood of each sample (log-pdf) under the model.\n\n        Parameters\n        ----------\n         X : array-like of shape (n_samples, 2)\n            The input data where each row represents a bivariate observation.\n            The data should be transformed to uniform marginals in [0, 1].\n\n        Returns\n        -------\n        density : ndarray of shape (n_samples,)\n            The log-likelihood of each sample under the fitted copula.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._joe._tau_diff", "project": "skfolio", "func": "_tau_diff", "origin_file": "skfolio/distribution/copula/_joe.py", "test_list": ["../tests/test_distribution/test_copula/test_joe.py"], "prob_info": {"func_start_lineno": 476, "func_end_lineno": 507, "key_block_start_lineno": 501, "key_block_end_lineno": 507, "new_func_code": "def _tau_diff(theta: float, tau_empirical: float) -> float:\n    r\"\"\"Compute the difference between the theoretical Kendall's tau for the Joe copula\n    and an empirical tau.\n\n    The theoretical relationship for the Joe copula is given by:\n\n    .. math::\n       \\tau(\\theta) = 1 + \\frac{2}{2-\\theta} \\left[ (1-\\gamma) - \\psi\\left(\\frac{2}{\\theta}+1\\right) \\right],\n\n    where :math:`\\psi` is the digamma function and :math:`\\gamma` is the\n    Euler-Mascheroni constant.\n\n    Parameters\n    ----------\n    theta : float\n        The dependence parameter (must be greater than 1).\n\n    tau_empirical : float\n        The empirical Kendall's tau.\n\n    Returns\n    -------\n    float\n        The difference :math:`\\tau(\\theta) - \\tau_{\\text{empirical}}`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._joe._neg_log_likelihood", "project": "skfolio", "func": "_neg_log_likelihood", "origin_file": "skfolio/distribution/copula/_joe.py", "test_list": ["../tests/test_distribution/test_copula/test_joe.py"], "prob_info": {"func_start_lineno": 418, "func_end_lineno": 436, "key_block_start_lineno": 436, "key_block_end_lineno": 436, "new_func_code": "def _neg_log_likelihood(theta: float, X: np.ndarray) -> float:\n    \"\"\"Negative log-likelihood function for optimization.\n\n    Parameters\n    ----------\n     X : array-like of shape (n_observations, 2)\n         An array of bivariate inputs `(u, v)` where each row represents a\n         bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n         having been transformed to uniform marginals.\n\n    theta : float\n         The dependence parameter (must be greater than 1).\n\n    Returns\n    -------\n     value : float\n         The negative log-likelihood value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._joe._base_sample_scores", "project": "skfolio", "func": "_base_sample_scores", "origin_file": "skfolio/distribution/copula/_joe.py", "test_list": ["../tests/test_distribution/test_copula/test_joe.py"], "prob_info": {"func_start_lineno": 439, "func_end_lineno": 473, "key_block_start_lineno": 463, "key_block_end_lineno": 473, "new_func_code": "def _base_sample_scores(X: np.ndarray, theta: float) -> np.ndarray:\n    \"\"\"Compute the log-likelihood of each sample (log-pdf) under the bivariate\n    Joe copula model.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        An array of bivariate inputs `(u, v)` where each row represents a\n        bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n        having been transformed to uniform marginals.\n\n    theta : float\n        The dependence parameter (must be greater than 1).\n\n    Returns\n    -------\n    density : ndarray of shape (n_observations,)\n        The log-likelihood of each sample under the fitted copula.\n\n    Raises\n    ------\n    ValueError\n        If rho is not in (-1, 1) or dof is not positive.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._joe.JoeCopula::partial_derivative", "project": "skfolio", "func": "JoeCopula::partial_derivative", "origin_file": "skfolio/distribution/copula/_joe.py", "test_list": ["../tests/test_distribution/test_copula/test_joe.py"], "prob_info": {"func_start_lineno": 265, "func_end_lineno": 311, "key_block_start_lineno": 302, "key_block_end_lineno": 311, "new_func_code": "def partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the h-function (partial derivative) for the bivariate Joe copula\n        with respect to a specified margin.\n\n        The h-function with respect to the second margin represents the conditional\n        distribution function of :math:`u` given :math:`v`:\n\n        .. math::  \\begin{aligned}\n                   h(u \\mid v)\n                     &= \\frac{\\partial C(u,v)}{\\partial v} \\\\[6pt]\n                     &= (1-v)^{\\theta-1}\\,\\Bigl[1 \\;-\\;(1-u)^{\\theta}\\Bigr]\\,\n                        \\Bigl[(1-u)^{\\theta} \\;+\\;(1-v)^{\\theta}\n                              \\;-\\;(1-u)^{\\theta}(1-v)^{\\theta}\\Bigr]^{\\frac{1}{\\theta}-1} \\\\[6pt]\n                     &= \\left( 1 \\;+\\;\\frac{(1-u)^{\\theta}}{(1-v)^{\\theta}}\n                              \\;-\\;(1-u)^{\\theta} \\right)^{-1 + \\frac{1}{\\theta}}\n                        \\;\\cdot\\;\\bigl[\\,1 \\;-\\;(1-u)^{\\theta}\\bigr].\n                   \\end{aligned}\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        first_margin : bool, default=False\n            If True, compute the partial derivative with respect to the first\n            margin `u`; otherwise, compute the partial derivative with respect to the\n            second margin `v`.\n\n        Returns\n        -------\n        p  : ndarray of shape (n_observations,)\n            h-function values :math:`h(u \\mid v) \\;=\\; p` for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._clayton.ClaytonCopula::score_samples", "project": "skfolio", "func": "ClaytonCopula::score_samples", "origin_file": "skfolio/distribution/copula/_clayton.py", "test_list": ["../tests/test_distribution/test_copula/test_selection.py"], "prob_info": {"func_start_lineno": 346, "func_end_lineno": 369, "key_block_start_lineno": 365, "key_block_end_lineno": 369, "new_func_code": "def score_samples(self, X: npt.ArrayLike) -> np.ndarray:\n        r\"\"\"Compute the log-likelihood of each sample (log-pdf) under the model.\n\n        For Clayton, the PDF is given by:\n\n        .. math:: c(u,v) = (\\theta+1)\\,\\Bigl(u^{-\\theta}+v^{-\\theta}-1\\Bigr)^{-\\frac{1}{\\theta}-2}\\,(u\\,v)^{-\\theta-1}\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        density : ndarray of shape (n_observations,)\n            The log-likelihood of each sample under the fitted copula.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._student_t._neg_log_likelihood", "project": "skfolio", "func": "_neg_log_likelihood", "origin_file": "skfolio/distribution/copula/_student_t.py", "test_list": ["../tests/test_distribution/test_copula/test_student_t.py"], "prob_info": {"func_start_lineno": 421, "func_end_lineno": 442, "key_block_start_lineno": 442, "key_block_end_lineno": 442, "new_func_code": "def _neg_log_likelihood(dof: float, rho: float, X: np.ndarray) -> float:\n    \"\"\"Negative log-likelihood function for optimization.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        An array of bivariate inputs `(u, v)` where each row represents a\n        bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n        having been transformed to uniform marginals.\n\n    rho : float\n        Correlation copula parameter.\n\n    dof : float\n        Degree of freedom copula parameter.\n\n    Returns\n    -------\n    value : float\n        The negative log-likelihood value.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._student_t.StudentTCopula::inverse_partial_derivative", "project": "skfolio", "func": "StudentTCopula::inverse_partial_derivative", "origin_file": "skfolio/distribution/copula/_student_t.py", "test_list": ["../tests/test_distribution/test_copula/test_student_t.py"], "prob_info": {"func_start_lineno": 323, "func_end_lineno": 381, "key_block_start_lineno": 370, "key_block_end_lineno": 381, "new_func_code": "def inverse_partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the inverse of the bivariate copula's partial derivative, commonly\n        known as the inverse h-function [1]_.\n\n        Let :math:`C(u, v)` be a bivariate copula. The h-function with respect to the\n        second margin is defined by\n\n        .. math::\n            h(u \\mid v) \\;=\\; \\frac{\\partial\\,C(u, v)}{\\partial\\,v},\n\n        which is the conditional distribution of :math:`U` given :math:`V = v`.\n        The **inverse h-function**, denoted :math:`h^{-1}(p \\mid v)`, is the unique\n        value :math:`u \\in [0,1]` such that\n\n        .. math::\n            h(u \\mid v) \\;=\\; p,\n            \\quad \\text{where } p \\in [0,1].\n\n        In practical terms, given :math:`(p, v)` in :math:`[0, 1]^2`,\n        :math:`h^{-1}(p \\mid v)` solves for the :math:`u` satisfying\n        :math:`p = \\partial C(u, v)/\\partial v`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(p, v)`, each in the interval `[0, 1]`.\n            - The first column `p` corresponds to the value of the h-function.\n            - The second column `v` is the conditioning variable.\n\n        first_margin : bool, default=False\n            If True, compute the inverse partial derivative with respect to the first\n            margin `u`; otherwise, compute the inverse partial derivative with respect\n            to the second margin `v`.\n\n        Returns\n        -------\n        u : ndarray of shape (n_observations,)\n            A 1D-array of length `n_observations`, where each element is the computed\n            :math:`u = h^{-1}(p \\mid v)` for the corresponding pair in `X`.\n\n        References\n        ----------\n        .. [1] \"Multivariate Models and Dependence Concepts\", Joe, H. (1997)\n        .. [2] \"An Introduction to Copulas\", Nelsen, R. B. (2006)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._student_t.StudentTCopula::score_samples", "project": "skfolio", "func": "StudentTCopula::score_samples", "origin_file": "skfolio/distribution/copula/_student_t.py", "test_list": ["../tests/test_distribution/test_copula/test_student_t.py"], "prob_info": {"func_start_lineno": 383, "func_end_lineno": 401, "key_block_start_lineno": 398, "key_block_end_lineno": 401, "new_func_code": "def score_samples(self, X: npt.ArrayLike) -> np.ndarray:\n        \"\"\"Compute the log-likelihood of each sample (log-pdf) under the model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        density : ndarray of shape (n_observations,)\n            The log-likelihood of each sample under the fitted copula.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._utils.compute_pseudo_observations", "project": "skfolio", "func": "compute_pseudo_observations", "origin_file": "skfolio/distribution/copula/_utils.py", "test_list": ["../tests/test_distribution/test_copula/test_utils.py"], "prob_info": {"func_start_lineno": 52, "func_end_lineno": 83, "key_block_start_lineno": 78, "key_block_end_lineno": 83, "new_func_code": "def compute_pseudo_observations(X: npt.ArrayLike) -> np.ndarray:\n    \"\"\"\n    Compute pseudo-observations by ranking each column of the data and scaling the\n    ranks.\n\n    The goal of computing pseudo-observations is to transform your raw data into a\n    form that has uniform marginal distributions on the open interval (0, 1). This is\n    particularly useful in copula modeling and other statistical methods where the\n    dependence structure is of primary interest, independent of the marginal\n    distributions.\n\n    This function transforms each column of the input data into pseudo-observations\n    on the (0, 1) interval. For each column, the ranks (starting at 1) are divided by\n    (n_samples + 1) to avoid 0 and 1 values, which are problematic for many copula\n    methods.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, n_assets)\n        Input data.\n\n    Returns\n    -------\n    pseudo_observations: ndarray of shape (n_observations, n_assets)\n        An array of pseudo-observations corresponding to the ranks scaled to (0, 1).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._utils._apply_rotation_cdf", "project": "skfolio", "func": "_apply_rotation_cdf", "origin_file": "skfolio/distribution/copula/_utils.py", "test_list": ["../tests/test_distribution/test_copula/test_utils.py"], "prob_info": {"func_start_lineno": 409, "func_end_lineno": 449, "key_block_start_lineno": 434, "key_block_end_lineno": 449, "new_func_code": "def _apply_rotation_cdf(\n    func: Callable, X: np.ndarray, rotation: CopulaRotation, **kwargs\n) -> np.ndarray:\n    \"\"\"\n    Apply a copula rotation to X and compute the corresponding CDF values.\n\n    Parameters\n    ----------\n    func : Callable\n       A function that computes the CDF given data X and additional keyword arguments.\n\n    X : ndarray of shape (n_observations, 2)\n       A 2D array of bivariate inputs.\n\n    rotation : CopulaRotation\n       The rotation to apply.\n\n    **kwargs\n       Additional keyword arguments to pass to the CDF function.\n\n    Returns\n    -------\n    rotated_cdf : ndarray of shape (n_observations,)\n       The transformed CDF values after applying the rotation.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._utils.Edge::get_X", "project": "skfolio", "func": "Edge::get_X", "origin_file": "skfolio/distribution/multivariate/_utils.py", "test_list": ["../tests/test_distribution/test_multivariate/test_utils.py"], "prob_info": {"func_start_lineno": 406, "func_end_lineno": 426, "key_block_start_lineno": 418, "key_block_end_lineno": 426, "new_func_code": "def get_X(self) -> np.ndarray:\n        \"\"\"Retrieve the bivariate pseudo-observation data associated with the edge.\n\n        For a root edge, this returns the pseudo-values from node1 and node2.\n        For non-root edges, the appropriate margins (u or v) are selected\n        based on the shared node order.\n\n        Returns\n        -------\n        X : ndarray of shape (n_observations, 2)\n            The bivariate pseudo-observation data corresponding to this edge.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._utils.Tree::set_edges_from_mst", "project": "skfolio", "func": "Tree::set_edges_from_mst", "origin_file": "skfolio/distribution/multivariate/_utils.py", "test_list": ["../tests/test_distribution/test_multivariate/test_utils.py"], "prob_info": {"func_start_lineno": 520, "func_end_lineno": 582, "key_block_start_lineno": 538, "key_block_end_lineno": 582, "new_func_code": "def set_edges_from_mst(self, dependence_method: DependenceMethod) -> None:\n        \"\"\"Construct the Maximum Spanning Tree (MST) from the current nodes using\n        the specified dependence method.\n\n        The MST is built based on pairwise dependence measures computed between nodes.\n        If any edge is (weakly) central, a central factor is added to the dependence\n        measure to favor edges connected to central nodes.\n\n        Parameters\n        ----------\n        dependence_method : DependenceMethod\n            The method used to compute the dependence measure between nodes (e.g.,\n            Kendall's tau).\n\n        Returns\n        -------\n        None\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.univariate._gaussian.Gaussian::fit", "project": "skfolio", "func": "Gaussian::fit", "origin_file": "skfolio/distribution/univariate/_gaussian.py", "test_list": ["../tests/test_distribution/test_univariate/test_gaussian.py"], "prob_info": {"func_start_lineno": 107, "func_end_lineno": 136, "key_block_start_lineno": 123, "key_block_end_lineno": 136, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"Gaussian\":\n        \"\"\"Fit the univariate Gaussian distribution model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 1)\n            The input data. X must contain a single column.\n\n        y : None\n            Ignored. Provided for compatibility with scikit-learn's API.\n\n        Returns\n        -------\n        self : Gaussian\n            Returns the instance itself.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.univariate._johnson_su.JohnsonSU::fit", "project": "skfolio", "func": "JohnsonSU::fit", "origin_file": "skfolio/distribution/univariate/_johnson_su.py", "test_list": ["../tests/test_distribution/test_univariate/test_johnson_su.py"], "prob_info": {"func_start_lineno": 122, "func_end_lineno": 152, "key_block_start_lineno": 138, "key_block_end_lineno": 152, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"JohnsonSU\":\n        \"\"\"Fit the univariate Johnson SU distribution model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 1)\n            The input data. X must contain a single column.\n\n        y : None\n            Ignored. Provided for compatibility with scikit-learn's API.\n\n        Returns\n        -------\n        self : JohnsonSU\n            Returns the instance itself.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.univariate._normal_inverse_gaussian.NormalInverseGaussian::fit", "project": "skfolio", "func": "NormalInverseGaussian::fit", "origin_file": "skfolio/distribution/univariate/_normal_inverse_gaussian.py", "test_list": ["../tests/test_distribution/test_univariate/test_normal_inverse_gaussian.py"], "prob_info": {"func_start_lineno": 123, "func_end_lineno": 153, "key_block_start_lineno": 139, "key_block_end_lineno": 153, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"NormalInverseGaussian\":\n        \"\"\"Fit the univariate Normal Inverse Gaussian distribution model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 1)\n            The input data. X must contain a single column.\n\n        y : None\n            Ignored. Provided for compatibility with scikit-learn's API.\n\n        Returns\n        -------\n        self : NormalInverseGaussian\n            Returns the instance itself.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.univariate._student_t.StudentT::fit", "project": "skfolio", "func": "StudentT::fit", "origin_file": "skfolio/distribution/univariate/_student_t.py", "test_list": ["../tests/test_distribution/test_univariate/test_selection.py"], "prob_info": {"func_start_lineno": 119, "func_end_lineno": 144, "key_block_start_lineno": 135, "key_block_end_lineno": 144, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"StudentT\":\n        \"\"\"Fit the univariate Student's t distribution model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 1)\n            The input data. X must contain a single column.\n\n        y : None\n            Ignored. Provided for compatibility with scikit-learn's API.\n\n        Returns\n        -------\n        self : StudentT\n            Returns the instance itself.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.semi_variance", "project": "skfolio", "func": "semi_variance", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 98, "func_end_lineno": 124, "key_block_start_lineno": 120, "key_block_end_lineno": 124, "new_func_code": "def semi_variance(\n    returns: np.ndarray, min_acceptable_return: float | None = None\n) -> float:\n    \"\"\"Compute the semi-variance (second lower partial moment).\n\n    The semi-variance is the variance of the returns below a minimum acceptable return.\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns\n\n    min_acceptable_return : float, optional\n        Minimum acceptable return. It is the return target to distinguish \"downside\" and\n        \"upside\" returns.\n        The default (`None`) is to use the mean.\n\n    Returns\n    -------\n    value : float\n        Semi-variance.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.fourth_central_moment", "project": "skfolio", "func": "fourth_central_moment", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 205, "func_end_lineno": 218, "key_block_start_lineno": 218, "key_block_end_lineno": 218, "new_func_code": "def fourth_central_moment(returns: np.ndarray) -> float:\n    \"\"\"Compute the Fourth central moment.\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    Returns\n    -------\n    value : float\n        Fourth central moment.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.fourth_lower_partial_moment", "project": "skfolio", "func": "fourth_lower_partial_moment", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 240, "func_end_lineno": 269, "key_block_start_lineno": 265, "key_block_end_lineno": 269, "new_func_code": "def fourth_lower_partial_moment(\n    returns: np.ndarray, min_acceptable_return: float | None = None\n) -> float:\n    \"\"\"Compute the fourth lower partial moment.\n\n    The Fourth Lower Partial Moment is a measure of the heaviness of the downside tail\n    of the returns below a minimum acceptable return.\n    Higher Fourth Lower Partial Moment corresponds to greater extremity of downside\n    deviations (downside fat tail).\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns\n\n    min_acceptable_return : float, optional\n        Minimum acceptable return. It is the return target to distinguish \"downside\" and\n        \"upside\" returns.\n        The default (`None`) is to use the returns mean.\n\n    Returns\n    -------\n    value : float\n        Fourth lower partial moment.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.mean_absolute_deviation", "project": "skfolio", "func": "mean_absolute_deviation", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 29, "func_end_lineno": 51, "key_block_start_lineno": 49, "key_block_end_lineno": 51, "new_func_code": "def mean_absolute_deviation(\n    returns: np.ndarray, min_acceptable_return: float | None = None\n) -> float:\n    \"\"\"Compute the mean absolute deviation (MAD).\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    min_acceptable_return : float, optional\n        Minimum acceptable return. It is the return target to distinguish \"downside\" and\n        \"upside\" returns.\n        The default (`None`) is to use the returns' mean.\n\n    Returns\n    -------\n    value : float\n        Mean absolute deviation.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.cvar", "project": "skfolio", "func": "cvar", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 314, "func_end_lineno": 338, "key_block_start_lineno": 333, "key_block_end_lineno": 338, "new_func_code": "def cvar(returns: np.ndarray, beta: float = 0.95) -> float:\n    \"\"\"Compute the historical CVaR (conditional value at risk).\n\n    The CVaR (or Tail VaR) represents the mean shortfall at a specified confidence\n    level (beta).\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    beta : float, default=0.95\n        The CVaR confidence level (expected VaR on the worst (1-beta)% observations).\n\n    Returns\n    -------\n    value : float\n        CVaR.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.value_at_risk", "project": "skfolio", "func": "value_at_risk", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 288, "func_end_lineno": 311, "key_block_start_lineno": 306, "key_block_end_lineno": 311, "new_func_code": "def value_at_risk(returns: np.ndarray, beta: float = 0.95) -> float:\n    \"\"\"Compute the historical value at risk (VaR).\n\n    The VaR is the maximum loss at a given confidence level (beta).\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    beta : float, default=0.95\n        The VaR confidence level (return on the worst (1-beta)% observation).\n\n    Returns\n    -------\n    value : float\n        Value at Risk.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.worst_realization", "project": "skfolio", "func": "worst_realization", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 272, "func_end_lineno": 285, "key_block_start_lineno": 285, "key_block_end_lineno": 285, "new_func_code": "def worst_realization(returns: np.ndarray) -> float:\n    \"\"\"Compute the worst realization (worst return).\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    Returns\n    -------\n    value : float\n        Worst realization.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.first_lower_partial_moment", "project": "skfolio", "func": "first_lower_partial_moment", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 54, "func_end_lineno": 79, "key_block_start_lineno": 77, "key_block_end_lineno": 79, "new_func_code": "def first_lower_partial_moment(\n    returns: np.ndarray, min_acceptable_return: float | None = None\n) -> float:\n    \"\"\"Compute the first lower partial moment.\n\n    The first lower partial moment is the mean of the returns below a minimum\n    acceptable return.\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns\n\n    min_acceptable_return : float, optional\n        Minimum acceptable return. It is the return target to distinguish \"downside\" and\n        \"upside\" returns.\n        The default (`None`) is to use the mean.\n\n    Returns\n    -------\n    value : float\n        First lower partial moment.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.entropic_risk_measure", "project": "skfolio", "func": "entropic_risk_measure", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 341, "func_end_lineno": 366, "key_block_start_lineno": 366, "key_block_end_lineno": 366, "new_func_code": "def entropic_risk_measure(\n    returns: np.ndarray, theta: float = 1, beta: float = 0.95\n) -> float:\n    \"\"\"Compute the entropic risk measure.\n\n    The entropic risk measure is a risk measure which depends on the risk aversion\n    defined by the investor (theta) through the exponential utility function at a given\n    confidence level (beta).\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    theta : float, default=1.0\n        Risk aversion.\n\n    beta : float, default=0.95\n         Confidence level.\n\n    Returns\n    -------\n    value : float\n        Entropic risk measure.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.get_drawdowns", "project": "skfolio", "func": "get_drawdowns", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 431, "func_end_lineno": 453, "key_block_start_lineno": 448, "key_block_end_lineno": 453, "new_func_code": "def get_drawdowns(returns: np.ndarray, compounded: bool = False) -> np.ndarray:\n    \"\"\"Compute the drawdowns' series from the returns.\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n       Vector of returns.\n\n    compounded : bool, default=False\n       If this is set to True, the cumulative returns are compounded otherwise they\n       are uncompounded.\n\n    Returns\n    -------\n    values: ndarray of shape (n_observations,)\n       Drawdowns.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.get_cumulative_returns", "project": "skfolio", "func": "get_cumulative_returns", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 405, "func_end_lineno": 428, "key_block_start_lineno": 424, "key_block_end_lineno": 428, "new_func_code": "def get_cumulative_returns(returns: np.ndarray, compounded: bool = False) -> np.ndarray:\n    \"\"\"Compute the cumulative returns from the returns.\n    Non-compounded cumulative returns start at 0.\n    Compounded cumulative returns are rescaled to start at 1000.\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    compounded : bool, default=False\n        If this is set to True, the cumulative returns are compounded otherwise they\n        are uncompounded.\n\n    Returns\n    -------\n    values: ndarray of shape (n_observations,)\n        Cumulative returns.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.convex._mean_risk.MeanRisk::fit", "project": "skfolio", "func": "MeanRisk::fit", "origin_file": "skfolio/optimization/convex/_mean_risk.py", "test_list": ["../tests/test_metrics/test_scorer.py"], "prob_info": {"func_start_lineno": 747, "func_end_lineno": 1100, "key_block_start_lineno": 766, "key_block_end_lineno": 1100, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y: npt.ArrayLike | None = None, **fit_params\n    ) -> \"MeanRisk\":\n        \"\"\"Fit the Mean-Risk Optimization estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_targets), optional\n            Price returns of factors or a target benchmark.\n            The default is `None`.\n\n        Returns\n        -------\n        self : MeanRisk\n           Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.expected_returns._empirical_mu.EmpiricalMu::fit", "project": "skfolio", "func": "EmpiricalMu::fit", "origin_file": "skfolio/moments/expected_returns/_empirical_mu.py", "test_list": ["../tests/test_metrics/test_scorer.py"], "prob_info": {"func_start_lineno": 44, "func_end_lineno": 64, "key_block_start_lineno": 60, "key_block_end_lineno": 64, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"EmpiricalMu\":\n        \"\"\"Fit the Mu Empirical estimator model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : EmpiricalMu\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.covariance._empirical_covariance.EmpiricalCovariance::fit", "project": "skfolio", "func": "EmpiricalCovariance::fit", "origin_file": "skfolio/moments/covariance/_empirical_covariance.py", "test_list": ["../tests/test_metrics/test_scorer.py"], "prob_info": {"func_start_lineno": 80, "func_end_lineno": 101, "key_block_start_lineno": 96, "key_block_end_lineno": 101, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"EmpiricalCovariance\":\n        \"\"\"Fit the empirical covariance estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : EmpiricalCovariance\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.model_selection._combinatorial.CombinatorialPurgedCV::split", "project": "skfolio", "func": "CombinatorialPurgedCV::split", "origin_file": "skfolio/model_selection/_combinatorial.py", "test_list": ["../tests/test_model_selection/test_combinatorial.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 316, "key_block_start_lineno": 269, "key_block_end_lineno": 316, "new_func_code": "def split(\n        self, X: npt.ArrayLike, y=None, groups=None\n    ) -> Iterator[tuple[np.ndarray, list[np.ndarray]]]:\n        \"\"\"Generate indices to split data into training and test set.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_samples, n_features)\n            Training data, where `n_samples` is the number of samples\n            and `n_features` is the number of features.\n\n        y : array-like of shape (n_samples,), optional\n            The (multi-)target variable\n\n        groups : array-like of shape (n_samples,), optional\n            Group labels for the samples used while splitting the dataset into\n            train/test set.\n\n        Yields\n        ------\n        train : ndarray\n            The training set indices for that split.\n\n        test : ndarray\n            The testing set indices for that split.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.model_selection._combinatorial._n_splits", "project": "skfolio", "func": "_n_splits", "origin_file": "skfolio/model_selection/_combinatorial.py", "test_list": ["../tests/test_model_selection/test_combinatorial.py"], "prob_info": {"func_start_lineno": 415, "func_end_lineno": 431, "key_block_start_lineno": 431, "key_block_end_lineno": 431, "new_func_code": "def _n_splits(n_folds: int, n_test_folds: int) -> int:\n    \"\"\"Number of splits.\n\n    Parameters\n    ----------\n    n_folds : int\n        Number of folds.\n\n    n_test_folds : int\n        Number of test folds.\n\n    Returns\n    -------\n    n_splits : int\n        Number of splits\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.model_selection._combinatorial._n_test_paths", "project": "skfolio", "func": "_n_test_paths", "origin_file": "skfolio/model_selection/_combinatorial.py", "test_list": ["../tests/test_model_selection/test_combinatorial.py"], "prob_info": {"func_start_lineno": 434, "func_end_lineno": 453, "key_block_start_lineno": 451, "key_block_end_lineno": 453, "new_func_code": "def _n_test_paths(n_folds: int, n_test_folds: int) -> int:\n    \"\"\"Number of test paths that can be reconstructed from the train/test\n    combinations.\n\n    Parameters\n    ----------\n    n_folds : int\n        Number of folds.\n\n    n_test_folds : int\n        Number of test folds.\n\n    Returns\n    -------\n    n_splits : int\n        Number of test paths.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.model_selection._combinatorial._avg_train_size", "project": "skfolio", "func": "_avg_train_size", "origin_file": "skfolio/model_selection/_combinatorial.py", "test_list": ["../tests/test_model_selection/test_combinatorial.py"], "prob_info": {"func_start_lineno": 456, "func_end_lineno": 475, "key_block_start_lineno": 475, "key_block_end_lineno": 475, "new_func_code": "def _avg_train_size(n_observations: int, n_folds: int, n_test_folds: int) -> float:\n    \"\"\"Average number of observations contained in each training set.\n\n    Parameters\n    ----------\n    n_observations : int\n        Number of observations.\n\n    n_folds : int\n        Number of folds.\n\n    n_test_folds : int\n        Number of test folds.\n\n    Returns\n    -------\n    avg_train_size : float\n        Average number of observations contained in each training set.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.model_selection._validation.cross_val_predict", "project": "skfolio", "func": "cross_val_predict", "origin_file": "skfolio/model_selection/_validation.py", "test_list": ["../tests/test_model_selection/test_validation.py"], "prob_info": {"func_start_lineno": 38, "func_end_lineno": 254, "key_block_start_lineno": 131, "key_block_end_lineno": 254, "new_func_code": "def cross_val_predict(\n    estimator: skb.BaseEstimator,\n    X: npt.ArrayLike,\n    y: npt.ArrayLike = None,\n    cv: sks.BaseCrossValidator | BaseCombinatorialCV | int | None = None,\n    n_jobs: int | None = None,\n    method: str = \"predict\",\n    verbose: int = 0,\n    params: dict | None = None,\n    pre_dispatch: str = \"2*n_jobs\",\n    column_indices: np.ndarray | None = None,\n    portfolio_params: dict | None = None,\n) -> MultiPeriodPortfolio | Population:\n    \"\"\"Generate cross-validated `Portfolios` estimates.\n\n    The data is split according to the `cv` parameter.\n    The optimization estimator is fitted on the training set and portfolios are\n    predicted on the corresponding test set.\n\n    For non-combinatorial cross-validation like `Kfold`, the output is the predicted\n    :class:`~skfolio.portfolio.MultiPeriodPortfolio` where\n    each :class:`~skfolio.portfolio.Portfolio` corresponds to the prediction on each\n    train/test pair (`k` portfolios for `Kfold`).\n\n    For combinatorial cross-validation\n    like :class:`~skfolio.model_selection.CombinatorialPurgedCV`, the output is the\n    predicted :class:`~skfolio.population.Population` of multiple\n    :class:`~skfolio.portfolio.MultiPeriodPortfolio` (each test outputs are a\n    collection of multiple paths instead of one single path).\n\n    Parameters\n    ----------\n    estimator : BaseOptimization\n        :ref:`Optimization estimators <optimization>` use to fit the data.\n\n    X : array-like of shape (n_observations, n_assets)\n        Price returns of the assets.\n\n    y : array-like of shape (n_observations, n_targets), optional\n        Target data (optional).\n        For example, the price returns of the factors.\n\n    cv : int | cross-validation generator, optional\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        * None, to use the default 5-fold cross validation,\n        * int, to specify the number of folds in a `(Stratified)KFold`,\n        * `CV splitter`,\n        * An iterable that generates (train, test) splits as arrays of indices.\n\n    n_jobs : int, optional\n        The number of jobs to run in parallel for `fit` of all `estimators`.\n        `None` means 1 unless in a `joblib.parallel_backend` context. -1 means\n        using all processors.\n\n    method : str\n        Invokes the passed method name of the passed estimator.\n\n    verbose : int, default=0\n        The verbosity level.\n\n    params : dict, optional\n        Parameters to pass to the underlying estimator's ``fit`` and the CV splitter.\n\n    pre_dispatch : int or str, default='2*n_jobs'\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n            * None, in which case all the jobs are immediately\n              created and spawned. Use this for lightweight and\n              fast-running jobs, to avoid delays due to on-demand\n              spawning of the jobs\n\n            * An int, giving the exact number of total jobs that are\n              spawned\n\n            * A str, giving an expression as a function of n_jobs,\n              as in '2*n_jobs'\n\n    column_indices : ndarray, optional\n        Indices of the `X` columns to cross-validate on.\n\n    portfolio_params :  dict, optional\n        Additional portfolio parameters passed to `MultiPeriodPortfolio`.\n\n    Returns\n    -------\n    predictions : MultiPeriodPortfolio | Population\n        This is the result of calling `predict`\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.safe_split", "project": "skfolio", "func": "safe_split", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_model_selection/test_validation.py"], "prob_info": {"func_start_lineno": 222, "func_end_lineno": 261, "key_block_start_lineno": 256, "key_block_end_lineno": 261, "new_func_code": "def safe_split(\n    X: npt.ArrayLike,\n    y: npt.ArrayLike | None = None,\n    indices: np.ndarray | None = None,\n    axis: int = 0,\n):\n    \"\"\"Create subset of dataset.\n\n    Slice X, y according to indices for cross-validation.\n\n    Parameters\n    ----------\n    X : array-like\n        Data to be indexed.\n\n    y : array-like\n        Data to be indexed.\n\n    indices : ndarray of int, optional\n        Rows or columns to select from X and y.\n        The default (`None`) is to select the entire data.\n\n    axis : int, default=0\n        The axis along which `X` will be sub-sampled. `axis=0` will select\n        rows while `axis=1` will select columns.\n\n    Returns\n    -------\n    X_subset : array-like\n        Indexed data.\n\n    y_subset : array-like\n        Indexed targets.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.safe_indexing", "project": "skfolio", "func": "safe_indexing", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_model_selection/test_validation.py"], "prob_info": {"func_start_lineno": 190, "func_end_lineno": 219, "key_block_start_lineno": 213, "key_block_end_lineno": 219, "new_func_code": "def safe_indexing(\n    X: npt.ArrayLike | pd.DataFrame, indices: npt.ArrayLike | None, axis: int = 0\n):\n    \"\"\"Return rows, items or columns of X using indices.\n\n    Parameters\n    ----------\n    X : array-like\n        Data from which to sample rows.\n\n    indices : array-like, optional\n        Indices of rows or columns.\n        The default (`None`) is to select the entire data.\n\n    axis : int, default=0\n        The axis along which `X` will be sub-sampled. `axis=0` will select\n        rows while `axis=1` will select columns.\n\n    Returns\n    -------\n    subset :\n        Subset of X on axis 0.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.model_selection._walk_forward.WalkForward::get_n_splits", "project": "skfolio", "func": "WalkForward::get_n_splits", "origin_file": "skfolio/model_selection/_walk_forward.py", "test_list": ["../tests/test_model_selection/test_walk_forward.py"], "prob_info": {"func_start_lineno": 275, "func_end_lineno": 302, "key_block_start_lineno": 294, "key_block_end_lineno": 302, "new_func_code": "def get_n_splits(self, X=None, y=None, groups=None) -> int:\n        \"\"\"Return the number of splitting iterations in the cross-validator.\n\n        Parameters\n        ----------\n         X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_targets)\n            Always ignored, exists for compatibility.\n\n        groups : array-like of shape (n_observations,)\n            Always ignored, exists for compatibility.\n\n        Returns\n        -------\n        n_folds : int\n            Returns the number of splitting iterations in the cross-validator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.datasets._base.load_sp500_implied_vol_dataset", "project": "skfolio", "func": "load_sp500_implied_vol_dataset", "origin_file": "skfolio/datasets/_base.py", "test_list": ["../tests/test_moment/test_covariance/test_implied_covariance.py"], "prob_info": {"func_start_lineno": 400, "func_end_lineno": 448, "key_block_start_lineno": 444, "key_block_end_lineno": 448, "new_func_code": "def load_sp500_implied_vol_dataset(\n    data_home=None, download_if_missing=True\n) -> pd.DataFrame:\n    \"\"\"Load the 3 months ATM implied volatility of the 20 assets from the\n    SP500 dataset.\n\n    This dataset is composed of the 3 months ATM implied volatility of 20 assets\n    from the S&P 500 composition starting from 2010-01-04 up to 2022-12-28.\n\n    The data comes from the Yahoo public API option chains.\n\n    ==============   ==================\n    Observations     3270\n    Assets           20\n    ==============   ==================\n\n    Parameters\n    ----------\n    data_home : str, optional\n        Specify another download and cache folder for the datasets.\n        By default, all skfolio data is stored in `~/skfolio_data` subfolders.\n\n    download_if_missing : bool, default=True\n        If False, raise an OSError if the data is not locally available\n        instead of trying to download the data from the source site.\n\n    Returns\n    -------\n    df : DataFrame of shape (n_observations, n_assets)\n        Implied volatility DataFrame\n\n    Examples\n    --------\n    >>> from skfolio.datasets import load_sp500_implied_vol_dataset\n    >>> implied_vol = load_sp500_implied_vol_dataset()\n    >>> implied_vol.head()\n                    AAPL       AMD       BAC  ...       UNH       WMT       XOM\n    Date                                      ...\n    2010-01-04  0.364353  0.572056  0.382926  ...  0.362751  0.171737  0.201485\n    2010-01-05  0.371865  0.568791  0.374699  ...  0.368504  0.174764  0.203852\n    2010-01-06  0.356746  0.558054  0.349220  ...  0.368514  0.171892  0.197475\n    2010-01-07  0.361084  0.560475  0.354942  ...  0.355792  0.169083  0.200046\n    2010-01-08  0.348085  0.543932  0.360345  ...  0.351130  0.170897  0.204832\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.datasets._base.download_dataset", "project": "skfolio", "func": "download_dataset", "origin_file": "skfolio/datasets/_base.py", "test_list": ["../tests/test_moment/test_covariance/test_implied_covariance.py"], "prob_info": {"func_start_lineno": 116, "func_end_lineno": 165, "key_block_start_lineno": 144, "key_block_end_lineno": 165, "new_func_code": "def download_dataset(\n    data_filename: str,\n    data_home: str | Path | None = None,\n    download_if_missing: bool = True,\n) -> pd.DataFrame:\n    \"\"\"Download and save locally a dataset from the remote GitHub dataset folder.\n\n    Parameters\n    ----------\n    data_filename : str\n        Name of gzip-compressed csv file  (`'*.csv.gz'`) to be loaded from a remote\n        GitHub dataset folder.\n\n    data_home : str or path-like, optional\n        Specify another download and cache folder for the datasets. By default,\n        all skfolio data is stored in `~/skfolio_data` sub-folders.\n\n    download_if_missing : bool, default=True\n        If False, raise an OSError if the data is not locally available\n        instead of trying to download the data from the source site.\n        The default is `True`.\n\n    Returns\n    -------\n    df : DataFrame of shape (n_observations, n_assets)\n        DataFrame with each row representing one observation and each column\n        representing the asset price of a given observation.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.datasets._base.get_data_home", "project": "skfolio", "func": "get_data_home", "origin_file": "skfolio/datasets/_base.py", "test_list": ["../tests/test_moment/test_covariance/test_implied_covariance.py"], "prob_info": {"func_start_lineno": 25, "func_end_lineno": 55, "key_block_start_lineno": 51, "key_block_end_lineno": 55, "new_func_code": "def get_data_home(data_home: str | Path | None = None) -> str:\n    \"\"\"Return the path of the skfolio data directory.\n\n    This folder is used by some large dataset loaders to avoid downloading the\n    data several times.\n\n    By default, the data directory is set to a folder named 'skfolio_data' in the\n    user home folder.\n\n    Alternatively, it can be set by the 'SKFOLIO_DATA' environment\n    variable or programmatically by giving an explicit folder path. The '~'\n    symbol is expanded to the user home folder.\n\n    If the folder does not already exist, it is automatically created.\n\n    Parameters\n    ----------\n    data_home : str, optional\n        The path to skfolio data directory. If `None`, the default path\n        is `~/skfolio_data`.\n\n    Returns\n    -------\n    data_home: str or path-like, optional\n        The path to skfolio data directory.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.expected_returns._ew_mu.EWMu::fit", "project": "skfolio", "func": "EWMu::fit", "origin_file": "skfolio/moments/expected_returns/_ew_mu.py", "test_list": ["../tests/test_moment/test_expected_returns/test_expected_returns.py"], "prob_info": {"func_start_lineno": 50, "func_end_lineno": 70, "key_block_start_lineno": 66, "key_block_end_lineno": 70, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"EWMu\":\n        \"\"\"Fit the EWMu estimator model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : EWMu\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.expected_returns._equilibrium_mu.EquilibriumMu::fit", "project": "skfolio", "func": "EquilibriumMu::fit", "origin_file": "skfolio/moments/expected_returns/_equilibrium_mu.py", "test_list": ["../tests/test_moment/test_expected_returns/test_expected_returns.py"], "prob_info": {"func_start_lineno": 82, "func_end_lineno": 125, "key_block_start_lineno": 105, "key_block_end_lineno": 125, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None, **fit_params) -> \"EquilibriumMu\":\n        \"\"\"Fit the EquilibriumMu estimator model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : EquilibriumMu\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.cluster.hierarchical._hrp.HierarchicalRiskParity::fit", "project": "skfolio", "func": "HierarchicalRiskParity::fit", "origin_file": "skfolio/optimization/cluster/hierarchical/_hrp.py", "test_list": ["../tests/test_optimization/test_cluster/test_hierarchical/test_hrp.py"], "prob_info": {"func_start_lineno": 273, "func_end_lineno": 387, "key_block_start_lineno": 291, "key_block_end_lineno": 387, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y: None = None, **fit_params\n    ) -> \"HierarchicalRiskParity\":\n        \"\"\"Fit the Hierarchical Risk Parity Optimization estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : HierarchicalRiskParity\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.convex._maximum_diversification.MaximumDiversification::fit", "project": "skfolio", "func": "MaximumDiversification::fit", "origin_file": "skfolio/optimization/convex/_maximum_diversification.py", "test_list": ["../tests/test_optimization/test_convex/test_maximum_diversification.py"], "prob_info": {"func_start_lineno": 401, "func_end_lineno": 437, "key_block_start_lineno": 427, "key_block_end_lineno": 437, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y: npt.ArrayLike | None = None, **fit_params\n    ) -> \"MaximumDiversification\":\n        \"\"\"Fit the Maximum Diversification Optimization estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_targets), optional\n            Price returns of factors or a target benchmark.\n            The default is `None`.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : MaximumDiversification\n           Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.convex._risk_budgeting.RiskBudgeting::fit", "project": "skfolio", "func": "RiskBudgeting::fit", "origin_file": "skfolio/optimization/convex/_risk_budgeting.py", "test_list": ["../tests/test_optimization/test_convex/test_risk_budgeting.py"], "prob_info": {"func_start_lineno": 436, "func_end_lineno": 573, "key_block_start_lineno": 454, "key_block_end_lineno": 573, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None, **fit_params) -> \"RiskBudgeting\":\n        \"\"\"Fit the Risk Budgeting Optimization estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_factors), optional\n            Price returns of factors.\n            The default is `None`.\n\n\n        Returns\n        -------\n        self : RiskBudgeting\n           Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.datasets._base.load_factors_dataset", "project": "skfolio", "func": "load_factors_dataset", "origin_file": "skfolio/datasets/_base.py", "test_list": ["../tests/test_optimization/test_naive/test_naive.py"], "prob_info": {"func_start_lineno": 247, "func_end_lineno": 292, "key_block_start_lineno": 290, "key_block_end_lineno": 292, "new_func_code": "def load_factors_dataset() -> pd.DataFrame:\n    \"\"\"Load the prices of 5 factor ETFs.\n\n    This dataset is composed of the daily prices of 5 ETF representing common factors\n    starting from 2014-01-02 up to 2022-12-28.\n\n    The factors are:\n\n        * \"MTUM\": Momentum\n        * \"QUAL\": Quality\n        * \"SIZE\": Size\n        * \"VLUE\": Value\n        * \"USMV\": low volatility\n\n    The data comes from the Yahoo public API.\n    The price is the adjusted close which is the closing price after adjustments for\n    all applicable splits and dividend distributions.\n    The adjustment uses appropriate split and dividend multipliers, adhering to\n    the Center for Research in Security Prices (CRSP) standards.\n\n    ==============   ==================\n    Observations     2264\n    Assets           5\n    ==============   ==================\n\n    Returns\n    -------\n    df : DataFrame of shape (n_observations, n_assets)\n        Prices DataFrame\n\n    Examples\n    --------\n    >>> from skfolio.datasets import load_factors_dataset\n    >>> prices = load_factors_dataset()\n    >>> prices.head()\n                  MTUM    QUAL    SIZE    USMV    VLUE\n    Date\n    2014-01-02  52.704  48.351  48.986  29.338  47.054\n    2014-01-03  52.792  48.256  48.722  29.330  46.999\n    2014-01-06  52.677  48.067  48.722  29.263  46.991\n    2014-01-07  53.112  48.455  48.731  29.430  47.253\n    2014-01-08  53.502  48.437  48.731  29.422  47.253\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.rand_weights", "project": "skfolio", "func": "rand_weights", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 145, "func_end_lineno": 166, "key_block_start_lineno": 162, "key_block_end_lineno": 166, "new_func_code": "def rand_weights(n: int, zeros: int = 0) -> np.array:\n    \"\"\"Produces n random weights that sum to one from an uniform distribution\n    (non-uniform distribution over a simplex).\n\n    Parameters\n    ----------\n    n : int\n        Number of weights.\n\n    zeros : int, default=0\n        The number of weights to randomly set to zeros.\n\n    Returns\n    -------\n    weights : ndarray of shape (n, )\n        The vector of weights.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.input_to_array", "project": "skfolio", "func": "input_to_array", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 357, "func_end_lineno": 442, "key_block_start_lineno": 396, "key_block_end_lineno": 442, "new_func_code": "def input_to_array(\n    items: dict | npt.ArrayLike,\n    n_assets: int,\n    fill_value: Any,\n    dim: int,\n    assets_names: np.ndarray | None,\n    name: str,\n) -> np.ndarray:\n    \"\"\"Convert a collection of items (array-like or dictionary) into\n    a numpy array and verify its shape.\n\n    Parameters\n    ----------\n    items : np.ndarray | dict | list\n        Items to verify and convert to array.\n\n    n_assets : int\n        Expected number of assets.\n        Used to verify the shape of the converted array.\n\n    fill_value : Any\n        When `items` is a dictionary, elements that are not in `asset_names` are filled\n        with `fill_value` in the converted array.\n\n    dim : int\n        Dimension of the final array.\n        Possible values are `1` or `2`.\n\n    assets_names : ndarray, optional\n        Asset names used when `items` is a dictionary.\n\n    name : str\n        Name of the items used for error messages.\n\n    Returns\n    -------\n    values : ndarray of shape (n_assets) for dim=1 or (n_groups, n_assets) for dim=2\n        Converted array.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.cached_property_slots::__get__", "project": "skfolio", "func": "cached_property_slots::__get__", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 92, "func_end_lineno": 106, "key_block_start_lineno": 94, "key_block_end_lineno": 106, "new_func_code": "def __get__(self, instance, owner=None):\n        \"\"\"Getter.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.args_names", "project": "skfolio", "func": "args_names", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 325, "key_block_start_lineno": 323, "key_block_end_lineno": 325, "new_func_code": "def args_names(func: object) -> list[str]:\n    \"\"\"Returns the argument names of a function.\n\n    Parameters\n    ----------\n    func : object\n        Function.\n\n    Returns\n    -------\n    args : list[str]\n        The list of function arguments.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.mean", "project": "skfolio", "func": "mean", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 13, "func_end_lineno": 26, "key_block_start_lineno": 26, "key_block_end_lineno": 26, "new_func_code": "def mean(returns: np.ndarray) -> float:\n    \"\"\"Compute the mean.\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    Returns\n    -------\n    value : float\n        Mean\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.semi_deviation", "project": "skfolio", "func": "semi_deviation", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 143, "func_end_lineno": 166, "key_block_start_lineno": 164, "key_block_end_lineno": 166, "new_func_code": "def semi_deviation(\n    returns: np.ndarray, min_acceptable_return: float | None = None\n) -> float:\n    \"\"\"Compute the semi standard-deviation (semi-deviation) (square root of the second lower\n    partial moment).\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    min_acceptable_return : float, optional\n        Minimum acceptable return. It is the return target to distinguish \"downside\" and\n        \"upside\" returns.\n        The default (`None`) is to use the returns mean.\n\n    Returns\n    -------\n    value : float\n        Semi-standard-deviation.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.portfolio._multi_period_portfolio.MultiPeriodPortfolio::_set_portfolios", "project": "skfolio", "func": "MultiPeriodPortfolio::_set_portfolios", "origin_file": "skfolio/portfolio/_multi_period_portfolio.py", "test_list": ["../tests/test_portfolio/test_multi_period_portfolio.py"], "prob_info": {"func_start_lineno": 493, "func_end_lineno": 530, "key_block_start_lineno": 501, "key_block_end_lineno": 530, "new_func_code": "def _set_portfolios(self, portfolios: list[Portfolio] | None = None) -> None:\n        \"\"\"Set the returns, observations and portfolios list.\n\n        Parameters\n        ----------\n        portfolios : list[Portfolio], optional\n            The list of Portfolios. The default (`None`) is to use an empty list.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.variance", "project": "skfolio", "func": "variance", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_portfolio/test_multi_period_portfolio.py"], "prob_info": {"func_start_lineno": 82, "func_end_lineno": 95, "key_block_start_lineno": 95, "key_block_end_lineno": 95, "new_func_code": "def variance(returns: np.ndarray) -> float:\n    \"\"\"Compute the variance (second moment).\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    Returns\n    -------\n    value : float\n        Variance.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.standard_deviation", "project": "skfolio", "func": "standard_deviation", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_portfolio/test_multi_period_portfolio.py"], "prob_info": {"func_start_lineno": 127, "func_end_lineno": 140, "key_block_start_lineno": 140, "key_block_end_lineno": 140, "new_func_code": "def standard_deviation(returns: np.ndarray) -> float:\n    \"\"\"Compute the standard-deviation (square root of the second moment).\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    Returns\n    -------\n    value : float\n        Standard-deviation.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.portfolio._portfolio.Portfolio::effective_number_assets", "project": "skfolio", "func": "Portfolio::effective_number_assets", "origin_file": "skfolio/portfolio/_portfolio.py", "test_list": ["../tests/test_portfolio/test_portfolio.py"], "prob_info": {"func_start_lineno": 707, "func_end_lineno": 726, "key_block_start_lineno": 726, "key_block_end_lineno": 726, "new_func_code": "def effective_number_assets(self) -> float:\n        r\"\"\"Computes the effective number of assets, defined as the inverse of the\n        Herfindahl index.\n\n        .. math:: N_{eff} = \\frac{1}{\\Vert w \\Vert_{2}^{2}}\n\n        It quantifies portfolio concentration, with a higher value indicating a more\n        diversified portfolio.\n\n        Returns\n        -------\n        value : float\n            Effective number of assets.\n\n        References\n        ----------\n        .. [1] \"Banking and Financial Institutions Law in a Nutshell\".\n            Lovett, William Anthony (1988)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.effective_number_assets", "project": "skfolio", "func": "effective_number_assets", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_portfolio/test_portfolio.py"], "prob_info": {"func_start_lineno": 609, "func_end_lineno": 633, "key_block_start_lineno": 633, "key_block_end_lineno": 633, "new_func_code": "def effective_number_assets(weights: np.ndarray) -> float:\n    r\"\"\"Compute the effective number of assets, defined as the inverse of the\n    Herfindahl index.\n\n    .. math:: N_{eff} = \\frac{1}{\\Vert w \\Vert_{2}^{2}}\n\n    It quantifies portfolio concentration, with a higher value indicating a more\n    diversified portfolio.\n\n    Parameters\n    ----------\n    weights : ndarray of shape (n_assets,)\n        Weights of the assets.\n\n    Returns\n    -------\n    value : float\n        Effective number of assets.\n\n    References\n    ----------\n    .. [1] \"Banking and Financial Institutions Law in a Nutshell\".\n        Lovett, William Anthony (1988)\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.pre_selection._select_k_extremes.SelectKExtremes::fit", "project": "skfolio", "func": "SelectKExtremes::fit", "origin_file": "skfolio/pre_selection/_select_k_extremes.py", "test_list": ["../tests/test_pre_selection/test_select_k_extremes.py"], "prob_info": {"func_start_lineno": 63, "func_end_lineno": 96, "key_block_start_lineno": 79, "key_block_end_lineno": 96, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"SelectKExtremes\":\n        \"\"\"Run the SelectKExtremes transformer and get the appropriate assets.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : SelectKExtremes\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.default_asset_names", "project": "skfolio", "func": "default_asset_names", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_pre_selection/test_select_k_extremes.py"], "prob_info": {"func_start_lineno": 688, "func_end_lineno": 701, "key_block_start_lineno": 701, "key_block_end_lineno": 701, "new_func_code": "def default_asset_names(n_assets: int) -> np.ndarray:\n    \"\"\"Default asset names are `[\"x0\", \"x1\", ..., \"x(n_assets - 1)\"]`.\n\n    Parameters\n    ----------\n    n_assets : int\n        Number of assets.\n\n    Returns\n    -------\n    asset_names : ndarray of str\n        Default assets names.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::sort_measure", "project": "skfolio", "func": "Population::sort_measure", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_pre_selection/test_select_k_extremes.py"], "prob_info": {"func_start_lineno": 260, "func_end_lineno": 282, "key_block_start_lineno": 276, "key_block_end_lineno": 282, "new_func_code": "def sort_measure(self, measure: skt.Measure, reverse: bool = False) -> \"Population\":\n        \"\"\"Sort the population by a given portfolio measure.\n\n        Parameters\n        ----------\n        measure : Measure\n            The portfolio measure.\n\n        reverse : bool, default=False\n            If this is set to True, the order is reversed.\n\n        Returns\n        -------\n        values : Populations\n            The sorted population.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.pre_selection._select_non_dominated.SelectNonDominated::fit", "project": "skfolio", "func": "SelectNonDominated::fit", "origin_file": "skfolio/pre_selection/_select_non_dominated.py", "test_list": ["../tests/test_pre_selection/test_select_non_dominated.py"], "prob_info": {"func_start_lineno": 82, "func_end_lineno": 157, "key_block_start_lineno": 98, "key_block_end_lineno": 157, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None):\n        \"\"\"Run the Non Dominated transformer and get the appropriate assets.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : SelectNonDominated\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::non_denominated_sort", "project": "skfolio", "func": "Population::non_denominated_sort", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_pre_selection/test_select_non_dominated.py"], "prob_info": {"func_start_lineno": 126, "func_end_lineno": 159, "key_block_start_lineno": 144, "key_block_end_lineno": 159, "new_func_code": "def non_denominated_sort(self, first_front_only: bool = False) -> list[list[int]]:\n        \"\"\"Fast non-dominated sorting.\n        Sort the portfolios into different non-domination levels.\n        Complexity O(MN^2) where M is the number of objectives and N the number of\n        portfolios.\n\n        Parameters\n        ----------\n        first_front_only : bool, default=False\n            If this is set to True, only the first front is sorted and returned.\n            The default is `False`.\n\n        Returns\n        -------\n        fronts : list[list[int]]\n            A list of Pareto fronts (lists), the first list includes\n            non-dominated portfolios.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.pre_selection._select_non_expiring.SelectNonExpiring::fit", "project": "skfolio", "func": "SelectNonExpiring::fit", "origin_file": "skfolio/pre_selection/_select_non_expiring.py", "test_list": ["../tests/test_pre_selection/test_select_non_expiring.py"], "prob_info": {"func_start_lineno": 101, "func_end_lineno": 141, "key_block_start_lineno": 117, "key_block_end_lineno": 141, "new_func_code": "def fit(self, X: pd.DataFrame, y=None) -> \"SelectNonExpiring\":\n        \"\"\"Run the SelectNonExpiring transformer and get the appropriate assets.\n\n        Parameters\n        ----------\n        X : pd.DataFrame of shape (n_observations, n_assets)\n            Returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : SelectNonExpiring\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.equations._validate_groups", "project": "skfolio", "func": "_validate_groups", "origin_file": "skfolio/utils/equations.py", "test_list": ["../tests/test_prior/test_black_litterman.py"], "prob_info": {"func_start_lineno": 195, "func_end_lineno": 226, "key_block_start_lineno": 209, "key_block_end_lineno": 226, "new_func_code": "def _validate_groups(groups: npt.ArrayLike, name: str = \"groups\") -> np.ndarray:\n    \"\"\"Validate groups by checking its dim and if group names don't appear in multiple\n    levels and convert to numpy array.\n\n    Parameters\n    ----------\n    groups : array-like of shape (n_groups, n_assets)\n        2D-array of strings.\n\n    Returns\n    -------\n    groups : ndarray of shape (n_groups, n_assets)\n        2D-array of strings.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.prior._synthetic_data.SyntheticData::fit", "project": "skfolio", "func": "SyntheticData::fit", "origin_file": "skfolio/prior/_synthetic_data.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 144, "func_end_lineno": 205, "key_block_start_lineno": 167, "key_block_end_lineno": 205, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None, **fit_params) -> \"SyntheticData\":\n        \"\"\"Fit the Synthetic Data estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : SyntheticData\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.prior._synthetic_data._check_sample_method", "project": "skfolio", "func": "_check_sample_method", "origin_file": "skfolio/prior/_synthetic_data.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 208, "func_end_lineno": 239, "key_block_start_lineno": 224, "key_block_end_lineno": 239, "new_func_code": "def _check_sample_method(distribution_estimator: skb.BaseEstimator) -> None:\n    \"\"\"Check that the distribution_estimator implements a valid 'sample' method.\n\n    This helper function verifies that the given estimator has a callable 'sample'\n    method and that this method accepts an 'n_samples' parameter.\n\n    Parameters\n    ----------\n    distribution_estimator : BaseEstimator\n        The estimator whose 'sample' method is to be validated.\n\n    Raises\n    ------\n    ValueError\n        If the 'sample' method is missing or does not have an 'n_samples' parameter.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._vine_copula.VineCopula::fit", "project": "skfolio", "func": "VineCopula::fit", "origin_file": "skfolio/distribution/multivariate/_vine_copula.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 299, "func_end_lineno": 462, "key_block_start_lineno": 321, "key_block_end_lineno": 462, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"VineCopula\":\n        \"\"\"\n        Fit the Vine Copula model to the data.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : VineCopula\n            The fitted VineCopula instance.\n\n        Raises\n        ------\n        ValueError\n            If the number of assets is less than or equal to 2, or if max_depth <= 1.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._utils.ChildNode::central", "project": "skfolio", "func": "ChildNode::central", "origin_file": "skfolio/distribution/multivariate/_utils.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 191, "func_end_lineno": 202, "key_block_start_lineno": 200, "key_block_end_lineno": 202, "new_func_code": "def central(self) -> bool:\n        \"\"\"Determine whether this node is considered central.\n        It is inherited from the associated edge's centrality.\n\n        Returns\n        -------\n        central: bool\n           True if the node is central; otherwise, False.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.uncertainty_set._bootstrap.BootstrapMuUncertaintySet::fit", "project": "skfolio", "func": "BootstrapMuUncertaintySet::fit", "origin_file": "skfolio/uncertainty_set/_bootstrap.py", "test_list": ["../tests/test_uncertainty_set/test_bootstrap.py"], "prob_info": {"func_start_lineno": 106, "func_end_lineno": 161, "key_block_start_lineno": 132, "key_block_end_lineno": 161, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y: npt.ArrayLike | None = None, **fit_params\n    ) -> \"BootstrapMuUncertaintySet\":\n        \"\"\"Fit the Bootstrap Mu Uncertainty set estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_factors), optional\n            Price returns of factors.\n            The default is `None`.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : BootstrapMuUncertaintySet\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.uncertainty_set._empirical.EmpiricalMuUncertaintySet::fit", "project": "skfolio", "func": "EmpiricalMuUncertaintySet::fit", "origin_file": "skfolio/uncertainty_set/_empirical.py", "test_list": ["../tests/test_uncertainty_set/test_empirical.py"], "prob_info": {"func_start_lineno": 91, "func_end_lineno": 136, "key_block_start_lineno": 117, "key_block_end_lineno": 136, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y: npt.ArrayLike | None = None, **fit_params\n    ) -> \"EmpiricalMuUncertaintySet\":\n        \"\"\"Fit the Empirical Mu Uncertainty set estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_factors), optional\n            Price returns of factors.\n            The default is `None`.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : EmpiricalMuUncertaintySet\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.bootstrap.stationary_bootstrap", "project": "skfolio", "func": "stationary_bootstrap", "origin_file": "skfolio/utils/bootstrap.py", "test_list": ["../tests/test_utils/test_bootstrap.py"], "prob_info": {"func_start_lineno": 68, "func_end_lineno": 118, "key_block_start_lineno": 99, "key_block_end_lineno": 118, "new_func_code": "def stationary_bootstrap(\n    returns: np.ndarray,\n    n_bootstrap_samples: int,\n    block_size: float | None = None,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Create `n_bootstrap_samples` samples from a multivariate return series via\n    stationary bootstrapping.\n\n    Parameters\n    ----------\n    returns: ndarray of shape (n_observations, n_assets)\n        The returns array.\n\n    n_bootstrap_samples: int\n        The number of bootstrap samples to generate.\n\n    block_size: float, optional\n        The block size.\n        If this is set to None, we estimate the optimal block size using Politis &\n        White algorithm for all individual asset and the median.\n\n    seed: int, optional\n        Random seed used to initialize the pseudo-random number generator\n\n    Returns\n    -------\n    value: ndarray\n           The sample returns of shape (reps, nb observations, nb assets)\n\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.equations._string_to_equation", "project": "skfolio", "func": "_string_to_equation", "origin_file": "skfolio/utils/equations.py", "test_list": ["../tests/test_utils/test_equations.py"], "prob_info": {"func_start_lineno": 374, "func_end_lineno": 499, "key_block_start_lineno": 400, "key_block_end_lineno": 499, "new_func_code": "def _string_to_equation(\n    groups: np.ndarray,\n    string: str,\n    sum_to_one: bool,\n) -> tuple[np.ndarray, float, bool]:\n    \"\"\"Convert a string to a left 1D-array and right float of the form:\n    `groups @ left <= right` or `groups @ left == right` and return whether it's an\n    equality or inequality.\n\n    Parameters\n    ----------\n    groups : ndarray of shape (n_groups, n_assets)\n        Groups 2D-array\n\n    string : str\n        String to convert\n\n    sum_to_one : bool\n        If this is set to True, the 1D-array is scaled to have a sum of one.\n\n    Returns\n    -------\n    left : 1D-array of shape (n_assets,)\n    right : float\n    is_inequality : bool\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.equations._sub_add_operator_sign", "project": "skfolio", "func": "_sub_add_operator_sign", "origin_file": "skfolio/utils/equations.py", "test_list": ["../tests/test_utils/test_equations.py"], "prob_info": {"func_start_lineno": 307, "func_end_lineno": 325, "key_block_start_lineno": 320, "key_block_end_lineno": 325, "new_func_code": "def _sub_add_operator_sign(operator: str) -> int:\n    \"\"\"Convert the operators '+' and '-' into 1 or -1.\n\n    Parameters\n    ----------\n    operator : str\n       Operator: '+' and '-'.\n\n    Returns\n    -------\n    value : int\n       Operator sign: 1 or -1.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.equations._comparison_operator_sign", "project": "skfolio", "func": "_comparison_operator_sign", "origin_file": "skfolio/utils/equations.py", "test_list": ["../tests/test_utils/test_equations.py"], "prob_info": {"func_start_lineno": 285, "func_end_lineno": 304, "key_block_start_lineno": 299, "key_block_end_lineno": 304, "new_func_code": "def _comparison_operator_sign(operator: str) -> int:\n    \"\"\"Convert the operators '>=', \"==\" and '<=' into the corresponding integer\n    values -1, 1 and 1, respectively.\n\n    Parameters\n    ----------\n    operator : str\n        Operator: '>=' or '<='.\n\n    Returns\n    -------\n    value : int\n        Operator sign: 1 or -1.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.sorting.dominate", "project": "skfolio", "func": "dominate", "origin_file": "skfolio/utils/sorting.py", "test_list": ["../tests/test_utils/test_sorting.py"], "prob_info": {"func_start_lineno": 12, "func_end_lineno": 40, "key_block_start_lineno": 32, "key_block_end_lineno": 40, "new_func_code": "def dominate(fitness_1: np.ndarray, fitness_2: np.ndarray) -> bool:\n    \"\"\"Compute the domination of two fitness arrays.\n\n    Domination of `fitness_1` over `fitness_2` means that each objective (value) of\n    `fitness_1` is not strictly worse than the corresponding objective of `fitness_2`\n    and at least one objective is strictly better.\n\n    Parameters\n    ----------\n    fitness_1 : ndarray of floats of shape (n_objectives,)\n        Fitness array 1.\n\n    fitness_2 : ndarray of floats of shape (n_objectives,)\n        Fitness array 2.\n\n    Returns\n    -------\n    is_dominated : bool\n        Ture if `fitness_1` dominates `fitness_2`, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.n_bins_freedman", "project": "skfolio", "func": "n_bins_freedman", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_utils/test_stats.py"], "prob_info": {"func_start_lineno": 59, "func_end_lineno": 85, "key_block_start_lineno": 77, "key_block_end_lineno": 85, "new_func_code": "def n_bins_freedman(x: np.ndarray) -> int:\n    \"\"\"Compute the optimal histogram bin size using the Freedman-Diaconis rule [1]_.\n\n    Parameters\n    ----------\n    x : ndarray of shape (n_observations,)\n        The input array.\n\n    Returns\n    -------\n    n_bins : int\n        The optimal bin size.\n\n    References\n    ----------\n    .. [1] \"On the histogram as a density estimator: L2 theory\".\n        Freedman & Diaconis (1981).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.datasets._base.load_nasdaq_dataset", "project": "skfolio", "func": "load_nasdaq_dataset", "origin_file": "skfolio/datasets/_base.py", "test_list": ["../tests/test_utils/test_stats.py"], "prob_info": {"func_start_lineno": 348, "func_end_lineno": 397, "key_block_start_lineno": 393, "key_block_end_lineno": 397, "new_func_code": "def load_nasdaq_dataset(data_home=None, download_if_missing=True) -> pd.DataFrame:\n    \"\"\"Load the prices of 1455 assets from the NASDAQ Composite Index.\n\n    This dataset is composed of the daily prices of 1455 assets from the NASDAQ\n    Composite starting from 2018-01-02 up to 2023-05-31.\n\n    The data comes from the Yahoo public API.\n    The price is the adjusted close which is the closing price after adjustments for\n    all applicable splits and dividend distributions.\n    The adjustment uses appropriate split and dividend multipliers, adhering to\n    the Center for Research in Security Prices (CRSP) standards.\n\n    ==============   ==================\n    Observations     1362\n    Assets           1455\n    ==============   ==================\n\n    Parameters\n    ----------\n    data_home : str, optional\n        Specify another download and cache folder for the datasets.\n        By default, all skfolio data is stored in `~/skfolio_data` subfolders.\n\n    download_if_missing : bool, default=True\n        If False, raise an OSError if the data is not locally available\n        instead of trying to download the data from the source site.\n\n    Returns\n    -------\n    df : DataFrame of shape (n_observations, n_assets)\n        Prices DataFrame\n\n    Examples\n    --------\n    >>> from skfolio.datasets import load_nasdaq_dataset\n    >>> prices = load_nasdaq_dataset()\n    >>> prices.head()\n                   AAL   AAOI    AAON    AAPL  ...  ZVRA   ZYME    ZYNE   ZYXI\n    Date                                       ...\n    2018-01-02  51.648  37.91  35.621  41.310  ...  66.4  7.933  12.995  2.922\n    2018-01-03  51.014  37.89  36.247  41.303  ...  72.8  7.965  13.460  2.913\n    2018-01-04  51.336  38.38  36.103  41.495  ...  78.4  8.430  12.700  2.869\n    2018-01-05  51.316  38.89  36.681  41.967  ...  77.6  8.400  12.495  2.780\n    2018-01-08  50.809  38.37  36.103  41.811  ...  82.4  8.310  12.550  2.825\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.format_measure", "project": "skfolio", "func": "format_measure", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_utils/test_tools.py"], "prob_info": {"func_start_lineno": 506, "func_end_lineno": 534, "key_block_start_lineno": 522, "key_block_end_lineno": 534, "new_func_code": "def format_measure(x: float, percent: bool = False) -> str:\n    \"\"\"Format a measure number into a user-friendly string.\n\n    Parameters\n    ----------\n    x : float\n        Number to format.\n\n    percent : bool, default=False\n        If this is set to True, the number is formatted in percentage.\n\n    Returns\n    -------\n    formatted : str\n        Formatted string.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.compute_optimal_n_clusters", "project": "skfolio", "func": "compute_optimal_n_clusters", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_cluster/test_hierarchical.py"], "prob_info": {"func_start_lineno": 424, "func_end_lineno": 493, "key_block_start_lineno": 473, "key_block_end_lineno": 493, "new_func_code": "def compute_optimal_n_clusters(distance: np.ndarray, linkage_matrix: np.ndarray) -> int:\n    r\"\"\"Compute the optimal number of clusters based on Two-Order Difference to Gap\n    Statistic [1]_.\n\n    The Two-Order Difference to Gap Statistic has been developed to improve the\n    performance and stability of the Tibshiranis Gap statistic.\n    It applies the two-order difference of the within-cluster dispersion to replace the\n    reference null distribution in the Gap statistic.\n\n    The number of cluster :math:`k` is determined by:\n\n    .. math::  \\begin{cases}\n                \\begin{aligned}\n                &\\max_{k} & & W_{k+2} + W_{k} - 2 W_{k+1} \\\\\n                &\\text{s.t.} & & 1 \\ge c \\ge max\\bigl(8, \\sqrt{n}\\bigr) \\\\\n                \\end{aligned}\n                \\end{cases}\n\n    with :math:`n` the sample size and :math:`W_{k}` the within-cluster dispersions\n    defined as:\n\n    .. math:: W_{k} = \\sum_{i=1}^{k} \\frac{D_{i}}{2|C_{i}|}\n\n    where :math:`|C_{i}|` is the cardinality of cluster :math:`i` and :math:`D_{i}` its\n    density defined as:\n\n    .. math:: D_{i} = \\sum_{u \\in C_{i}} \\sum_{v \\in C_{i}} d(u,v)\n\n    with :math:`d(u,v)` the distance between u and v.\n\n\n    Parameters\n    ----------\n    distance : ndarray of shape (n, n)\n        Distance matrix.\n\n    linkage_matrix : ndarray of shape (n - 1, 4)\n        Linkage matrix.\n\n    Returns\n    -------\n    value : int\n        Optimal number of clusters.\n\n    References\n    ----------\n    .. [1] \"Application of two-order difference to gap statistic\".\n        Yue, Wang & Wei (2009)\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.cluster._hierarchical.HierarchicalClustering::plot_dendrogram", "project": "skfolio", "func": "HierarchicalClustering::plot_dendrogram", "origin_file": "skfolio/cluster/_hierarchical.py", "test_list": ["../tests/test_cluster/test_hierarchical.py"], "prob_info": {"func_start_lineno": 210, "func_end_lineno": 389, "key_block_start_lineno": 234, "key_block_end_lineno": 389, "new_func_code": "def plot_dendrogram(self, heatmap: bool = True) -> go.Figure:\n        \"\"\"Plot the dendrogram.\n\n        The blue lines represent distinct clusters composed of a single asset.\n        The remaining colors represent clusters of more than one asset.\n\n        When `heatmap` is set to True, the heatmap of the reordered distance matrix is\n        displayed below the dendrogram and clusters are outlined with yellow squares.\n\n        The number of clusters used in the plot is the same as the `n_clusters_`\n        attribute if it exists, otherwise a default number is used corresponding to the\n        number of cluster with a distance above 70% of the maximum cluster distance.\n\n        Parameters\n        ----------\n        heatmap : bool, default=True\n            If this is set to True, the distance heatmap is returned with the clustered\n            outlined in yellow.\n\n        Returns\n        -------\n        fig : Figure\n            The dendrogram figure.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.is_cholesky_dec", "project": "skfolio", "func": "is_cholesky_dec", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 169, "func_end_lineno": 189, "key_block_start_lineno": 184, "key_block_end_lineno": 189, "new_func_code": "def is_cholesky_dec(x: np.ndarray) -> bool:\n    \"\"\"Returns True if Cholesky decomposition can be computed.\n    The matrix must be Hermitian (symmetric if real-valued) and positive-definite.\n    No checking is performed to verify whether the matrix is Hermitian or not.\n\n    Parameters\n    ----------\n    x : ndarray of shape (n, m)\n       The matrix.\n\n    Returns\n    -------\n    value : bool\n        True if Cholesky decomposition can be applied to the matrix, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.is_positive_definite", "project": "skfolio", "func": "is_positive_definite", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 192, "func_end_lineno": 205, "key_block_start_lineno": 205, "key_block_end_lineno": 205, "new_func_code": "def is_positive_definite(x: np.ndarray) -> bool:\n    \"\"\"Returns True if the matrix is positive definite.\n\n    Parameters\n    ----------\n    x : ndarray of shape (n, m)\n       The matrix.\n\n    Returns\n    -------\n    value : bool\n        True if the matrix is positive definite, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.cov_to_corr", "project": "skfolio", "func": "cov_to_corr", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 260, "func_end_lineno": 277, "key_block_start_lineno": 273, "key_block_end_lineno": 277, "new_func_code": "def cov_to_corr(cov: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"Convert a covariance matrix to a correlation matrix.\n\n    Parameters\n    ----------\n    cov : ndarray of shape (n, n)\n        Covariance matrix.\n\n    Returns\n    -------\n    corr, std : tuple[ndarray of shape (n, n), ndarray of shape (n, )]\n        Correlation matrix and standard-deviation vector\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.covariance._implied_covariance.ImpliedCovariance::fit", "project": "skfolio", "func": "ImpliedCovariance::fit", "origin_file": "skfolio/moments/covariance/_implied_covariance.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 210, "func_end_lineno": 327, "key_block_start_lineno": 238, "key_block_end_lineno": 327, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y=None, implied_vol: npt.ArrayLike = None, **fit_params\n    ) -> \"ImpliedCovariance\":\n        \"\"\"Fit the implied covariance estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        implied_vol : array-like of shape (n_observations, n_assets)\n            Implied volatilities of the assets.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : ImpliedCovariance\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.get_feature_names", "project": "skfolio", "func": "get_feature_names", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 729, "func_end_lineno": 787, "key_block_start_lineno": 749, "key_block_end_lineno": 787, "new_func_code": "def get_feature_names(X):\n    \"\"\"Get feature names from X.\n\n    Support for other array containers should place its implementation here.\n\n    Parameters\n    ----------\n    X : {ndarray, dataframe} of shape (n_samples, n_features)\n        Array container to extract feature names.\n\n        - pandas dataframe : The columns will be considered to be feature\n          names. If the dataframe contains non-string feature names, `None` is\n          returned.\n        - All other array containers will return `None`.\n\n    Returns\n    -------\n    names: ndarray or None\n        Feature names of `X`. Unrecognized array containers will return `None`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.covariance._implied_covariance.check_implied_vol", "project": "skfolio", "func": "check_implied_vol", "origin_file": "skfolio/moments/covariance/_implied_covariance.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 413, "func_end_lineno": 457, "key_block_start_lineno": 429, "key_block_end_lineno": 457, "new_func_code": "def check_implied_vol(implied_vol: npt.ArrayLike, X: npt.ArrayLike) -> np.ndarray:\n    \"\"\"Validate implied volatilities.\n\n    Parameters\n    ----------\n    implied_vol : array-like of shape (n_observations, n_assets)\n        Implied volatilities of the assets.\n\n    X : array-like of shape (n_observations, n_assets)\n        Price returns of the assets.\n\n    Returns\n    -------\n    implied_vol : ndarray of shape (n_observations, n_assets)\n        Validated implied volatilities.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distance._distance.DistanceCorrelation::fit", "project": "skfolio", "func": "DistanceCorrelation::fit", "origin_file": "skfolio/distance/_distance.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 397, "func_end_lineno": 422, "key_block_start_lineno": 413, "key_block_end_lineno": 422, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"DistanceCorrelation\":\n        \"\"\"Fit the Distance Correlation estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : DistanceCorrelation\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._clayton._base_partial_derivative", "project": "skfolio", "func": "_base_partial_derivative", "origin_file": "skfolio/distribution/copula/_clayton.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 461, "func_end_lineno": 498, "key_block_start_lineno": 494, "key_block_end_lineno": 498, "new_func_code": "def _base_partial_derivative(\n    X: np.ndarray, first_margin: bool, theta: float\n) -> np.ndarray:\n    r\"\"\"\n    Compute the partial derivative (h-function) for the unrotated Clayton copula.\n\n    For Clayton, the copula is defined as:\n\n    .. math::\n        C(u,v)=\\Bigl(u^{-\\theta}+v^{-\\theta}-1\\Bigr)^{-1/\\theta}.\n\n    The partial derivative with respect to v is:\n\n    .. math::\n        \\frac{\\partial C(u,v)}{\\partial v} = \\Bigl(u^{-\\theta}+v^{-\\theta}-1\\Bigr)^{-1/\\theta-1}\\,v^{-\\theta-1}.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n         An array of bivariate inputs `(u, v)` with values in [0, 1].\n\n    first_margin : bool, default=False\n         If True, compute with respect to u (by swapping margins); otherwise\n         compute with respect to v.\n\n    theta : float\n         The dependence parameter (must be > 0).\n\n    Returns\n    -------\n    p : ndarray of shape (n_observations,)\n         The computed h-function values.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._clayton._base_inverse_partial_derivative", "project": "skfolio", "func": "_base_inverse_partial_derivative", "origin_file": "skfolio/distribution/copula/_clayton.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 501, "func_end_lineno": 539, "key_block_start_lineno": 535, "key_block_end_lineno": 539, "new_func_code": "def _base_inverse_partial_derivative(\n    X: np.ndarray, first_margin: bool, theta: float\n) -> np.ndarray:\n    r\"\"\"\n    Compute the inverse partial derivative for the unrotated Clayton copula,\n    i.e. solve for u in h(u|v)=p.\n\n    In other words, given\n      - p, the value of the h-function, and\n      - v, the conditioning variable,\n    solve:\n\n    .. math::\n      p = \\Bigl(u^{-\\theta}+v^{-\\theta}-1\\Bigr)^{-1/\\theta-1}\\,v^{-\\theta-1},\n\n    for u  [0,1]. Since no closed-form solution exists, we use a Newton method.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n         An array with first column p (h-function values) and second column v\n         (conditioning variable).\n\n    first_margin : bool, default=False\n         If True, treat the first margin as the conditioning variable.\n\n    theta : float\n         The dependence parameter (must be > 0).\n\n    Returns\n    -------\n    u : ndarray of shape (n_observations,)\n         A 1D-array where each element is the solution u  [0,1] such that h(u|v)=p.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._clayton.ClaytonCopula::inverse_partial_derivative", "project": "skfolio", "func": "ClaytonCopula::inverse_partial_derivative", "origin_file": "skfolio/distribution/copula/_clayton.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 293, "func_end_lineno": 344, "key_block_start_lineno": 335, "key_block_end_lineno": 344, "new_func_code": "def inverse_partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the inverse of the bivariate copula's partial derivative, commonly\n        known as the inverse h-function.\n\n        Let :math:`C(u, v)` be a bivariate copula. The h-function with respect to the\n        second margin is defined by\n\n        .. math::\n            h(u \\mid v) \\;=\\; \\frac{\\partial\\,C(u, v)}{\\partial\\,v},\n\n        which is the conditional distribution of :math:`U` given :math:`V = v`.\n        The **inverse h-function**, denoted :math:`h^{-1}(p \\mid v)`, is the unique\n        value :math:`u \\in [0,1]` such that\n\n        .. math::\n            h(u \\mid v) \\;=\\; p,\n            \\quad \\text{where } p \\in [0,1].\n\n        In practical terms, given :math:`(p, v)` in :math:`[0, 1]^2`,\n        :math:`h^{-1}(p \\mid v)` solves for the :math:`u` satisfying\n        :math:`p = \\partial C(u, v)/\\partial v`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(p, v)`, each in the interval `[0, 1]`.\n            - The first column `p` corresponds to the value of the h-function.\n            - The second column `v` is the conditioning variable.\n\n        first_margin : bool, default=False\n            If True, compute the inverse partial derivative with respect to the first\n            margin `u`; otherwise, compute the inverse partial derivative with respect\n            to the second margin `v`.\n\n        Returns\n        -------\n        u : ndarray of shape (n_observations,)\n            A 1D-array of length `n_observations`, where each element is the computed\n            :math:`u = h^{-1}(p \\mid v)` for the corresponding pair in `X`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._clayton.ClaytonCopula::cdf", "project": "skfolio", "func": "ClaytonCopula::cdf", "origin_file": "skfolio/distribution/copula/_clayton.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 227, "func_end_lineno": 247, "key_block_start_lineno": 242, "key_block_end_lineno": 247, "new_func_code": "def cdf(self, X: npt.ArrayLike) -> np.ndarray:\n        \"\"\"Compute the CDF of the bivariate Clayton copula.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        cdf : ndarray of shape (n_observations,)\n            CDF values for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gumbel.GumbelCopula::inverse_partial_derivative", "project": "skfolio", "func": "GumbelCopula::inverse_partial_derivative", "origin_file": "skfolio/distribution/copula/_gumbel.py", "test_list": ["../tests/test_distribution/test_copula/test_gumbel.py"], "prob_info": {"func_start_lineno": 296, "func_end_lineno": 347, "key_block_start_lineno": 338, "key_block_end_lineno": 347, "new_func_code": "def inverse_partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the inverse of the bivariate copula's partial derivative, commonly\n        known as the inverse h-function.\n\n        Let :math:`C(u, v)` be a bivariate copula. The h-function with respect to the\n        second margin is defined by\n\n        .. math::\n            h(u \\mid v) \\;=\\; \\frac{\\partial\\,C(u, v)}{\\partial\\,v},\n\n        which is the conditional distribution of :math:`U` given :math:`V = v`.\n        The **inverse h-function**, denoted :math:`h^{-1}(p \\mid v)`, is the unique\n        value :math:`u \\in [0,1]` such that\n\n        .. math::\n            h(u \\mid v) \\;=\\; p,\n            \\quad \\text{where } p \\in [0,1].\n\n        In practical terms, given :math:`(p, v)` in :math:`[0, 1]^2`,\n        :math:`h^{-1}(p \\mid v)` solves for the :math:`u` satisfying\n        :math:`p = \\partial C(u, v)/\\partial v`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(p, v)`, each in the interval [0, 1].\n            - The first column `p` corresponds to the value of the h-function.\n            - The second column `v` is the conditioning variable.\n\n        first_margin : bool, default=False\n            If True, compute the inverse partial derivative with respect to the first\n            margin `u`; otherwise, compute the inverse partial derivative with respect\n            to the second margin `v`.\n\n        Returns\n        -------\n        u : ndarray of shape (n_observations,)\n            A 1D-array where each element is the computed :math:`u = h^{-1}(p \\mid v)`\n            for the corresponding pair in `X`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gumbel.GumbelCopula::score_samples", "project": "skfolio", "func": "GumbelCopula::score_samples", "origin_file": "skfolio/distribution/copula/_gumbel.py", "test_list": ["../tests/test_distribution/test_copula/test_gumbel.py"], "prob_info": {"func_start_lineno": 349, "func_end_lineno": 375, "key_block_start_lineno": 371, "key_block_end_lineno": 375, "new_func_code": "def score_samples(self, X: npt.ArrayLike) -> np.ndarray:\n        r\"\"\"Compute the log-likelihood of each sample (log-pdf) under the model.\n\n        For Gumbel, the PDF is given by:\n\n        .. math::\n            c(u,v) = \\exp\\Bigl(-\\Bigl((-\\ln u)^{\\theta}+(-\\ln v)^{\\theta}\\Bigr)^{1/\\theta}\\Bigr)\n                     \\cdot \\left[\\Bigl((-\\ln u)^{\\theta}+(-\\ln v)^{\\theta}\\Bigr)^{1/\\theta-1}\n                          \\left\\{ \\frac{(-\\ln u)^{\\theta}}{u}+\\frac{(-\\ln v)^{\\theta}}{v}\\right\\}\\right].\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval [0, 1],\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        density : ndarray of shape (n_observations,)\n            The log-likelihood of each sample under the fitted copula.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gumbel.GumbelCopula::cdf", "project": "skfolio", "func": "GumbelCopula::cdf", "origin_file": "skfolio/distribution/copula/_gumbel.py", "test_list": ["../tests/test_distribution/test_copula/test_gumbel.py"], "prob_info": {"func_start_lineno": 227, "func_end_lineno": 250, "key_block_start_lineno": 245, "key_block_end_lineno": 250, "new_func_code": "def cdf(self, X: npt.ArrayLike) -> np.ndarray:\n        r\"\"\"Compute the CDF of the bivariate Gumbel copula.\n\n        .. math::\n            C(u,v) = \\exp\\Bigl(-\\Bigl[(-\\ln u)^{\\theta}+(-\\ln v)^{\\theta}\\Bigr]^{1/\\theta}\\Bigr).\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval [0, 1],\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        cdf : ndarray of shape (n_observations,)\n            CDF values for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._joe._base_partial_derivative", "project": "skfolio", "func": "_base_partial_derivative", "origin_file": "skfolio/distribution/copula/_joe.py", "test_list": ["../tests/test_distribution/test_copula/test_joe.py"], "prob_info": {"func_start_lineno": 517, "func_end_lineno": 546, "key_block_start_lineno": 543, "key_block_end_lineno": 546, "new_func_code": "def _base_partial_derivative(\n    X: np.ndarray, first_margin: bool, theta: float\n) -> np.ndarray:\n    r\"\"\"Compute the h-function (partial derivative) for the bivariate unrotated\n    Joe copula with respect to a specified margin.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        An array of bivariate inputs `(u, v)` where each row represents a\n        bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n        having been transformed to uniform marginals.\n\n    first_margin : bool, default=False\n        If True, compute the partial derivative with respect to the first\n        margin `u`; otherwise, compute the partial derivative with respect to the\n        second margin `v`.\n\n    theta : float\n        The dependence parameter (must be greater than 1).\n\n    Returns\n    -------\n      : ndarray of shape (n_observations,)\n        h-function values :math:`h(u \\mid v) \\;=\\; p` for each observation in X.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._joe.JoeCopula::inverse_partial_derivative", "project": "skfolio", "func": "JoeCopula::inverse_partial_derivative", "origin_file": "skfolio/distribution/copula/_joe.py", "test_list": ["../tests/test_distribution/test_copula/test_joe.py"], "prob_info": {"func_start_lineno": 313, "func_end_lineno": 371, "key_block_start_lineno": 361, "key_block_end_lineno": 371, "new_func_code": "def inverse_partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the inverse of the bivariate copula's partial derivative, commonly\n        known as the inverse h-function [1]_.\n\n        Let :math:`C(u, v)` be a bivariate copula. The h-function with respect to the\n        second margin is defined by\n\n        .. math::\n            h(u \\mid v) \\;=\\; \\frac{\\partial\\,C(u, v)}{\\partial\\,v},\n\n        which is the conditional distribution of :math:`U` given :math:`V = v`.\n        The **inverse h-function**, denoted :math:`h^{-1}(p \\mid v)`, is the unique\n        value :math:`u \\in [0,1]` such that\n\n        .. math::\n            h(u \\mid v) \\;=\\; p,\n            \\quad \\text{where } p \\in [0,1].\n\n        In practical terms, given :math:`(p, v)` in :math:`[0, 1]^2`,\n        :math:`h^{-1}(p \\mid v)` solves for the :math:`u` satisfying\n        :math:`p = \\partial C(u, v)/\\partial v`.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(p, v)`, each in the interval `[0, 1]`.\n            - The first column `p` corresponds to the value of the h-function.\n            - The second column `v` is the conditioning variable.\n\n        first_margin : bool, default=False\n            If True, compute the inverse partial derivative with respect to the first\n            margin `u`; otherwise, compute the inverse partial derivative with respect\n            to the second margin `v`.\n\n        Returns\n        -------\n        u : ndarray of shape (n_observations,)\n            A 1D-array of length `n_observations`, where each element is the computed\n            :math:`u = h^{-1}(p \\mid v)` for the corresponding pair in `X`.\n\n        References\n        ----------\n        .. [1] \"Multivariate Models and Dependence Concepts\", Joe, H. (1997)\n        .. [2] \"An Introduction to Copulas\", Nelsen, R. B. (2006)\n        .. [3] . \"Nested Archimedean Copulas Meet \", Hofert & Mchler (2011)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._joe.JoeCopula::score_samples", "project": "skfolio", "func": "JoeCopula::score_samples", "origin_file": "skfolio/distribution/copula/_joe.py", "test_list": ["../tests/test_distribution/test_copula/test_joe.py"], "prob_info": {"func_start_lineno": 373, "func_end_lineno": 392, "key_block_start_lineno": 388, "key_block_end_lineno": 392, "new_func_code": "def score_samples(self, X: npt.ArrayLike) -> np.ndarray:\n        \"\"\"Compute the log-likelihood of each sample (log-pdf) under the model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        density : ndarray of shape (n_observations,)\n            The log-likelihood of each sample under the fitted copula.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._joe.JoeCopula::cdf", "project": "skfolio", "func": "JoeCopula::cdf", "origin_file": "skfolio/distribution/copula/_joe.py", "test_list": ["../tests/test_distribution/test_copula/test_joe.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 263, "key_block_start_lineno": 258, "key_block_end_lineno": 263, "new_func_code": "def cdf(self, X: npt.ArrayLike) -> np.ndarray:\n        \"\"\"Compute the CDF of the bivariate Joe copula.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        cdf : ndarray of shape (n_observations,)\n            CDF values for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.drawdown_at_risk", "project": "skfolio", "func": "drawdown_at_risk", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 456, "func_end_lineno": 474, "key_block_start_lineno": 474, "key_block_end_lineno": 474, "new_func_code": "def drawdown_at_risk(drawdowns: np.ndarray, beta: float = 0.95) -> float:\n    \"\"\"Compute the Drawdown at risk.\n\n    The Drawdown at risk is the maximum drawdown at a given confidence level (beta).\n\n    Parameters\n    ----------\n    drawdowns : ndarray of shape (n_observations,)\n        Vector of drawdowns.\n\n    beta : float, default = 0.95\n        The DaR confidence level (drawdown on the worst (1-beta)% observations).\n\n    Returns\n    -------\n    value : float\n       Drawdown at risk.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.cdar", "project": "skfolio", "func": "cdar", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 509, "func_end_lineno": 526, "key_block_start_lineno": 526, "key_block_end_lineno": 526, "new_func_code": "def cdar(drawdowns: np.ndarray, beta: float = 0.95) -> float:\n    \"\"\"Compute the historical CDaR (conditional drawdown at risk).\n\n    Parameters\n    ----------\n    drawdowns : ndarray of shape (n_observations,)\n        Vector of drawdowns.\n\n    beta : float, default = 0.95\n        The CDaR confidence level (expected drawdown on the worst\n        (1-beta)% observations).\n\n    Returns\n    -------\n    value : float\n        CDaR.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.max_drawdown", "project": "skfolio", "func": "max_drawdown", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 477, "func_end_lineno": 490, "key_block_start_lineno": 490, "key_block_end_lineno": 490, "new_func_code": "def max_drawdown(drawdowns: np.ndarray) -> float:\n    \"\"\"Compute the maximum drawdown.\n\n    Parameters\n    ----------\n    drawdowns : ndarray of shape (n_observations,)\n        Vector of drawdowns.\n\n    Returns\n    -------\n    value : float\n        Maximum drawdown.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.average_drawdown", "project": "skfolio", "func": "average_drawdown", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 493, "func_end_lineno": 506, "key_block_start_lineno": 506, "key_block_end_lineno": 506, "new_func_code": "def average_drawdown(drawdowns: np.ndarray) -> float:\n    \"\"\"Compute the average drawdown.\n\n    Parameters\n    ----------\n    drawdowns : ndarray of shape (n_observations,)\n        Vector of drawdowns.\n\n    Returns\n    -------\n    value : float\n        Average drawdown.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.ulcer_index", "project": "skfolio", "func": "ulcer_index", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 552, "func_end_lineno": 565, "key_block_start_lineno": 565, "key_block_end_lineno": 565, "new_func_code": "def ulcer_index(drawdowns: np.ndarray) -> float:\n    \"\"\"Compute the Ulcer index.\n\n    Parameters\n    ----------\n    drawdowns : ndarray of shape (n_observations,)\n        Vector of drawdowns.\n\n    Returns\n    -------\n    value : float\n        Ulcer index.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.gini_mean_difference", "project": "skfolio", "func": "gini_mean_difference", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 586, "func_end_lineno": 606, "key_block_start_lineno": 605, "key_block_end_lineno": 606, "new_func_code": "def gini_mean_difference(returns: np.ndarray) -> float:\n    \"\"\"Compute the Gini mean difference (GMD).\n\n    The GMD is the expected absolute difference between two realisations.\n    The GMD is a superior measure of variability  for non-normal distribution than the\n    variance.\n    It can be used to form necessary conditions for second-degree stochastic dominance,\n    while the variance cannot.\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    Returns\n    -------\n    value : float\n        Gini mean difference.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.owa_gmd_weights", "project": "skfolio", "func": "owa_gmd_weights", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_measures/test_measures.py"], "prob_info": {"func_start_lineno": 568, "func_end_lineno": 583, "key_block_start_lineno": 581, "key_block_end_lineno": 583, "new_func_code": "def owa_gmd_weights(n_observations: int) -> np.ndarray:\n    \"\"\"Compute the OWA weights used for the Gini mean difference (GMD) computation.\n\n    Parameters\n    ----------\n    n_observations : int\n        Number of observations.\n\n    Returns\n    -------\n    value : float\n        OWA GMD weights.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.metrics._scorer.make_scorer", "project": "skfolio", "func": "make_scorer", "origin_file": "skfolio/metrics/_scorer.py", "test_list": ["../tests/test_metrics/test_scorer.py"], "prob_info": {"func_start_lineno": 57, "func_end_lineno": 126, "key_block_start_lineno": 107, "key_block_end_lineno": 126, "new_func_code": "def make_scorer(\n    score_func: skt.Measure | Callable,\n    greater_is_better: bool | None = None,\n    **kwargs,\n) -> Callable:\n    \"\"\"Make a scorer from a :ref:`measure <measures_ref>` or from a custom score\n    function.\n\n    This is a modified version from `scikit-learn` `make_scorer` for enhanced\n    functionalities with `Portfolio` objects.\n\n    This factory function wraps scoring functions for use in\n    `sklearn.model_selection.GridSearchCV` and\n    `sklearn.model_selection.cross_val_score`.\n\n    Parameters\n    ----------\n    score_func : Measure | callable\n        If `score_func` is a :ref:`measure <measures_ref>`, we return the measure of\n        the predicted :class:`~skfolio.portfolio.Portfolio` times `1` or `-1`\n        depending on the `greater_is_better` parameter.\n\n        Otherwise, `score_func` must be a score function (or loss function) with\n        signature `score_func(pred, **kwargs)`. The argument `pred` is the predicted\n        :class:`~skfolio.portfolio.Portfolio`.\n\n        Note that you can convert this portfolio object into a numpy array of price\n        returns with `np.asarray(pred)`.\n\n    greater_is_better : bool, optional\n        If this is set to True, `score_func` is a score function (default) meaning high\n        is good, otherwise it is a loss function, meaning low is good.\n        In the latter case, the scorer object will sign-flip the outcome of the `score_func`.\n        The default (`None`) is to use:\n\n        * If `score_func` is a :ref:`measure <measures_ref>`:\n\n            * True for `PerfMeasure` and `RationMeasure`\n            * False for `RiskMeasure` and `ExtraRiskMeasure`.\n\n        * Otherwise, True.\n\n    **kwargs : additional arguments\n        Additional parameters to be passed to score_func.\n\n    Returns\n    -------\n    scorer : callable\n        Callable object that returns a scalar score.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.fit_and_predict", "project": "skfolio", "func": "fit_and_predict", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_model_selection/test_validation.py"], "prob_info": {"func_start_lineno": 618, "func_end_lineno": 685, "key_block_start_lineno": 665, "key_block_end_lineno": 685, "new_func_code": "def fit_and_predict(\n    estimator: Any,\n    X: npt.ArrayLike,\n    y: npt.ArrayLike | None,\n    train: np.ndarray,\n    test: np.ndarray | list[np.ndarray],\n    fit_params: dict,\n    method: str,\n    column_indices: np.ndarray | None = None,\n) -> npt.ArrayLike | list[npt.ArrayLike]:\n    \"\"\"Fit the estimator and predict values for a given dataset split.\n\n    Parameters\n    ----------\n    estimator : estimator object implementing 'fit' and 'predict'\n        The object to use to fit the data.\n\n    X : array-like of shape (n_observations, n_assets)\n        The data to fit.\n\n    y : array-like of shape (n_observations, n_factors) or None\n        The factor array if provided\n\n    train : ndarray of int of shape (n_train_observations,)\n        Indices of training samples.\n\n    test : ndarray of int of shape (n_test_samples,) or list of ndarray\n        Indices of test samples or list of indices.\n\n    fit_params : dict\n        Parameters that will be passed to `estimator.fit`.\n\n    method : str\n        Invokes the passed method name of the passed estimator.\n\n    column_indices : ndarray, optional\n        Indices of columns to select.\n        The default (`None`) is to select all columns.\n\n    Returns\n    -------\n    predictions : array-like or list of array-like\n        If `test` is an array, it returns the array-like result of calling\n        'estimator.method' on `test`.\n        Otherwise, if `test` is a list of arrays, it returns the list of array-like\n        results of calling 'estimator.method' on each test set in `test`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools._check_method_params", "project": "skfolio", "func": "_check_method_params", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_model_selection/test_validation.py"], "prob_info": {"func_start_lineno": 147, "func_end_lineno": 187, "key_block_start_lineno": 173, "key_block_end_lineno": 187, "new_func_code": "def _check_method_params(\n    X: npt.ArrayLike, params: dict, indices: np.ndarray = None, axis: int = 0\n):\n    \"\"\"Check and validate the parameters passed to a specific\n    method like `fit`.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_samples, n_features)\n        Data array.\n\n    params : dict\n        Dictionary containing the parameters passed to the method.\n\n    indices : ndarray of shape (n_samples,), default=None\n        Indices to be selected if the parameter has the same size as `X`.\n\n    axis : int, default=0\n        The axis along which `X` will be sub-sampled. `axis=0` will select\n        rows while `axis=1` will select columns.\n\n    Returns\n    -------\n    method_params_validated : dict\n        Validated parameters. We ensure that the values support indexing.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.portfolio._multi_period_portfolio.MultiPeriodPortfolio::append", "project": "skfolio", "func": "MultiPeriodPortfolio::append", "origin_file": "skfolio/portfolio/_multi_period_portfolio.py", "test_list": ["../tests/test_model_selection/test_validation.py"], "prob_info": {"func_start_lineno": 630, "func_end_lineno": 658, "key_block_start_lineno": 638, "key_block_end_lineno": 658, "new_func_code": "def append(self, portfolio: Portfolio) -> None:\n        \"\"\"Append a Portfolio to the Portfolio list.\n\n        Parameters\n        ----------\n        portfolio : Portfolio\n            The Portfolio to append.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.naive._naive.InverseVolatility::fit", "project": "skfolio", "func": "InverseVolatility::fit", "origin_file": "skfolio/optimization/naive/_naive.py", "test_list": ["../tests/test_model_selection/test_validation.py"], "prob_info": {"func_start_lineno": 66, "func_end_lineno": 104, "key_block_start_lineno": 92, "key_block_end_lineno": 104, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y: npt.ArrayLike | None = None, **fit_params\n    ) -> \"InverseVolatility\":\n        \"\"\"Fit the Inverse Volatility estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_targets), optional\n            Price returns of factors or a target benchmark.\n            The default is `None`.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : InverseVolatility\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.covariance._ledoit_wolf.LedoitWolf::fit", "project": "skfolio", "func": "LedoitWolf::fit", "origin_file": "skfolio/moments/covariance/_ledoit_wolf.py", "test_list": ["../tests/test_moment/test_covariance/test_implied_covariance.py"], "prob_info": {"func_start_lineno": 122, "func_end_lineno": 140, "key_block_start_lineno": 138, "key_block_end_lineno": 140, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"LedoitWolf\":\n        \"\"\"Fit the Ledoit-Wolf shrunk covariance model to X.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n         Price returns of the assets.\n\n        y : Ignored\n          Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : LedoitWolf\n          Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.expected_returns._shrunk_mu.ShrunkMu::fit", "project": "skfolio", "func": "ShrunkMu::fit", "origin_file": "skfolio/moments/expected_returns/_shrunk_mu.py", "test_list": ["../tests/test_moment/test_expected_returns/test_expected_returns.py"], "prob_info": {"func_start_lineno": 152, "func_end_lineno": 244, "key_block_start_lineno": 175, "key_block_end_lineno": 244, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None, **fit_params) -> \"ShrunkMu\":\n        \"\"\"Fit the ShrunkMu estimator model.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : ShrunkMu\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.fit_single_estimator", "project": "skfolio", "func": "fit_single_estimator", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_optimization/test_cluster/test_nco.py"], "prob_info": {"func_start_lineno": 573, "func_end_lineno": 615, "key_block_start_lineno": 610, "key_block_end_lineno": 615, "new_func_code": "def fit_single_estimator(\n    estimator: Any,\n    X: npt.ArrayLike,\n    y: npt.ArrayLike | None,\n    fit_params: dict,\n    indices: np.ndarray | None = None,\n    axis: int = 0,\n):\n    \"\"\"Function used to fit an estimator within a job.\n\n    Parameters\n    ----------\n    estimator : estimator object implementing 'fit' and 'predict'\n        The object to use to fit the data.\n\n    X : array-like of shape (n_observations, n_assets)\n        The data to fit.\n\n    y : array-like of shape (n_observations, n_targets), optional\n        The target array if provided.\n\n    fit_params : dict\n        Parameters that will be passed to `estimator.fit`.\n\n    indices : ndarray of int, optional\n        Rows or columns to select from X and y.\n        The default (`None`) is to select the entire data.\n\n    axis : int, default=0\n        The axis along which `X` will be sub-sampled. `axis=0` will select\n        rows while `axis=1` will select columns.\n\n    Returns\n    -------\n    fitted_estimator : estimator\n        The fitted estimator.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.equations._validate_equations", "project": "skfolio", "func": "_validate_equations", "origin_file": "skfolio/utils/equations.py", "test_list": ["../tests/test_optimization/test_cluster/test_nco.py"], "prob_info": {"func_start_lineno": 229, "func_end_lineno": 250, "key_block_start_lineno": 244, "key_block_end_lineno": 250, "new_func_code": "def _validate_equations(\n    equations: npt.ArrayLike, name: str = \"equations\"\n) -> np.ndarray:\n    \"\"\"Validate equations by checking its dim and convert to numpy array.\n\n    Parameters\n    ----------\n    equations : array-like of shape (n_equations,)\n        1D array of equations.\n\n    Returns\n    -------\n    equations : ndarray of shape (n_equations,)\n        1D array of equations.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::quantile", "project": "skfolio", "func": "Population::quantile", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_optimization/test_cluster/test_nco.py"], "prob_info": {"func_start_lineno": 284, "func_end_lineno": 309, "key_block_start_lineno": 305, "key_block_end_lineno": 309, "new_func_code": "def quantile(\n        self,\n        measure: skt.Measure,\n        q: float,\n    ) -> BasePortfolio:\n        \"\"\"Return the portfolio corresponding to the `q` quantile for a given portfolio\n        measure.\n\n        Parameters\n        ----------\n        measure : Measure\n            The portfolio measure.\n\n        q : float\n            The quantile value.\n\n        Returns\n        -------\n        values : BasePortfolio\n           Portfolio corresponding to the `q` quantile for the measure.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.deduplicate_names", "project": "skfolio", "func": "deduplicate_names", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_optimization/test_cluster/test_nco.py"], "prob_info": {"func_start_lineno": 704, "func_end_lineno": 726, "key_block_start_lineno": 719, "key_block_end_lineno": 726, "new_func_code": "def deduplicate_names(names: npt.ArrayLike) -> list[str]:\n    \"\"\"Rename duplicated names by appending \"_{duplicate_nb}\" at the end.\n\n    This function is inspired by the pandas function `_maybe_dedup_names`.\n\n    Parameters\n    ----------\n    names : array-like of shape (n_names,)\n        List of names.\n\n    Returns\n    -------\n    names : list[str]\n        Deduplicate names.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools._make_indexable", "project": "skfolio", "func": "_make_indexable", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_optimization/test_cluster/test_nco.py"], "prob_info": {"func_start_lineno": 127, "func_end_lineno": 144, "key_block_start_lineno": 138, "key_block_end_lineno": 144, "new_func_code": "def _make_indexable(iterable):\n    \"\"\"Ensure iterable supports indexing or convert to an indexable variant.\n\n    Convert sparse matrices to csr and other non-indexable iterable to arrays.\n    Let `None` and indexable objects (e.g. pandas dataframes) pass unchanged.\n\n    Parameters\n    ----------\n    iterable : {list, dataframe, ndarray, sparse matrix} or None\n        Object to be converted to an indexable iterable.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.portfolio._portfolio.Portfolio::variance_from_assets", "project": "skfolio", "func": "Portfolio::variance_from_assets", "origin_file": "skfolio/portfolio/_portfolio.py", "test_list": ["../tests/test_optimization/test_cluster/test_hierarchical/test_herc.py"], "prob_info": {"func_start_lineno": 749, "func_end_lineno": 763, "key_block_start_lineno": 763, "key_block_end_lineno": 763, "new_func_code": "def variance_from_assets(self, assets_covariance: np.ndarray) -> float:\n        \"\"\"Compute the Portfolio variance expectation from the assets covariance and\n        weights.\n\n        Parameters\n        ----------\n        assets_covariance : ndarray of shape (n_assets,n_assets)\n            The matrix of assets covariance expectation.\n\n        Returns\n        -------\n        value : float\n            The Portfolio variance from the assets covariance.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.covariance._ew_covariance.EWCovariance::fit", "project": "skfolio", "func": "EWCovariance::fit", "origin_file": "skfolio/moments/covariance/_ew_covariance.py", "test_list": ["../tests/test_optimization/test_cluster/test_hierarchical/test_herc.py"], "prob_info": {"func_start_lineno": 82, "func_end_lineno": 110, "key_block_start_lineno": 98, "key_block_end_lineno": 110, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None):\n        \"\"\"Fit the Exponentially Weighted Covariance estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n         Price returns of the assets.\n\n        y : Ignored\n          Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : EWCovariance\n          Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.prior._factor_model.LoadingMatrixRegression::fit", "project": "skfolio", "func": "LoadingMatrixRegression::fit", "origin_file": "skfolio/prior/_factor_model.py", "test_list": ["../tests/test_optimization/test_cluster/test_hierarchical/test_herc.py"], "prob_info": {"func_start_lineno": 97, "func_end_lineno": 142, "key_block_start_lineno": 120, "key_block_end_lineno": 142, "new_func_code": "def fit(self, X: npt.ArrayLike, y: npt.ArrayLike, **fit_params):\n        \"\"\"Fit the Loading Matrix Regression Estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_factors)\n            Price returns of the factors.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : LoadingMatrixRegression\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.edar", "project": "skfolio", "func": "edar", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_optimization/test_cluster/test_hierarchical/test_herc.py"], "prob_info": {"func_start_lineno": 529, "func_end_lineno": 549, "key_block_start_lineno": 549, "key_block_end_lineno": 549, "new_func_code": "def edar(drawdowns: np.ndarray, beta: float = 0.95) -> float:\n    \"\"\"Compute the EDaR (entropic drawdown at risk).\n\n    The EDaR is a coherent risk measure which is an upper bound for the DaR and the\n    CDaR, obtained from the Chernoff inequality. The EDaR can be represented by using\n    the concept of relative entropy.\n\n    Parameters\n    ----------\n    drawdowns : ndarray of shape (n_observations,)\n        Vector of drawdowns.\n\n    beta : float, default=0.95\n      The EDaR confidence level.\n\n    Returns\n    -------\n    value : float\n        EDaR.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.cluster.hierarchical._hrp._apply_weight_constraints_to_split_factor", "project": "skfolio", "func": "_apply_weight_constraints_to_split_factor", "origin_file": "skfolio/optimization/cluster/hierarchical/_hrp.py", "test_list": ["../tests/test_optimization/test_cluster/test_hierarchical/test_hrp.py"], "prob_info": {"func_start_lineno": 390, "func_end_lineno": 438, "key_block_start_lineno": 427, "key_block_end_lineno": 438, "new_func_code": "def _apply_weight_constraints_to_split_factor(\n    alpha: float,\n    max_weights: np.ndarray,\n    min_weights: np.ndarray,\n    weights: np.ndarray,\n    left_cluster: np.ndarray,\n    right_cluster: np.ndarray,\n) -> float:\n    \"\"\"\n    Apply weight constraints to the split factor alpha of the ,Hierarchical Tree\n    Clustering algorithm.\n\n    Parameters\n    ----------\n    alpha : float\n        The split factor alpha of the Hierarchical Tree Clustering algorithm.\n\n    min_weights : ndarray of shape (n_assets,)\n        The weight lower bound 1D array.\n\n    max_weights : ndarray of shape (n_assets,)\n        The weight upper bound 1D array.\n\n    weights : np.ndarray of shape (n_assets,)\n        The assets weights.\n\n    left_cluster : ndarray of shape (n_left_cluster,)\n        Indices of the left cluster weights.\n\n    right_cluster : ndarray of shape (n_right_cluster,)\n        Indices of the right cluster weights.\n\n    Returns\n    -------\n    value : float\n        The transformed split factor alpha incorporating the weight constraints.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.moments.covariance._implied_covariance._compute_realised_vol", "project": "skfolio", "func": "_compute_realised_vol", "origin_file": "skfolio/moments/covariance/_implied_covariance.py", "test_list": ["../tests/test_optimization/test_cluster/test_hierarchical/test_hrp.py"], "prob_info": {"func_start_lineno": 385, "func_end_lineno": 399, "key_block_start_lineno": 389, "key_block_end_lineno": 399, "new_func_code": "def _compute_realised_vol(\n    returns: np.ndarray, window_size: int, ddof: int = 1\n) -> np.ndarray:\n    \"\"\"Create the realised volatilities samples for the regression model.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.convex._mean_risk._optimal_homogenization_factor", "project": "skfolio", "func": "_optimal_homogenization_factor", "origin_file": "skfolio/optimization/convex/_mean_risk.py", "test_list": ["../tests/test_optimization/test_convex/test_maximum_diversification.py"], "prob_info": {"func_start_lineno": 1103, "func_end_lineno": 1123, "key_block_start_lineno": 1123, "key_block_end_lineno": 1123, "new_func_code": "def _optimal_homogenization_factor(mu: np.ndarray) -> float:\n    \"\"\"\n    Compute the optimal homogenization factor for ratio optimization based on expected\n    returns.\n\n    While a default value of 1 is commonly used in textbooks for simplicity,\n    fine-tuning this factor based on the underlying data can enhance convergence.\n    Additionally, using a data-driven approach to determine this factor can improve the\n    robustness of certain constraints, such as the calibration of big M methods.\n\n    Parameters\n    ----------\n    mu : ndarray of shape (n_assets,)\n        Vector of expected returns.\n\n    Returns\n    -------\n    value : float\n        Homogenization factor.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.ensemble._stacking.StackingOptimization::_validate_estimators", "project": "skfolio", "func": "StackingOptimization::_validate_estimators", "origin_file": "skfolio/optimization/ensemble/_stacking.py", "test_list": ["../tests/test_optimization/test_ensemble/test_stacking.py"], "prob_info": {"func_start_lineno": 168, "func_end_lineno": 187, "key_block_start_lineno": 178, "key_block_end_lineno": 187, "new_func_code": "def _validate_estimators(self) -> tuple[list[str], list[BaseOptimization]]:\n        \"\"\"Validate the `estimators` parameter.\n\n        Returns\n        -------\n        names : list[str]\n            The list of estimators names.\n        estimators : list[BaseOptimization\n            The list of optimization estimators.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.ensemble._stacking.StackingOptimization::get_params", "project": "skfolio", "func": "StackingOptimization::get_params", "origin_file": "skfolio/optimization/ensemble/_stacking.py", "test_list": ["../tests/test_optimization/test_ensemble/test_stacking.py"], "prob_info": {"func_start_lineno": 213, "func_end_lineno": 231, "key_block_start_lineno": 231, "key_block_end_lineno": 231, "new_func_code": "def get_params(self, deep=True):\n        \"\"\"Get the parameters of an estimator from the ensemble.\n\n        Returns the parameters given in the constructor as well as the\n        estimators contained within the `estimators` parameter.\n\n        Parameters\n        ----------\n        deep : bool, default=True\n            Setting it to True gets the various estimators and the parameters\n            of the estimators as well.\n\n        Returns\n        -------\n        params : dict\n            Parameter and estimator names mapped to their values or parameter\n            names mapped to their values.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.ensemble._stacking.StackingOptimization::set_params", "project": "skfolio", "func": "StackingOptimization::set_params", "origin_file": "skfolio/optimization/ensemble/_stacking.py", "test_list": ["../tests/test_optimization/test_ensemble/test_stacking.py"], "prob_info": {"func_start_lineno": 189, "func_end_lineno": 211, "key_block_start_lineno": 210, "key_block_end_lineno": 211, "new_func_code": "def set_params(self, **params):\n        \"\"\"Set the parameters of an estimator from the ensemble.\n\n        Valid parameter keys can be listed with `get_params()`. Note that you\n        can directly set the parameters of the estimators contained in\n        `estimators`.\n\n        Parameters\n        ----------\n        **params : keyword arguments\n            Specific parameters using e.g.\n            `set_params(parameter_name=new_value)`. In addition, to setting the\n            parameters of the estimator, the individual estimator of the\n            estimators can also be set, or can be removed by setting them to\n            'drop'.\n\n        Returns\n        -------\n        self : object\n            Estimator instance.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.naive._naive.EqualWeighted::fit", "project": "skfolio", "func": "EqualWeighted::fit", "origin_file": "skfolio/optimization/naive/_naive.py", "test_list": ["../tests/test_optimization/test_naive/test_naive.py"], "prob_info": {"func_start_lineno": 129, "func_end_lineno": 148, "key_block_start_lineno": 145, "key_block_end_lineno": 148, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"EqualWeighted\":\n        \"\"\"Fit the Equal Weighted estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : EqualWeighted\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.naive._naive.Random::fit", "project": "skfolio", "func": "Random::fit", "origin_file": "skfolio/optimization/naive/_naive.py", "test_list": ["../tests/test_optimization/test_naive/test_naive.py"], "prob_info": {"func_start_lineno": 173, "func_end_lineno": 192, "key_block_start_lineno": 189, "key_block_end_lineno": 192, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None):\n        \"\"\"Fit the Random Weighted estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : EqualWeighted\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.rand_weights_dirichlet", "project": "skfolio", "func": "rand_weights_dirichlet", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_optimization/test_naive/test_naive.py"], "prob_info": {"func_start_lineno": 128, "func_end_lineno": 142, "key_block_start_lineno": 142, "key_block_end_lineno": 142, "new_func_code": "def rand_weights_dirichlet(n: int) -> np.array:\n    \"\"\"Produces n random weights that sum to one from a dirichlet distribution\n    (uniform distribution over a simplex).\n\n    Parameters\n    ----------\n    n : int\n        Number of weights.\n\n    Returns\n    -------\n    weights : ndarray of shape (n, )\n        The vector of weights.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::plot_measures", "project": "skfolio", "func": "Population::plot_measures", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 696, "func_end_lineno": 894, "key_block_start_lineno": 742, "key_block_end_lineno": 894, "new_func_code": "def plot_measures(\n        self,\n        x: skt.Measure,\n        y: skt.Measure,\n        z: skt.Measure = None,\n        to_surface: bool = False,\n        hover_measures: list[skt.Measure] | None = None,\n        show_fronts: bool = False,\n        color_scale: skt.Measure | str | None = None,\n        title=\"Portfolios\",\n    ) -> go.Figure:\n        \"\"\"Plot the 2D (or 3D) scatter points (or surface) of a given set of\n        measures for each portfolio in the population.\n\n        Parameters\n        ----------\n        x : Measure\n            The x-axis measure.\n\n        y : Measure\n            The y-axis measure.\n\n        z : Measure, optional\n            The z-axis measure.\n\n        to_surface : bool, default=False\n            If this is set to True, a surface is estimated.\n\n        hover_measures : list[Measure], optional\n            The list of measure to show on point hover.\n\n        show_fronts : bool, default=False\n            If this is set to True, the pareto fronts are highlighted.\n            The default is `False`.\n\n        color_scale : Measure | str, optional\n            If this is provided, a color scale is displayed.\n\n        title : str, default=\"Portfolios\"\n            The graph title. The default value is \"Portfolios\".\n\n        Returns\n        -------\n        plot : Figure\n            Returns the plotly Figure object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::filter", "project": "skfolio", "func": "Population::filter", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 161, "func_end_lineno": 201, "key_block_start_lineno": 180, "key_block_end_lineno": 201, "new_func_code": "def filter(\n        self, names: skt.Names | None = None, tags: skt.Tags | None = None\n    ) -> \"Population\":\n        \"\"\"Filter the Population of portfolios by names and tags.\n        If both names and tags are provided, the intersection is returned.\n\n        Parameters\n        ----------\n        names : str | list[str], optional\n            If provided, the population is filtered by portfolio names.\n\n        tags :  str | list[str], optional\n            If provided, the population is filtered by portfolio tags.\n\n        Returns\n        -------\n        population : Population\n            A new population of portfolios filtered by names and tags.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::min_measure", "project": "skfolio", "func": "Population::min_measure", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 311, "func_end_lineno": 327, "key_block_start_lineno": 327, "key_block_end_lineno": 327, "new_func_code": "def min_measure(\n        self,\n        measure: skt.Measure,\n    ) -> BasePortfolio:\n        \"\"\"Return the portfolio with the minimum measure.\n\n        Parameters\n        ----------\n        measure : Measure\n            The portfolio measure.\n\n        Returns\n        -------\n        values : BasePortfolio\n            The portfolio with minimum measure.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::max_measure", "project": "skfolio", "func": "Population::max_measure", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 329, "func_end_lineno": 345, "key_block_start_lineno": 345, "key_block_end_lineno": 345, "new_func_code": "def max_measure(\n        self,\n        measure: skt.Measure,\n    ) -> BasePortfolio:\n        \"\"\"Return the portfolio with the maximum measure.\n\n        Parameters\n        ----------\n        measure: Measure\n            The portfolio measure.\n\n        Returns\n        -------\n        values : BasePortfolio\n            The portfolio with maximum measure.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::composition", "project": "skfolio", "func": "Population::composition", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 372, "func_end_lineno": 405, "key_block_start_lineno": 389, "key_block_end_lineno": 405, "new_func_code": "def composition(\n        self,\n        display_sub_ptf_name: bool = True,\n    ) -> pd.DataFrame:\n        \"\"\"Composition of each portfolio in the population.\n\n        Parameters\n        ----------\n        display_sub_ptf_name : bool, default=True\n            If this is set to True, each sub-portfolio name composing a multi-period\n            portfolio is displayed.\n\n        Returns\n        -------\n        df : DataFrame\n            Composition of the portfolios in the population.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::plot_composition", "project": "skfolio", "func": "Population::plot_composition", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 622, "func_end_lineno": 647, "key_block_start_lineno": 636, "key_block_end_lineno": 647, "new_func_code": "def plot_composition(self, display_sub_ptf_name: bool = True) -> go.Figure:\n        \"\"\"Plot the compositions of the portfolios in the population.\n\n        Parameters\n        ----------\n        display_sub_ptf_name : bool, default=True\n            If this is set to True, each sub-portfolio name composing a multi-period\n            portfolio is displayed.\n\n        Returns\n        -------\n        plot : Figure\n            Returns the plotly Figure object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::plot_returns_distribution", "project": "skfolio", "func": "Population::plot_returns_distribution", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 943, "func_end_lineno": 969, "key_block_start_lineno": 951, "key_block_end_lineno": 969, "new_func_code": "def plot_returns_distribution(self) -> go.Figure:\n        \"\"\"Plot the Portfolios returns distribution using Gaussian KDE.\n\n        Returns\n        -------\n        plot : Figure\n            Returns the plot Figure object\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::set_portfolio_params", "project": "skfolio", "func": "Population::set_portfolio_params", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 80, "func_end_lineno": 111, "key_block_start_lineno": 93, "key_block_end_lineno": 111, "new_func_code": "def set_portfolio_params(self, **params: Any) -> \"Population\":\n        \"\"\"Set the parameters of all the portfolios.\n\n        Parameters\n        ----------\n        **params : Any\n            Portfolio parameters.\n\n        Returns\n        -------\n        self : Population\n            The Population instance.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::plot_rolling_measure", "project": "skfolio", "func": "Population::plot_rolling_measure", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 896, "func_end_lineno": 941, "key_block_start_lineno": 916, "key_block_end_lineno": 941, "new_func_code": "def plot_rolling_measure(\n        self,\n        measure: skt.Measure = RatioMeasure.SHARPE_RATIO,\n        window: int = 30,\n    ) -> go.Figure:\n        \"\"\"Plot the measure over a rolling window for each portfolio in the population.\n\n        Parameters\n        ----------\n        measure : ct.Measure, default = RatioMeasure.SHARPE_RATIO\n           The measure.\n\n        window : int, default=30\n           The window size.\n\n        Returns\n        -------\n        plot : Figure\n            Returns the plot Figure object\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::contribution", "project": "skfolio", "func": "Population::contribution", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 407, "func_end_lineno": 455, "key_block_start_lineno": 435, "key_block_end_lineno": 455, "new_func_code": "def contribution(\n        self,\n        measure: skt.Measure,\n        spacing: float | None = None,\n        display_sub_ptf_name: bool = True,\n    ) -> pd.DataFrame:\n        r\"\"\"Contribution of each asset to a given measure of each portfolio in the\n        population.\n\n        Parameters\n        ----------\n        measure : Measure\n            The measure used for the contribution computation.\n\n        spacing : float, optional\n            Spacing \"h\" of the finite difference:\n            :math:`contribution(wi)= \\frac{measure(wi-h) - measure(wi+h)}{2h}`.\n\n        display_sub_ptf_name : bool, default=True\n            If this is set to True, each sub-portfolio name composing a multi-period\n            portfolio is displayed.\n\n        Returns\n        -------\n        df : DataFrame\n            Contribution of each asset to a given measure of each portfolio in the\n            population.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.population._population.Population::plot_contribution", "project": "skfolio", "func": "Population::plot_contribution", "origin_file": "skfolio/population/_population.py", "test_list": ["../tests/test_population/test_population.py"], "prob_info": {"func_start_lineno": 649, "func_end_lineno": 694, "key_block_start_lineno": 676, "key_block_end_lineno": 694, "new_func_code": "def plot_contribution(\n        self,\n        measure: skt.Measure,\n        spacing: float | None = None,\n        display_sub_ptf_name: bool = True,\n    ) -> go.Figure:\n        r\"\"\"Plot the contribution of each asset to a given measure of the portfolios\n        in the population.\n\n        Parameters\n        ----------\n        measure : Measure\n            The measure used for the contribution computation.\n\n        spacing : float, optional\n            Spacing \"h\" of the finite difference:\n            :math:`contribution(wi)= \\frac{measure(wi-h) - measure(wi+h)}{2h}`\n\n        display_sub_ptf_name : bool, default=True\n            If this is set to True, each sub-portfolio name composing a multi-period\n            portfolio is displayed.\n\n        Returns\n        -------\n        plot : Figure\n            Returns the plotly Figure object.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.portfolio._multi_period_portfolio.MultiPeriodPortfolio::summary", "project": "skfolio", "func": "MultiPeriodPortfolio::summary", "origin_file": "skfolio/portfolio/_multi_period_portfolio.py", "test_list": ["../tests/test_portfolio/test_multi_period_portfolio.py"], "prob_info": {"func_start_lineno": 605, "func_end_lineno": 627, "key_block_start_lineno": 619, "key_block_end_lineno": 627, "new_func_code": "def summary(self, formatted: bool = True) -> pd.Series:\n        \"\"\"Portfolio summary of all its measures.\n\n        Parameters\n        ----------\n        formatted : bool, default=True\n            If this is set to True, the measures are formatted into rounded string with\n            units.\n\n        Returns\n        -------\n        summary : series\n            Portfolio summary of all its measures.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.skew", "project": "skfolio", "func": "skew", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_portfolio/test_multi_period_portfolio.py"], "prob_info": {"func_start_lineno": 185, "func_end_lineno": 202, "key_block_start_lineno": 202, "key_block_end_lineno": 202, "new_func_code": "def skew(returns: np.ndarray) -> float:\n    \"\"\"Compute the Skew.\n\n    The Skew is a measure of the lopsidedness of the distribution.\n    A symmetric distribution have a Skew of zero.\n    Higher Skew corresponds to longer right tail.\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    Returns\n    -------\n    value : float\n        Skew.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.third_central_moment", "project": "skfolio", "func": "third_central_moment", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_portfolio/test_multi_period_portfolio.py"], "prob_info": {"func_start_lineno": 169, "func_end_lineno": 182, "key_block_start_lineno": 182, "key_block_end_lineno": 182, "new_func_code": "def third_central_moment(returns: np.ndarray) -> float:\n    \"\"\"Compute the third central moment.\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    Returns\n    -------\n    value : float\n        Third central moment.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.measures._measures.kurtosis", "project": "skfolio", "func": "kurtosis", "origin_file": "skfolio/measures/_measures.py", "test_list": ["../tests/test_portfolio/test_multi_period_portfolio.py"], "prob_info": {"func_start_lineno": 221, "func_end_lineno": 237, "key_block_start_lineno": 237, "key_block_end_lineno": 237, "new_func_code": "def kurtosis(returns: np.ndarray) -> float:\n    \"\"\"Compute the Kurtosis.\n\n    The Kurtosis is a measure of the heaviness of the tail of the distribution.\n    Higher Kurtosis corresponds to greater extremity of deviations (fat tails).\n\n    Parameters\n    ----------\n    returns : ndarray of shape (n_observations,)\n        Vector of returns.\n\n    Returns\n    -------\n    value : float\n        Kurtosis.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.portfolio._multi_period_portfolio.MultiPeriodPortfolio::contribution", "project": "skfolio", "func": "MultiPeriodPortfolio::contribution", "origin_file": "skfolio/portfolio/_multi_period_portfolio.py", "test_list": ["../tests/test_portfolio/test_multi_period_portfolio.py"], "prob_info": {"func_start_lineno": 569, "func_end_lineno": 603, "key_block_start_lineno": 594, "key_block_end_lineno": 603, "new_func_code": "def contribution(\n        self, measure: skt.Measure, spacing: float | None = None, to_df: bool = True\n    ) -> np.ndarray | pd.DataFrame:\n        r\"\"\"Compute the contribution of each asset to a given measure for each\n        portfolio.\n\n        Parameters\n        ----------\n        measure : Measure\n            The measure used for the contribution computation.\n\n        spacing : float, optional\n            Spacing \"h\" of the finite difference:\n            :math:`contribution(wi)= \\frac{measure(wi-h) - measure(wi+h)}{2h}`\n\n        to_df : bool, default=False\n            If this is set to True, a DataFrame with asset names in index and portfolio\n            names in columns is returned, otherwise a list of numpy array is returned.\n            When a DataFrame is returned, the assets with zero weights are removed.\n\n        Returns\n        -------\n        values : list of numpy array of shape (n_assets,) for each portfolio or a DataFrame\n            The measure contribution of each asset for each portfolio.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.portfolio._portfolio.Portfolio::sric", "project": "skfolio", "func": "Portfolio::sric", "origin_file": "skfolio/portfolio/_portfolio.py", "test_list": ["../tests/test_portfolio/test_portfolio.py"], "prob_info": {"func_start_lineno": 691, "func_end_lineno": 704, "key_block_start_lineno": 702, "key_block_end_lineno": 704, "new_func_code": "def sric(self) -> float:\n        \"\"\"Sharpe Ratio Information Criterion (SRIC).\n\n        It is an unbiased estimator of the Sharpe Ratio adjusting for both sources of\n        bias which are noise fit and estimation error [1]_.\n\n        References\n        ----------\n        .. [1]  \"Noise Fit, Estimation Error and a Sharpe Information Criterion\",\n            Dirk Paulsen (2019)\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.portfolio._portfolio.Portfolio::summary", "project": "skfolio", "func": "Portfolio::summary", "origin_file": "skfolio/portfolio/_portfolio.py", "test_list": ["../tests/test_portfolio/test_portfolio.py"], "prob_info": {"func_start_lineno": 821, "func_end_lineno": 843, "key_block_start_lineno": 835, "key_block_end_lineno": 843, "new_func_code": "def summary(self, formatted: bool = True) -> pd.Series:\n        \"\"\"Portfolio summary of all its measures.\n\n        Parameters\n        ----------\n        formatted : bool, default=True\n            If this is set to True, the measures are formatted into rounded string\n            with units.\n\n        Returns\n        -------\n        summary : series\n            Portfolio summary.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.portfolio._portfolio.Portfolio::get_weight", "project": "skfolio", "func": "Portfolio::get_weight", "origin_file": "skfolio/portfolio/_portfolio.py", "test_list": ["../tests/test_portfolio/test_portfolio.py"], "prob_info": {"func_start_lineno": 845, "func_end_lineno": 861, "key_block_start_lineno": 858, "key_block_end_lineno": 861, "new_func_code": "def get_weight(self, asset: str) -> float:\n        \"\"\"Get the weight of a given asset.\n\n        Parameters\n        ----------\n        asset : str\n            Name of the asset.\n\n        Returns\n        -------\n        weight : float\n            Weight of the asset.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.portfolio._portfolio.Portfolio::expected_returns_from_assets", "project": "skfolio", "func": "Portfolio::expected_returns_from_assets", "origin_file": "skfolio/portfolio/_portfolio.py", "test_list": ["../tests/test_portfolio/test_portfolio.py"], "prob_info": {"func_start_lineno": 729, "func_end_lineno": 747, "key_block_start_lineno": 745, "key_block_end_lineno": 747, "new_func_code": "def expected_returns_from_assets(\n        self, assets_expected_returns: np.ndarray\n    ) -> float:\n        \"\"\"Compute the Portfolio expected returns from the assets expected returns,\n        weights, management costs and transaction fees.\n\n        Parameters\n        ----------\n        assets_expected_returns : ndarray of shape (n_assets,)\n            The vector of assets expected returns.\n\n        Returns\n        -------\n        value : float\n            The Portfolio expected returns.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.prior._black_litterman.BlackLitterman::fit", "project": "skfolio", "func": "BlackLitterman::fit", "origin_file": "skfolio/prior/_black_litterman.py", "test_list": ["../tests/test_prior/test_black_litterman.py"], "prob_info": {"func_start_lineno": 149, "func_end_lineno": 266, "key_block_start_lineno": 172, "key_block_end_lineno": 266, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None, **fit_params) -> \"BlackLitterman\":\n        \"\"\"Fit the Black & Litterman estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : BlackLitterman\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._utils.Edge::share_one_node", "project": "skfolio", "func": "Edge::share_one_node", "origin_file": "skfolio/distribution/multivariate/_utils.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 460, "func_end_lineno": 473, "key_block_start_lineno": 473, "key_block_end_lineno": 473, "new_func_code": "def share_one_node(self, other: \"Edge\") -> bool:\n        \"\"\"Check whether two edges share exactly one node.\n\n        Parameters\n        ----------\n        other : Edge\n            Another edge to compare with.\n\n        Returns\n        -------\n        bool\n            True if the two edges share exactly one node; otherwise, False.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._utils.Edge::shared_node_is_left", "project": "skfolio", "func": "Edge::shared_node_is_left", "origin_file": "skfolio/distribution/multivariate/_utils.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 428, "func_end_lineno": 458, "key_block_start_lineno": 451, "key_block_end_lineno": 458, "new_func_code": "def shared_node_is_left(self, other: \"Edge\") -> tuple[bool, bool]:\n        \"\"\"Determine the ordering of shared nodes between this edge and another edge.\n\n        If the two edges share one node, this method indicates for each edge whether the\n        shared node is the left node.\n\n        Parameters\n        ----------\n        other : Edge\n            Another edge to compare with.\n\n        Returns\n        -------\n        is_left1, is_left2 : tuple[bool, bool]\n            A tuple (is_left1, is_left2) where is_left1 is True if the shared node is\n            the left node of self and is_left2 is True if the shared node is the left\n            node of other.\n\n        Raises\n        ------\n        ValueError\n            If the edges do not share exactly one node.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._utils.ChildNode::u", "project": "skfolio", "func": "ChildNode::u", "origin_file": "skfolio/distribution/multivariate/_utils.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 205, "func_end_lineno": 241, "key_block_start_lineno": 216, "key_block_end_lineno": 241, "new_func_code": "def u(self) -> np.ndarray:\n        \"\"\"Get the first margin value (u) for the node.\n\n        It is obtained by computing the partial derivative of the copula with respect\n        to v.\n\n        Returns\n        -------\n        u : ndarray\n            The u values for this node.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._utils.ChildNode::v", "project": "skfolio", "func": "ChildNode::v", "origin_file": "skfolio/distribution/multivariate/_utils.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 248, "func_end_lineno": 284, "key_block_start_lineno": 259, "key_block_end_lineno": 284, "new_func_code": "def v(self) -> np.ndarray:\n        \"\"\"Get the second margin value (v) for the node.\n\n        It is obtained by computing the partial derivative of the copula with respect\n        to u.\n\n        Returns\n        -------\n        v : ndarray\n           The v values for this node.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._utils.ChildNode::clear_cache", "project": "skfolio", "func": "ChildNode::clear_cache", "origin_file": "skfolio/distribution/multivariate/_utils.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 310, "func_end_lineno": 324, "key_block_start_lineno": 318, "key_block_end_lineno": 324, "new_func_code": "def clear_cache(self, clear_count: bool):\n        \"\"\"Clear the cached margin values (u and v) and counts.\n\n        Parameters\n        ----------\n        clear_count : bool\n            If True, the visit counts are also reset.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._vine_copula.VineCopula::sample", "project": "skfolio", "func": "VineCopula::sample", "origin_file": "skfolio/distribution/multivariate/_vine_copula.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 514, "func_end_lineno": 644, "key_block_start_lineno": 561, "key_block_end_lineno": 644, "new_func_code": "def sample(\n        self,\n        n_samples: int = 1,\n        conditioning: dict[int | str : float | tuple[float, float] | npt.ArrayLike]\n        | None = None,\n    ) -> np.ndarray:\n        \"\"\"Generate random samples from the vine copula.\n\n        This method generates `n_samples` from the fitted vine copula model. The\n        resulting samples represent multivariate observations drawn according to the\n        dependence structure captured by the vine copula.\n\n        Parameters\n        ----------\n        n_samples : int, default=1\n            Number of samples to generate.\n\n        conditioning : dict[int | str, float | tuple[float, float] | array-like], optional\n            A dictionary specifying conditioning information for one or more assets.\n            The dictionary keys are asset indices or names, and the values define how\n            the samples are conditioned for that asset. Three types of conditioning\n            values are supported:\n\n            1. **Fixed value (float):**\n               If a float is provided, all samples are generated under the condition\n               that the asset takes exactly that value.\n\n            2. **Bounds (tuple of two floats):**\n               If a tuple `(min_value, max_value)` is provided, samples are generated\n               under the condition that the asset's value falls within the specified\n               bounds. Use `-np.Inf` for no lower bound or `np.Inf` for no upper bound.\n\n            3. **Array-like (1D array):**\n               If an array-like of length `n_samples` is provided, each sample is\n               conditioned on the corresponding value in the array for that asset.\n\n            **Important:** When using conditional sampling, it is recommended that the\n            assets you condition on are set as central during the vine copula\n            construction. This can be specified via the `central_assets` parameter in\n            the vine copula instantiation.\n\n        Returns\n        -------\n        X : array-like of shape (n_samples, n_assets)\n            A two-dimensional array where each row is a multivariate observation sampled\n            from the vine copula.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._vine_copula.VineCopula::_init_conditioning", "project": "skfolio", "func": "VineCopula::_init_conditioning", "origin_file": "skfolio/distribution/multivariate/_vine_copula.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 676, "func_end_lineno": 839, "key_block_start_lineno": 724, "key_block_end_lineno": 839, "new_func_code": "def _init_conditioning(\n        self,\n        n_samples: int,\n        conditioning: dict[int | str : float | tuple[float, float] | npt.ArrayLike],\n    ) -> tuple[\n        np.random.RandomState, set[int], dict[int, float], dict[int, np.ndarray]\n    ]:\n        \"\"\"\n        Initialised conditioning variables used in the conditioning sampling.\n\n        Parameters\n        ----------\n        n_samples : int, default=1\n            Number of samples to generate.\n\n        conditioning : dict[int | str, float | tuple[float, float] | array-like], optional\n            A dictionary specifying conditioning information for one or more assets.\n            The dictionary keys are asset indices or names, and the values define how\n            the samples are conditioned for that asset. Three types of conditioning\n            values are supported:\n\n            1. **Fixed value (float):**\n               If a float is provided, all samples are generated under the condition\n               that the asset takes exactly that value.\n\n            2. **Bounds (tuple of two floats):**\n               If a tuple `(min_value, max_value)` is provided, samples are generated\n               under the condition that the asset's value falls within the specified\n               bounds. Use `-np.Inf` for no lower bound or `np.Inf` for no upper bound.\n\n            3. **Array-like (1D array):**\n               If an array-like of length `n_samples` is provided, each sample is\n               conditioned on the corresponding value in the array for that asset.\n\n        Returns\n        -------\n        random_sate : RandomState\n            Numpy Random State.\n\n        conditioning_vars : set[int]\n            The conditioning variables.\n\n        conditioning_clean : dict[int, float]\n            The cleaned conditioning dictionary.\n\n        uniform_cond_samples : dict[int, np.ndarray]\n            The uniform conditioning samples corresponding to the `conditioning`.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._vine_copula.VineCopula::_sampling_order", "project": "skfolio", "func": "VineCopula::_sampling_order", "origin_file": "skfolio/distribution/multivariate/_vine_copula.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 841, "func_end_lineno": 960, "key_block_start_lineno": 878, "key_block_end_lineno": 960, "new_func_code": "def _sampling_order(\n        self, conditioning_vars: set[int] | None = None\n    ) -> list[tuple[RootNode | ChildNode, bool]]:\n        \"\"\"\n        Determine the optimal sampling order for the vine copula.\n\n        The sampling order is derived using a top-down elimination strategy that is\n        analogous to finding a perfect elimination ordering for chordal graphs. In our\n        vine copula, each conditional density is expressed as a product of bivariate\n        copula densities and univariate margins. The algorithm starts with the deepest\n        tree (i.e., the tree with the largest conditioning sets) and selects a variable\n        from its conditioned set. This variable is then marginalized out, effectively\n        generating a new sub-vine with a new deepest node. This process is repeated\n        until the first tree level is reached and all n variables have been ordered.\n\n        Choosing the optimal sampling order in this manner simplifies the inversion of\n        conditional CDFs, thereby improving numerical stability. At each elimination\n        step, among the candidate variables, the one that appears least frequently in\n        the conditioning sets of shallower trees is chosen, ensuring that variables\n        critical for conditional sampling occupy central roles.\n\n        Parameters\n        ----------\n        conditioning_vars : set[int], optional\n            A set of asset indices for which conditioning samples are provided.\n            If specified, these assets will be prioritized during the sampling order\n            determination.\n\n        Returns\n        -------\n        sampling_order : list[tuple(Node, bool | None)]\n            A list of tuples representing the optimal sampling order. Each tuple\n            contains:\n              - A Node object corresponding to an asset or an edge in the vine.\n              - A boolean flag indicating whether the left branch is used for sampling\n               at that node, or None if the node is the root.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._vine_copula.VineCopula::_conditioning_count", "project": "skfolio", "func": "VineCopula::_conditioning_count", "origin_file": "skfolio/distribution/multivariate/_vine_copula.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 653, "func_end_lineno": 674, "key_block_start_lineno": 661, "key_block_end_lineno": 674, "new_func_code": "def _conditioning_count(self) -> np.ndarray:\n        \"\"\"Compute cumulative counts of conditioning set occurrences in the vine.\n\n        Returns\n        -------\n        conditioning_counts : ndarray of shape (n_trees, n_assets)\n            Array of cumulative conditioning counts.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._vine_copula._is_left_branch", "project": "skfolio", "func": "_is_left_branch", "origin_file": "skfolio/distribution/multivariate/_vine_copula.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 1124, "func_end_lineno": 1152, "key_block_start_lineno": 1147, "key_block_end_lineno": 1152, "new_func_code": "def _is_left_branch(\n    edge: Edge, conditioning_vars: set[int], conditioning_counts: np.ndarray\n) -> bool:\n    \"\"\"\n    Determine whether the left branch should be followed during the elimination ordering\n    (tree peeling).\n\n    Parameters\n    ----------\n    edge : Edge\n        The edge for which to decide the branch.\n\n    conditioning_vars : set[int]\n        Set of asset indices with conditioning samples.\n\n    conditioning_counts : np.ndarray\n        Array of conditioning counts for each asset.\n\n    Returns\n    -------\n    bool\n        True if the left branch is preferred, False otherwise.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._vine_copula.VineCopula::_count_node_visits", "project": "skfolio", "func": "VineCopula::_count_node_visits", "origin_file": "skfolio/distribution/multivariate/_vine_copula.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 1109, "func_end_lineno": 1121, "key_block_start_lineno": 1114, "key_block_end_lineno": 1121, "new_func_code": "def _count_node_visits(self):\n        \"\"\"A context manager to enable counting node visits within the tree.\n        Temporarily enables node visit counting for the duration of the context.\n        After the block is executed, the original state is restored.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._utils.ChildNode::get_var", "project": "skfolio", "func": "ChildNode::get_var", "origin_file": "skfolio/distribution/multivariate/_utils.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 290, "func_end_lineno": 308, "key_block_start_lineno": 305, "key_block_end_lineno": 308, "new_func_code": "def get_var(self, is_left: bool) -> int:\n        \"\"\"Return the variable index associated with this node.\n\n        The variable is determined by the conditioned set of the edge.\n\n        Parameters\n        ----------\n        is_left : bool\n            Indicates whether to select the left or right node.\n\n        Returns\n        -------\n        var : int\n            The variable index corresponding to this node.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.validate_input_list", "project": "skfolio", "func": "validate_input_list", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_prior/test_synthetic_data.py"], "prob_info": {"func_start_lineno": 445, "func_end_lineno": 503, "key_block_start_lineno": 479, "key_block_end_lineno": 503, "new_func_code": "def validate_input_list(\n    items: list[int | str],\n    n_assets: int,\n    assets_names: np.ndarray[str] | None,\n    name: str,\n    raise_if_string_missing: bool = True,\n) -> list[int]:\n    \"\"\"Convert a list of items (asset indices or asset names) into a list of\n    validated asset indices.\n\n    Parameters\n    ----------\n    items : list[int | str]\n       List of asset indices or asset names.\n\n    n_assets : int\n       Expected number of assets.\n       Used for verification.\n\n    assets_names : ndarray, optional\n       Asset names used when `items` contain strings.\n\n    name : str\n       Name of the items used for error messages.\n\n    raise_if_string_missing : bool, default=True\n        If set to True, raises an error if an item string is missing from assets_names;\n        otherwise, issue a User Warning.\n\n    Returns\n    -------\n    values : list[int]\n       Converted and validated list.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.bootstrap.optimal_block_size", "project": "skfolio", "func": "optimal_block_size", "origin_file": "skfolio/utils/bootstrap.py", "test_list": ["../tests/test_uncertainty_set/test_bootstrap.py"], "prob_info": {"func_start_lineno": 14, "func_end_lineno": 65, "key_block_start_lineno": 36, "key_block_end_lineno": 65, "new_func_code": "def optimal_block_size(x: np.ndarray) -> float:\n    \"\"\"Compute the optimal block size for a single series using Politis & White\n    algorithm [1]_.\n\n    Parameters\n    ----------\n    x : ndarray\n        The input 1D-array.\n\n    Returns\n    -------\n    value : float\n        The optimal block size.\n\n    References\n    ----------\n    .. [1] \"Automatic Block-Length Selection for the Dependent Bootstrap\".\n        Politis & White (2004).\n\n    .. [2] \"Correction to Automatic Block-Length Selection for the Dependent Bootstrap\".\n        Patton, Politis & White (2009).\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.uncertainty_set._bootstrap.BootstrapCovarianceUncertaintySet::fit", "project": "skfolio", "func": "BootstrapCovarianceUncertaintySet::fit", "origin_file": "skfolio/uncertainty_set/_bootstrap.py", "test_list": ["../tests/test_uncertainty_set/test_bootstrap.py"], "prob_info": {"func_start_lineno": 244, "func_end_lineno": 303, "key_block_start_lineno": 270, "key_block_end_lineno": 303, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y=None, **fit_params\n    ) -> \"BootstrapCovarianceUncertaintySet\":\n        \"\"\"Fit the Bootstrap Covariance Uncertainty set estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_factors), optional\n            Price returns of factors.\n            The default is `None`.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : EmpiricalCovarianceUncertaintySet\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.uncertainty_set._empirical.EmpiricalCovarianceUncertaintySet::fit", "project": "skfolio", "func": "EmpiricalCovarianceUncertaintySet::fit", "origin_file": "skfolio/uncertainty_set/_empirical.py", "test_list": ["../tests/test_uncertainty_set/test_empirical.py"], "prob_info": {"func_start_lineno": 206, "func_end_lineno": 259, "key_block_start_lineno": 232, "key_block_end_lineno": 259, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y: npt.ArrayLike | None = None, **fit_params\n    ) -> \"EmpiricalCovarianceUncertaintySet\":\n        \"\"\"Fit the Empirical Covariance Uncertainty set estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_factors), optional\n            Price returns of factors.\n            The default is `None`.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : EmpiricalCovarianceUncertaintySet\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.commutation_matrix", "project": "skfolio", "func": "commutation_matrix", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_uncertainty_set/test_empirical.py"], "prob_info": {"func_start_lineno": 403, "func_end_lineno": 421, "key_block_start_lineno": 416, "key_block_end_lineno": 421, "new_func_code": "def commutation_matrix(x):\n    \"\"\"Compute the commutation matrix.\n\n    Parameters\n    ----------\n    x : ndarray of shape (n,  m)\n        The matrix.\n\n    Returns\n    -------\n    K : ndarray of shape (m * n, m * n)\n        The commutation matrix.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distance._distance.CovarianceDistance::fit", "project": "skfolio", "func": "CovarianceDistance::fit", "origin_file": "skfolio/distance/_distance.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 313, "func_end_lineno": 347, "key_block_start_lineno": 329, "key_block_end_lineno": 347, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None, **fit_params) -> \"CovarianceDistance\":\n        \"\"\"Fit the Covariance Distance estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : CovarianceDistance\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.cov_nearest", "project": "skfolio", "func": "cov_nearest", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_distance/test_distance.py"], "prob_info": {"func_start_lineno": 308, "func_end_lineno": 400, "key_block_start_lineno": 361, "key_block_end_lineno": 400, "new_func_code": "def cov_nearest(\n    cov: np.ndarray,\n    higham: bool = False,\n    higham_max_iteration: int = 100,\n    warn: bool = False,\n):\n    \"\"\"Compute the nearest covariance matrix that is positive definite and with a\n    cholesky decomposition than can be computed. The variance is left unchanged.\n    A covariance matrix that is not positive definite often occurs in high\n    dimensional problems. It can be due to multicollinearity, floating-point\n    inaccuracies, or when the number of observations is smaller than the number of\n    assets.\n\n    First, it converts the covariance matrix to a correlation matrix.\n    Then, it finds the nearest correlation matrix and converts it back to a covariance\n    matrix using the initial standard deviation.\n\n    Cholesky decomposition can fail for symmetric positive definite (SPD) matrix due\n    to floating point error and inversely, Cholesky decomposition can success for\n    non-SPD matrix. Therefore, we need to test for both. We always start by testing\n    for Cholesky decomposition which is significantly faster than checking for positive\n    eigenvalues.\n\n    Parameters\n    ----------\n    cov : ndarray of shape (n, n)\n        Covariance matrix.\n\n    higham : bool, default=False\n        If this is set to True, the Higham & Nick (2002) algorithm [1]_ is used,\n        otherwise the eigenvalues are clipped to threshold above zeros (1e-13).\n        The default (`False`) is to use the clipping method as the Higham & Nick\n        algorithm can be slow for large datasets.\n\n    higham_max_iteration : int, default=100\n        Maximum number of iteration of the Higham & Nick (2002) algorithm.\n        The default value is `100`.\n\n    warn : bool, default=False\n        If this is set to True, a user warning is emitted when the covariance matrix\n        is not positive definite and replaced by the nearest. The default is False.\n\n    Returns\n    -------\n    cov : ndarray\n        The nearest covariance matrix.\n\n    References\n    ----------\n    .. [1] \"Computing the nearest correlation matrix - a problem from finance\"\n        IMA Journal of Numerical Analysis\n        Higham & Nick (2002)\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._clayton.ClaytonCopula::fit", "project": "skfolio", "func": "ClaytonCopula::fit", "origin_file": "skfolio/distribution/copula/_clayton.py", "test_list": ["../tests/test_distribution/test_copula/test_clayton.py"], "prob_info": {"func_start_lineno": 178, "func_end_lineno": 225, "key_block_start_lineno": 199, "key_block_end_lineno": 225, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"ClaytonCopula\":\n        r\"\"\"Fit the Bivariate Clayton Copula.\n\n        If `itau` is True, estimates :math:`\\theta` using Kendall's tau inversion.\n        Otherwise, uses MLE by maximizing the log-likelihood.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval [0, 1],\n            having been transformed to uniform marginals.\n\n        y : None\n            Ignored. Provided for compatibility with scikit-learn's API.\n\n        Returns\n        -------\n        self : object\n            Returns the instance itself.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gaussian.GaussianCopula::fit", "project": "skfolio", "func": "GaussianCopula::fit", "origin_file": "skfolio/distribution/copula/_gaussian.py", "test_list": ["../tests/test_distribution/test_copula/test_gaussian.py"], "prob_info": {"func_start_lineno": 146, "func_end_lineno": 192, "key_block_start_lineno": 167, "key_block_end_lineno": 192, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"GaussianCopula\":\n        r\"\"\"Fit the Bivariate Gaussian Copula.\n\n        If `itau` is True, estimates :math:`\\rho` using Kendall's tau inversion.\n        Otherwise, uses MLE by maximizing the log-likelihood.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval [0, 1],\n            having been transformed to uniform marginals.\n\n        y : None\n            Ignored. Provided for compatibility with scikit-learn's API.\n\n        Returns\n        -------\n        self : GaussianCopula\n            Returns the instance itself.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._gumbel.GumbelCopula::fit", "project": "skfolio", "func": "GumbelCopula::fit", "origin_file": "skfolio/distribution/copula/_gumbel.py", "test_list": ["../tests/test_distribution/test_copula/test_gumbel.py"], "prob_info": {"func_start_lineno": 179, "func_end_lineno": 225, "key_block_start_lineno": 200, "key_block_end_lineno": 225, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"GumbelCopula\":\n        r\"\"\"Fit the Bivariate Gumbel Copula.\n\n        If `itau` is True, estimates :math:`\\theta` using Kendall's tau inversion.\n        Otherwise, uses MLE by maximizing the log-likelihood.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval [0, 1],\n            having been transformed to uniform marginals.\n\n        y : None\n            Ignored. Provided for compatibility with scikit-learn's API.\n\n        Returns\n        -------\n        self : object\n            Returns the instance itself.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._joe.JoeCopula::fit", "project": "skfolio", "func": "JoeCopula::fit", "origin_file": "skfolio/distribution/copula/_joe.py", "test_list": ["../tests/test_distribution/test_copula/test_joe.py"], "prob_info": {"func_start_lineno": 183, "func_end_lineno": 241, "key_block_start_lineno": 204, "key_block_end_lineno": 241, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"JoeCopula\":\n        r\"\"\"Fit the Bivariate Joe Copula.\n\n        If `itau` is True, estimates :math:`\\theta` using Kendall's tau inversion.\n        Otherwise, uses MLE by maximizing the log-likelihood.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval [0, 1],\n            having been transformed to uniform marginals.\n\n        y : None\n            Ignored. Provided for compatibility with scikit-learn's API.\n\n        Returns\n        -------\n        self : object\n            Returns the instance itself.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._selection.select_bivariate_copula", "project": "skfolio", "func": "select_bivariate_copula", "origin_file": "skfolio/distribution/copula/_selection.py", "test_list": ["../tests/test_distribution/test_copula/test_selection.py"], "prob_info": {"func_start_lineno": 23, "func_end_lineno": 111, "key_block_start_lineno": 73, "key_block_end_lineno": 111, "new_func_code": "def select_bivariate_copula(\n    X: npt.ArrayLike,\n    copula_candidates: list[BaseBivariateCopula] | None = None,\n    selection_criterion: SelectionCriterion = SelectionCriterion.AIC,\n    independence_level: float = 0.05,\n) -> BaseBivariateCopula:\n    \"\"\"\n    Select the best bivariate copula from a list of candidates using an information\n    criterion.\n\n    This function first tests the dependence between the two variables in X using\n    Kendall's tau independence test. If the p-value is greater than or equal to\n    `independence_level`, the null hypothesis of independence is not rejected, and the\n    `IndependentCopula` is returned. Otherwise, each candidate copula in\n    `copula_candidates` is fitted to the data X. For each candidate, either the\n    Akaike Information Criterion (AIC) or the Bayesian Information Criterion (BIC) is\n    computed, and the copula with the lowest criterion value is selected.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        An array of bivariate inputs (u, v) with uniform marginals (values in [0, 1]).\n\n    copula_candidates : list[BaseBivariateCopula]\n        A list of candidate copula models. Each candidate must inherit from\n        `BaseBivariateCopula`. If None, defaults to\n        `[GaussianCopula(), StudentTCopula(), ClaytonCopula(), GumbelCopula(), JoeCopula()]`.\n\n    selection_criterion : SelectionCriterion, default=SelectionCriterion.AIC\n        The criterion used for model selection. Possible values are:\n            - SelectionCriterion.AIC : Akaike Information Criterion\n            - SelectionCriterion.BIC : Bayesian Information Criterion\n\n    independence_level : float, default=0.05\n        The significance level for the Kendall tau independence test. If the p-value is\n        greater than or equal to this level, the independence hypothesis is not\n        rejected, and the `IndependentCopula` is returned.\n\n    Returns\n    -------\n    selected_copula : BaseBivariateCopula\n        The fitted copula model among the candidates that minimizes the selected\n        information criterion (AIC or BIC).\n\n    Raises\n    ------\n    ValueError\n        If X is not a 2D array with exactly two columns, or if any candidate in\n        `copula_candidates` does not inherit from `BaseBivariateCopula`.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._student_t.StudentTCopula::fit", "project": "skfolio", "func": "StudentTCopula::fit", "origin_file": "skfolio/distribution/copula/_student_t.py", "test_list": ["../tests/test_distribution/test_copula/test_student_t.py"], "prob_info": {"func_start_lineno": 165, "func_end_lineno": 243, "key_block_start_lineno": 194, "key_block_end_lineno": 243, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"StudentTCopula\":\n        r\"\"\"Fit the Bivariate Student's t Copula.\n\n        If `itau` is True, it uses a Kendall-based two-step method:\n            - Estimates the correlation parameter (:math:`\\rho`) from Kendall's\n              tau inversion.\n\n            - Optimizes the degrees of freedom (:math:`\\nu`) by maximizing the\n              log-likelihood.\n\n        Otherwise, it uses the full MLE method: optimizes both :math:`\\rho` and\n        :math:`\\nu` by maximizing the log-likelihood.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval [0, 1],\n            having been transformed to uniform marginals.\n\n        y : None\n            Ignored. Provided for compatibility with scikit-learn's API.\n\n        Returns\n        -------\n        self : StudentTCopula\n            Returns the instance itself.\n\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._student_t.StudentTCopula::cdf", "project": "skfolio", "func": "StudentTCopula::cdf", "origin_file": "skfolio/distribution/copula/_student_t.py", "test_list": ["../tests/test_distribution/test_copula/test_student_t.py"], "prob_info": {"func_start_lineno": 245, "func_end_lineno": 268, "key_block_start_lineno": 260, "key_block_end_lineno": 268, "new_func_code": "def cdf(self, X: npt.ArrayLike) -> np.ndarray:\n        \"\"\"Compute the CDF of the bivariate Student-t copula.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        Returns\n        -------\n        cdf : ndarray of shape (n_observations,)\n            CDF values for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._student_t.StudentTCopula::partial_derivative", "project": "skfolio", "func": "StudentTCopula::partial_derivative", "origin_file": "skfolio/distribution/copula/_student_t.py", "test_list": ["../tests/test_distribution/test_copula/test_student_t.py"], "prob_info": {"func_start_lineno": 270, "func_end_lineno": 321, "key_block_start_lineno": 308, "key_block_end_lineno": 321, "new_func_code": "def partial_derivative(\n        self, X: npt.ArrayLike, first_margin: bool = False\n    ) -> np.ndarray:\n        r\"\"\"Compute the h-function (partial derivative) for the bivariate Student's t\n        copula.\n\n        The h-function with respect to the second margin represents the conditional\n        distribution function of :math:`u` given :math:`v`:\n\n        .. math:: \\begin{aligned}\n                   h(u \\mid v) &= \\frac{\\partial C(u,v)}{\\partial v} \\\\\n                               &= t_{\\nu+1}\\!\\left(\\frac{t_\\nu^{-1}(u) - \\rho\\,t_\\nu^{-1}(v)}\n                                  {\\sqrt{\\frac{(1-\\rho^2)\\left(\\nu + \\left(t_\\nu^{-1}(v)\\right)^2\\right)}{\\nu+1}}}\\right).\n                  \\end{aligned}\n\n        where:\n            - :math:`\\nu > 0` is the degrees of freedom.\n            - :math:`\\rho \\in (-1, 1)` is the correlation coefficient.\n            - :math:`t_{\\nu}^{-1}(p)` is the quantile function (inverse CDF) of the\n              univariate \\(t\\)-distribution.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, 2)\n            An array of bivariate inputs `(u, v)` where each row represents a\n            bivariate observation. Both `u` and `v` must be in the interval `[0, 1]`,\n            having been transformed to uniform marginals.\n\n        first_margin : bool, default=False\n            If True, compute the partial derivative with respect to the first\n            margin `u`; otherwise, compute the partial derivative with respect to the\n            second margin `v`.\n\n        Returns\n        -------\n        p : ndarray of shape (n_observations,)\n            h-function values :math:`h(u \\mid v) \\;=\\; p` for each observation in X.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.copula._utils.empirical_tail_concentration", "project": "skfolio", "func": "empirical_tail_concentration", "origin_file": "skfolio/distribution/copula/_utils.py", "test_list": ["../tests/test_distribution/test_copula/test_utils.py"], "prob_info": {"func_start_lineno": 86, "func_end_lineno": 144, "key_block_start_lineno": 121, "key_block_end_lineno": 144, "new_func_code": "def empirical_tail_concentration(X: npt.ArrayLike, quantiles: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute empirical tail concentration for the two variables in X.\n    This function computes the concentration at each quantile provided.\n\n    The tail concentration are estimated as:\n      - Lower tail: _L(q) = P(U  q | U  q)\n      - Upper tail: _U(q) = P(U  q | U  q)\n\n    where U and U are the pseudo-observations.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        A 2D array with exactly 2 columns representing the pseudo-observations.\n\n    quantiles : array-like of shape (n_quantiles,)\n        A 1D array of quantile levels (values between 0 and 1) at which to compute the\n        concentration.\n\n    Returns\n    -------\n    concentration : ndarray of shape (n_quantiles,)\n        An array of empirical tail concentration values for the given quantiles.\n\n    References\n    ----------\n    .. [1] \"Quantitative Risk Management: Concepts, Techniques, and Tools\",\n        McNeil, Frey, Embrechts (2005)\n\n    Raises\n    ------\n    ValueError\n        If X is not a 2D array with exactly 2 columns or if quantiles are not in [0, 1].\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.multivariate._utils._dependence", "project": "skfolio", "func": "_dependence", "origin_file": "skfolio/distribution/multivariate/_utils.py", "test_list": ["../tests/test_distribution/test_multivariate/test_utils.py"], "prob_info": {"func_start_lineno": 594, "func_end_lineno": 632, "key_block_start_lineno": 620, "key_block_end_lineno": 632, "new_func_code": "def _dependence(X, dependence_method: DependenceMethod) -> float:\n    \"\"\"Compute the dependence between two variables in X using the specified method.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 2)\n        A 2D array of bivariate inputs (u, v), where u and v are assumed to lie in\n        [0, 1].\n\n    dependence_method : DependenceMethod\n        The method to use for measuring dependence. Options are:\n        - DependenceMethod.KENDALL_TAU\n        - DependenceMethod.MUTUAL_INFORMATION\n        - DependenceMethod.WASSERSTEIN_DISTANCE\n\n    Returns\n    -------\n    dependence : float\n        The computed dependence measure.\n\n    Raises\n    ------\n    ValueError\n        If X does not have exactly 2 columns or if an unsupported dependence method is\n        provided.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.distribution.univariate._selection.select_univariate_dist", "project": "skfolio", "func": "select_univariate_dist", "origin_file": "skfolio/distribution/univariate/_selection.py", "test_list": ["../tests/test_distribution/test_univariate/test_selection.py"], "prob_info": {"func_start_lineno": 19, "func_end_lineno": 85, "key_block_start_lineno": 58, "key_block_end_lineno": 85, "new_func_code": "def select_univariate_dist(\n    X: npt.ArrayLike,\n    distribution_candidates: list[BaseUnivariateDist] | None = None,\n    selection_criterion: SelectionCriterion = SelectionCriterion.AIC,\n) -> BaseUnivariateDist:\n    \"\"\"Select the optimal univariate distribution estimator based on an information\n    criterion.\n\n    For each candidate distribution, the function fits the distribution to X and then\n    computes either the Akaike Information Criterion (AIC) or the Bayesian Information\n    Criterion (BIC). The candidate with the lowest criterion value is returned.\n\n    Parameters\n    ----------\n    X : array-like of shape (n_observations, 1)\n        The input data used to fit each candidate distribution.\n\n    distribution_candidates : list of BaseUnivariateDist\n        A list of candidate distribution estimators. Each candidate must be an instance\n        of a class that inherits from `BaseUnivariateDist`.\n        If None, defaults to `[Gaussian(), StudentT(), JohnsonSU()]`.\n\n    selection_criterion : SelectionCriterion, default=SelectionCriterion.AIC\n        The criterion used for model selection. Possible values are:\n            - SelectionCriterion.AIC : Akaike Information Criterion\n            - SelectionCriterion.BIC : Bayesian Information Criterion\n\n    Returns\n    -------\n    BaseUnivariateDist\n        The fitted candidate estimator that minimizes the selected information\n        criterion.\n\n    Raises\n    ------\n    ValueError\n        If X does not have exactly one column or if any candidate in the list does not\n        inherit from BaseUnivariateDist.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.prior._empirical.EmpiricalPrior::fit", "project": "skfolio", "func": "EmpiricalPrior::fit", "origin_file": "skfolio/prior/_empirical.py", "test_list": ["../tests/test_metrics/test_scorer.py"], "prob_info": {"func_start_lineno": 108, "func_end_lineno": 202, "key_block_start_lineno": 131, "key_block_end_lineno": 202, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None, **fit_params) -> \"EmpiricalPrior\":\n        \"\"\"Fit the Empirical Prior estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : EmpiricalPrior\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.model_selection._combinatorial.optimal_folds_number", "project": "skfolio", "func": "optimal_folds_number", "origin_file": "skfolio/model_selection/_combinatorial.py", "test_list": ["../tests/test_model_selection/test_combinatorial.py"], "prob_info": {"func_start_lineno": 478, "func_end_lineno": 564, "key_block_start_lineno": 533, "key_block_end_lineno": 564, "new_func_code": "def optimal_folds_number(\n    n_observations: int,\n    target_train_size: int,\n    target_n_test_paths: int,\n    weight_train_size: float = 1,\n    weight_n_test_paths: float = 1,\n) -> tuple[int, int]:\n    r\"\"\"Find the optimal number of folds (total folds and test folds) for a target\n    training size and a target number of test paths.\n\n    We find `x = n_folds` and `y = n_test_folds` that minimizes the below\n    cost function of the relative distance from the two targets:\n\n    .. math::\n           cost(x,y) = w_{f} \\times \\lvert\\frac{f(x,y)-f_{target}}{f_{target}}\\rvert + w_{g} \\times \\lvert\\frac{g(x,y)-g_{target}}{g_{target}}\\rvert\n\n    with :math:`w_{f}` and :math:`w_{g}` the weights assigned to the distance\n    from each target and :math:`f(x,y)` and :math:`g(x,y)` the average training size\n    and the number of test paths as a function of the number of total folds and test\n    folds.\n\n    This is a combinatorial problem with :math:`\\frac{T\\times(T-3)}{2}` combinations,\n    with :math:`T` the number of observations.\n\n    We reduce the search space by using the combinatorial symetry\n    :math:`{n \\choose k}={n \\choose n-k}` and skipping cost computation above 1e5.\n\n    Parameters\n    ----------\n    n_observations : int\n        Number of observations.\n\n    target_train_size : int\n        The target number of observation in the training set.\n\n    target_n_test_paths : int\n        The target number of test paths (that can be reconstructed from the train/test\n        combinations).\n\n    weight_train_size : float, default=1\n        The weight assigned to the distance from the target train size.\n        The default value is 1.\n\n    weight_n_test_paths : float, default=1\n        The weight assigned to the distance from the target number of test paths.\n        The default value is 1.\n\n    Returns\n    -------\n    n_folds : int\n        Optimal number of total folds.\n\n    n_test_folds : int\n        Optimal number of test folds.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.model_selection._walk_forward.WalkForward::split", "project": "skfolio", "func": "WalkForward::split", "origin_file": "skfolio/model_selection/_walk_forward.py", "test_list": ["../tests/test_model_selection/test_walk_forward.py"], "prob_info": {"func_start_lineno": 203, "func_end_lineno": 273, "key_block_start_lineno": 227, "key_block_end_lineno": 273, "new_func_code": "def split(\n        self, X: npt.ArrayLike, y=None, groups=None\n    ) -> Iterator[np.ndarray, np.ndarray]:\n        \"\"\"Generate indices to split data into training and test set.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_targets)\n            Always ignored, exists for compatibility.\n\n        groups : array-like of shape (n_observations,)\n            Always ignored, exists for compatibility.\n\n        Yields\n        ------\n        train : ndarray\n            The training set indices for that split.\n\n        test : ndarray\n            The testing set indices for that split.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.cluster._nco.NestedClustersOptimization::fit", "project": "skfolio", "func": "NestedClustersOptimization::fit", "origin_file": "skfolio/optimization/cluster/_nco.py", "test_list": ["../tests/test_optimization/test_cluster/test_nco.py"], "prob_info": {"func_start_lineno": 216, "func_end_lineno": 392, "key_block_start_lineno": 242, "key_block_end_lineno": 392, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y: npt.ArrayLike | None = None, **fit_params\n    ) -> \"NestedClustersOptimization\":\n        \"\"\"Fit the Nested Clusters Optimization estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_targets), optional\n            Price returns of factors or a target benchmark.\n            The default is `None`.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : NestedClustersOptimization\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.cluster.hierarchical._herc.HierarchicalEqualRiskContribution::fit", "project": "skfolio", "func": "HierarchicalEqualRiskContribution::fit", "origin_file": "skfolio/optimization/cluster/hierarchical/_herc.py", "test_list": ["../tests/test_optimization/test_cluster/test_hierarchical/test_herc.py"], "prob_info": {"func_start_lineno": 314, "func_end_lineno": 475, "key_block_start_lineno": 339, "key_block_end_lineno": 475, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y: None = None, **fit_params\n    ) -> \"HierarchicalEqualRiskContribution\":\n        \"\"\"Fit the Hierarchical Equal Risk Contribution estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : HierarchicalEqualRiskContribution\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.ensemble._stacking.StackingOptimization::fit", "project": "skfolio", "func": "StackingOptimization::fit", "origin_file": "skfolio/optimization/ensemble/_stacking.py", "test_list": ["../tests/test_optimization/test_ensemble/test_stacking.py"], "prob_info": {"func_start_lineno": 243, "func_end_lineno": 355, "key_block_start_lineno": 269, "key_block_end_lineno": 355, "new_func_code": "def fit(\n        self, X: npt.ArrayLike, y: npt.ArrayLike | None = None, **fit_params\n    ) -> \"StackingOptimization\":\n        \"\"\"Fit the Stacking Optimization estimator.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n           Price returns of the assets.\n\n        y : array-like of shape (n_observations, n_targets), optional\n            Price returns of factors or a target benchmark.\n            The default is `None`.\n\n        **fit_params : dict\n            Parameters to pass to the underlying estimators.\n            Only available if `enable_metadata_routing=True`, which can be\n            set by using ``sklearn.set_config(enable_metadata_routing=True)``.\n            See :ref:`Metadata Routing User Guide <metadata_routing>` for\n            more details.\n\n        Returns\n        -------\n        self : StackingOptimization\n           Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.pre_selection._drop_zero_variance.DropZeroVariance::fit", "project": "skfolio", "func": "DropZeroVariance::fit", "origin_file": "skfolio/pre_selection/_drop_zero_variance.py", "test_list": ["../tests/test_pre_selection/test_drop_zero_variance.py"], "prob_info": {"func_start_lineno": 47, "func_end_lineno": 71, "key_block_start_lineno": 63, "key_block_end_lineno": 71, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None):\n        \"\"\"Fit the transformer on some assets.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Price returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : DropZeroVariance\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.pre_selection._select_complete.SelectComplete::fit", "project": "skfolio", "func": "SelectComplete::fit", "origin_file": "skfolio/pre_selection/_select_complete.py", "test_list": ["../tests/test_pre_selection/test_select_complete.py"], "prob_info": {"func_start_lineno": 82, "func_end_lineno": 108, "key_block_start_lineno": 98, "key_block_end_lineno": 108, "new_func_code": "def fit(self, X: npt.ArrayLike, y=None) -> \"SelectComplete\":\n        \"\"\"Run the SelectComplete transformer and get the appropriate assets.\n\n        Parameters\n        ----------\n        X : array-like of shape (n_observations, n_assets)\n            Returns of the assets.\n\n        y : Ignored\n            Not used, present for API consistency by convention.\n\n        Returns\n        -------\n        self : SelectComplete\n            Fitted estimator.\n        \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.equations.equations_to_matrix", "project": "skfolio", "func": "equations_to_matrix", "origin_file": "skfolio/utils/equations.py", "test_list": ["../tests/test_prior/test_black_litterman.py"], "prob_info": {"func_start_lineno": 32, "func_end_lineno": 134, "key_block_start_lineno": 103, "key_block_end_lineno": 134, "new_func_code": "def equations_to_matrix(\n    groups: npt.ArrayLike,\n    equations: npt.ArrayLike,\n    sum_to_one: bool = False,\n    raise_if_group_missing: bool = False,\n    names: tuple[str, str] = (\"groups\", \"equations\"),\n) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Convert a list of linear equations into the left and right matrices of the\n    inequality A <= B and equality A == B.\n\n    Parameters\n    ----------\n    groups : array-like of shape (n_groups, n_assets)\n        2D array of assets groups.\n\n        For example:\n\n             groups = np.array(\n                [\n                    [\"SPX\", \"SX5E\", \"NKY\", \"TLT\"],\n                    [\"Equity\", \"Equity\", \"Equity\", \"Bond\"],\n                    [\"US\", \"Europe\", \"Japan\", \"US\"],\n                ]\n            )\n\n    equations : array-like of shape (n_equations,)\n         1D array of equations.\n\n         Example of valid equation patterns:\n            * \"number_1 * group_1 + number_3 <= number_4 * group_3 + number_5\"\n            * \"group_1 == number * group_2\"\n            * \"group_1 <= number\"\n            * \"group_1 == number\"\n\n        \"group_1\" and \"group_2\" are the group names defined in `groups`.\n        The second expression means that the sum of all assets in \"group_1\" should be\n        less or equal to \"number\" times the sum of all assets in \"group_2\".\n\n        For example:\n\n             equations = [\n                \"Equity <= 3 * Bond\",\n                \"US >= 1.5\",\n                \"Europe >= 0.5 * Japan\",\n                \"Japan == 1\",\n                \"3*SPX + 5*SX5E == 2*TLT + 3\",\n            ]\n\n    sum_to_one : bool\n        If this is set to True, all elements in a group sum to one (used in the `views`\n        of the Black-Litterman model).\n\n    raise_if_group_missing : bool, default=False\n        If this is set to True, an error is raised when a group is not found in the\n        groups, otherwise only a warning is shown.\n        The default is False.\n\n    names : tuple[str, str], default=('groups', 'equations')\n        The group and equation names used in error messages.\n        The default is `('groups', 'equations')`.\n\n    Returns\n    -------\n    left_equality: ndarray of shape (n_equations_equality, n_assets)\n    right_equality: ndarray of shape (n_equations_equality,)\n        The left and right matrices of the inequality A <= B.\n\n    left_inequality: ndarray of shape (n_equations_inequality, n_assets)\n    right_inequality: ndarray of shape (n_equations_inequality,)\n        The left and right matrices of the equality A == B.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.equations._matching_array", "project": "skfolio", "func": "_matching_array", "origin_file": "skfolio/utils/equations.py", "test_list": ["../tests/test_utils/test_equations.py"], "prob_info": {"func_start_lineno": 253, "func_end_lineno": 282, "key_block_start_lineno": 275, "key_block_end_lineno": 282, "new_func_code": "def _matching_array(values: np.ndarray, key: str, sum_to_one: bool) -> np.ndarray:\n    \"\"\"Takes in a 2D array of strings, a key string, and a boolean flag.\n    It returns a 1D array where the value is 1 if there is a match between the key and\n    any value in the 2D array, and 0 otherwise. The returned array can be scaled to\n    have a sum of one if the flag is set to True.\n\n    Parameters\n    ----------\n    values : ndarray of shape (n, m)\n        2D-array of strings.\n\n    key : str\n        String to match in the values.\n\n    sum_to_one : bool\n        If this is set to True, the matching 1D-array is scaled to have a sum of one.\n\n    Returns\n    -------\n    matching_array : ndarray of shape (n, )\n        Matching 1D-array.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.sorting.non_denominated_sort", "project": "skfolio", "func": "non_denominated_sort", "origin_file": "skfolio/utils/sorting.py", "test_list": ["../tests/test_utils/test_sorting.py"], "prob_info": {"func_start_lineno": 43, "func_end_lineno": 118, "key_block_start_lineno": 65, "key_block_end_lineno": 118, "new_func_code": "def non_denominated_sort(\n    fitnesses: np.ndarray, first_front_only: bool\n) -> list[list[int]]:\n    \"\"\"Fast non-dominated sorting.\n\n    Sort the fitnesses into different non-domination levels.\n    Complexity O(MN^2) where M is the number of objectives and N the number of\n    portfolios.\n\n    Parameters\n    ----------\n    fitnesses: ndarray of shape(n, n_fitness)\n        Fitnesses array.\n\n    first_front_only : bool\n        If this is set to True, only the first front is computed and returned.\n\n    Returns\n    -------\n    fronts: list[list[int]]\n      A list of Pareto fronts (lists), the first list includes non-dominated fitnesses.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.stats.n_bins_knuth", "project": "skfolio", "func": "n_bins_knuth", "origin_file": "skfolio/utils/stats.py", "test_list": ["../tests/test_utils/test_stats.py"], "prob_info": {"func_start_lineno": 88, "func_end_lineno": 125, "key_block_start_lineno": 106, "key_block_end_lineno": 125, "new_func_code": "def n_bins_knuth(x: np.ndarray) -> int:\n    \"\"\"Compute the optimal histogram bin size using Knuth's rule [1]_.\n\n    Parameters\n    ----------\n    x : ndarray of shape (n_observations,)\n        The input array.\n\n    Returns\n    -------\n    n_bins : int\n        The optimal bin size.\n\n    References\n    ----------\n    .. [1] \"Optimal Data-Based Binning for Histograms\".\n        Knuth.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.utils.tools.bisection", "project": "skfolio", "func": "bisection", "origin_file": "skfolio/utils/tools.py", "test_list": ["../tests/test_utils/test_tools.py"], "prob_info": {"func_start_lineno": 553, "func_end_lineno": 570, "key_block_start_lineno": 566, "key_block_end_lineno": 570, "new_func_code": "def bisection(x: list[np.ndarray]) -> Iterator[list[np.ndarray, np.ndarray]]:\n    \"\"\"Generator to bisect a list of array.\n\n    Parameters\n    ----------\n    x : list[ndarray]\n        A list of array.\n\n    Yields\n    ------\n    arr :  Iterator[list[ndarray, ndarray]]\n        Bisected array.\n    \"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
{"id": "skfolio.src.skfolio.optimization.convex._mean_risk.MeanRisk::_validation", "project": "skfolio", "func": "MeanRisk::_validation", "origin_file": "skfolio/optimization/convex/_mean_risk.py", "test_list": ["../tests/test_optimization/test_cluster/test_nco.py"], "prob_info": {"func_start_lineno": 714, "func_end_lineno": 729, "key_block_start_lineno": 716, "key_block_end_lineno": 729, "new_func_code": "def _validation(self) -> None:\n        \"\"\"Validate the input parameters.\"\"\"\n <complete code here>"}, "model_info": {"gen_model": "gpt4o", "rewrite_model": "", "debug_gen_model": ""}, "type": "Function_empty", "language": "Python", "pytest_info": {"total_num": null, "base_passed_num": null}}
